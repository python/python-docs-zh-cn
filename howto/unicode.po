# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Nyuan Zhang, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 16:48+0000\n"
"PO-Revision-Date: 2025-07-18 20:05+0000\n"
"Last-Translator: Nyuan Zhang, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/unicode.rst:5
msgid "Unicode HOWTO"
msgstr "Unicode 指南"

#: ../../howto/unicode.rst:0
msgid "Release"
msgstr "发布版本"

#: ../../howto/unicode.rst:7
msgid "1.12"
msgstr "1.12"

#: ../../howto/unicode.rst:9
msgid ""
"This HOWTO discusses Python's support for the Unicode specification for "
"representing textual data, and explains various problems that people "
"commonly encounter when trying to work with Unicode."
msgstr "本文介绍了 Python 对表示文本数据的 Unicode 规范的支持，并对各种 Unicode 常见使用问题做了解释。"

#: ../../howto/unicode.rst:15
msgid "Introduction to Unicode"
msgstr "Unicode 概述"

#: ../../howto/unicode.rst:18
msgid "Definitions"
msgstr "定义"

#: ../../howto/unicode.rst:20
msgid ""
"Today's programs need to be able to handle a wide variety of characters.  "
"Applications are often internationalized to display messages and output in a"
" variety of user-selectable languages; the same program might need to output"
" an error message in English, French, Japanese, Hebrew, or Russian.  Web "
"content can be written in any of these languages and can also include a "
"variety of emoji symbols. Python's string type uses the Unicode Standard for"
" representing characters, which lets Python programs work with all these "
"different possible characters."
msgstr ""
"如今的程序需要能够处理各种各样的字符。应用程序通常做了国际化处理，用户可以选择不同的语言显示信息和输出数据。同一个程序可能需要以英语、法语、日语、希伯来语或俄语输出错误信息。网页内容可能由这些语言书写，并且可能包含不同的表情符号。Python"
" 的字符串类型采用 Unicode 标准来表示字符，使得 Python 程序能够正常处理所有这些不同的字符。"

#: ../../howto/unicode.rst:30
msgid ""
"Unicode (https://www.unicode.org/) is a specification that aims to list "
"every character used by human languages and give each character its own "
"unique code.  The Unicode specifications are continually revised and updated"
" to add new languages and symbols."
msgstr ""
"Unicode "
"规范（https://www.unicode.org/）旨在罗列人类语言所用到的所有字符，并赋予每个字符唯一的编码。该规范一直在进行修订和更新，不断加入新的语种和符号。"

#: ../../howto/unicode.rst:35
msgid ""
"A **character** is the smallest possible component of a text.  'A', 'B', "
"'C', etc., are all different characters.  So are 'È' and 'Í'.  Characters "
"vary depending on the language or context you're talking about.  For "
"example, there's a character for \"Roman Numeral One\", 'Ⅰ', that's separate"
" from the uppercase letter 'I'.  They'll usually look the same, but these "
"are two different characters that have different meanings."
msgstr ""
"一个 **字符** 是文本的最小组件。‘A’、‘B’、‘C’ 等都是不同的字符。‘È’ 和 ‘Í’ "
"也一样。字符会随着语言或者上下文的变化而变化。比如，‘Ⅰ’ 是一个表示 “罗马数字 1” 的字符，它与大写字母 ‘I’ "
"不同。他们往往看起来相同，但这是两个有着不同含义的字符。"

#: ../../howto/unicode.rst:42
msgid ""
"The Unicode standard describes how characters are represented by **code "
"points**.  A code point value is an integer in the range 0 to 0x10FFFF "
"(about 1.1 million values, the `actual number assigned "
"<https://www.unicode.org/versions/latest/#Summary>`_ is less than that). In "
"the standard and in this document, a code point is written using the "
"notation ``U+265E`` to mean the character with value ``0x265e`` (9,822 in "
"decimal)."
msgstr ""
"Unicode 标准描述了字符是如何用 **码位（code point）** 表示的。码位的取值范围是 0 到 0x10FFFF 的整数（大约 110 "
"万个值，`实际分配的数字 <https://www.unicode.org/versions/latest/#Summary>`_ 没有那么多）。在 "
"Unicode 标准和本文中，码位采用 ``U+265E`` 的形式，表示值为 ``0x265e`` 的字符（十进制为 9822）。"

#: ../../howto/unicode.rst:50
msgid ""
"The Unicode standard contains a lot of tables listing characters and their "
"corresponding code points:"
msgstr "Unicode 标准中包含了许多表格，列出了很多字符及其对应的码位。"

#: ../../howto/unicode.rst:71
msgid ""
"Strictly, these definitions imply that it's meaningless to say 'this is "
"character ``U+265E``'.  ``U+265E`` is a code point, which represents some "
"particular character; in this case, it represents the character 'BLACK CHESS"
" KNIGHT', '♞'.  In informal contexts, this distinction between code points "
"and characters will sometimes be forgotten."
msgstr ""
"严格地说，上述定义暗示了以下说法是没有意义的：“这是字符 ``U+265E``”。``U+265E`` "
"只是一个码位，代表某个特定的字符；这里它代表了字符 “国际象棋黑骑士” '♞'。在非正式的上下文中，有时会忽略码位和字符的区别。"

#: ../../howto/unicode.rst:78
msgid ""
"A character is represented on a screen or on paper by a set of graphical "
"elements that's called a **glyph**.  The glyph for an uppercase A, for "
"example, is two diagonal strokes and a horizontal stroke, though the exact "
"details will depend on the font being used.  Most Python code doesn't need "
"to worry about glyphs; figuring out the correct glyph to display is "
"generally the job of a GUI toolkit or a terminal's font renderer."
msgstr ""
"一个字符在屏幕或纸上被表示为一组图形元素，被称为 **字形（glyph）** 。比如，大写字母 A "
"的字形，是两笔斜线和一笔横线，而具体的细节取决于所使用的字体。大部分 Python 代码不必担心字形，找到正确的显示字形通常是交给 GUI "
"工具包或终端的字体渲染程序来完成。"

#: ../../howto/unicode.rst:87
msgid "Encodings"
msgstr "编码"

#: ../../howto/unicode.rst:89
msgid ""
"To summarize the previous section: a Unicode string is a sequence of code "
"points, which are numbers from 0 through ``0x10FFFF`` (1,114,111 decimal).  "
"This sequence of code points needs to be represented in memory as a set of "
"**code units**, and **code units** are then mapped to 8-bit bytes.  The "
"rules for translating a Unicode string into a sequence of bytes are called a"
" **character encoding**, or just an **encoding**."
msgstr ""
"上一段可以归结为：一个 Unicode 字符串是一系列码位（从 0 到 ``0x10FFFF`` 或者说十进制的 1,114,111 "
"的数字）组成的序列。这一序列在内存中需被表示为一组 **码元（code unit）** ， **码元** 会映射成包含八个二进制位的字节。将 "
"Unicode 字符串翻译成字节序列的规则称为 **字符编码** ，或者 **编码** 。"

#: ../../howto/unicode.rst:97
msgid ""
"The first encoding you might think of is using 32-bit integers as the code "
"unit, and then using the CPU's representation of 32-bit integers. In this "
"representation, the string \"Python\" might look like this:"
msgstr ""
"大家首先会想到的编码可能是用 32 位的整数作为代码位，然后采用 CPU 对 32 位整数的表示法。字符串 “Python” "
"用这种表示法可能会如下所示："

#: ../../howto/unicode.rst:107
msgid ""
"This representation is straightforward but using it presents a number of "
"problems."
msgstr "这种表示法非常直白，但也存在 一些问题。"

#: ../../howto/unicode.rst:110
msgid "It's not portable; different processors order the bytes differently."
msgstr "不具可移植性；不同的处理器的字节序不同。"

#: ../../howto/unicode.rst:112
msgid ""
"It's very wasteful of space.  In most texts, the majority of the code points"
" are less than 127, or less than 255, so a lot of space is occupied by "
"``0x00`` bytes.  The above string takes 24 bytes compared to the 6 bytes "
"needed for an ASCII representation.  Increased RAM usage doesn't matter too "
"much (desktop computers have gigabytes of RAM, and strings aren't usually "
"that large), but expanding our usage of disk and network bandwidth by a "
"factor of 4 is intolerable."
msgstr ""
"非常浪费空间。 在大多数文本中，大部分码位都小于 127 或 255，因此字节 ``0x00`` 占用了大量空间。相较于 ASCII 表示法所需的 6 "
"个字节，以上字符串需要占用 24 个字节。RAM 用量的增加没那么要紧（台式计算机有成 GB 的 "
"RAM，而字符串通常不会有那么大），但要把磁盘和网络带宽的用量增加 4 倍是无法忍受的。"

#: ../../howto/unicode.rst:120
msgid ""
"It's not compatible with existing C functions such as ``strlen()``, so a new"
" family of wide string functions would need to be used."
msgstr "与现有的 C 函数（如 ``strlen()`` ）不兼容，因此需要采用一套新的宽字符串函数。"

#: ../../howto/unicode.rst:123
msgid ""
"Therefore this encoding isn't used very much, and people instead choose "
"other encodings that are more efficient and convenient, such as UTF-8."
msgstr "因此这种编码用得不多，人们转而选择其他更高效、更方便的编码，比如 UTF-8。"

#: ../../howto/unicode.rst:126
msgid ""
"UTF-8 is one of the most commonly used encodings, and Python often defaults "
"to using it.  UTF stands for \"Unicode Transformation Format\", and the '8' "
"means that 8-bit values are used in the encoding.  (There are also UTF-16 "
"and UTF-32 encodings, but they are less frequently used than UTF-8.)  UTF-8 "
"uses the following rules:"
msgstr ""
"UTF-8 是最常用的编码之一，Python 往往默认会采用它。UTF 代表“Unicode Transformation Format”，'8' "
"表示编码采用 8 位数。（UTF-16 和 UTF-32 编码也是存在的，但其使用频率不如 UTF-8。）UTF-8 的规则如下："

#: ../../howto/unicode.rst:132
msgid ""
"If the code point is < 128, it's represented by the corresponding byte "
"value."
msgstr "如果码位 < 128，则直接用对应的字节值表示。"

#: ../../howto/unicode.rst:133
msgid ""
"If the code point is >= 128, it's turned into a sequence of two, three, or "
"four bytes, where each byte of the sequence is between 128 and 255."
msgstr "如果码位  >= 128，则转换为 2、3、4 个字节的序列，每个字节值都位于 128 和 255 之间。"

#: ../../howto/unicode.rst:136
msgid "UTF-8 has several convenient properties:"
msgstr "UTF-8 有几个很方便的特性："

#: ../../howto/unicode.rst:138
msgid "It can handle any Unicode code point."
msgstr "可以处理任何 Unicode 码位。"

#: ../../howto/unicode.rst:139
msgid ""
"A Unicode string is turned into a sequence of bytes that contains embedded "
"zero bytes only where they represent the null character (U+0000). This means"
" that UTF-8 strings can be processed by C functions such as ``strcpy()`` and"
" sent through protocols that can't handle zero bytes for anything other than"
" end-of-string markers."
msgstr ""
"Unicode 字符串被转换为一个字节序列，仅在表示空（null ）字符（U+0000）时才会包含零值的字节。这意味着 ``strcpy()`` "
"之类的C 函数可以处理 UTF-8 字符串，而且用那些不能处理字符串结束符之外的零值字节的协议也能发送。"

#: ../../howto/unicode.rst:144
msgid "A string of ASCII text is also valid UTF-8 text."
msgstr "ASCII 字符串也是也是也是合法的 UTF-8 文本。"

#: ../../howto/unicode.rst:145
msgid ""
"UTF-8 is fairly compact; the majority of commonly used characters can be "
"represented with one or two bytes."
msgstr "UTF-8 相当紧凑；大多数常用字符均可用一两个字节表示。"

#: ../../howto/unicode.rst:147
msgid ""
"If bytes are corrupted or lost, it's possible to determine the start of the "
"next UTF-8-encoded code point and resynchronize.  It's also unlikely that "
"random 8-bit data will look like valid UTF-8."
msgstr ""
"如果字节数据被损坏或丢失，则可以找出下一个 UTF-8 码点的开始位置并重新开始同步。随机的 8 位数据也不太可能像是有效的 UTF-8 编码。"

#: ../../howto/unicode.rst:150
msgid ""
"UTF-8 is a byte oriented encoding. The encoding specifies that each "
"character is represented by a specific sequence of one or more bytes. This "
"avoids the byte-ordering issues that can occur with integer and word "
"oriented encodings, like UTF-16 and UTF-32, where the sequence of bytes "
"varies depending on the hardware on which the string was encoded."
msgstr ""
"UTF-8 是一种面向字节的编码。编码规定了每个字符由一个或多个字节的序列表示。这避免了整数和双字节编码（如 UTF-16 和 "
"UTF-32）可能出现的字节顺序问题，那时的字节序列会因执行编码的硬件而异。"

#: ../../howto/unicode.rst:158 ../../howto/unicode.rst:514
#: ../../howto/unicode.rst:735
msgid "References"
msgstr "参考文献"

#: ../../howto/unicode.rst:160
msgid ""
"The `Unicode Consortium site <https://www.unicode.org>`_ has character "
"charts, a glossary, and PDF versions of the Unicode specification.  Be "
"prepared for some difficult reading.  `A chronology "
"<https://www.unicode.org/history/>`_ of the origin and development of "
"Unicode is also available on the site."
msgstr ""
"`Unicode Consortium 站点 <https://www.unicode.org>`_ 包含 Unicode 规范的字符图表、词汇表和 "
"PDF 版本。请做好准备，有些内容读起来有点难度。该网站上还提供了 Unicode 起源和发展的 `年表 "
"<https://www.unicode.org/history/>`_ 。"

#: ../../howto/unicode.rst:165
msgid ""
"On the Computerphile Youtube channel, Tom Scott briefly `discusses the "
"history of Unicode and UTF-8 <https://www.youtube.com/watch?v=MijmeoH9LT4>`_"
" (9 minutes 36 seconds)."
msgstr ""
"在 Computerphile 的 Youtube 频道上，Tom Scott 简要地 `讨论了 Unicode 和 UTF-8 "
"<https://www.youtube.com/watch?v=MijmeoH9LT4>`_ （9 分 36 秒）的历史。"

#: ../../howto/unicode.rst:169
msgid ""
"To help understand the standard, Jukka Korpela has written `an introductory "
"guide <https://jkorpela.fi/unicode/guide.html>`_ to reading the Unicode "
"character tables."
msgstr ""
"为了帮助理解该标准，Jukka Korpela 编写了阅读 Unicode 字符表的 `介绍性指南 "
"<https://jkorpela.fi/unicode/guide.html>`_ 。"

#: ../../howto/unicode.rst:173
msgid ""
"Another `good introductory article "
"<https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-"
"software-developer-absolutely-positively-must-know-about-unicode-and-"
"character-sets-no-excuses/>`_ was written by Joel Spolsky. If this "
"introduction didn't make things clear to you, you should try reading this "
"alternate article before continuing."
msgstr ""
"Joel Spolsky 撰写了另一篇不错的介绍性文章 <https://www.joelonsoftware.com/2003/10/08/the-"
"absolute-minimum-every-software-developer-absolutely-positively-must-know-"
"about-unicode-and-character- set-no-excuses/>`_ "
"。如果本文没让您弄清楚，那应在继续之前先试着读读这篇文章。"

#: ../../howto/unicode.rst:178
msgid ""
"Wikipedia entries are often helpful; see the entries for \"`character "
"encoding <https://en.wikipedia.org/wiki/Character_encoding>`_\" and `UTF-8 "
"<https://en.wikipedia.org/wiki/UTF-8>`_, for example."
msgstr ""
"Wikipedia 条目通常也有帮助；请参阅“`字符编码 "
"<https://en.wikipedia.org/wiki/Character_encoding>`_”和 `UTF-8 "
"<https://en.wikipedia.org/wiki/UTF-8>`_ 的条目，例如："

#: ../../howto/unicode.rst:184
msgid "Python's Unicode Support"
msgstr "Python对Unicode的支持"

#: ../../howto/unicode.rst:186
msgid ""
"Now that you've learned the rudiments of Unicode, we can look at Python's "
"Unicode features."
msgstr "现在您已经了解了 Unicode 的基础知识，可以看下 Python 的 Unicode 特性。"

#: ../../howto/unicode.rst:190
msgid "The String Type"
msgstr "字符串类型"

#: ../../howto/unicode.rst:192
msgid ""
"Since Python 3.0, the language's :class:`str` type contains Unicode "
"characters, meaning any string created using ``\"unicode rocks!\"``, "
"``'unicode rocks!'``, or the triple-quoted string syntax is stored as "
"Unicode."
msgstr ""
"从 Python 3.0 开始， :class:`str` 类型包含了 Unicode 字符，这意味着用 ``\"unicode "
"rocks!\"``、``'unicode rocks!'`` 或三重引号字符串语法创建的任何字符串都会存储为 Unicode。"

#: ../../howto/unicode.rst:196
msgid ""
"The default encoding for Python source code is UTF-8, so you can simply "
"include a Unicode character in a string literal::"
msgstr "Python 源代码的默认编码是 UTF-8，因此可以直接在字符串中包含 Unicode 字符："

#: ../../howto/unicode.rst:206
msgid ""
"Side note: Python 3 also supports using Unicode characters in identifiers::"
msgstr "旁注：Python 3 还支持在标识符中使用 Unicode 字符："

#: ../../howto/unicode.rst:212
msgid ""
"If you can't enter a particular character in your editor or want to keep the"
" source code ASCII-only for some reason, you can also use escape sequences "
"in string literals. (Depending on your system, you may see the actual "
"capital-delta glyph instead of a \\u escape.) ::"
msgstr ""
"如果无法在编辑器中输入某个字符，或出于某种原因想只保留 ASCII 编码的源代码，则还可以在字符串中使用转义序列。（根据系统的不同，可能会看到真的大写 "
"Delta 字体而不是 \\u 转义符。）："

#: ../../howto/unicode.rst:224
msgid ""
"In addition, one can create a string using the :func:`~bytes.decode` method "
"of :class:`bytes`.  This method takes an *encoding* argument, such as "
"``UTF-8``, and optionally an *errors* argument."
msgstr ""
"此外，可以用 :class:`bytes` 的 :func:`~bytes.decode` 方法创建一个字符串。 该方法可以接受 *encoding* "
"参数，比如可以为 ``UTF-8`` ，以及可选的 *errors* 参数。"

#: ../../howto/unicode.rst:228
msgid ""
"The *errors* argument specifies the response when the input string can't be "
"converted according to the encoding's rules.  Legal values for this argument"
" are ``'strict'`` (raise a :exc:`UnicodeDecodeError` exception), "
"``'replace'`` (use ``U+FFFD``, ``REPLACEMENT CHARACTER``), ``'ignore'`` "
"(just leave the character out of the Unicode result), or "
"``'backslashreplace'`` (inserts a ``\\xNN`` escape sequence). The following "
"examples show the differences::"
msgstr ""
"若无法根据编码规则对输入字符串进行编码，*errors* 参数指定了响应策略。 该参数的合法值可以是 ``'strict'`` (触发 "
":exc:`UnicodeDecodeError` 异常)、``'replace'`` (用 ``U+FFFD``、``REPLACEMENT "
"CHARACTER``)、``'ignore'`` (只是将字符从 Unicode 结果中去掉)，或 ``'backslashreplace'`` "
"(插入一个 ``\\xNN`` 转义序列)。 以下示例演示了这些不同的参数::"

#: ../../howto/unicode.rst:248
msgid ""
"Encodings are specified as strings containing the encoding's name.  Python "
"comes with roughly 100 different encodings; see the Python Library Reference"
" at :ref:`standard-encodings` for a list.  Some encodings have multiple "
"names; for example, ``'latin-1'``, ``'iso_8859_1'`` and ``'8859``' are all "
"synonyms for the same encoding."
msgstr ""
"编码格式以包含编码格式名称的字符串来指明。 Python 有大约 100 种不同的编码格式；清单详见 Python 库参考文档 "
":ref:`standard-encodings`。 一些编码格式有多个名称，比如 ``'latin-1'``、``'iso_8859_1'`` 和 "
"``'8859`` 都是指同一种编码。"

#: ../../howto/unicode.rst:254
msgid ""
"One-character Unicode strings can also be created with the :func:`chr` "
"built-in function, which takes integers and returns a Unicode string of "
"length 1 that contains the corresponding code point.  The reverse operation "
"is the built-in :func:`ord` function that takes a one-character Unicode "
"string and returns the code point value::"
msgstr ""
"利用内置函数 :func:`chr` 还可以创建单字符的 Unicode 字符串，该函数可接受整数参数，并返回包含对应码位的长度为 1 的 "
"Unicode 字符串。内置函数 :func:`ord` 是其逆操作，参数为单个字符的 Unicode 字符串，并返回码位值："

#: ../../howto/unicode.rst:266
msgid "Converting to Bytes"
msgstr "转换为字节"

#: ../../howto/unicode.rst:268
msgid ""
"The opposite method of :meth:`bytes.decode` is :meth:`str.encode`, which "
"returns a :class:`bytes` representation of the Unicode string, encoded in "
"the requested *encoding*."
msgstr ""
":meth:`bytes.decode` 的逆方法是 :meth:`str.encode` ，它会返回 Unicode 字符串的 "
":class:`bytes` 形式，已按要求的 *encoding* 进行了编码。"

#: ../../howto/unicode.rst:272
msgid ""
"The *errors* parameter is the same as the parameter of the "
":meth:`~bytes.decode` method but supports a few more possible handlers. As "
"well as ``'strict'``, ``'ignore'``, and ``'replace'`` (which in this case "
"inserts a question mark instead of the unencodable character), there is also"
" ``'xmlcharrefreplace'`` (inserts an XML character reference), "
"``backslashreplace`` (inserts a ``\\uNNNN`` escape sequence) and "
"``namereplace`` (inserts a ``\\N{...}`` escape sequence)."
msgstr ""
"参数 *errors* 的意义与 :meth:`~bytes.decode` 方法相同，但支持更多可能的handler。除了 ``'strict'`` "
"、 ``'ignore'`` 和 ``'replace'`` （这时会插入问号替换掉无法编码的字符），还有 "
"``'xmlcharrefreplace'`` （插入一个 XML 字符引用）、 ``backslashreplace`` （插入一个 "
"``\\uNNNN`` 转义序列）和  ``namereplace`` （插入一个 ``\\N{...}`` 转义序列 ）。"

#: ../../howto/unicode.rst:280
msgid "The following example shows the different results::"
msgstr "以下例子演示了各种不同的结果："

#: ../../howto/unicode.rst:301
msgid ""
"The low-level routines for registering and accessing the available encodings"
" are found in the :mod:`codecs` module.  Implementing new encodings also "
"requires understanding the :mod:`codecs` module. However, the encoding and "
"decoding functions returned by this module are usually more low-level than "
"is comfortable, and writing new encodings is a specialized task, so the "
"module won't be covered in this HOWTO."
msgstr ""
"用于注册和访问可用编码格式的底层函数，位于 :mod:`codecs` 模块中。 若要实现新的编码格式，则还需要了解 :mod:`codecs` 模块。"
" 不过该模块返回的编码和解码函数通常更为底层一些，不大好用，编写新的编码格式是一项专业的任务，因此本文不会涉及该模块。"

#: ../../howto/unicode.rst:310
msgid "Unicode Literals in Python Source Code"
msgstr "Python 源代码中的 Unicode 文字"

#: ../../howto/unicode.rst:312
msgid ""
"In Python source code, specific Unicode code points can be written using the"
" ``\\u`` escape sequence, which is followed by four hex digits giving the "
"code point.  The ``\\U`` escape sequence is similar, but expects eight hex "
"digits, not four::"
msgstr ""
"在 Python 源代码中，可以用 ``\\u`` 转义序列书写特定的 Unicode 码位，该序列后跟 4 个代表码位的十六进制数字。``\\U`` "
"转义序列用法类似，但要用8 个十六进制数字，而不是 4 个："

#: ../../howto/unicode.rst:324
msgid ""
"Using escape sequences for code points greater than 127 is fine in small "
"doses, but becomes an annoyance if you're using many accented characters, as"
" you would in a program with messages in French or some other accent-using "
"language.  You can also assemble strings using the :func:`chr` built-in "
"function, but this is even more tedious."
msgstr ""
"对大于 127 "
"的码位使用转义序列，数量不多时没什么问题，但如果要用到很多重音字符，这会变得很烦人，类似于程序中的信息是用法语或其他使用重音的语言写的。也可以用内置函数"
" :func:`chr` 拼装字符串，但会更加乏味。"

#: ../../howto/unicode.rst:330
msgid ""
"Ideally, you'd want to be able to write literals in your language's natural "
"encoding.  You could then edit Python source code with your favorite editor "
"which would display the accented characters naturally, and have the right "
"characters used at runtime."
msgstr ""
"理想情况下，都希望能用母语的编码书写文本。还能用喜好的编辑器编辑 Python 源代码，编辑器要能自然地显示重音符，并在运行时使用正确的字符。"

#: ../../howto/unicode.rst:335
msgid ""
"Python supports writing source code in UTF-8 by default, but you can use "
"almost any encoding if you declare the encoding being used.  This is done by"
" including a special comment as either the first or second line of the "
"source file::"
msgstr ""
"默认情况下，Python 支持以 UTF-8 "
"格式编写源代码，但如果声明要用的编码，则几乎可以使用任何编码。只要在源文件的第一行或第二行包含一个特殊注释即可："

#: ../../howto/unicode.rst:345
msgid ""
"The syntax is inspired by Emacs's notation for specifying variables local to"
" a file.  Emacs supports many different variables, but Python only supports "
"'coding'.  The ``-*-`` symbols indicate to Emacs that the comment is "
"special; they have no significance to Python but are a convention.  Python "
"looks for ``coding: name`` or ``coding=name`` in the comment."
msgstr ""
"上述语法的灵感来自于 Emacs 用于指定文件局部变量的符号。Emacs 支持许多不同的变量，但 Python 仅支持“编码”。 ``-*-`` 符号向"
" Emacs 标明该注释是特殊的；这对 Python 没有什么意义，只是一种约定。Python 会在注释中查找 ``coding: name`` 或 "
"``coding=name`` 。"

#: ../../howto/unicode.rst:351
msgid ""
"If you don't include such a comment, the default encoding used will be UTF-8"
" as already mentioned.  See also :pep:`263` for more information."
msgstr "如果没有这种注释，则默认编码将会是前面提到的 UTF-8。更多信息请参阅 :pep:`263` 。"

#: ../../howto/unicode.rst:356
msgid "Unicode Properties"
msgstr "Unicode属性"

#: ../../howto/unicode.rst:358
msgid ""
"The Unicode specification includes a database of information about code "
"points.  For each defined code point, the information includes the "
"character's name, its category, the numeric value if applicable (for "
"characters representing numeric concepts such as the Roman numerals, "
"fractions such as one-third and four-fifths, etc.).  There are also display-"
"related properties, such as how to use the code point in bidirectional text."
msgstr ""
"Unicode "
"规范包含了一个码位信息数据库。对于定义的每一个码位，都包含了字符的名称、类别、数值（对于表示数字概念的字符，如罗马数字、分数如三分之一和五分之四等）。还有有关显示的属性，比如如何在双向文本中使用码位。"

#: ../../howto/unicode.rst:366
msgid ""
"The following program displays some information about several characters, "
"and prints the numeric value of one particular character::"
msgstr "以下程序显示了几个字符的信息，并打印一个字符的数值："

#: ../../howto/unicode.rst:380
msgid "When run, this prints:"
msgstr "当运行时，这将打印出："

#: ../../howto/unicode.rst:391
msgid ""
"The category codes are abbreviations describing the nature of the character."
" These are grouped into categories such as \"Letter\", \"Number\", "
"\"Punctuation\", or \"Symbol\", which in turn are broken up into "
"subcategories.  To take the codes from the above output, ``'Ll'`` means "
"'Letter, lowercase', ``'No'`` means \"Number, other\", ``'Mn'`` is \"Mark, "
"nonspacing\", and ``'So'`` is \"Symbol, other\".  See `the General Category "
"Values section of the Unicode Character Database documentation "
"<https://www.unicode.org/reports/tr44/#General_Category_Values>`_ for a list"
" of category codes."
msgstr ""
"类别代码是描述字符性质的一个缩写。分为“字母”、“数字”、“标点符号”或“符号”等类别，而这些类别又分为子类别。就以上输出的代码而言，``'Ll'`` "
"表示“字母，小写”，``'No'`` 表示“数字，其他”，``'Mn'`` 表示“标记，非空白符” ,  ``'So'`` "
"是“符号，其他”。有关类别代码的清单，请参阅 `Unicode 字符库文档 "
"<https://www.unicode.org/reports/tr44/#General_Category_Values>`_ "
"的“通用类别值”部分。"

#: ../../howto/unicode.rst:402
msgid "Comparing Strings"
msgstr "字符串比较"

#: ../../howto/unicode.rst:404
msgid ""
"Unicode adds some complication to comparing strings, because the same set of"
" characters can be represented by different sequences of code points.  For "
"example, a letter like 'ê' can be represented as a single code point U+00EA,"
" or as U+0065 U+0302, which is the code point for 'e' followed by a code "
"point for 'COMBINING CIRCUMFLEX ACCENT'.  These will produce the same output"
" when printed, but one is a string of length 1 and the other is of length 2."
msgstr ""
"Unicode 让字符串的比较变得复杂了一些，因为同一组字符可能由不同的码位序列组成。例如，像“ê”这样的字母可以表示为单码位 U+00EA，或是 "
"U+0065 U+0302，即“e”的码位后跟“COMBINING CIRCUMFLEX "
"ACCENT”的码位。虽然在打印时会产生同样的输出，但一个是长度为 1 的字符串，另一个是长度为 2 的字符串。"

#: ../../howto/unicode.rst:412
msgid ""
"One tool for a case-insensitive comparison is the :meth:`~str.casefold` "
"string method that converts a string to a case-insensitive form following an"
" algorithm described by the Unicode Standard.  This algorithm has special "
"handling for characters such as the German letter 'ß' (code point U+00DF), "
"which becomes the pair of lowercase letters 'ss'."
msgstr ""
"一种不区分大小写比较的工具是字符串方法 :meth:`~str.casefold` ，将按照 Unicode "
"标准描述的算法将字符串转换为不区分大小写的形式。该算法对诸如德语字母“ß”（代码点 U+00DF）之类的字符进行了特殊处理，变为一对小写字母“ss”。"

#: ../../howto/unicode.rst:425
msgid ""
"A second tool is the :mod:`unicodedata` module's "
":func:`~unicodedata.normalize` function that converts strings to one of "
"several normal forms, where letters followed by a combining character are "
"replaced with single characters.  :func:`~unicodedata.normalize` can be used"
" to perform string comparisons that won't falsely report inequality if two "
"strings use combining characters differently:"
msgstr ""
"第二个工具是 :mod:`unicodedata` 模块的 :func:`~unicodedata.normalize` "
"函数，该函数可将字符串转换为几种规范化形式之一，即用单字符替换后面带一个组合字符的多个字母。 "
":func:`~unicodedata.normalize` 可被用于执行字符串比较，如果两个字符串使用不同的组合字符，也不会错误地报告两者不相等:"

#: ../../howto/unicode.rst:448
msgid "When run, this outputs:"
msgstr "当运行时，这将输出："

#: ../../howto/unicode.rst:457
msgid ""
"The first argument to the :func:`~unicodedata.normalize` function is a "
"string giving the desired normalization form, which can be one of 'NFC', "
"'NFKC', 'NFD', and 'NFKD'."
msgstr ""
":func:`~unicodedata.normalize` "
"函数的第一个参数是个字符串，给出所需的规范化形式，可以是“NFC”、“NFKC”、“NFD”和“NFKD”之一。"

#: ../../howto/unicode.rst:461
msgid "The Unicode Standard also specifies how to do caseless comparisons::"
msgstr "Unicode 标准还设定了如何进行不区分大小写的比较："

#: ../../howto/unicode.rst:477
msgid ""
"This will print ``True``.  (Why is :func:`!NFD` invoked twice?  Because "
"there are a few characters that make :meth:`~str.casefold` return a non-"
"normalized string, so the result needs to be normalized again. See section "
"3.13 of the Unicode Standard for a discussion and an example.)"
msgstr ""
"这将打印 ``True``。 （为什么 :func:`!NFD` 会两次被唤起？ 因为有几个字符会使 :meth:`~str.casefold` "
"返回非规范化的字符串，所以需要再次对结果进行规范化处理。 有关讨论和示例，请参阅 Unicode 标准第 3.13 节）。"

#: ../../howto/unicode.rst:484
msgid "Unicode Regular Expressions"
msgstr "Unicode 正则表达式"

#: ../../howto/unicode.rst:486
msgid ""
"The regular expressions supported by the :mod:`re` module can be provided "
"either as bytes or strings.  Some of the special character sequences such as"
" ``\\d`` and ``\\w`` have different meanings depending on whether the "
"pattern is supplied as bytes or a string.  For example, ``\\d`` will match "
"the characters ``[0-9]`` in bytes but in strings will match any character "
"that's in the ``'Nd'`` category."
msgstr ""
":mod:`re` 模块支持的正则表达式可以用字节串或字符串的形式提供。有一些特殊字符序列，比如 ``\\d`` 和 ``\\w`` "
"具有不同的含义，具体取决于匹配模式是以字节串还是字符串形式提供的。例如，``\\d`` 将匹配字节串中的字符 ``[0-9]`` ，但对于字符串将会匹配"
" ``'Nd'`` 类别中的任何字符。"

#: ../../howto/unicode.rst:493
msgid ""
"The string in this example has the number 57 written in both Thai and Arabic"
" numerals::"
msgstr "上述示例中的字符串包含了泰语和阿拉伯数字书写的数字 57："

#: ../../howto/unicode.rst:503
msgid ""
"When executed, ``\\d+`` will match the Thai numerals and print them out.  If"
" you supply the :const:`re.ASCII` flag to :func:`~re.compile`, ``\\d+`` will"
" match the substring \"57\" instead."
msgstr ""
"执行时，``\\d+`` 将匹配上泰语数字并打印出来。如果向  :func:`~re.compile` 提供的是 :const:`re.ASCII` "
"标志，``\\d+`` 则会匹配子串 \"57\"。"

#: ../../howto/unicode.rst:507
msgid ""
"Similarly, ``\\w`` matches a wide variety of Unicode characters but only "
"``[a-zA-Z0-9_]`` in bytes or if :const:`re.ASCII` is supplied, and ``\\s`` "
"will match either Unicode whitespace characters or ``[ \\t\\n\\r\\f\\v]``."
msgstr ""
"类似地，``\\w`` 将匹配多种 Unicode 字符，但对于字节串则只会匹配 ``[a-zA-Z0-9_]`` ，如果指定 "
":const:`re.ASCII` ， ``\\s`` 将匹配 Unicode 空白符或 ``[ \\t\\n\\r\\f\\v]`` 。"

#: ../../howto/unicode.rst:518
msgid "Some good alternative discussions of Python's Unicode support are:"
msgstr "关于 Python 的 Unicode 支持，其他还有一些很好的讨论："

#: ../../howto/unicode.rst:520
msgid ""
"`Processing Text Files in Python 3 <https://python-"
"notes.curiousefficiency.org/en/latest/python3/text_file_processing.html>`_, "
"by Nick Coghlan."
msgstr ""
"`用 Python 3 处理文本文件 <https://python-"
"notes.curiousefficiency.org/en/latest/python3/text_file_processing.html>`_ "
"，作者 Nick Coghlan。"

#: ../../howto/unicode.rst:521
msgid ""
"`Pragmatic Unicode <https://nedbatchelder.com/text/unipain.html>`_, a PyCon "
"2012 presentation by Ned Batchelder."
msgstr ""
"`实用的 Unicode <https://nedbatchelder.com/text/unipain.html>`_，Ned Batchelder "
"在 PyCon 2012 上的演示。"

#: ../../howto/unicode.rst:523
msgid ""
"The :class:`str` type is described in the Python library reference at "
":ref:`textseq`."
msgstr ":class:`str` 类型在 Python 库参考文档 :ref:`textseq` 中有介绍。"

#: ../../howto/unicode.rst:526
msgid "The documentation for the :mod:`unicodedata` module."
msgstr ":mod:`unicodedata` 模块的文档"

#: ../../howto/unicode.rst:528
msgid "The documentation for the :mod:`codecs` module."
msgstr ":mod:`codecs` 模块的文档"

#: ../../howto/unicode.rst:530
msgid ""
"Marc-André Lemburg gave `a presentation titled \"Python and Unicode\" (PDF "
"slides) <https://downloads.egenix.com/python/Unicode-EPC2002-Talk.pdf>`_ at "
"EuroPython 2002.  The slides are an excellent overview of the design of "
"Python 2's Unicode features (where the Unicode string type is called "
"``unicode`` and literals start with ``u``)."
msgstr ""
"Marc-André Lemburg 在 EuroPython 2002 上做了一个题为“Python 和 Unicode”（PDF "
"幻灯片）<https://downloads.egenix.com/python/Unicode-EPC2002-Talk.pdf>`_ "
"的演示文稿。该幻灯片很好地概括了 Python 2 的 Unicode 功能设计（其中 Unicode 字符串类型称为 ``unicode``，文字以 "
"``u`` 开头）。"

#: ../../howto/unicode.rst:538
msgid "Reading and Writing Unicode Data"
msgstr "Unicode 数据的读写"

#: ../../howto/unicode.rst:540
msgid ""
"Once you've written some code that works with Unicode data, the next problem"
" is input/output.  How do you get Unicode strings into your program, and how"
" do you convert Unicode into a form suitable for storage or transmission?"
msgstr ""
"既然处理 Unicode 数据的代码写好了，下一个问题就是输入/输出了。如何将 Unicode 字符串读入程序，如何将 Unicode "
"转换为适于存储或传输的形式呢？"

#: ../../howto/unicode.rst:544
msgid ""
"It's possible that you may not need to do anything depending on your input "
"sources and output destinations; you should check whether the libraries used"
" in your application support Unicode natively.  XML parsers often return "
"Unicode data, for example.  Many relational databases also support Unicode-"
"valued columns and can return Unicode values from an SQL query."
msgstr ""
"根据输入源和输出目标的不同，或许什么都不用干；请检查一下应用程序用到的库是否原生支持 Unicode。例如，XML 解析器往往会返回 Unicode "
"数据。许多关系数据库的字段也支持 Unicode 值，并且 SQL 查询也能返回 Unicode 值。"

#: ../../howto/unicode.rst:550
msgid ""
"Unicode data is usually converted to a particular encoding before it gets "
"written to disk or sent over a socket.  It's possible to do all the work "
"yourself: open a file, read an 8-bit bytes object from it, and convert the "
"bytes with ``bytes.decode(encoding)``.  However, the manual approach is not "
"recommended."
msgstr ""
"在写入磁盘或通过套接字发送之前，Unicode 数据通常要转换为特定的编码。可以自己完成所有工作：打开一个文件，从中读取一个 8 位字节对象，然后用 "
"``bytes.decode(encoding)`` 对字节串进行转换。但是，不推荐采用这种全人工的方案。"

#: ../../howto/unicode.rst:555
msgid ""
"One problem is the multi-byte nature of encodings; one Unicode character can"
" be represented by several bytes.  If you want to read the file in "
"arbitrary-sized chunks (say, 1024 or 4096 bytes), you need to write error-"
"handling code to catch the case where only part of the bytes encoding a "
"single Unicode character are read at the end of a chunk.  One solution would"
" be to read the entire file into memory and then perform the decoding, but "
"that prevents you from working with files that are extremely large; if you "
"need to read a 2 GiB file, you need 2 GiB of RAM. (More, really, since for "
"at least a moment you'd need to have both the encoded string and its Unicode"
" version in memory.)"
msgstr ""
"编码的多字节特性就是一个难题； 一个 Unicode 字符可以用几个字节表示。 如果要以任意大小的块（例如 1024 或 4096 "
"字节）读取文件，那么在块的末尾可能只读到某个 Unicode 字符的部分字节，这就需要编写错误处理代码。 "
"有一种解决方案是将整个文件读入内存，然后进行解码，但这样就没法处理很大的文件了；若要读取 2 GB 的文件，就需要 2 GB 的 "
"RAM。（其实需要的内存会更多些，因为至少有一段时间需要在内存中同时存放已编码字符串及其 Unicode 版本。）"

#: ../../howto/unicode.rst:565
msgid ""
"The solution would be to use the low-level decoding interface to catch the "
"case of partial coding sequences.  The work of implementing this has already"
" been done for you: the built-in :func:`open` function can return a file-"
"like object that assumes the file's contents are in a specified encoding and"
" accepts Unicode parameters for methods such as :meth:`~io.TextIOBase.read` "
"and :meth:`~io.TextIOBase.write`.  This works through :func:`open`\\'s "
"*encoding* and *errors* parameters which are interpreted just like those in "
":meth:`str.encode` and :meth:`bytes.decode`."
msgstr ""
"解决方案是利用底层解码接口去捕获编码序列不完整的情况。这部分代码已经是现成的：内置函数 :func:`open` "
"可以返回一个文件类的对象，该对象认为文件的内容采用指定的编码，:meth:`~io.TextIOBase.read` 和 "
":meth:`~io.TextIOBase.write` 等方法接受 Unicode 参数。只要用 :func:`open` 的 *encoding* "
"和 *errors* 参数即可，参数释义同 :meth:`str.encode` 和 :meth:`bytes.decode` 。"

#: ../../howto/unicode.rst:574
msgid "Reading Unicode from a file is therefore simple::"
msgstr "因此从文件读取 Unicode 就比较简单了："

#: ../../howto/unicode.rst:580
msgid ""
"It's also possible to open files in update mode, allowing both reading and "
"writing::"
msgstr "也可以在更新模式下打开文件，以便同时读取和写入："

#: ../../howto/unicode.rst:588
msgid ""
"The Unicode character ``U+FEFF`` is used as a byte-order mark (BOM), and is "
"often written as the first character of a file in order to assist with "
"autodetection of the file's byte ordering.  Some encodings, such as UTF-16, "
"expect a BOM to be present at the start of a file; when such an encoding is "
"used, the BOM will be automatically written as the first character and will "
"be silently dropped when the file is read.  There are variants of these "
"encodings, such as 'utf-16-le' and 'utf-16-be' for little-endian and big-"
"endian encodings, that specify one particular byte ordering and don't skip "
"the BOM."
msgstr ""
"Unicode 字符 ``U+FEFF`` 用作字节顺序标记（BOM），通常作为文件的第一个字符写入，以帮助自动检测文件的字节顺序。某些编码（例如 "
"UTF-16）期望在文件开头出现 BOM；当采用这种编码时，BOM 将自动作为第一个字符写入，并在读取文件时会静默删除。这些编码有多种变体，例如用于 "
"little-endian 和 big-endian 编码的 “utf-16-le” 和 “utf-16-be”，会指定一种特定的字节顺序并且不会忽略 "
"BOM。"

#: ../../howto/unicode.rst:597
msgid ""
"In some areas, it is also convention to use a \"BOM\" at the start of UTF-8 "
"encoded files; the name is misleading since UTF-8 is not byte-order "
"dependent. The mark simply announces that the file is encoded in UTF-8.  For"
" reading such files, use the 'utf-8-sig' codec to automatically skip the "
"mark if present."
msgstr ""
"在某些地区，习惯在 UTF-8 编码文件的开头用上“BOM”；此名称具有误导性，因为 UTF-8 与字节顺序无关。此标记只是声明该文件以 UTF-8 "
"编码。要读取此类文件，请使用“utf-8-sig”编解码器自动忽略此标记。"

#: ../../howto/unicode.rst:604
msgid "Unicode filenames"
msgstr "Unicode 文件名"

#: ../../howto/unicode.rst:606
msgid ""
"Most of the operating systems in common use today support filenames that "
"contain arbitrary Unicode characters.  Usually this is implemented by "
"converting the Unicode string into some encoding that varies depending on "
"the system.  Today Python is converging on using UTF-8: Python on MacOS has "
"used UTF-8 for several versions, and Python 3.6 switched to using UTF-8 on "
"Windows as well.  On Unix systems, there will only be a :term:`filesystem "
"encoding <filesystem encoding and error handler>`. if you've set the "
"``LANG`` or ``LC_CTYPE`` environment variables; if you haven't, the default "
"encoding is again UTF-8."
msgstr ""
"当今大多数操作系统都支持包含任意 Unicode 字符的文件名。 通常这是通过将 Unicode 字符串转换为某种根据具体系统而定的编码格式来实现的。 "
"如今的 Python 倾向于使用 UTF-8：MacOS 上的 Python 已经在多个版本中使用了 UTF-8，而 Python 3.6 也已在 "
"Windows 上改用了 UTF-8。 在 Unix 系统中，将只有一个 :term:`文件系统编码格式 <filesystem encoding "
"and error handler>`。 如果你已设置了 ``LANG`` 或 ``LC_CTYPE`` 环境变量的话；如果未设置，则默认编码格式还是 "
"UTF-8。"

#: ../../howto/unicode.rst:616
msgid ""
"The :func:`sys.getfilesystemencoding` function returns the encoding to use "
"on your current system, in case you want to do the encoding manually, but "
"there's not much reason to bother.  When opening a file for reading or "
"writing, you can usually just provide the Unicode string as the filename, "
"and it will be automatically converted to the right encoding for you::"
msgstr ""
":func:`sys.getfilesystemencoding` "
"函数将返回要在当前系统采用的编码，若想手动进行编码时即可用到，但无需多虑。在打开文件进行读写时，通常只需提供 Unicode "
"字符串作为文件名，会自动转换为合适的编码格式："

#: ../../howto/unicode.rst:626
msgid ""
"Functions in the :mod:`os` module such as :func:`os.stat` will also accept "
"Unicode filenames."
msgstr ":mod:`os` 模块中的函数也能接受 Unicode 文件名，如 :func:`os.stat` 。"

#: ../../howto/unicode.rst:629
msgid ""
"The :func:`os.listdir` function returns filenames, which raises an issue: "
"should it return the Unicode version of filenames, or should it return bytes"
" containing the encoded versions?  :func:`os.listdir` can do both, depending"
" on whether you provided the directory path as bytes or a Unicode string.  "
"If you pass a Unicode string as the path, filenames will be decoded using "
"the filesystem's encoding and a list of Unicode strings will be returned, "
"while passing a byte path will return the filenames as bytes.  For example, "
"assuming the default :term:`filesystem encoding <filesystem encoding and "
"error handler>` is UTF-8, running the following program::"
msgstr ""
":func:`os.listdir` 函数返回文件名，这引发了一个问题：它应该返回文件名的 Unicode 版本，还是应该返回包含已编码版本的字节串？ "
"这两者 :func:`os.listdir` 都能做到，具体取决于你给出的目录路径是字节串还是 Unicode 字符串形式的。 如果你传入一个 "
"Unicode 字符串作为路径，文件名将使用文件系统的编码格式进行解码并返回一个 Unicode "
"字符串列表，而传入一个字节串形式的路径则将返回字节串形式的文件名。 例如，假定默认 :term:`文件系统编码 <filesystem encoding"
" and error handler>` 为 UTF-8，运行以下程序::"

#: ../../howto/unicode.rst:647
msgid "will produce the following output:"
msgstr "将产生以下输出："

#: ../../howto/unicode.rst:655
msgid ""
"The first list contains UTF-8-encoded filenames, and the second list "
"contains the Unicode versions."
msgstr "第一个列表包含 UTF-8 编码的文件名，第二个列表则包含 Unicode 版本的。"

#: ../../howto/unicode.rst:658
msgid ""
"Note that on most occasions, you should can just stick with using Unicode "
"with these APIs.  The bytes APIs should only be used on systems where "
"undecodable file names can be present; that's pretty much only Unix systems "
"now."
msgstr ""
"请注意，大多时候应该坚持用这些 API 处理 Unicode。字节串 API 应该仅用于可能存在不可解码文件名的系统；现在几乎仅剩 Unix 系统了。"

#: ../../howto/unicode.rst:665
msgid "Tips for Writing Unicode-aware Programs"
msgstr "识别 Unicode 的编程技巧"

#: ../../howto/unicode.rst:667
msgid ""
"This section provides some suggestions on writing software that deals with "
"Unicode."
msgstr "本节提供了一些关于编写 Unicode 处理软件的建议。"

#: ../../howto/unicode.rst:670
msgid "The most important tip is:"
msgstr "最重要的技巧如下："

#: ../../howto/unicode.rst:672
msgid ""
"Software should only work with Unicode strings internally, decoding the "
"input data as soon as possible and encoding the output only at the end."
msgstr "程序应只在内部处理 Unicode 字符串，尽快对输入数据进行解码，并只在最后对输出进行编码。"

#: ../../howto/unicode.rst:675
msgid ""
"If you attempt to write processing functions that accept both Unicode and "
"byte strings, you will find your program vulnerable to bugs wherever you "
"combine the two different kinds of strings.  There is no automatic encoding "
"or decoding: if you do e.g. ``str + bytes``, a :exc:`TypeError` will be "
"raised."
msgstr ""
"如果尝试编写的处理函数对 Unicode "
"和字节串形式的字符串都能接受，就会发现组合使用两种不同类型的字符串时，容易产生差错。没办法做到自动编码或解码：如果执行 ``str + "
"bytes``，则会触发 :exc:`TypeError`。"

#: ../../howto/unicode.rst:680
msgid ""
"When using data coming from a web browser or some other untrusted source, a "
"common technique is to check for illegal characters in a string before using"
" the string in a generated command line or storing it in a database.  If "
"you're doing this, be careful to check the decoded string, not the encoded "
"bytes data; some encodings may have interesting properties, such as not "
"being bijective or not being fully ASCII-compatible.  This is especially "
"true if the input data also specifies the encoding, since the attacker can "
"then choose a clever way to hide malicious text in the encoded bytestream."
msgstr ""
"当要使用的数据来自 Web "
"浏览器或其他不受信来源时，常用技术是在用该字符串生成命令行之前，或要存入数据库之前，先检查字符串中是否包含非法字符。请仔细检查解码后的字符串，而不是编码格式的字节串数据；有些编码可能具备一些有趣的特性，例如与"
" ASCII 不是一一对应或不完全兼容。如果输入数据还指定了编码格式，则尤其如此，因为攻击者可以选择一种巧妙的方式将恶意文本隐藏在经过编码的字节流中。"

#: ../../howto/unicode.rst:691
msgid "Converting Between File Encodings"
msgstr "在文件编码格式之间进行转换"

#: ../../howto/unicode.rst:693
msgid ""
"The :class:`~codecs.StreamRecoder` class can transparently convert between "
"encodings, taking a stream that returns data in encoding #1 and behaving "
"like a stream returning data in encoding #2."
msgstr ""
":class:`~codecs.StreamRecoder` 类可以在两种编码之间透明地进行转换，参数为编码格式为 #1 "
"的数据流，表现行为则是编码格式为 #2 的数据流。"

#: ../../howto/unicode.rst:697
msgid ""
"For example, if you have an input file *f* that's in Latin-1, you can wrap "
"it with a :class:`~codecs.StreamRecoder` to return bytes encoded in UTF-8::"
msgstr ""
"假设输入文件 *f* 采用 Latin-1 编码格式，即可用 :class:`~codecs.StreamRecoder` 包装后返回 UTF-8 "
"编码的字节串："

#: ../../howto/unicode.rst:711
msgid "Files in an Unknown Encoding"
msgstr "编码格式未知的文件"

#: ../../howto/unicode.rst:713
msgid ""
"What can you do if you need to make a change to a file, but don't know the "
"file's encoding?  If you know the encoding is ASCII-compatible and only want"
" to examine or modify the ASCII parts, you can open the file with the "
"``surrogateescape`` error handler::"
msgstr ""
"若需对文件进行修改，但不知道文件的编码，那该怎么办呢？如果已知编码格式与 ASCII 兼容，并且只想查看或修改 ASCII 部分，则可利用 "
"``surrogateescape`` 错误处理 handler 打开文件："

#: ../../howto/unicode.rst:727
msgid ""
"The ``surrogateescape`` error handler will decode any non-ASCII bytes as "
"code points in a special range running from U+DC80 to U+DCFF.  These code "
"points will then turn back into the same bytes when the ``surrogateescape`` "
"error handler is used to encode the data and write it back out."
msgstr ""
"``surrogateescape`` 错误处理 handler 会把所有非 ASCII 字节解码为 U+DC80 至 U+DCFF "
"这一特殊范围的码位。当 ``surrogateescape`` 错误处理 handler用于数据编码并回写时，这些码位将转换回原样。"

#: ../../howto/unicode.rst:737
msgid ""
"One section of `Mastering Python 3 Input/Output "
"<https://pyvideo.org/video/289/pycon-2010--mastering-python-3-i-o>`_, a "
"PyCon 2010 talk by David Beazley, discusses text processing and binary data "
"handling."
msgstr ""
"David Beazley 在 PyCon 2010 上的演讲 `掌握 Python 3 输入/输出 "
"<https://pyvideo.org/video/289/pycon-2010--mastering-python-3-io>`_ "
"中，有一节讨论了文本和二进制数据的处理。"

#: ../../howto/unicode.rst:741
msgid ""
"The `PDF slides for Marc-André Lemburg's presentation \"Writing Unicode-"
"aware Applications in Python\" "
"<https://downloads.egenix.com/python/LSM2005-Developing-Unicode-aware-"
"applications-in-Python.pdf>`_ discuss questions of character encodings as "
"well as how to internationalize and localize an application.  These slides "
"cover Python 2.x only."
msgstr ""
"`Marc-André Lemburg 演示的PDF 幻灯片“在 Python 中编写支持 Unicode 的应用程序”  "
"<https://downloads.egenix.com/python/LSM2005-Developing-Unicode-aware-"
"applications-in-Python.pdf>`_ ，讨论了字符编码问题以及如何国际化和本地化应用程序。这些幻灯片仅涵盖 Python 2.x。"

#: ../../howto/unicode.rst:747
msgid ""
"`The Guts of Unicode in Python <https://pyvideo.org/video/1768/the-guts-of-"
"unicode-in-python>`_ is a PyCon 2013 talk by Benjamin Peterson that "
"discusses the internal Unicode representation in Python 3.3."
msgstr ""
"`Python Unicode 实质 <https://pyvideo.org/video/1768/the-guts-of-unicode-in-"
"python>`_ 是 Benjamin Peterson 在 PyCon 2013 上的演讲，讨论了 Unicode  在 Python 3.3 "
"中的内部表示。"

#: ../../howto/unicode.rst:754
msgid "Acknowledgements"
msgstr "致谢"

#: ../../howto/unicode.rst:756
msgid ""
"The initial draft of this document was written by Andrew Kuchling. It has "
"since been revised further by Alexander Belopolsky, Georg Brandl, Andrew "
"Kuchling, and Ezio Melotti."
msgstr ""
"本文初稿由 Andrew Kuchling 撰写。此后，Alexander Belopolsky、Georg Brandl、Andrew "
"Kuchling 和 Ezio Melotti 作了进一步修订。"

#: ../../howto/unicode.rst:760
msgid ""
"Thanks to the following people who have noted errors or offered suggestions "
"on this article: Éric Araujo, Nicholas Bastin, Nick Coghlan, Marius "
"Gedminas, Kent Johnson, Ken Krugler, Marc-André Lemburg, Martin von Löwis, "
"Terry J. Reedy, Serhiy Storchaka, Eryk Sun, Chad Whitacre, Graham Wideman."
msgstr ""
"感谢以下各位指出本文错误或提出建议：Éric Araujo、Nicholas Bastin、Nick Coghlan、Marius "
"Gedminas、Kent Johnson、Ken Krugler、Marc-André Lemburg、Martin von Löwis、Terry "
"J. Reedy、Serhiy Storchaka , Eryk Sun, Chad Whitacre, Graham Wideman。"
