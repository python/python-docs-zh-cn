# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# wi24rd, 2021
# ww song <sww4718168@gmail.com>, 2021
# Fei Yin <icebirds@163.com>, 2021
# Kder <kder@live.cn>, 2021
# Konge <zkonge@outlook.com>, 2021
# nick <2330458484@qq.com>, 2021
# MuSheng Chen <sheng.2179@gmail.com>, 2021
# Xu Siyuan, 2021
# chen_chao <wenbushi@gmail.com>, 2021
# Alpha Du <alphanow@gmail.com>, 2022
# ProgramRipper, 2023
# Wulian233 <xiguawulian@gmail.com>, 2024
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-04 14:20+0000\n"
"PO-Revision-Date: 2021-06-28 00:53+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/functional.rst:5
msgid "Functional Programming HOWTO"
msgstr "函数式编程指引"

#: ../../howto/functional.rst:0
msgid "Author"
msgstr "作者"

#: ../../howto/functional.rst:7
msgid "A. M. Kuchling"
msgstr "A. M. Kuchling"

#: ../../howto/functional.rst:0
msgid "Release"
msgstr "发布版本"

#: ../../howto/functional.rst:8
msgid "0.32"
msgstr "0.32"

#: ../../howto/functional.rst:10
msgid ""
"In this document, we'll take a tour of Python's features suitable for "
"implementing programs in a functional style.  After an introduction to the "
"concepts of functional programming, we'll look at language features such as "
":term:`iterator`\\s and :term:`generator`\\s and relevant library modules "
"such as :mod:`itertools` and :mod:`functools`."
msgstr ""
"本文档提供恰当的 Python 函数式编程范例，在函数式编程简单的介绍之后，将简单介绍Python中关于函数式编程的特性如 "
":term:`iterator` 和 :term:`generator` 以及相关库模块如 :mod:`itertools` 和 "
":mod:`functools` 等。"

#: ../../howto/functional.rst:18
msgid "Introduction"
msgstr "概述"

#: ../../howto/functional.rst:20
msgid ""
"This section explains the basic concept of functional programming; if you're"
" just interested in learning about Python language features, skip to the "
"next section on :ref:`functional-howto-iterators`."
msgstr ""
"本章介绍函数式编程的基本概念。如您仅想学习 Python 语言的特性，可跳过本章直接查看 :ref:`functional-howto-"
"iterators`."

#: ../../howto/functional.rst:24
msgid ""
"Programming languages support decomposing problems in several different "
"ways:"
msgstr "编程语言支持通过以下几种方式来解构具体问题："

#: ../../howto/functional.rst:26
msgid ""
"Most programming languages are **procedural**: programs are lists of "
"instructions that tell the computer what to do with the program's input.  C,"
" Pascal, and even Unix shells are procedural languages."
msgstr ""
"大多数的编程语言都是 **过程式** 的，所谓程序就是一连串告诉计算机怎样处理程序输入的指令。C、Pascal 甚至 Unix shells "
"都是过程式语言。"

#: ../../howto/functional.rst:30
msgid ""
"In **declarative** languages, you write a specification that describes the "
"problem to be solved, and the language implementation figures out how to "
"perform the computation efficiently.  SQL is the declarative language you're"
" most likely to be familiar with; a SQL query describes the data set you "
"want to retrieve, and the SQL engine decides whether to scan tables or use "
"indexes, which subclauses should be performed first, etc."
msgstr ""
"在 **声明式** 语言中，你编写一个用来描述待解决问题的说明，并且这个语言的具体实现会指明怎样高效的进行计算。 SQL 可能是你最熟悉的声明式语言了。"
" 一个 SQL 查询语句描述了你想要检索的数据集，并且 SQL 引擎会决定是扫描整张表还是使用索引，应该先执行哪些子句等等。"

#: ../../howto/functional.rst:37
msgid ""
"**Object-oriented** programs manipulate collections of objects.  Objects "
"have internal state and support methods that query or modify this internal "
"state in some way. Smalltalk and Java are object-oriented languages.  C++ "
"and Python are languages that support object-oriented programming, but don't"
" force the use of object-oriented features."
msgstr ""
"**面向对象** 程序会操作一组对象。 对象拥有内部状态，并能够以某种方式支持请求和修改这个内部状态的方法。Smalltalk 和 Java "
"都是面向对象的语言。 C++ 和 Python 支持面向对象编程，但并不强制使用面向对象特性。"

#: ../../howto/functional.rst:43
msgid ""
"**Functional** programming decomposes a problem into a set of functions. "
"Ideally, functions only take inputs and produce outputs, and don't have any "
"internal state that affects the output produced for a given input.  Well-"
"known functional languages include the ML family (Standard ML, OCaml, and "
"other variants) and Haskell."
msgstr ""
"**函数式** 编程则将一个问题分解成一系列函数。 理想情况下，函数只接受输入并输出结果，对一个给定的输入也不会有影响输出的内部状态。 "
"著名的函数式语言有 ML 家族（Standard ML，Ocaml 以及其他变种）和 Haskell。"

#: ../../howto/functional.rst:49
msgid ""
"The designers of some computer languages choose to emphasize one particular "
"approach to programming.  This often makes it difficult to write programs "
"that use a different approach.  Other languages are multi-paradigm languages"
" that support several different approaches. Lisp, C++, and Python are multi-"
"paradigm; you can write programs or libraries that are largely procedural, "
"object-oriented, or functional in all of these languages.  In a large "
"program, different sections might be written using different approaches; the"
" GUI might be object-oriented while the processing logic is procedural or "
"functional, for example."
msgstr ""
"一些语言的设计者选择强调一种特定的编程方式。 这通常会让以不同的方式来编写程序变得困难。其他多范式语言则支持几种不同的编程方式。Lisp，C++ 和 "
"Python "
"都是多范式语言；使用这些语言，你可以编写主要为过程式，面向对象或者函数式的程序和函数库。在大型程序中，不同的部分可能会采用不同的方式编写；比如 GUI "
"可能是面向对象的而处理逻辑则是过程式或者函数式。"

#: ../../howto/functional.rst:60
msgid ""
"In a functional program, input flows through a set of functions. Each "
"function operates on its input and produces some output.  Functional style "
"discourages functions with side effects that modify internal state or make "
"other changes that aren't visible in the function's return value.  Functions"
" that have no side effects at all are called **purely functional**.  "
"Avoiding side effects means not using data structures that get updated as a "
"program runs; every function's output must only depend on its input."
msgstr ""
"在函数式程序里，输入会流经一系列函数。每个函数接受输入并输出结果。函数式风格反对使用带有副作用的函数，这些副作用会修改内部状态，或者引起一些无法体现在函数的返回值中的变化。完全不产生副作用的函数被称作“纯函数”。消除副作用意味着不能使用随程序运行而更新的数据结构；每个函数的输出必须只依赖于输入。"

#: ../../howto/functional.rst:68
msgid ""
"Some languages are very strict about purity and don't even have assignment "
"statements such as ``a=3`` or ``c = a + b``, but it's difficult to avoid all"
" side effects, such as printing to the screen or writing to a disk file. "
"Another example is a call to the :func:`print` or :func:`time.sleep` "
"function, neither of which returns a useful value. Both are called only for "
"their side effects of sending some text to the screen or pausing execution "
"for a second."
msgstr ""
"有些语言对纯洁性要求非常严格，甚至没有诸如 ``a=3`` 或 ``c = a + b`` "
"之类的赋值语句，但很难避免所有的副作用，如打印到屏幕上或写到磁盘文件之类的副作用。另一个例子是调用 :func:`print` 或 "
":func:`time.sleep` 函数，它们都没有返回一个有用的值。这两个函数被调用只是为了它们的副作用，即向屏幕发送一些文本或暂停执行一秒钟。"

#: ../../howto/functional.rst:75
msgid ""
"Python programs written in functional style usually won't go to the extreme "
"of avoiding all I/O or all assignments; instead, they'll provide a "
"functional-appearing interface but will use non-functional features "
"internally. For example, the implementation of a function will still use "
"assignments to local variables, but won't modify global variables or have "
"other side effects."
msgstr ""
"函数式风格的 Python 程序并不会极端到消除所有 I/O "
"或者赋值的程度；相反，他们会提供像函数式一样的接口，但会在内部使用非函数式的特性。比如，函数的实现仍然会使用局部变量，但不会修改全局变量或者有其他副作用。"

#: ../../howto/functional.rst:81
msgid ""
"Functional programming can be considered the opposite of object-oriented "
"programming.  Objects are little capsules containing some internal state "
"along with a collection of method calls that let you modify this state, and "
"programs consist of making the right set of state changes.  Functional "
"programming wants to avoid state changes as much as possible and works with "
"data flowing between functions.  In Python you might combine the two "
"approaches by writing functions that take and return instances representing "
"objects in your application (e-mail messages, transactions, etc.)."
msgstr ""
"函数式编程可以被认为是面向对象编程的对立面。对象就像是颗小胶囊，包裹着内部状态和随之而来的能让你修改这个内部状态的一组调用方法，以及由正确的状态变化所构成的程序。函数式编程希望尽可能地消除状态变化，只和流经函数的数据打交道。在"
" Python 里你可以把两种编程方式结合起来，在你的应用（电子邮件信息，事务处理）中编写接受和返回对象实例的函数。"

#: ../../howto/functional.rst:90
msgid ""
"Functional design may seem like an odd constraint to work under.  Why should"
" you avoid objects and side effects?  There are theoretical and practical "
"advantages to the functional style:"
msgstr "函数式设计在工作中看起来是个奇怪的约束。为什么你要消除对象和副作用呢？不过函数式风格有其理论和实践上的优点："

#: ../../howto/functional.rst:94
msgid "Formal provability."
msgstr "形式证明。"

#: ../../howto/functional.rst:95
msgid "Modularity."
msgstr "模块化。"

#: ../../howto/functional.rst:96
msgid "Composability."
msgstr "组合性。"

#: ../../howto/functional.rst:97
msgid "Ease of debugging and testing."
msgstr "易于调试和测试。"

#: ../../howto/functional.rst:101
msgid "Formal provability"
msgstr "形式证明"

#: ../../howto/functional.rst:103
msgid ""
"A theoretical benefit is that it's easier to construct a mathematical proof "
"that a functional program is correct."
msgstr "一个理论上的优点是，构造数学证明来说明函数式程序是正确的相对更容易些。"

#: ../../howto/functional.rst:106
msgid ""
"For a long time researchers have been interested in finding ways to "
"mathematically prove programs correct.  This is different from testing a "
"program on numerous inputs and concluding that its output is usually "
"correct, or reading a program's source code and concluding that the code "
"looks right; the goal is instead a rigorous proof that a program produces "
"the right result for all possible inputs."
msgstr ""
"很长时间，研究者们对寻找证明程序正确的数学方法都很感兴趣。这和通过大量输入来测试，并得出程序的输出基本正确，或者阅读一个程序的源代码然后得出代码看起来没问题不同；相反，这里的目标是一个严格的证明，证明程序对所有可能的输入都能给出正确的结果。"

#: ../../howto/functional.rst:113
msgid ""
"The technique used to prove programs correct is to write down "
"**invariants**, properties of the input data and of the program's variables "
"that are always true.  For each line of code, you then show that if "
"invariants X and Y are true **before** the line is executed, the slightly "
"different invariants X' and Y' are true **after** the line is executed.  "
"This continues until you reach the end of the program, at which point the "
"invariants should match the desired conditions on the program's output."
msgstr ""
"证明程序正确性所用到的技术是写出 **不变量**，也就是对于输入数据和程序中的变量永远为真的特性。然后对每行代码，你说明这行代码执行前的不变量 X 和 "
"Y 以及执行后稍有不同的不变量 X' 和 Y' 为真。如此一直到程序结束，这时候在程序的输出上，不变量应该会与期望的状态一致。"

#: ../../howto/functional.rst:121
msgid ""
"Functional programming's avoidance of assignments arose because assignments "
"are difficult to handle with this technique; assignments can break "
"invariants that were true before the assignment without producing any new "
"invariants that can be propagated onward."
msgstr "函数式编程之所以要消除赋值，是因为赋值在这个技术中难以处理；赋值可能会破坏赋值前为真的不变量，却并不产生任何可以传递下去的新的不变量。"

#: ../../howto/functional.rst:126
msgid ""
"Unfortunately, proving programs correct is largely impractical and not "
"relevant to Python software. Even trivial programs require proofs that are "
"several pages long; the proof of correctness for a moderately complicated "
"program would be enormous, and few or none of the programs you use daily "
"(the Python interpreter, your XML parser, your web browser) could be proven "
"correct.  Even if you wrote down or generated a proof, there would then be "
"the question of verifying the proof; maybe there's an error in it, and you "
"wrongly believe you've proved the program correct."
msgstr ""
"不幸的是，证明程序的正确性很大程度上是经验性质的，而且和 Python "
"软件无关。即使是微不足道的程序都需要几页长的证明；一个中等复杂的程序的正确性证明会非常庞大，而且，极少甚至没有你日常所使用的程序（Python "
"解释器，XML "
"解析器，浏览器）的正确性能够被证明。即使你写出或者生成一个证明，验证证明也会是一个问题；里面可能出了差错，而你错误地相信你证明了程序的正确性。"

#: ../../howto/functional.rst:137
msgid "Modularity"
msgstr "模块化"

#: ../../howto/functional.rst:139
msgid ""
"A more practical benefit of functional programming is that it forces you to "
"break apart your problem into small pieces.  Programs are more modular as a "
"result.  It's easier to specify and write a small function that does one "
"thing than a large function that performs a complicated transformation.  "
"Small functions are also easier to read and to check for errors."
msgstr ""
"函数式编程的一个更实用的优点是，它强制你把问题分解成小的方面。因此程序会更加模块化。相对于一个进行了复杂变换的大型函数，一个小的函数更明确，更易于编写,"
" 也更易于阅读和检查错误。"

#: ../../howto/functional.rst:147
msgid "Ease of debugging and testing"
msgstr "易于调试和测试"

#: ../../howto/functional.rst:149
msgid "Testing and debugging a functional-style program is easier."
msgstr "测试和调试函数式程序相对来说更容易。"

#: ../../howto/functional.rst:151
msgid ""
"Debugging is simplified because functions are generally small and clearly "
"specified.  When a program doesn't work, each function is an interface point"
" where you can check that the data are correct.  You can look at the "
"intermediate inputs and outputs to quickly isolate the function that's "
"responsible for a bug."
msgstr ""
"调试很简单是因为函数通常都很小而且清晰明确。当程序无法工作的时候，每个函数都是一个可以检查数据是否正确的接入点。你可以通过查看中间输入和输出迅速找到出错的函数。"

#: ../../howto/functional.rst:156
msgid ""
"Testing is easier because each function is a potential subject for a unit "
"test. Functions don't depend on system state that needs to be replicated "
"before running a test; instead you only have to synthesize the right input "
"and then check that the output matches expectations."
msgstr ""
"测试更容易是因为每个函数都是单元测试的潜在目标。在执行测试前，函数并不依赖于需要重现的系统状态；相反，你只需要给出正确的输入，然后检查输出是否和期望的结果一致。"

#: ../../howto/functional.rst:163
msgid "Composability"
msgstr "组合性"

#: ../../howto/functional.rst:165
msgid ""
"As you work on a functional-style program, you'll write a number of "
"functions with varying inputs and outputs.  Some of these functions will be "
"unavoidably specialized to a particular application, but others will be "
"useful in a wide variety of programs.  For example, a function that takes a "
"directory path and returns all the XML files in the directory, or a function"
" that takes a filename and returns its contents, can be applied to many "
"different situations."
msgstr ""
"当你编写函数式风格的程序时，你会写出很多带有不同输入和输出的函数。其中一些不可避免地会局限于特定的应用，但其他的却可以广泛的用在程序中。举例来说，一个接受文件夹目录返回所有文件夹中的"
" XML 文件的函数； 或是一个接受文件名，然后返回文件内容的函数，都可以应用在很多不同的场合。"

#: ../../howto/functional.rst:172
msgid ""
"Over time you'll form a personal library of utilities.  Often you'll "
"assemble new programs by arranging existing functions in a new configuration"
" and writing a few functions specialized for the current task."
msgstr "久而久之你会形成一个个人工具库。通常你可以重新组织已有的函数来组成新的程序，然后为当前的工作写一些特殊的函数。"

#: ../../howto/functional.rst:180
msgid "Iterators"
msgstr "迭代器"

#: ../../howto/functional.rst:182
msgid ""
"I'll start by looking at a Python language feature that's an important "
"foundation for writing functional-style programs: iterators."
msgstr "我会从 Python 的一个语言特性， 编写函数式风格程序的重要基石开始说起：迭代器。"

#: ../../howto/functional.rst:185
msgid ""
"An iterator is an object representing a stream of data; this object returns "
"the data one element at a time.  A Python iterator must support a method "
"called :meth:`~iterator.__next__` that takes no arguments and always returns"
" the next element of the stream.  If there are no more elements in the "
"stream, :meth:`~iterator.__next__` must raise the :exc:`StopIteration` "
"exception. Iterators don't have to be finite, though; it's perfectly "
"reasonable to write an iterator that produces an infinite stream of data."
msgstr ""
"迭代器是一个表示数据流的对象；这个对象每次只返回一个元素。Python 迭代器必须支持 :meth:`~iterator.__next__` "
"方法；这个方法不接受参数，并总是返回数据流中的下一个元素。如果数据流中没有元素，:meth:`~iterator.__next__` 会抛出 "
":exc:`StopIteration` 异常。迭代器未必是有限的；完全有理由构造一个输出无限数据流的迭代器。"

#: ../../howto/functional.rst:193
msgid ""
"The built-in :func:`iter` function takes an arbitrary object and tries to "
"return an iterator that will return the object's contents or elements, "
"raising :exc:`TypeError` if the object doesn't support iteration.  Several "
"of Python's built-in data types support iteration, the most common being "
"lists and dictionaries.  An object is called :term:`iterable` if you can get"
" an iterator for it."
msgstr ""
"内置的 :func:`iter` 函数接受任意对象并试图返回一个迭代器来输出对象的内容或元素，并会在对象不支持迭代的时候抛出 "
":exc:`TypeError` 异常。Python 有几种内置数据类型支持迭代，最常见的就是列表和字典。如果一个对象能生成迭代器，那么它就会被称作 "
":term:`iterable`。"

#: ../../howto/functional.rst:200
msgid "You can experiment with the iteration interface manually:"
msgstr "你可以手动试验迭代器的接口。"

#: ../../howto/functional.rst:218
msgid ""
"Python expects iterable objects in several different contexts, the most "
"important being the :keyword:`for` statement.  In the statement ``for X in "
"Y``, Y must be an iterator or some object for which :func:`iter` can create "
"an iterator.  These two statements are equivalent::"
msgstr ""
"Python 有不少要求使用可迭代的对象的地方，其中最重要的就是 :keyword:`for` 表达式。在表达式 ``for X in Y``，Y "
"要么自身是一个迭代器，要么能够由 :func:`iter` 创建一个迭代器。以下两种表达是等价的::"

#: ../../howto/functional.rst:224
msgid ""
"for i in iter(obj):\n"
"    print(i)\n"
"\n"
"for i in obj:\n"
"    print(i)"
msgstr ""
"for i in iter(obj):\n"
"    print(i)\n"
"\n"
"for i in obj:\n"
"    print(i)"

#: ../../howto/functional.rst:230
msgid ""
"Iterators can be materialized as lists or tuples by using the :func:`list` "
"or :func:`tuple` constructor functions:"
msgstr "可以用 :func:`list` 或 :func:`tuple` 这样的构造函数把迭代器具体化成列表或元组:"

#: ../../howto/functional.rst:239
msgid ""
"Sequence unpacking also supports iterators: if you know an iterator will "
"return N elements, you can unpack them into an N-tuple:"
msgstr "序列的解压操作也支持迭代器：如果你知道一个迭代器能够返回 N 个元素，你可以把他们解压到有 N 个元素的元组:"

#: ../../howto/functional.rst:248
msgid ""
"Built-in functions such as :func:`max` and :func:`min` can take a single "
"iterator argument and will return the largest or smallest element.  The "
"``\"in\"`` and ``\"not in\"`` operators also support iterators: ``X in "
"iterator`` is true if X is found in the stream returned by the iterator.  "
"You'll run into obvious problems if the iterator is infinite; :func:`max`, "
":func:`min` will never return, and if the element X never appears in the "
"stream, the ``\"in\"`` and ``\"not in\"`` operators won't return either."
msgstr ""
"像 :func:`max` 和 :func:`min` 这样的内置函数可以接受单个迭代器参数，然后返回其中最大或者最小的元素。 ``\"in\"`` 和"
" ``\"not in\"`` 操作也支持迭代器：如果能够在迭代器 iterator 返回的数据流中找到 X 的话，则 ``X in "
"iterator`` 为真。很显然，如果迭代器是无限的，这么做你就会遇到问题；:func:`max` 和 :func:`min` "
"永远也不会返回；如果元素 X 也不出现在数据流中， ``\"in\"`` 和 ``\"not in\"`` 操作同样也永远不会返回。"

#: ../../howto/functional.rst:256
msgid ""
"Note that you can only go forward in an iterator; there's no way to get the "
"previous element, reset the iterator, or make a copy of it.  Iterator "
"objects can optionally provide these additional capabilities, but the "
"iterator protocol only specifies the :meth:`~iterator.__next__` method.  "
"Functions may therefore consume all of the iterator's output, and if you "
"need to do something different with the same stream, you'll have to create a"
" new iterator."
msgstr ""
"注意你只能在迭代器中顺序前进；没有获取前一个元素的方法，除非重置迭代器，或者重新复制一份。迭代器对象可以提供这些额外的功能，但迭代器协议只明确了 "
":meth:`~iterator.__next__` "
"方法。函数可能因此而耗尽迭代器的输出，如果你要对同样的数据流做不同的操作，你必须重新创建一个迭代器。"

#: ../../howto/functional.rst:266
msgid "Data Types That Support Iterators"
msgstr "支持迭代器的数据类型"

#: ../../howto/functional.rst:268
msgid ""
"We've already seen how lists and tuples support iterators.  In fact, any "
"Python sequence type, such as strings, will automatically support creation "
"of an iterator."
msgstr "我们已经知道列表和元组支持迭代器。实际上，Python 中的任何序列类型，比如字符串，都自动支持创建迭代器。"

#: ../../howto/functional.rst:272
msgid ""
"Calling :func:`iter` on a dictionary returns an iterator that will loop over"
" the dictionary's keys::"
msgstr "对字典调用 :func:`iter` 会返回一个遍历字典的键的迭代器::"

#: ../../howto/functional.rst:275
msgid ""
">>> m = {'Jan': 1, 'Feb': 2, 'Mar': 3, 'Apr': 4, 'May': 5, 'Jun': 6,\n"
"...      'Jul': 7, 'Aug': 8, 'Sep': 9, 'Oct': 10, 'Nov': 11, 'Dec': 12}\n"
">>> for key in m:\n"
"...     print(key, m[key])\n"
"Jan 1\n"
"Feb 2\n"
"Mar 3\n"
"Apr 4\n"
"May 5\n"
"Jun 6\n"
"Jul 7\n"
"Aug 8\n"
"Sep 9\n"
"Oct 10\n"
"Nov 11\n"
"Dec 12"
msgstr ""
">>> m = {'Jan': 1, 'Feb': 2, 'Mar': 3, 'Apr': 4, 'May': 5, 'Jun': 6,\n"
"...      'Jul': 7, 'Aug': 8, 'Sep': 9, 'Oct': 10, 'Nov': 11, 'Dec': 12}\n"
">>> for key in m:\n"
"...     print(key, m[key])\n"
"Jan 1\n"
"Feb 2\n"
"Mar 3\n"
"Apr 4\n"
"May 5\n"
"Jun 6\n"
"Jul 7\n"
"Aug 8\n"
"Sep 9\n"
"Oct 10\n"
"Nov 11\n"
"Dec 12"

#: ../../howto/functional.rst:292
msgid ""
"Note that starting with Python 3.7, dictionary iteration order is guaranteed"
" to be the same as the insertion order. In earlier versions, the behaviour "
"was unspecified and could vary between implementations."
msgstr "注意从 Python 3.7 开始，字典的遍历顺序一定和输入顺序一样。先前的版本并没有明确这一点，所以不同的实现可能不一致。"

#: ../../howto/functional.rst:296
msgid ""
"Applying :func:`iter` to a dictionary always loops over the keys, but "
"dictionaries have methods that return other iterators.  If you want to "
"iterate over values or key/value pairs, you can explicitly call the "
":meth:`~dict.values` or :meth:`~dict.items` methods to get an appropriate "
"iterator."
msgstr ""
"对字典使用 :func:`iter` 总是会遍历键，但字典也有返回其他迭代器的方法。如果你只遍历值或者键/值对，你可以明确地调用 "
":meth:`~dict.values` 或 :meth:`~dict.items` 方法得到合适的迭代器。"

#: ../../howto/functional.rst:302
msgid ""
"The :func:`dict` constructor can accept an iterator that returns a finite "
"stream of ``(key, value)`` tuples:"
msgstr ":func:`dict` 构造函数可以接受一个迭代器，然后返回一个有限的 ``(key, value)`` 元组的数据流:"

#: ../../howto/functional.rst:309
msgid ""
"Files also support iteration by calling the :meth:`~io.TextIOBase.readline` "
"method until there are no more lines in the file.  This means you can read "
"each line of a file like this::"
msgstr ""
"文件也可以通过调用 :meth:`~io.TextIOBase.readline` "
"来遍历，直到穷尽文件中所有的行。这意味着你可以像这样读取文件中的每一行::"

#: ../../howto/functional.rst:313
msgid ""
"for line in file:\n"
"    # do something for each line\n"
"    ..."
msgstr ""
"for line in file:\n"
"    # 对每一行执行某些操作\n"
"    ..."

#: ../../howto/functional.rst:317
msgid ""
"Sets can take their contents from an iterable and let you iterate over the "
"set's elements::"
msgstr "集合可以从可遍历的对象获取内容，也可以让你遍历集合的元素::"

#: ../../howto/functional.rst:320
msgid ""
">>> S = {2, 3, 5, 7, 11, 13}\n"
">>> for i in S:\n"
"...     print(i)\n"
"2\n"
"3\n"
"5\n"
"7\n"
"11\n"
"13"
msgstr ""
">>> S = {2, 3, 5, 7, 11, 13}\n"
">>> for i in S:\n"
"...     print(i)\n"
"2\n"
"3\n"
"5\n"
"7\n"
"11\n"
"13"

#: ../../howto/functional.rst:333
msgid "Generator expressions and list comprehensions"
msgstr "生成器表达式和列表推导式"

#: ../../howto/functional.rst:335
msgid ""
"Two common operations on an iterator's output are 1) performing some "
"operation for every element, 2) selecting a subset of elements that meet "
"some condition. For example, given a list of strings, you might want to "
"strip off trailing whitespace from each line or extract all the strings "
"containing a given substring."
msgstr ""
"迭代器的输出有两个很常见的使用方式，1) 对每一个元素执行操作，2) "
"选择一个符合条件的元素子集。比如，给定一个字符串列表，你可能想去掉每个字符串尾部的空白字符，或是选出所有包含给定子串的字符串。"

#: ../../howto/functional.rst:341
msgid ""
"List comprehensions and generator expressions (short form: \"listcomps\" and"
" \"genexps\") are a concise notation for such operations, borrowed from the "
"functional programming language Haskell (https://www.haskell.org/).  You can"
" strip all the whitespace from a stream of strings with the following code::"
msgstr ""
"列表推导式和生成器表达式 (简写: \"listcomp\" 和 \"genexp\") 让这些操作更加简明，这个形式借鉴自函数式编程语言 "
"Haskell (https://www.haskell.org/)。 你可以用以下代码去掉一个字符串流中的所有空白符:"

#: ../../howto/functional.rst:346
msgid ""
">>> line_list = ['  line 1\\n', 'line 2  \\n', ' \\n', '']\n"
"\n"
">>> # Generator expression -- returns iterator\n"
">>> stripped_iter = (line.strip() for line in line_list)\n"
"\n"
">>> # List comprehension -- returns list\n"
">>> stripped_list = [line.strip() for line in line_list]"
msgstr ""
">>> line_list = ['  line 1\\n', 'line 2  \\n', ' \\n', '']\n"
"\n"
">>> # 生成器表达式 -- 返回迭代器\n"
">>> stripped_iter = (line.strip() for line in line_list)\n"
"\n"
">>> # 列表推导式 -- 返回列表\n"
">>> stripped_list = [line.strip() for line in line_list]"

#: ../../howto/functional.rst:354
msgid "You can select only certain elements by adding an ``\"if\"`` condition::"
msgstr "你可以加上条件语句 ``\"if\"`` 来选取特定的元素:"

#: ../../howto/functional.rst:356
msgid ""
">>> stripped_list = [line.strip() for line in line_list\n"
"...                  if line != \"\"]"
msgstr ""
">>> stripped_list = [line.strip() for line in line_list\n"
"...                  if line != \"\"]"

#: ../../howto/functional.rst:359
msgid ""
"With a list comprehension, you get back a Python list; ``stripped_list`` is "
"a list containing the resulting lines, not an iterator.  Generator "
"expressions return an iterator that computes the values as necessary, not "
"needing to materialize all the values at once.  This means that list "
"comprehensions aren't useful if you're working with iterators that return an"
" infinite stream or a very large amount of data.  Generator expressions are "
"preferable in these situations."
msgstr ""
"通过列表推导式，你会获得一个 Python 列表；``stripped_list`` 就是一个包含所有结果行的列表，并不是迭代器。 "
"生成器表达式会返回一个迭代器，它在必要的时候计算结果，避免一次性生成所有的值。 "
"这意味着，如果迭代器返回一个无限数据流或者大量的数据，列表推导式就不太好用了。 这种情况下生成器表达式会更受青睐。"

#: ../../howto/functional.rst:366
msgid ""
"Generator expressions are surrounded by parentheses (\"()\") and list "
"comprehensions are surrounded by square brackets (\"[]\").  Generator "
"expressions have the form::"
msgstr "生成器表达式两边使用圆括号 (\"()\") ，而列表推导式则使用方括号 (\"[]\")。生成器表达式的形式为::"

#: ../../howto/functional.rst:370
msgid ""
"( expression for expr in sequence1\n"
"             if condition1\n"
"             for expr2 in sequence2\n"
"             if condition2\n"
"             for expr3 in sequence3\n"
"             ...\n"
"             if condition3\n"
"             for exprN in sequenceN\n"
"             if conditionN )"
msgstr ""
"( expression for expr in sequence1\n"
"             if condition1\n"
"             for expr2 in sequence2\n"
"             if condition2\n"
"             for expr3 in sequence3\n"
"             ...\n"
"             if condition3\n"
"             for exprN in sequenceN\n"
"             if conditionN )"

#: ../../howto/functional.rst:380
msgid ""
"Again, for a list comprehension only the outside brackets are different "
"(square brackets instead of parentheses)."
msgstr "再次说明，列表推导式只有两边的括号不一样（方括号而不是圆括号）。"

#: ../../howto/functional.rst:383
msgid ""
"The elements of the generated output will be the successive values of "
"``expression``.  The ``if`` clauses are all optional; if present, "
"``expression`` is only evaluated and added to the result when ``condition`` "
"is true."
msgstr ""
"这些生成用于输出的元素会成为 ``expression`` 的后继值。其中 ``if`` 语句是可选的；如果给定的话 ``expression`` "
"只会在符合条件时计算并加入到结果中。"

#: ../../howto/functional.rst:387
msgid ""
"Generator expressions always have to be written inside parentheses, but the "
"parentheses signalling a function call also count.  If you want to create an"
" iterator that will be immediately passed to a function you can write::"
msgstr "生成器表达式总是写在圆括号里面，不过也可以算上调用函数时用的括号。如果你想即时创建一个传递给函数的迭代器，可以这么写::"

#: ../../howto/functional.rst:391
msgid "obj_total = sum(obj.count for obj in list_all_objects())"
msgstr "obj_total = sum(obj.count for obj in list_all_objects())"

#: ../../howto/functional.rst:393
msgid ""
"The ``for...in`` clauses contain the sequences to be iterated over.  The "
"sequences do not have to be the same length, because they are iterated over "
"from left to right, **not** in parallel.  For each element in ``sequence1``,"
" ``sequence2`` is looped over from the beginning.  ``sequence3`` is then "
"looped over for each resulting pair of elements from ``sequence1`` and "
"``sequence2``."
msgstr ""
"其中 ``for...in`` 语句包含了将要遍历的序列。这些序列并不必须同样长，因为它们会从左往右开始遍历，而 **不是** 同时执行。对每个 "
"``sequence1`` 中的元素，``sequence2`` 会从头开始遍历。``sequence3`` 会对每个 ``sequence1`` 和 "
"``sequence2`` 的元素对开始遍历。"

#: ../../howto/functional.rst:399
msgid ""
"To put it another way, a list comprehension or generator expression is "
"equivalent to the following Python code::"
msgstr "换句话说，列表推导式器是和下面的 Python 代码等价::"

#: ../../howto/functional.rst:402
msgid ""
"for expr1 in sequence1:\n"
"    if not (condition1):\n"
"        continue   # Skip this element\n"
"    for expr2 in sequence2:\n"
"        if not (condition2):\n"
"            continue   # Skip this element\n"
"        ...\n"
"        for exprN in sequenceN:\n"
"            if not (conditionN):\n"
"                continue   # Skip this element\n"
"\n"
"            # Output the value of\n"
"            # the expression."
msgstr ""
"for expr1 in sequence1:\n"
"    if not (condition1):\n"
"        continue   # 跳过此元素\n"
"    for expr2 in sequence2:\n"
"        if not (condition2):\n"
"            continue   # 跳过此元素\n"
"        ...\n"
"        for exprN in sequenceN:\n"
"            if not (conditionN):\n"
"                continue   # 跳过此元素\n"
"\n"
"            # 输出表达式的值。"

#: ../../howto/functional.rst:416
msgid ""
"This means that when there are multiple ``for...in`` clauses but no ``if`` "
"clauses, the length of the resulting output will be equal to the product of "
"the lengths of all the sequences.  If you have two lists of length 3, the "
"output list is 9 elements long:"
msgstr ""
"这说明，如果有多个 ``for...in`` 语句而没有 ``if`` "
"语句，输出结果的长度就是所有序列长度的乘积。如果你的两个列表长度为3，那么输出的列表长度就是9:"

#: ../../howto/functional.rst:428
msgid ""
"To avoid introducing an ambiguity into Python's grammar, if ``expression`` "
"is creating a tuple, it must be surrounded with parentheses.  The first list"
" comprehension below is a syntax error, while the second one is correct::"
msgstr ""
"为了不让 Python 语法变得含糊，如果 ``expression`` "
"会生成元组，那这个元组必须要用括号括起来。下面第一个列表推导式语法错误，第二个则是正确的::"

#: ../../howto/functional.rst:432
msgid ""
"# Syntax error\n"
"[x, y for x in seq1 for y in seq2]\n"
"# Correct\n"
"[(x, y) for x in seq1 for y in seq2]"
msgstr ""
"# 语法错误\n"
"[x, y for x in seq1 for y in seq2]\n"
"# 正确\n"
"[(x, y) for x in seq1 for y in seq2]"

#: ../../howto/functional.rst:439
msgid "Generators"
msgstr "生成器"

#: ../../howto/functional.rst:441
msgid ""
"Generators are a special class of functions that simplify the task of "
"writing iterators.  Regular functions compute a value and return it, but "
"generators return an iterator that returns a stream of values."
msgstr "生成器是一类用来简化编写迭代器工作的特殊函数。普通的函数计算并返回一个值，而生成器返回一个能返回数据流的迭代器。"

#: ../../howto/functional.rst:445
msgid ""
"You're doubtless familiar with how regular function calls work in Python or "
"C. When you call a function, it gets a private namespace where its local "
"variables are created.  When the function reaches a ``return`` statement, "
"the local variables are destroyed and the value is returned to the caller.  "
"A later call to the same function creates a new private namespace and a "
"fresh set of local variables. But, what if the local variables weren't "
"thrown away on exiting a function?  What if you could later resume the "
"function where it left off?  This is what generators provide; they can be "
"thought of as resumable functions."
msgstr ""
"毫无疑问，你已经对如何在 Python 和 C 中调用普通函数很熟悉了，这时候函数会获得一个创建局部变量的私有命名空间。当函数到达 ``return``"
" "
"表达式时，局部变量会被销毁然后把返回给调用者。之后调用同样的函数时会创建一个新的私有命名空间和一组全新的局部变量。但是，如果在退出一个函数时不扔掉局部变量会如何呢？如果稍后你能够从退出函数的地方重新恢复又如何呢？这就是生成器所提供的；他们可以被看成可恢复的函数。"

#: ../../howto/functional.rst:454
msgid "Here's the simplest example of a generator function:"
msgstr "这里有简单的生成器函数示例::"

#: ../../howto/functional.rst:460
msgid ""
"Any function containing a :keyword:`yield` keyword is a generator function; "
"this is detected by Python's :term:`bytecode` compiler which compiles the "
"function specially as a result."
msgstr ""
"任何包含了 :keyword:`yield` 关键字的函数都是生成器函数；Python 的 :term:`bytecode` "
"编译器会在编译的时候检测到并因此而特殊处理。"

#: ../../howto/functional.rst:464
msgid ""
"When you call a generator function, it doesn't return a single value; "
"instead it returns a generator object that supports the iterator protocol.  "
"On executing the ``yield`` expression, the generator outputs the value of "
"``i``, similar to a ``return`` statement.  The big difference between "
"``yield`` and a ``return`` statement is that on reaching a ``yield`` the "
"generator's state of execution is suspended and local variables are "
"preserved.  On the next call to the generator's :meth:`~generator.__next__` "
"method, the function will resume executing."
msgstr ""
"当你调用一个生成器函数，它并不会返回单独的值，而是返回一个支持生成器协议的生成器对象。当执行 ``yield`` 表达式时，生成器会输出 ``i`` "
"的值，就像 ``return`` 表达式一样。``yield`` 和 ``return`` 最大的区别在于，到达 ``yield`` "
"的时候生成器的执行状态会挂起并保留局部变量。在下一次调用生成器 :meth:`~generator.__next__` 方法的时候，函数会恢复执行。"

#: ../../howto/functional.rst:473
msgid "Here's a sample usage of the ``generate_ints()`` generator:"
msgstr "这里有一个 ``generate_ints()`` 生成器的示例:"

#: ../../howto/functional.rst:490
msgid ""
"You could equally write ``for i in generate_ints(5)``, or ``a, b, c = "
"generate_ints(3)``."
msgstr ""
"同样，你可以写出 ``for i in generate_ints(5)``，或者 ``a, b, c = generate_ints(3)``。"

#: ../../howto/functional.rst:493
msgid ""
"Inside a generator function, ``return value`` causes "
"``StopIteration(value)`` to be raised from the :meth:`~generator.__next__` "
"method.  Once this happens, or the bottom of the function is reached, the "
"procession of values ends and the generator cannot yield any further values."
msgstr ""
"在生成器函数里面，``return value`` 会触发从 :meth:`~generator.__next__` 方法抛出 "
"``StopIteration(value)`` 异常。一旦抛出这个异常，或者函数结束，处理数据的过程就会停止，生成器也不会再生成新的值。"

#: ../../howto/functional.rst:498
msgid ""
"You could achieve the effect of generators manually by writing your own "
"class and storing all the local variables of the generator as instance "
"variables.  For example, returning a list of integers could be done by "
"setting ``self.count`` to 0, and having the :meth:`~iterator.__next__` "
"method increment ``self.count`` and return it. However, for a moderately "
"complicated generator, writing a corresponding class can be much messier."
msgstr ""
"你可以手动编写自己的类来达到生成器的效果，把生成器的所有局部变量作为实例的成员变量存储起来。 比如，可以这么返回一个整数列表：把 "
"``self.count`` 设为0，然后通过 :meth:`~iterator.__next__` 方法增加并返回 ``self.count``。 "
"然而，对于一个中等复杂程度的生成器，写出一个相应的类可能会相当繁杂。"

#: ../../howto/functional.rst:506
msgid ""
"The test suite included with Python's library, "
":source:`Lib/test/test_generators.py`, contains a number of more interesting"
" examples.  Here's one generator that implements an in-order traversal of a "
"tree using generators recursively. ::"
msgstr ""
"包含在 Python 库中的测试套件 :source:`Lib/test/test_generators.py` "
"里有很多非常有趣的例子。这里是一个用生成器实现树的递归中序遍历示例。::"

#: ../../howto/functional.rst:511
msgid ""
"# A recursive generator that generates Tree leaves in in-order.\n"
"def inorder(t):\n"
"    if t:\n"
"        for x in inorder(t.left):\n"
"            yield x\n"
"\n"
"        yield t.label\n"
"\n"
"        for x in inorder(t.right):\n"
"            yield x"
msgstr ""
"# 一个按内部顺序生成 Tree 叶子节点的递归生成器。\n"
"def inorder(t):\n"
"    if t:\n"
"        for x in inorder(t.left):\n"
"            yield x\n"
"\n"
"        yield t.label\n"
"\n"
"        for x in inorder(t.right):\n"
"            yield x"

#: ../../howto/functional.rst:522
msgid ""
"Two other examples in ``test_generators.py`` produce solutions for the "
"N-Queens problem (placing N queens on an NxN chess board so that no queen "
"threatens another) and the Knight's Tour (finding a route that takes a "
"knight to every square of an NxN chessboard without visiting any square "
"twice)."
msgstr ""
"另外两个 ``test_generators.py`` 中的例子给出了 N 皇后问题（在 NxN 的棋盘上放置 N "
"个皇后，任何一个都不能吃掉另一个），以及马的遍历路线（在NxN 的棋盘上给马找出一条不重复的走过所有格子的路线）的解。"

#: ../../howto/functional.rst:530
msgid "Passing values into a generator"
msgstr "向生成器传递值"

#: ../../howto/functional.rst:532
msgid ""
"In Python 2.4 and earlier, generators only produced output.  Once a "
"generator's code was invoked to create an iterator, there was no way to pass"
" any new information into the function when its execution is resumed.  You "
"could hack together this ability by making the generator look at a global "
"variable or by passing in some mutable object that callers then modify, but "
"these approaches are messy."
msgstr ""
"在 Python 2.4 "
"及之前的版本中，生成器只产生输出。一旦调用生成器的代码创建一个迭代器，就没有办法在函数恢复执行的时候向它传递新的信息。你可以设法实现这个功能，让生成器引用一个全局变量或者一个调用者可以修改的可变对象，但是这些方法都很繁杂。"

#: ../../howto/functional.rst:539
msgid ""
"In Python 2.5 there's a simple way to pass values into a generator. "
":keyword:`yield` became an expression, returning a value that can be "
"assigned to a variable or otherwise operated on::"
msgstr ""
"在 Python 2.5 里有一个简单的将值传递给生成器的方法。:keyword:`yield` "
"变成了一个表达式，返回一个可以赋给变量或执行操作的值::"

#: ../../howto/functional.rst:543
msgid "val = (yield i)"
msgstr "val = (yield i)"

#: ../../howto/functional.rst:545
msgid ""
"I recommend that you **always** put parentheses around a ``yield`` "
"expression when you're doing something with the returned value, as in the "
"above example. The parentheses aren't always necessary, but it's easier to "
"always add them instead of having to remember when they're needed."
msgstr ""
"我建议你在处理 ``yield`` 表达式返回值的时候， **总是** "
"两边写上括号，就像上面的例子一样。括号并不总是必须的，但是比起记住什么时候需要括号，写出来会更容易一点。"

#: ../../howto/functional.rst:550
msgid ""
"(:pep:`342` explains the exact rules, which are that a ``yield``-expression "
"must always be parenthesized except when it occurs at the top-level "
"expression on the right-hand side of an assignment.  This means you can "
"write ``val = yield i`` but have to use parentheses when there's an "
"operation, as in ``val = (yield i) + 12``.)"
msgstr ""
"（:pep:`342` 解释了具体的规则，也就是 ``yield`` 表达式必须括起来，除非是出现在最顶级的赋值表达式的右边。这意味着你可以写 "
"``val = yield i``，但是必须在操作的时候加上括号，就像 ``val = (yield i) + 12``）"

#: ../../howto/functional.rst:556
msgid ""
"Values are sent into a generator by calling its :meth:`send(value) "
"<generator.send>` method.  This method resumes the generator's code and the "
"``yield`` expression returns the specified value.  If the regular "
":meth:`~generator.__next__` method is called, the ``yield`` returns "
"``None``."
msgstr ""
"可以调用 :meth:`send(value)` <generator.send> 方法向生成器发送值。这个方法会恢复执行生成器的代码，然后 "
"``yield`` 表达式返回特定的值。 如果调用普通的 :meth:`~generator.__next__` 方法，``yield`` 会返回 "
"``None``。"

#: ../../howto/functional.rst:561
msgid ""
"Here's a simple counter that increments by 1 and allows changing the value "
"of the internal counter."
msgstr "这里有一个简单的每次加1的计数器，并允许改变内部计数器的值。"

#: ../../howto/functional.rst:564
msgid ""
"def counter(maximum):\n"
"    i = 0\n"
"    while i < maximum:\n"
"        val = (yield i)\n"
"        # If value provided, change counter\n"
"        if val is not None:\n"
"            i = val\n"
"        else:\n"
"            i += 1"
msgstr ""
"def counter(maximum):\n"
"    i = 0\n"
"    while i < maximum:\n"
"        val = (yield i)\n"
"        # 如果提供了值，则改变计数器\n"
"        if val is not None:\n"
"            i = val\n"
"        else:\n"
"            i += 1"

#: ../../howto/functional.rst:576
msgid "And here's an example of changing the counter:"
msgstr "这是改变计数器的一个示例"

#: ../../howto/functional.rst:593
msgid ""
"Because ``yield`` will often be returning ``None``, you should always check "
"for this case.  Don't just use its value in expressions unless you're sure "
"that the :meth:`~generator.send` method will be the only method used to "
"resume your generator function."
msgstr ""
"因为 ``yield`` 很多时候会返回 ``None``，所以你应该总是检查这个情况。不要在表达式中使用 ``yield`` 的值，除非你确定 "
":meth:`~generator.send` 是唯一的用来恢复你的生成器函数的方法。"

#: ../../howto/functional.rst:598
msgid ""
"In addition to :meth:`~generator.send`, there are two other methods on "
"generators:"
msgstr "除了 :meth:`~generator.send` 之外，生成器还有两个其他的方法:"

#: ../../howto/functional.rst:601
msgid ""
":meth:`throw(value) <generator.throw>` is used to raise an exception inside "
"the generator; the exception is raised by the ``yield`` expression where the"
" generator's execution is paused."
msgstr ""
":meth:`throw(value) <generator.throw>` 用于在生成器内部抛出异常；这个异常会在生成器暂停执行的时候由 "
"``yield`` 表达式抛出。"

#: ../../howto/functional.rst:605
msgid ""
":meth:`~generator.close` sends a :exc:`GeneratorExit` exception to the "
"generator to terminate the iteration.  On receiving this exception, the "
"generator's code must either raise :exc:`GeneratorExit` or "
":exc:`StopIteration`; catching the exception and doing anything else is "
"illegal and will trigger a :exc:`RuntimeError`.  :meth:`~generator.close` "
"will also be called by Python's garbage collector when the generator is "
"garbage-collected."
msgstr ""
":meth:`~generator.close` 会向生成器发送一个 :exc:`GeneratorExit` 异常来终结迭代。 "
"当接收到此异常时，生成器的代码必须引发 :exc:`GeneratorExit` 或者 "
":exc:`StopIteration`；捕获此异常并作任何其他操作都是非法的并会触发 :exc:`RuntimeError`。 "
":meth:`~generator.close` 还会在生成器被作为垃圾回收时由 Python 的垃圾回收器调用。"

#: ../../howto/functional.rst:613
msgid ""
"If you need to run cleanup code when a :exc:`GeneratorExit` occurs, I "
"suggest using a ``try: ... finally:`` suite instead of catching "
":exc:`GeneratorExit`."
msgstr ""
"如果你要在 :exc:`GeneratorExit` 发生的时候清理代码，我建议使用 ``try: ... finally:`` 组合来代替 "
":exc:`GeneratorExit`。"

#: ../../howto/functional.rst:616
msgid ""
"The cumulative effect of these changes is to turn generators from one-way "
"producers of information into both producers and consumers."
msgstr "这些改变的累积效应是，让生成器从单向的信息生产者变成了既是生产者，又是消费者。"

#: ../../howto/functional.rst:619
msgid ""
"Generators also become **coroutines**, a more generalized form of "
"subroutines. Subroutines are entered at one point and exited at another "
"point (the top of the function, and a ``return`` statement), but coroutines "
"can be entered, exited, and resumed at many different points (the ``yield`` "
"statements)."
msgstr ""
"生成器也可以成为 **协程** ，一种更广义的子过程形式。子过程可以从一个地方进入，然后从另一个地方退出（从函数的顶端进入，从 ``return`` "
"语句退出），而协程可以进入，退出，然后在很多不同的地方恢复（``yield`` 语句）。"

#: ../../howto/functional.rst:626
msgid "Built-in functions"
msgstr "内置函数"

#: ../../howto/functional.rst:628
msgid ""
"Let's look in more detail at built-in functions often used with iterators."
msgstr "我们可以看看迭代器常常用到的函数的更多细节。"

#: ../../howto/functional.rst:630
msgid ""
"Two of Python's built-in functions, :func:`map` and :func:`filter` duplicate"
" the features of generator expressions:"
msgstr "Python 内置的两个函数 :func:`map` 和 :func:`filter` 复制了生成器表达式的两个特性:"

#: ../../howto/functional.rst:633
msgid ""
":func:`map(f, iterA, iterB, ...) <map>` returns an iterator over the "
"sequence"
msgstr ":func:`map(f, iterA, iterB, ...) <map>` 返回一个遍历序列的迭代器"

#: ../../howto/functional.rst:634
msgid ""
"``f(iterA[0], iterB[0]), f(iterA[1], iterB[1]), f(iterA[2], iterB[2]), "
"...``."
msgstr ""
"``f(iterA[0], iterB[0]), f(iterA[1], iterB[1]), f(iterA[2], iterB[2]), "
"...``."

#: ../../howto/functional.rst:644
msgid "You can of course achieve the same effect with a list comprehension."
msgstr "你当然也可以用列表推导式达到同样的效果。"

#: ../../howto/functional.rst:646
msgid ""
":func:`filter(predicate, iter) <filter>` returns an iterator over all the "
"sequence elements that meet a certain condition, and is similarly duplicated"
" by list comprehensions.  A **predicate** is a function that returns the "
"truth value of some condition; for use with :func:`filter`, the predicate "
"must take a single value."
msgstr ""
":func:`filter(predicate, iter) <filter>` 返回一个遍历序列中满足指定条件的元素的迭代器，和列表推导式的功能相似。"
" **predicate** （谓词）是一个在特定条件下返回真值的函数；要使用函数 :func:`filter`，谓词函数必须只能接受一个参数。"

#: ../../howto/functional.rst:659
msgid "This can also be written as a list comprehension:"
msgstr "这也可以写成列表推导式:"

#: ../../howto/functional.rst:665
msgid ""
":func:`enumerate(iter, start=0) <enumerate>` counts off the elements in the "
"iterable returning 2-tuples containing the count (from *start*) and each "
"element. ::"
msgstr ""
":func:`enumerate(iter, start=0) <enumerate>` 计数可迭代对象中的元素，然后返回包含每个计数（从 "
"**start** 开始）和元素两个值的元组。::"

#: ../../howto/functional.rst:669
msgid ""
">>> for item in enumerate(['subject', 'verb', 'object']):\n"
"...     print(item)\n"
"(0, 'subject')\n"
"(1, 'verb')\n"
"(2, 'object')"
msgstr ""
">>> for item in enumerate(['subject', 'verb', 'object']):\n"
"...     print(item)\n"
"(0, 'subject')\n"
"(1, 'verb')\n"
"(2, 'object')"

#: ../../howto/functional.rst:675
msgid ""
":func:`enumerate` is often used when looping through a list and recording "
"the indexes at which certain conditions are met::"
msgstr ":func:`enumerate` 常常用于遍历列表并记录达到特定条件时的下标::"

#: ../../howto/functional.rst:678
msgid ""
"f = open('data.txt', 'r')\n"
"for i, line in enumerate(f):\n"
"    if line.strip() == '':\n"
"        print('Blank line at line #%i' % i)"
msgstr ""
"f = open('data.txt', 'r')\n"
"for i, line in enumerate(f):\n"
"    if line.strip() == '':\n"
"        print('Blank line at line #%i' % i)"

#: ../../howto/functional.rst:683
msgid ""
":func:`sorted(iterable, key=None, reverse=False) <sorted>` collects all the "
"elements of the iterable into a list, sorts the list, and returns the sorted"
" result.  The *key* and *reverse* arguments are passed through to the "
"constructed list's :meth:`~list.sort` method. ::"
msgstr ""
":func:`sorted(iterable, key=None, reverse=False) <sorted>` 会将 iterable "
"中的元素收集到一个列表中，然后排序并返回结果。其中 *key* 和 *reverse* 参数会传递给所创建列表的 :meth:`~list.sort` "
"方法。::"

#: ../../howto/functional.rst:688
msgid ""
">>> import random\n"
">>> # Generate 8 random numbers between [0, 10000)\n"
">>> rand_list = random.sample(range(10000), 8)\n"
">>> rand_list\n"
"[769, 7953, 9828, 6431, 8442, 9878, 6213, 2207]\n"
">>> sorted(rand_list)\n"
"[769, 2207, 6213, 6431, 7953, 8442, 9828, 9878]\n"
">>> sorted(rand_list, reverse=True)\n"
"[9878, 9828, 8442, 7953, 6431, 6213, 2207, 769]"
msgstr ""
">>> import random\n"
">>> # 生成在 [0, 10000) 区间内的 8 个随机数\n"
">>> rand_list = random.sample(range(10000), 8)\n"
">>> rand_list\n"
"[769, 7953, 9828, 6431, 8442, 9878, 6213, 2207]\n"
">>> sorted(rand_list)\n"
"[769, 2207, 6213, 6431, 7953, 8442, 9828, 9878]\n"
">>> sorted(rand_list, reverse=True)\n"
"[9878, 9828, 8442, 7953, 6431, 6213, 2207, 769]"

#: ../../howto/functional.rst:698
msgid ""
"(For a more detailed discussion of sorting, see the :ref:`sortinghowto`.)"
msgstr "（对排序更详细的讨论可参见 :ref:`sortinghowto`。）"

#: ../../howto/functional.rst:701
msgid ""
"The :func:`any(iter) <any>` and :func:`all(iter) <all>` built-ins look at "
"the truth values of an iterable's contents.  :func:`any` returns ``True`` if"
" any element in the iterable is a true value, and :func:`all` returns "
"``True`` if all of the elements are true values:"
msgstr ""
"内置函数 :func:`any(iter) <any>` 和 :func:`all(iter) <all>` "
"会查看一个可迭代对象内容的逻辑值。:func:`any` 在可迭代对象中任意一个元素为真时返回 ``True``，而 :func:`all` "
"在所有元素为真时返回 ``True``:"

#: ../../howto/functional.rst:720
msgid ""
":func:`zip(iterA, iterB, ...) <zip>` takes one element from each iterable "
"and returns them in a tuple::"
msgstr ":func:`zip(iterA, iterB, ...) <zip>` 从每个可迭代对象中选取单个元素组成列表并返回::"

#: ../../howto/functional.rst:723
msgid ""
"zip(['a', 'b', 'c'], (1, 2, 3)) =>\n"
"  ('a', 1), ('b', 2), ('c', 3)"
msgstr ""
"zip(['a', 'b', 'c'], (1, 2, 3)) =>\n"
"  ('a', 1), ('b', 2), ('c', 3)"

#: ../../howto/functional.rst:726
msgid ""
"It doesn't construct an in-memory list and exhaust all the input iterators "
"before returning; instead tuples are constructed and returned only if "
"they're requested.  (The technical term for this behaviour is `lazy "
"evaluation <https://en.wikipedia.org/wiki/Lazy_evaluation>`__.)"
msgstr ""
"它并不会在内存创建一个列表并因此在返回前而耗尽输入的迭代器；相反，只有在被请求的时候元组才会创建并返回。（这种行为的技术术语叫惰性计算，参见 `lazy"
" evaluation <https://en.wikipedia.org/wiki/Lazy_evaluation>`__.）"

#: ../../howto/functional.rst:731
msgid ""
"This iterator is intended to be used with iterables that are all of the same"
" length.  If the iterables are of different lengths, the resulting stream "
"will be the same length as the shortest iterable. ::"
msgstr "这个迭代器设计用于长度相同的可迭代对象。如果可迭代对象的长度不一致，返回的数据流的长度会和最短的可迭代对象相同"

#: ../../howto/functional.rst:735
msgid ""
"zip(['a', 'b'], (1, 2, 3)) =>\n"
"  ('a', 1), ('b', 2)"
msgstr ""
"zip(['a', 'b'], (1, 2, 3)) =>\n"
"  ('a', 1), ('b', 2)"

#: ../../howto/functional.rst:738
msgid ""
"You should avoid doing this, though, because an element may be taken from "
"the longer iterators and discarded.  This means you can't go on to use the "
"iterators further because you risk skipping a discarded element."
msgstr "然而，你应该避免这种情况，因为所有从更长的迭代器中取出的元素都会被丢弃。这意味着之后你也无法冒着跳过被丢弃元素的风险来继续使用这个迭代器。"

#: ../../howto/functional.rst:744
msgid "The itertools module"
msgstr "itertools 模块"

#: ../../howto/functional.rst:746
msgid ""
"The :mod:`itertools` module contains a number of commonly used iterators as "
"well as functions for combining several iterators.  This section will "
"introduce the module's contents by showing small examples."
msgstr ":mod:`itertools` 模块包含很多常用的迭代器以及用于组合多个迭代器的函数。 本节会用一些小例子来介绍这个模块的内容。"

#: ../../howto/functional.rst:750
msgid "The module's functions fall into a few broad classes:"
msgstr "这个模块里的函数大致可以分为几类："

#: ../../howto/functional.rst:752
msgid "Functions that create a new iterator based on an existing iterator."
msgstr "从已有的迭代器创建新的迭代器的函数。"

#: ../../howto/functional.rst:753
msgid "Functions for treating an iterator's elements as function arguments."
msgstr "接受迭代器元素作为参数的函数。"

#: ../../howto/functional.rst:754
msgid "Functions for selecting portions of an iterator's output."
msgstr "选取部分迭代器输出的函数。"

#: ../../howto/functional.rst:755
msgid "A function for grouping an iterator's output."
msgstr "给迭代器输出分组的函数。"

#: ../../howto/functional.rst:758
msgid "Creating new iterators"
msgstr "创建新的迭代器"

#: ../../howto/functional.rst:760
msgid ""
":func:`itertools.count(start, step) <itertools.count>` returns an infinite "
"stream of evenly spaced values.  You can optionally supply the starting "
"number, which defaults to 0, and the interval between numbers, which "
"defaults to 1::"
msgstr ""
":func:`itertools.count(start, step) <itertools.count>` "
"返回一个等分的无限数据流。初始值默认为0，间隔默认为1，你也选择可以指定初始值和间隔::"

#: ../../howto/functional.rst:764
msgid ""
"itertools.count() =>\n"
"  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ...\n"
"itertools.count(10) =>\n"
"  10, 11, 12, 13, 14, 15, 16, 17, 18, 19, ...\n"
"itertools.count(10, 5) =>\n"
"  10, 15, 20, 25, 30, 35, 40, 45, 50, 55, ..."
msgstr ""
"itertools.count() =>\n"
"  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ...\n"
"itertools.count(10) =>\n"
"  10, 11, 12, 13, 14, 15, 16, 17, 18, 19, ...\n"
"itertools.count(10, 5) =>\n"
"  10, 15, 20, 25, 30, 35, 40, 45, 50, 55, ..."

#: ../../howto/functional.rst:771
msgid ""
":func:`itertools.cycle(iter) <itertools.cycle>` saves a copy of the contents"
" of a provided iterable and returns a new iterator that returns its elements"
" from first to last.  The new iterator will repeat these elements "
"infinitely. ::"
msgstr ""
":func:`itertools.cycle(iter) <itertools.cycle>` "
"保存一份所提供的可迭代对象的副本，并返回一个能产生整个可迭代对象序列的新迭代器。新迭代器会无限重复这些元素。::"

#: ../../howto/functional.rst:775
msgid ""
"itertools.cycle([1, 2, 3, 4, 5]) =>\n"
"  1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ..."
msgstr ""
"itertools.cycle([1, 2, 3, 4, 5]) =>\n"
"  1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ..."

#: ../../howto/functional.rst:778
msgid ""
":func:`itertools.repeat(elem, [n]) <itertools.repeat>` returns the provided "
"element *n* times, or returns the element endlessly if *n* is not provided. "
"::"
msgstr ""
":func:`itertools.repeat(elem, [n]) <itertools.repeat>` 返回 *n* 次所提供的元素，当 *n* "
"不存在时，返回无数次所提供的元素。 ::"

#: ../../howto/functional.rst:781
msgid ""
"itertools.repeat('abc') =>\n"
"  abc, abc, abc, abc, abc, abc, abc, abc, abc, abc, ...\n"
"itertools.repeat('abc', 5) =>\n"
"  abc, abc, abc, abc, abc"
msgstr ""
"itertools.repeat('abc') =>\n"
"  abc, abc, abc, abc, abc, abc, abc, abc, abc, abc, ...\n"
"itertools.repeat('abc', 5) =>\n"
"  abc, abc, abc, abc, abc"

#: ../../howto/functional.rst:786
msgid ""
":func:`itertools.chain(iterA, iterB, ...) <itertools.chain>` takes an "
"arbitrary number of iterables as input, and returns all the elements of the "
"first iterator, then all the elements of the second, and so on, until all of"
" the iterables have been exhausted. ::"
msgstr ""
":func:`itertools.chain(iterA, iterB, ...) <itertools.chain>` "
"接受任意数量的可迭代对象作为输入，首先返回第一个迭代器的所有元素，然后是第二个的所有元素，如此一直进行下去，直到消耗掉所有输入的可迭代对象。"

#: ../../howto/functional.rst:791
msgid ""
"itertools.chain(['a', 'b', 'c'], (1, 2, 3)) =>\n"
"  a, b, c, 1, 2, 3"
msgstr ""
"itertools.chain(['a', 'b', 'c'], (1, 2, 3)) =>\n"
"  a, b, c, 1, 2, 3"

#: ../../howto/functional.rst:794
msgid ""
":func:`itertools.islice(iter, [start], stop, [step]) <itertools.islice>` "
"returns a stream that's a slice of the iterator.  With a single *stop* "
"argument, it will return the first *stop* elements.  If you supply a "
"starting index, you'll get *stop-start* elements, and if you supply a value "
"for *step*, elements will be skipped accordingly.  Unlike Python's string "
"and list slicing, you can't use negative values for *start*, *stop*, or "
"*step*. ::"
msgstr ""
":func:`itertools.islice(iter, [start], stop, [step]) <itertools.islice>` "
"返回一个所输入的迭代器切片的数据流。如果只单独给定 *stop* 参数的话，它会返回从起始算起 *stop* 个数量的元素。如果你提供了起始下标 "
"*start*，你会得到 *stop-start* 个元素；如果你给定了 *step* 参数，数据流会跳过相应的元素。和 Python "
"里的字符串和列表切片不同，你不能在 *start*, *stop* 或者 *step* 这些参数中使用负数。::"

#: ../../howto/functional.rst:801
msgid ""
"itertools.islice(range(10), 8) =>\n"
"  0, 1, 2, 3, 4, 5, 6, 7\n"
"itertools.islice(range(10), 2, 8) =>\n"
"  2, 3, 4, 5, 6, 7\n"
"itertools.islice(range(10), 2, 8, 2) =>\n"
"  2, 4, 6"
msgstr ""
"itertools.islice(range(10), 8) =>\n"
"  0, 1, 2, 3, 4, 5, 6, 7\n"
"itertools.islice(range(10), 2, 8) =>\n"
"  2, 3, 4, 5, 6, 7\n"
"itertools.islice(range(10), 2, 8, 2) =>\n"
"  2, 4, 6"

#: ../../howto/functional.rst:808
msgid ""
":func:`itertools.tee(iter, [n]) <itertools.tee>` replicates an iterator; it "
"returns *n* independent iterators that will all return the contents of the "
"source iterator. If you don't supply a value for *n*, the default is 2.  "
"Replicating iterators requires saving some of the contents of the source "
"iterator, so this can consume significant memory if the iterator is large "
"and one of the new iterators is consumed more than the others. ::"
msgstr ""
":func:`itertools.tee(iter, [n]) <itertools.tee>` 可以复制一个迭代器；它返回 *n* "
"个能够返回源迭代器内容的独立迭代器。如果你不提供参数 *n*，默认值为 "
"2。复制迭代器需要保存源迭代器的一部分内容，因此在源迭代器比较大的时候会显著地占用内存；同时，在所有新迭代器中，有一个迭代器会比其他迭代器占用更多的内存。"

#: ../../howto/functional.rst:816
msgid ""
"itertools.tee( itertools.count() ) =>\n"
"   iterA, iterB\n"
"\n"
"where iterA ->\n"
"   0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ...\n"
"\n"
"and   iterB ->\n"
"   0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ..."
msgstr ""
"itertools.tee( itertools.count() ) =>\n"
"   iterA, iterB\n"
"\n"
"where iterA ->\n"
"   0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ...\n"
"\n"
"and   iterB ->\n"
"   0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ..."

#: ../../howto/functional.rst:827
msgid "Calling functions on elements"
msgstr "对元素使用函数"

#: ../../howto/functional.rst:829
msgid ""
"The :mod:`operator` module contains a set of functions corresponding to "
"Python's operators.  Some examples are :func:`operator.add(a, b) "
"<operator.add>` (adds two values), :func:`operator.ne(a, b)  <operator.ne>` "
"(same as ``a != b``), and :func:`operator.attrgetter('id') "
"<operator.attrgetter>` (returns a callable that fetches the ``.id`` "
"attribute)."
msgstr ""
":mod:`operator` 模块包含一组对应于 Python 操作符的函数。比如 :func:`operator.add(a, b) "
"<operator.add>` （把两个数加起来），:func:`operator.ne(a, b)  <operator.ne>` （和 ``a !="
" b`` 相同），以及 :func:`operator.attrgetter('id') <operator.attrgetter>` （返回获取 "
"``.id`` 属性的可调用对象）。"

#: ../../howto/functional.rst:835
msgid ""
":func:`itertools.starmap(func, iter) <itertools.starmap>` assumes that the "
"iterable will return a stream of tuples, and calls *func* using these tuples"
" as the arguments::"
msgstr ""
":func:`itertools.starmap(func, iter) <itertools.starmap>` "
"假定可迭代对象能够返回一个元组的流，并且利用这些元组作为参数来调用 *func*::"

#: ../../howto/functional.rst:839
msgid ""
"itertools.starmap(os.path.join,\n"
"                  [('/bin', 'python'), ('/usr', 'bin', 'java'),\n"
"                   ('/usr', 'bin', 'perl'), ('/usr', 'bin', 'ruby')])\n"
"=>\n"
"  /bin/python, /usr/bin/java, /usr/bin/perl, /usr/bin/ruby"
msgstr ""
"itertools.starmap(os.path.join,\n"
"                  [('/bin', 'python'), ('/usr', 'bin', 'java'),\n"
"                   ('/usr', 'bin', 'perl'), ('/usr', 'bin', 'ruby')])\n"
"=>\n"
"  /bin/python, /usr/bin/java, /usr/bin/perl, /usr/bin/ruby"

#: ../../howto/functional.rst:847
msgid "Selecting elements"
msgstr "选择元素"

#: ../../howto/functional.rst:849
msgid ""
"Another group of functions chooses a subset of an iterator's elements based "
"on a predicate."
msgstr "另外一系列函数根据谓词选取一个迭代器中元素的子集。"

#: ../../howto/functional.rst:852
msgid ""
":func:`itertools.filterfalse(predicate, iter) <itertools.filterfalse>` is "
"the opposite of :func:`filter`, returning all elements for which the "
"predicate returns false::"
msgstr ""
":func:`itertools.filterfalse(predicate, iter) <itertools.filterfalse>` 和  "
":func:`filter` 相反，返回所有让 predicate 返回 false 的元素::"

#: ../../howto/functional.rst:856
msgid ""
"itertools.filterfalse(is_even, itertools.count()) =>\n"
"  1, 3, 5, 7, 9, 11, 13, 15, ..."
msgstr ""
"itertools.filterfalse(is_even, itertools.count()) =>\n"
"  1, 3, 5, 7, 9, 11, 13, 15, ..."

#: ../../howto/functional.rst:859
msgid ""
":func:`itertools.takewhile(predicate, iter) <itertools.takewhile>` returns "
"elements for as long as the predicate returns true.  Once the predicate "
"returns false, the iterator will signal the end of its results. ::"
msgstr ""
":func:`itertools.takewhile(predicate, iter) <itertools.takewhile>` 返回一直让 "
"predicate 返回 true 的元素。一旦 predicate 返回 false，迭代器就会发出终止结果的信号。::"

#: ../../howto/functional.rst:863
msgid ""
"def less_than_10(x):\n"
"    return x < 10\n"
"\n"
"itertools.takewhile(less_than_10, itertools.count()) =>\n"
"  0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n"
"\n"
"itertools.takewhile(is_even, itertools.count()) =>\n"
"  0"
msgstr ""
"def less_than_10(x):\n"
"    return x < 10\n"
"\n"
"itertools.takewhile(less_than_10, itertools.count()) =>\n"
"  0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n"
"\n"
"itertools.takewhile(is_even, itertools.count()) =>\n"
"  0"

#: ../../howto/functional.rst:872
msgid ""
":func:`itertools.dropwhile(predicate, iter) <itertools.dropwhile>` discards "
"elements while the predicate returns true, and then returns the rest of the "
"iterable's results. ::"
msgstr ""
":func:`itertools.dropwhile(predicate, iter) <itertools.dropwhile>` 在 "
"predicate 返回 true 的时候丢弃元素，并且返回可迭代对象的剩余结果。::"

#: ../../howto/functional.rst:876
msgid ""
"itertools.dropwhile(less_than_10, itertools.count()) =>\n"
"  10, 11, 12, 13, 14, 15, 16, 17, 18, 19, ...\n"
"\n"
"itertools.dropwhile(is_even, itertools.count()) =>\n"
"  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ..."
msgstr ""
"itertools.dropwhile(less_than_10, itertools.count()) =>\n"
"  10, 11, 12, 13, 14, 15, 16, 17, 18, 19, ...\n"
"\n"
"itertools.dropwhile(is_even, itertools.count()) =>\n"
"  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ..."

#: ../../howto/functional.rst:882
msgid ""
":func:`itertools.compress(data, selectors) <itertools.compress>` takes two "
"iterators and returns only those elements of *data* for which the "
"corresponding element of *selectors* is true, stopping whenever either one "
"is exhausted::"
msgstr ""
":func:`itertools.compress(data, selectors) <itertools.compress>` "
"接受两个迭代器，然后返回 *data* 中使相应地 *selector* 中的元素为真的元素；它会在任一个迭代器耗尽的时候停止::"

#: ../../howto/functional.rst:886
msgid ""
"itertools.compress([1, 2, 3, 4, 5], [True, True, False, False, True]) =>\n"
"   1, 2, 5"
msgstr ""
"itertools.compress([1, 2, 3, 4, 5], [True, True, False, False, True]) =>\n"
"   1, 2, 5"

#: ../../howto/functional.rst:891
msgid "Combinatoric functions"
msgstr "组合函数"

#: ../../howto/functional.rst:893
msgid ""
"The :func:`itertools.combinations(iterable, r) <itertools.combinations>` "
"returns an iterator giving all possible *r*-tuple combinations of the "
"elements contained in *iterable*.  ::"
msgstr ""
":func:`itertools.combinations(iterable, r) <itertools.combinations>` "
"返回一个迭代器，它能给出输入迭代器中所包含的元素的所有可能的 *r* 元元组的组合。::"

#: ../../howto/functional.rst:897
msgid ""
"itertools.combinations([1, 2, 3, 4, 5], 2) =>\n"
"  (1, 2), (1, 3), (1, 4), (1, 5),\n"
"  (2, 3), (2, 4), (2, 5),\n"
"  (3, 4), (3, 5),\n"
"  (4, 5)\n"
"\n"
"itertools.combinations([1, 2, 3, 4, 5], 3) =>\n"
"  (1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 3, 4), (1, 3, 5), (1, 4, 5),\n"
"  (2, 3, 4), (2, 3, 5), (2, 4, 5),\n"
"  (3, 4, 5)"
msgstr ""
"itertools.combinations([1, 2, 3, 4, 5], 2) =>\n"
"  (1, 2), (1, 3), (1, 4), (1, 5),\n"
"  (2, 3), (2, 4), (2, 5),\n"
"  (3, 4), (3, 5),\n"
"  (4, 5)\n"
"\n"
"itertools.combinations([1, 2, 3, 4, 5], 3) =>\n"
"  (1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 3, 4), (1, 3, 5), (1, 4, 5),\n"
"  (2, 3, 4), (2, 3, 5), (2, 4, 5),\n"
"  (3, 4, 5)"

#: ../../howto/functional.rst:908
msgid ""
"The elements within each tuple remain in the same order as *iterable* "
"returned them.  For example, the number 1 is always before 2, 3, 4, or 5 in "
"the examples above.  A similar function, "
":func:`itertools.permutations(iterable, r=None) <itertools.permutations>`, "
"removes this constraint on the order, returning all possible arrangements of"
" length *r*::"
msgstr ""
"每个元组中的元素保持着 *可迭代对象* 返回他们的顺序。例如，在上面的例子中数字 1 总是会在 2, 3, 4 或 5 "
"前面。一个类似的函数，:func:`itertools.permutations(iterable, r=None) "
"<itertools.permutations>`，取消了保持顺序的限制，返回所有可能的长度为 *r* 的排列::"

#: ../../howto/functional.rst:915
msgid ""
"itertools.permutations([1, 2, 3, 4, 5], 2) =>\n"
"  (1, 2), (1, 3), (1, 4), (1, 5),\n"
"  (2, 1), (2, 3), (2, 4), (2, 5),\n"
"  (3, 1), (3, 2), (3, 4), (3, 5),\n"
"  (4, 1), (4, 2), (4, 3), (4, 5),\n"
"  (5, 1), (5, 2), (5, 3), (5, 4)\n"
"\n"
"itertools.permutations([1, 2, 3, 4, 5]) =>\n"
"  (1, 2, 3, 4, 5), (1, 2, 3, 5, 4), (1, 2, 4, 3, 5),\n"
"  ...\n"
"  (5, 4, 3, 2, 1)"
msgstr ""
"itertools.permutations([1, 2, 3, 4, 5], 2) =>\n"
"  (1, 2), (1, 3), (1, 4), (1, 5),\n"
"  (2, 1), (2, 3), (2, 4), (2, 5),\n"
"  (3, 1), (3, 2), (3, 4), (3, 5),\n"
"  (4, 1), (4, 2), (4, 3), (4, 5),\n"
"  (5, 1), (5, 2), (5, 3), (5, 4)\n"
"\n"
"itertools.permutations([1, 2, 3, 4, 5]) =>\n"
"  (1, 2, 3, 4, 5), (1, 2, 3, 5, 4), (1, 2, 4, 3, 5),\n"
"  ...\n"
"  (5, 4, 3, 2, 1)"

#: ../../howto/functional.rst:927
msgid ""
"If you don't supply a value for *r* the length of the iterable is used, "
"meaning that all the elements are permuted."
msgstr "如果你不提供 *r* 参数的值，它会使用可迭代对象的长度，也就是说会排列所有的元素。"

#: ../../howto/functional.rst:930
msgid ""
"Note that these functions produce all of the possible combinations by "
"position and don't require that the contents of *iterable* are unique::"
msgstr "注意这些函数会输出所有可能的位置组合，并不要求 *可迭代对象* 的内容不重复::"

#: ../../howto/functional.rst:933
msgid ""
"itertools.permutations('aba', 3) =>\n"
"  ('a', 'b', 'a'), ('a', 'a', 'b'), ('b', 'a', 'a'),\n"
"  ('b', 'a', 'a'), ('a', 'a', 'b'), ('a', 'b', 'a')"
msgstr ""
"itertools.permutations('aba', 3) =>\n"
"  ('a', 'b', 'a'), ('a', 'a', 'b'), ('b', 'a', 'a'),\n"
"  ('b', 'a', 'a'), ('a', 'a', 'b'), ('a', 'b', 'a')"

#: ../../howto/functional.rst:937
msgid ""
"The identical tuple ``('a', 'a', 'b')`` occurs twice, but the two 'a' "
"strings came from different positions."
msgstr "同一个元组 ``('a', 'a', 'b')`` 出现了两次，但是两个 'a' 字符来自不同的位置。"

#: ../../howto/functional.rst:940
msgid ""
"The :func:`itertools.combinations_with_replacement(iterable, r) "
"<itertools.combinations_with_replacement>` function relaxes a different "
"constraint: elements can be repeated within a single tuple.  Conceptually an"
" element is selected for the first position of each tuple and then is "
"replaced before the second element is selected.  ::"
msgstr ""
":func:`itertools.combinations_with_replacement(iterable, r) "
"<itertools.combinations_with_replacement>` "
"函数放松了一个不同的限制：元组中的元素可以重复。从概念讲，为每个元组第一个位置选取一个元素，然后在选择第二个元素前替换掉它。::"

#: ../../howto/functional.rst:946
msgid ""
"itertools.combinations_with_replacement([1, 2, 3, 4, 5], 2) =>\n"
"  (1, 1), (1, 2), (1, 3), (1, 4), (1, 5),\n"
"  (2, 2), (2, 3), (2, 4), (2, 5),\n"
"  (3, 3), (3, 4), (3, 5),\n"
"  (4, 4), (4, 5),\n"
"  (5, 5)"
msgstr ""
"itertools.combinations_with_replacement([1, 2, 3, 4, 5], 2) =>\n"
"  (1, 1), (1, 2), (1, 3), (1, 4), (1, 5),\n"
"  (2, 2), (2, 3), (2, 4), (2, 5),\n"
"  (3, 3), (3, 4), (3, 5),\n"
"  (4, 4), (4, 5),\n"
"  (5, 5)"

#: ../../howto/functional.rst:955
msgid "Grouping elements"
msgstr "为元素分组"

#: ../../howto/functional.rst:957
msgid ""
"The last function I'll discuss, :func:`itertools.groupby(iter, "
"key_func=None) <itertools.groupby>`, is the most complicated.  "
"``key_func(elem)`` is a function that can compute a key value for each "
"element returned by the iterable.  If you don't supply a key function, the "
"key is simply each element itself."
msgstr ""
"我要讨论的最后一个函数，:func:`itertools.groupby(iter,key_func=None) "
"<itertools.groupby>`，是最复杂的函数。 ``key_func(elem)`` 是一个可以对迭代器返回的每个元素计算键值的函数。 "
"如果你不提供这个键值函数，它就会简化成每个元素自身。"

#: ../../howto/functional.rst:962
msgid ""
":func:`~itertools.groupby` collects all the consecutive elements from the "
"underlying iterable that have the same key value, and returns a stream of "
"2-tuples containing a key value and an iterator for the elements with that "
"key."
msgstr ""
":func:`~itertools.groupby` 从所依据的可迭代对象中连续地收集具有相同值的元素，然后返回一个长度为2的元组的数据流, "
"每个元组包含键值以及对应这个键值的元素所组成的迭代器。"

#: ../../howto/functional.rst:968
msgid ""
"city_list = [('Decatur', 'AL'), ('Huntsville', 'AL'), ('Selma', 'AL'),\n"
"             ('Anchorage', 'AK'), ('Nome', 'AK'),\n"
"             ('Flagstaff', 'AZ'), ('Phoenix', 'AZ'), ('Tucson', 'AZ'),\n"
"             ...\n"
"            ]\n"
"\n"
"def get_state(city_state):\n"
"    return city_state[1]\n"
"\n"
"itertools.groupby(city_list, get_state) =>\n"
"  ('AL', iterator-1),\n"
"  ('AK', iterator-2),\n"
"  ('AZ', iterator-3), ...\n"
"\n"
"where\n"
"iterator-1 =>\n"
"  ('Decatur', 'AL'), ('Huntsville', 'AL'), ('Selma', 'AL')\n"
"iterator-2 =>\n"
"  ('Anchorage', 'AK'), ('Nome', 'AK')\n"
"iterator-3 =>\n"
"  ('Flagstaff', 'AZ'), ('Phoenix', 'AZ'), ('Tucson', 'AZ')"
msgstr ""
"city_list = [('Decatur', 'AL'), ('Huntsville', 'AL'), ('Selma', 'AL'),\n"
"             ('Anchorage', 'AK'), ('Nome', 'AK'),\n"
"             ('Flagstaff', 'AZ'), ('Phoenix', 'AZ'), ('Tucson', 'AZ'),\n"
"             ...\n"
"            ]\n"
"\n"
"def get_state(city_state):\n"
"    return city_state[1]\n"
"\n"
"itertools.groupby(city_list, get_state) =>\n"
"  ('AL', iterator-1),\n"
"  ('AK', iterator-2),\n"
"  ('AZ', iterator-3), ...\n"
"\n"
"where\n"
"iterator-1 =>\n"
"  ('Decatur', 'AL'), ('Huntsville', 'AL'), ('Selma', 'AL')\n"
"iterator-2 =>\n"
"  ('Anchorage', 'AK'), ('Nome', 'AK')\n"
"iterator-3 =>\n"
"  ('Flagstaff', 'AZ'), ('Phoenix', 'AZ'), ('Tucson', 'AZ')"

#: ../../howto/functional.rst:990
msgid ""
":func:`~itertools.groupby` assumes that the underlying iterable's contents "
"will already be sorted based on the key.  Note that the returned iterators "
"also use the underlying iterable, so you have to consume the results of "
"iterator-1 before requesting iterator-2 and its corresponding key."
msgstr ""
":func:`~itertools.groupby` "
"假定了所依据的可迭代对象的内容已经根据键值排序。注意，返回的迭代器也会使用所依据的可迭代对象，所以在请求迭代器 2和相应的键之前你必须先消耗迭代器 1 "
"的结果。"

#: ../../howto/functional.rst:997
msgid "The functools module"
msgstr "functools 模块"

#: ../../howto/functional.rst:999
msgid ""
"The :mod:`functools` module contains some higher-order functions. A "
"**higher-order function** takes one or more functions as input and returns a"
" new function.  The most useful tool in this module is the "
":func:`functools.partial` function."
msgstr ""
":mod:`functools` 模块包含一些高阶函数。 **高阶函数** 接受一个或多个函数作为输入并返回一个新的函数。 这个模块中最有用的工具是 "
":func:`functools.partial` 函数。"

#: ../../howto/functional.rst:1004
msgid ""
"For programs written in a functional style, you'll sometimes want to "
"construct variants of existing functions that have some of the parameters "
"filled in. Consider a Python function ``f(a, b, c)``; you may wish to create"
" a new function ``g(b, c)`` that's equivalent to ``f(1, b, c)``; you're "
"filling in a value for one of ``f()``'s parameters.  This is called "
"\"partial function application\"."
msgstr ""
"对于用函数式风格编写的程序，有时你会希望通过给定部分参数，将已有的函数构变形称新的函数。考虑一个 Python 函数 ``f(a, b, "
"c)``；你希望创建一个和 ``f(1, b, c)`` 等价的新函数 ``g(b, c)``；也就是说你给定了 ``f()`` "
"的一个参数的值。这就是所谓的“部分函数应用”。"

#: ../../howto/functional.rst:1010
msgid ""
"The constructor for :func:`~functools.partial` takes the arguments "
"``(function, arg1, arg2, ..., kwarg1=value1, kwarg2=value2)``.  The "
"resulting object is callable, so you can just call it to invoke ``function``"
" with the filled-in arguments."
msgstr ""
":func:`~functools.partial` 接受参数 ``(function, arg1, arg2, ..., kwarg1=value1,"
" kwarg2=value2)``。它会返回一个可调用的对象，所以你能够直接调用这个结果以使用给定参数的 ``function``。"

#: ../../howto/functional.rst:1015
msgid "Here's a small but realistic example::"
msgstr "这里有一个很小但很现实的例子::"

#: ../../howto/functional.rst:1017
msgid ""
"import functools\n"
"\n"
"def log(message, subsystem):\n"
"    \"\"\"Write the contents of 'message' to the specified subsystem.\"\"\"\n"
"    print('%s: %s' % (subsystem, message))\n"
"    ...\n"
"\n"
"server_log = functools.partial(log, subsystem='server')\n"
"server_log('Unable to open socket')"
msgstr ""
"import functools\n"
"\n"
"def log(message, subsystem):\n"
"    \"\"\"将 'message' 的内容写到指定的子系统。\"\"\"\n"
"    print('%s: %s' % (subsystem, message))\n"
"    ...\n"
"\n"
"server_log = functools.partial(log, subsystem='server')\n"
"server_log('Unable to open socket')"

#: ../../howto/functional.rst:1027
msgid ""
":func:`functools.reduce(func, iter, [initial_value]) <functools.reduce>` "
"cumulatively performs an operation on all the iterable's elements and, "
"therefore, can't be applied to infinite iterables. *func* must be a function"
" that takes two elements and returns a single value.  "
":func:`functools.reduce` takes the first two elements A and B returned by "
"the iterator and calculates ``func(A, B)``.  It then requests the third "
"element, C, calculates ``func(func(A, B), C)``, combines this result with "
"the fourth element returned, and continues until the iterable is exhausted."
"  If the iterable returns no values at all, a :exc:`TypeError` exception is "
"raised.  If the initial value is supplied, it's used as a starting point and"
" ``func(initial_value, A)`` is the first calculation. ::"
msgstr ""
":func:`functools.reduce(func, iter, [initial_value]) <functools.reduce>` "
"持续地在可迭代对象的所有元素上执行操作，因此它不能够用在无限的可迭代对象上。*func* "
"必须是一个接受两个元素并返回一个值的函数。:func:`functools.reduce` 接受迭代器返回的前两个元素 A 和 B 并计算 "
"``func(A, B)`` 。然后它会请求第三个元素，C，计算 ``func(func(A, B), "
"C)``，然后把这个结果再和第四个元素组合并返回，如此继续下去直到消耗整个可迭代对象。如果输入的可迭代对象完全不返回任何值，:exc:`TypeError`"
" 异常就会抛出。如果提供了初值(initial value)，它会被用作起始值，也就是先计算 ``func(initial_value, A)`` "
"。::"

#: ../../howto/functional.rst:1039
msgid ""
">>> import operator, functools\n"
">>> functools.reduce(operator.concat, ['A', 'BB', 'C'])\n"
"'ABBC'\n"
">>> functools.reduce(operator.concat, [])\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: reduce() of empty sequence with no initial value\n"
">>> functools.reduce(operator.mul, [1, 2, 3], 1)\n"
"6\n"
">>> functools.reduce(operator.mul, [], 1)\n"
"1"
msgstr ""
">>> import operator, functools\n"
">>> functools.reduce(operator.concat, ['A', 'BB', 'C'])\n"
"'ABBC'\n"
">>> functools.reduce(operator.concat, [])\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: reduce() of empty sequence with no initial value\n"
">>> functools.reduce(operator.mul, [1, 2, 3], 1)\n"
"6\n"
">>> functools.reduce(operator.mul, [], 1)\n"
"1"

#: ../../howto/functional.rst:1051
msgid ""
"If you use :func:`operator.add` with :func:`functools.reduce`, you'll add up"
" all the elements of the iterable.  This case is so common that there's a "
"special built-in called :func:`sum` to compute it:"
msgstr ""
"如果你在 :func:`functools.reduce` 中使用 "
":func:`operator.add`，你就会把可迭代对象中的所有元素加起来.这种情况非常常见, 所以 Python 有一个特殊的内置函数 "
":func:`sum`:"

#: ../../howto/functional.rst:1063
msgid ""
"For many uses of :func:`functools.reduce`, though, it can be clearer to just"
" write the obvious :keyword:`for` loop::"
msgstr ""
"不过, 对于很多使用 :func:`functools.reduce` 的情形, 使用明显的 :keyword:`for` 循环会更清晰::"

#: ../../howto/functional.rst:1066
msgid ""
"import functools\n"
"# Instead of:\n"
"product = functools.reduce(operator.mul, [1, 2, 3], 1)\n"
"\n"
"# You can write:\n"
"product = 1\n"
"for i in [1, 2, 3]:\n"
"    product *= i"
msgstr ""
"import functools\n"
"# 作为以下语句的替代：\n"
"product = functools.reduce(operator.mul, [1, 2, 3], 1)\n"
"\n"
"# 你可以这样写：\n"
"product = 1\n"
"for i in [1, 2, 3]:\n"
"    product *= i"

#: ../../howto/functional.rst:1075
msgid ""
"A related function is :func:`itertools.accumulate(iterable, "
"func=operator.add) <itertools.accumulate>`.  It performs the same "
"calculation, but instead of returning only the final result, "
":func:`~itertools.accumulate` returns an iterator that also yields each "
"partial result::"
msgstr ""
"一个相关的函数是 :func:`itertools.accumulate(iterable, func=operator.add) "
"<itertools.accumulate>`。 它执行同样的计算，但 :func:`~itertools.accumulate` "
"不是仅仅返回最终结果，而是返回一个会产生每个部分结果的迭代器::"

#: ../../howto/functional.rst:1080
msgid ""
"itertools.accumulate([1, 2, 3, 4, 5]) =>\n"
"  1, 3, 6, 10, 15\n"
"\n"
"itertools.accumulate([1, 2, 3, 4, 5], operator.mul) =>\n"
"  1, 2, 6, 24, 120"
msgstr ""
"itertools.accumulate([1, 2, 3, 4, 5]) =>\n"
"  1, 3, 6, 10, 15\n"
"\n"
"itertools.accumulate([1, 2, 3, 4, 5], operator.mul) =>\n"
"  1, 2, 6, 24, 120"

#: ../../howto/functional.rst:1088
msgid "The operator module"
msgstr "operator 模块"

#: ../../howto/functional.rst:1090
msgid ""
"The :mod:`operator` module was mentioned earlier.  It contains a set of "
"functions corresponding to Python's operators.  These functions are often "
"useful in functional-style code because they save you from writing trivial "
"functions that perform a single operation."
msgstr ""
"前面已经提到了 :mod:`operator` 模块。它包含一系列对应于 Python "
"操作符的函数。在函数式风格的代码中，这些函数通常很有用，可以帮你省下不少时间，避免写一些琐碎的仅仅执行一个简单操作的函数。"

#: ../../howto/functional.rst:1095
msgid "Some of the functions in this module are:"
msgstr "这个模块里的一些函数："

#: ../../howto/functional.rst:1097
msgid ""
"Math operations: ``add()``, ``sub()``, ``mul()``, ``floordiv()``, ``abs()``,"
" ..."
msgstr "数学运算： ``add()``，``sub()``，``mul()``，``floordiv()``，``abs()``， ..."

#: ../../howto/functional.rst:1098
msgid "Logical operations: ``not_()``, ``truth()``."
msgstr "逻辑运算： ``not_()``，``truth()``。"

#: ../../howto/functional.rst:1099
msgid "Bitwise operations: ``and_()``, ``or_()``, ``invert()``."
msgstr "位运算： ``and_()``，``or_()``，``invert()``。"

#: ../../howto/functional.rst:1100
msgid ""
"Comparisons: ``eq()``, ``ne()``, ``lt()``, ``le()``, ``gt()``, and ``ge()``."
msgstr "比较： ``eq()``，``ne()``，``lt()``，``le()``，``gt()``，和 ``ge()``。"

#: ../../howto/functional.rst:1101
msgid "Object identity: ``is_()``, ``is_not()``."
msgstr "确认对象： ``is_()``，``is_not()``。"

#: ../../howto/functional.rst:1103
msgid "Consult the operator module's documentation for a complete list."
msgstr "全部函数列表可以参考 operator 模块的文档。"

#: ../../howto/functional.rst:1107
msgid "Small functions and the lambda expression"
msgstr "小函数和 lambda 表达式"

#: ../../howto/functional.rst:1109
msgid ""
"When writing functional-style programs, you'll often need little functions "
"that act as predicates or that combine elements in some way."
msgstr "编写函数式风格程序时，你会经常需要很小的函数，作为谓词函数或者以某种方式来组合元素。"

#: ../../howto/functional.rst:1112
msgid ""
"If there's a Python built-in or a module function that's suitable, you don't"
" need to define a new function at all::"
msgstr "如果合适的 Python 内置的或者其他模块中的函数，你就一点也不需要定义新的函数::"

#: ../../howto/functional.rst:1115
msgid ""
"stripped_lines = [line.strip() for line in lines]\n"
"existing_files = filter(os.path.exists, file_list)"
msgstr ""
"stripped_lines = [line.strip() for line in lines]\n"
"existing_files = filter(os.path.exists, file_list)"

#: ../../howto/functional.rst:1118
msgid ""
"If the function you need doesn't exist, you need to write it.  One way to "
"write small functions is to use the :keyword:`lambda` expression.  "
"``lambda`` takes a number of parameters and an expression combining these "
"parameters, and creates an anonymous function that returns the value of the "
"expression::"
msgstr ""
"如果不存在你需要的函数，你就必须自己编写。一个编写小函数的方式是使用 :keyword:`lambda` 表达式。``lambda`` "
"接受一组参数以及组合这些参数的表达式，它会创建一个返回表达式值的匿名函数::"

#: ../../howto/functional.rst:1123
msgid ""
"adder = lambda x, y: x+y\n"
"\n"
"print_assign = lambda name, value: name + '=' + str(value)"
msgstr ""
"adder = lambda x, y: x+y\n"
"\n"
"print_assign = lambda name, value: name + '=' + str(value)"

#: ../../howto/functional.rst:1127
msgid ""
"An alternative is to just use the ``def`` statement and define a function in"
" the usual way::"
msgstr "另一种替代方案就是通常的使用 ``def`` 语句来定义函数::"

#: ../../howto/functional.rst:1130
msgid ""
"def adder(x, y):\n"
"    return x + y\n"
"\n"
"def print_assign(name, value):\n"
"    return name + '=' + str(value)"
msgstr ""
"def adder(x, y):\n"
"    return x + y\n"
"\n"
"def print_assign(name, value):\n"
"    return name + '=' + str(value)"

#: ../../howto/functional.rst:1136
msgid ""
"Which alternative is preferable?  That's a style question; my usual course "
"is to avoid using ``lambda``."
msgstr "哪一种更受青睐呢？这是一个风格问题；我通常的做法是避免使用 ``lambda``。"

#: ../../howto/functional.rst:1139
msgid ""
"One reason for my preference is that ``lambda`` is quite limited in the "
"functions it can define.  The result has to be computable as a single "
"expression, which means you can't have multiway ``if... elif... else`` "
"comparisons or ``try... except`` statements.  If you try to do too much in a"
" ``lambda`` statement, you'll end up with an overly complicated expression "
"that's hard to read.  Quick, what's the following code doing? ::"
msgstr ""
"我这么偏好的一个原因是，``lambda`` 能够定义的函数非常受限。函数的结果必须能够作为单独的表达式来计算，这意味着你不能使用多路 ``if... "
"elif... else`` 比较，或者 ``try... except`` 语句。如果你尝试在 ``lambda`` "
"语句中做太多事情，你最终会把表达式过于复杂以至于难以阅读。你能快速的说出下面的代码做了什么事情吗？::"

#: ../../howto/functional.rst:1146
msgid ""
"import functools\n"
"total = functools.reduce(lambda a, b: (0, a[1] + b[1]), items)[1]"
msgstr ""
"import functools\n"
"total = functools.reduce(lambda a, b: (0, a[1] + b[1]), items)[1]"

#: ../../howto/functional.rst:1149
msgid ""
"You can figure it out, but it takes time to disentangle the expression to "
"figure out what's going on.  Using a short nested ``def`` statements makes "
"things a little bit better::"
msgstr "你可以弄明白，不过要花上时间来理清表达式来搞清楚发生了什么。使用一个简短的嵌套的 ``def`` 语句可以让情况变得更好::"

#: ../../howto/functional.rst:1153
msgid ""
"import functools\n"
"def combine(a, b):\n"
"    return 0, a[1] + b[1]\n"
"\n"
"total = functools.reduce(combine, items)[1]"
msgstr ""
"import functools\n"
"def combine(a, b):\n"
"    return 0, a[1] + b[1]\n"
"\n"
"total = functools.reduce(combine, items)[1]"

#: ../../howto/functional.rst:1159
msgid "But it would be best of all if I had simply used a ``for`` loop::"
msgstr "如果我仅仅使用一个 ``for`` 循环会更好::"

#: ../../howto/functional.rst:1161
msgid ""
"total = 0\n"
"for a, b in items:\n"
"    total += b"
msgstr ""
"total = 0\n"
"for a, b in items:\n"
"    total += b"

#: ../../howto/functional.rst:1165
msgid "Or the :func:`sum` built-in and a generator expression::"
msgstr "或者使用内置的 :func:`sum` 和一个生成器表达式::"

#: ../../howto/functional.rst:1167
msgid "total = sum(b for a, b in items)"
msgstr "total = sum(b for a, b in items)"

#: ../../howto/functional.rst:1169
msgid ""
"Many uses of :func:`functools.reduce` are clearer when written as ``for`` "
"loops."
msgstr "许多使用 :func:`functools.reduce` 的情形可以更清晰地写成 ``for`` 循环的形式。"

#: ../../howto/functional.rst:1171
msgid ""
"Fredrik Lundh once suggested the following set of rules for refactoring uses"
" of ``lambda``:"
msgstr "Fredrik Lundh 曾经建议以下一组规则来重构 ``lambda`` 的使用:"

#: ../../howto/functional.rst:1174
msgid "Write a lambda function."
msgstr "写一个 lambda 函数。"

#: ../../howto/functional.rst:1175
msgid "Write a comment explaining what the heck that lambda does."
msgstr "写一句注释来说明这个 lambda 究竟干了什么。"

#: ../../howto/functional.rst:1176
msgid ""
"Study the comment for a while, and think of a name that captures the essence"
" of the comment."
msgstr "研究一会这个注释，然后想出一个抓住注释本质的名字。"

#: ../../howto/functional.rst:1178
msgid "Convert the lambda to a def statement, using that name."
msgstr "用这个名字，把这个 lambda 改写成 def 语句。"

#: ../../howto/functional.rst:1179
msgid "Remove the comment."
msgstr "把注释去掉。"

#: ../../howto/functional.rst:1181
msgid ""
"I really like these rules, but you're free to disagree about whether this "
"lambda-free style is better."
msgstr "我非常喜欢这些规则，不过你完全有权利争辩这种消除 lambda 的风格是不是更好。"

#: ../../howto/functional.rst:1186
msgid "Revision History and Acknowledgements"
msgstr "修订记录和致谢"

#: ../../howto/functional.rst:1188
msgid ""
"The author would like to thank the following people for offering "
"suggestions, corrections and assistance with various drafts of this article:"
" Ian Bicking, Nick Coghlan, Nick Efford, Raymond Hettinger, Jim Jewett, Mike"
" Krell, Leandro Lameiro, Jussi Salmela, Collin Winter, Blake Winton."
msgstr ""
"作者要感谢以下人员对本文各种草稿给予的建议，更正和协助：Ian Bicking,Nick Coghlan, Nick Efford, Raymond "
"Hettinger, Jim Jewett, Mike Krell,Leandro Lameiro, Jussi Salmela, Collin "
"Winter, Blake Winton。"

#: ../../howto/functional.rst:1193
msgid "Version 0.1: posted June 30 2006."
msgstr "0.1 版: 2006 年 6 月 30 日发布。"

#: ../../howto/functional.rst:1195
msgid "Version 0.11: posted July 1 2006.  Typo fixes."
msgstr "0.11 版: 2006 年 7 月 1 日发布。 修正拼写错误。"

#: ../../howto/functional.rst:1197
msgid ""
"Version 0.2: posted July 10 2006.  Merged genexp and listcomp sections into "
"one. Typo fixes."
msgstr "0.2 版: 2006 年 7 月 10 日发布。 将 genexp 与 listcomp 两节合二为一。 修正拼写错误。"

#: ../../howto/functional.rst:1200
msgid ""
"Version 0.21: Added more references suggested on the tutor mailing list."
msgstr "0.21 版: 加入了 tutor 邮件列表中建议的更多参考文件。"

#: ../../howto/functional.rst:1202
msgid ""
"Version 0.30: Adds a section on the ``functional`` module written by Collin "
"Winter; adds short section on the operator module; a few other edits."
msgstr ""
"0.30 版: 添加了有关 ``functional`` 模块的小节，由 Collin Winter 撰写；添加了有关 operator "
"模块的简短小节；其他少量修改。"

#: ../../howto/functional.rst:1207
msgid "References"
msgstr "参考文献"

#: ../../howto/functional.rst:1210
msgid "General"
msgstr "通用文献"

#: ../../howto/functional.rst:1212
msgid ""
"**Structure and Interpretation of Computer Programs**, by Harold Abelson and"
" Gerald Jay Sussman with Julie Sussman.  The book can be found at "
"https://mitpress.mit.edu/sicp.  In this classic textbook of computer "
"science, chapters 2 and 3 discuss the use of sequences and streams to "
"organize the data flow inside a program.  The book uses Scheme for its "
"examples, but many of the design approaches described in these chapters are "
"applicable to functional-style Python code."
msgstr ""
"**Structure and Interpretation of Computer Programs**, Harold Abelson 和 "
"Gerald Jay Sussman 与 Julie Sussman 著。 该书可在 https://mitpress.mit.edu/sicp 获取。"
" 在这部计算机科学的经典教科书中，第 2 和第 3 章讨论了使用序列和流来组织程序内部的数据传递。 书中的示例使用了 Scheme "
"语言，但这些章节中介绍的许多设计理念同样适用于函数式风格的 Python 代码。"

#: ../../howto/functional.rst:1220
msgid ""
"https://defmacro.org/2006/06/19/fp.html: A general introduction to "
"functional programming that uses Java examples and has a lengthy historical "
"introduction."
msgstr ""
"https://defmacro.org/2006/06/19/fp.html: 一个使用 Java 示例并且具有详细的历史说明的函数式编程的总体介绍。"

#: ../../howto/functional.rst:1223
msgid ""
"https://en.wikipedia.org/wiki/Functional_programming: General Wikipedia "
"entry describing functional programming."
msgstr ""
"https://en.wikipedia.org/wiki/Functional_programming: 一般性的函数式编程的 Wikipedia "
"条目。"

#: ../../howto/functional.rst:1226
msgid "https://en.wikipedia.org/wiki/Coroutine: Entry for coroutines."
msgstr "https://en.wikipedia.org/wiki/Coroutine: 协程条目。"

#: ../../howto/functional.rst:1228
msgid ""
"https://en.wikipedia.org/wiki/Partial_application: Entry for the concept of "
"partial function application."
msgstr "https://en.wikipedia.org/wiki/Partial_application: 部分化函数应用相关概念的条目。"

#: ../../howto/functional.rst:1230
msgid ""
"https://en.wikipedia.org/wiki/Currying: Entry for the concept of currying."
msgstr "https://en.wikipedia.org/wiki/Currying: 函数柯里化条目。"

#: ../../howto/functional.rst:1233
msgid "Python-specific"
msgstr "Python 相关"

#: ../../howto/functional.rst:1235
msgid ""
"https://gnosis.cx/TPiP/: The first chapter of David Mertz's book :title-"
"reference:`Text Processing in Python` discusses functional programming for "
"text processing, in the section titled \"Utilizing Higher-Order Functions in"
" Text Processing\"."
msgstr ""
"https://gnosis.cx/TPiP/: David Mertz 书中的第一章 :title-reference:`Text "
"Processing in Python` 中标题为 \"Utilizing Higher-Order Functions in Text "
"Processing\" 的小节讨论了针对文本处理的函数式编程。"

#: ../../howto/functional.rst:1240
msgid ""
"Mertz also wrote a 3-part series of articles on functional programming for "
"IBM's DeveloperWorks site; see `part 1 "
"<https://developer.ibm.com/articles/l-prog/>`__, `part 2 "
"<https://developer.ibm.com/tutorials/l-prog2/>`__, and `part 3 "
"<https://developer.ibm.com/tutorials/l-prog3/>`__,"
msgstr ""
"Mertz 还在 IBM 的 DeveloperWorks 站点上针对函数式编程撰写了一系列共 3 篇文章；参见 `part 1 "
"<https://developer.ibm.com/articles/l-prog/>`__, `part 2 "
"<https://developer.ibm.com/tutorials/l-prog2/>`__ 和 `part 3 "
"<https://developer.ibm.com/tutorials/l-prog3/>`__,"

#: ../../howto/functional.rst:1248
msgid "Python documentation"
msgstr "Python 文档"

#: ../../howto/functional.rst:1250
msgid "Documentation for the :mod:`itertools` module."
msgstr ":mod:`itertools` 模块文档。"

#: ../../howto/functional.rst:1252
msgid "Documentation for the :mod:`functools` module."
msgstr ":mod:`functools` 模块文档。"

#: ../../howto/functional.rst:1254
msgid "Documentation for the :mod:`operator` module."
msgstr ":mod:`operator` 模块文档。"

#: ../../howto/functional.rst:1256
msgid ":pep:`289`: \"Generator Expressions\""
msgstr ":pep:`289`: \"Generator Expressions\""

#: ../../howto/functional.rst:1258
msgid ""
":pep:`342`: \"Coroutines via Enhanced Generators\" describes the new "
"generator features in Python 2.5."
msgstr ""
":pep:`342`: \"Coroutines via Enhanced Generators\" 描述了 Python 2.5 中新的生成器特性。"
