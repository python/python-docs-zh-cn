# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-06-27 14:55+0000\n"
"PO-Revision-Date: 2025-05-08 05:09+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/isolating-extensions.rst:7
msgid "Isolating Extension Modules"
msgstr "隔离扩展模块"

#: ../../howto/isolating-extensions.rst-1
msgid "Abstract"
msgstr "摘要"

#: ../../howto/isolating-extensions.rst:11
msgid ""
"Traditionally, state belonging to Python extension modules was kept in C "
"``static`` variables, which have process-wide scope. This document describes"
" problems of such per-process state and shows a safer way: per-module state."
msgstr ""
"在传统上，属于 Python 扩展模块的状态都是保存为 C ``static`` 变量，它们具有进程级的作用域。 "
"本文档描述了此类进程级状态的问题并演示了一种更安全的方式：模块级状态。"

#: ../../howto/isolating-extensions.rst:16
msgid ""
"The document also describes how to switch to per-module state where "
"possible. This transition involves allocating space for that state, "
"potentially switching from static types to heap types, and—perhaps most "
"importantly—accessing per-module state from code."
msgstr ""
"本文档还描述了如何在可能的情况下切换到模块级状态。 这种转换涉及为状态分配空间、从静态类型到堆类型的潜在切换，以及 — 也许是最重要的 — "
"从代码访问模块级状态。"

#: ../../howto/isolating-extensions.rst:23
msgid "Who should read this"
msgstr "谁应当阅读本文档"

#: ../../howto/isolating-extensions.rst:25
msgid ""
"This guide is written for maintainers of :ref:`C-API <c-api-index>` "
"extensions who would like to make that extension safer to use in "
"applications where Python itself is used as a library."
msgstr ""
"本指南是针对想要让扩展更安全地在将 Python 本身用作库的应用程序中使用的 :ref:`C-API <c-api-index>` 扩展维护者撰写的。"

#: ../../howto/isolating-extensions.rst:31
msgid "Background"
msgstr "背景"

#: ../../howto/isolating-extensions.rst:33
msgid ""
"An *interpreter* is the context in which Python code runs. It contains "
"configuration (e.g. the import path) and runtime state (e.g. the set of "
"imported modules)."
msgstr "*解释器* 是 Python 代码运行所在的上下文。 它包含配置（例如导入路径）和运行时状态（例如已导入模块的集合）。"

#: ../../howto/isolating-extensions.rst:37
msgid ""
"Python supports running multiple interpreters in one process. There are two "
"cases to think about—users may run interpreters:"
msgstr "Python 支持在一个进程中运行多个解释器。 这里有两种情况需要考虑 — 用户可能会以下列方式运行解释器:"

#: ../../howto/isolating-extensions.rst:40
msgid ""
"in sequence, with several :c:func:`Py_InitializeEx`/:c:func:`Py_FinalizeEx` "
"cycles, and"
msgstr "串行，使用多个 :c:func:`Py_InitializeEx`/:c:func:`Py_FinalizeEx` 循环，以及"

#: ../../howto/isolating-extensions.rst:42
msgid ""
"in parallel, managing \"sub-interpreters\" using "
":c:func:`Py_NewInterpreter`/:c:func:`Py_EndInterpreter`."
msgstr ""
"并行，使用 :c:func:`Py_NewInterpreter`/:c:func:`Py_EndInterpreter` 管理多个“子解释器”。"

#: ../../howto/isolating-extensions.rst:45
msgid ""
"Both cases (and combinations of them) would be most useful when embedding "
"Python within a library. Libraries generally shouldn't make assumptions "
"about the application that uses them, which include assuming a process-wide "
"\"main Python interpreter\"."
msgstr ""
"这两种情况（以及它们的组合）最适用于将 Python 嵌入到某个库中。 库通常不应假定使用它们的应用程序，这包括假定存在一个进程级的“主 Python "
"解释器”。"

#: ../../howto/isolating-extensions.rst:50
msgid ""
"Historically, Python extension modules don't handle this use case well. Many"
" extension modules (and even some stdlib modules) use *per-process* global "
"state, because C ``static`` variables are extremely easy to use. Thus, data "
"that should be specific to an interpreter ends up being shared between "
"interpreters. Unless the extension developer is careful, it is very easy to "
"introduce edge cases that lead to crashes when a module is loaded in more "
"than one interpreter in the same process."
msgstr ""
"在历史上，Python 扩展模块对这种应用场景处理不佳。 许多扩展模块（甚至是某些标准库模块）都是使用 *进程内共享* 的全局状态，因为 C "
"``static`` 变量十分易用。 结果，本应专属于某个解释器的数据最终却被多个解释器所共享。 "
"除非扩展的开发者小心谨慎，否则当一个模块被相同进程内的多个解释器导入时很容易引入会导致崩溃的边界情况。"

#: ../../howto/isolating-extensions.rst:58
msgid ""
"Unfortunately, *per-interpreter* state is not easy to achieve. Extension "
"authors tend to not keep multiple interpreters in mind when developing, and "
"it is currently cumbersome to test the behavior."
msgstr "不幸的是，*解释器级* 状态很不容易做到。 扩展的作者在开发中总是倾向于不考虑多解释器的情况，并且目前要测试此类行为也是很困难的。"

#: ../../howto/isolating-extensions.rst:63
msgid "Enter Per-Module State"
msgstr "进入模块级状态"

#: ../../howto/isolating-extensions.rst:65
msgid ""
"Instead of focusing on per-interpreter state, Python's C API is evolving to "
"better support the more granular *per-module* state. This means that C-level"
" data should be attached to a *module object*. Each interpreter creates its "
"own module object, keeping the data separate. For testing the isolation, "
"multiple module objects corresponding to a single extension can even be "
"loaded in a single interpreter."
msgstr ""
"Python 的 C API 不是专注于解释器级状态，而是演化为更好地支持更细粒度的 *模块级* 状态。 这意味着 C 层级数据应当关联到 "
"*模块对象*。 每个解释器都会创建自己的模块对象，保持数据的相互分隔。 要测试这种分隔，甚至可以在单个解释器中加载对应于单个扩展的多个模块对象。"

#: ../../howto/isolating-extensions.rst:72
msgid ""
"Per-module state provides an easy way to think about lifetime and resource "
"ownership: the extension module will initialize when a module object is "
"created, and clean up when it's freed. In this regard, a module is just like"
" any other :c:expr:`PyObject *`; there are no \"on interpreter shutdown\" "
"hooks to think—or forget—about."
msgstr ""
"模块级状态提供了一种处理生命周期和资源归属的简单方式：扩展模块将在模块对象被创建时初始化，并在其释放时被清理。 在这一点上，模块就像是任何其他的 "
":c:expr:`PyObject *`；没有必要添加 — 或者去除 — 处理“解释器关闭”的钩子。"

#: ../../howto/isolating-extensions.rst:78
msgid ""
"Note that there are use cases for different kinds of \"globals\": per-"
"process, per-interpreter, per-thread or per-task state. With per-module "
"state as the default, these are still possible, but you should treat them as"
" exceptional cases: if you need them, you should give them additional care "
"and testing. (Note that this guide does not cover them.)"
msgstr ""
"请注意各种不同“全局”状态：进程级、解释器级、线程级状态的应用场景。 "
"默认为模块级状态，其他状态也是可选择的，但你应当将它们视为特殊情况：如果你需要它们，你应当给予它们额外的关注和测试。 （请注意本指南并没有涉及它们。）"

#: ../../howto/isolating-extensions.rst:87
msgid "Isolated Module Objects"
msgstr "隔离的模块对象"

#: ../../howto/isolating-extensions.rst:89
msgid ""
"The key point to keep in mind when developing an extension module is that "
"several module objects can be created from a single shared library. For "
"example:"
msgstr "在开发扩展模块时要记住的关键点是多个模块对象可以从单个共享库来创建。 例如:"

#: ../../howto/isolating-extensions.rst:93
msgid ""
">>> import sys\n"
">>> import binascii\n"
">>> old_binascii = binascii\n"
">>> del sys.modules['binascii']\n"
">>> import binascii  # create a new module object\n"
">>> old_binascii == binascii\n"
"False"
msgstr ""
">>> import sys\n"
">>> import binascii\n"
">>> old_binascii = binascii\n"
">>> del sys.modules['binascii']\n"
">>> import binascii  # create a new module object\n"
">>> old_binascii == binascii\n"
"False"

#: ../../howto/isolating-extensions.rst:103
msgid ""
"As a rule of thumb, the two modules should be completely independent. All "
"objects and state specific to the module should be encapsulated within the "
"module object, not shared with other module objects, and cleaned up when the"
" module object is deallocated. Since this just is a rule of thumb, "
"exceptions are possible (see `Managing Global State`_), but they will need "
"more thought and attention to edge cases."
msgstr ""
"作为经验法则，这两个模块应该是完全独立的。 模块专属的所有对象和状态应该被封装在模块对象内部，不与其他模块对象共享，并在模块对象被释放时进行清理。 "
"由于这只是一个经验法则，例外情况也是可能的（参见 `Managing Global State`_)，但这将需要更多的考虑并注意边界情况。"

#: ../../howto/isolating-extensions.rst:111
msgid ""
"While some modules could do with less stringent restrictions, isolated "
"modules make it easier to set clear expectations and guidelines that work "
"across a variety of use cases."
msgstr "虽然有些模块不用太多的严格限制，但是隔离的模块使得更容易制定适合各种应用场景的明确期望和指南。"

#: ../../howto/isolating-extensions.rst:117
msgid "Surprising Edge Cases"
msgstr "令人惊讶的边界情况"

#: ../../howto/isolating-extensions.rst:119
msgid ""
"Note that isolated modules do create some surprising edge cases. Most "
"notably, each module object will typically not share its classes and "
"exceptions with other similar modules. Continuing from the `example above "
"<Isolated Module Objects_>`__, note that ``old_binascii.Error`` and "
"``binascii.Error`` are separate objects. In the following code, the "
"exception is *not* caught:"
msgstr ""
"请注意隔离的模块会创造一些令人惊讶的边界情况。 最明显的一点，每个模块对象通常都不会与其他类似模块共享它的类和异常。 继续 `上面的例子 "
"<Isolated Module Objects_>`__，请注意 ``old_binascii.Error`` 和 "
"``binascii.Error`` 是单独的对象。 在下面的代码中，异常 *不会* 被捕获:"

#: ../../howto/isolating-extensions.rst:126
msgid ""
">>> old_binascii.Error == binascii.Error\n"
"False\n"
">>> try:\n"
"...     old_binascii.unhexlify(b'qwertyuiop')\n"
"... except binascii.Error:\n"
"...     print('boo')\n"
"...\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 2, in <module>\n"
"binascii.Error: Non-hexadecimal digit found"
msgstr ""
">>> old_binascii.Error == binascii.Error\n"
"False\n"
">>> try:\n"
"...     old_binascii.unhexlify(b'qwertyuiop')\n"
"... except binascii.Error:\n"
"...     print('boo')\n"
"...\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 2, in <module>\n"
"binascii.Error: Non-hexadecimal digit found"

#: ../../howto/isolating-extensions.rst:139
msgid ""
"This is expected. Notice that pure-Python modules behave the same way: it is"
" a part of how Python works."
msgstr "这是预期的结果。 请注意纯 Python 模块的行为相同：它是 Python 语言特性的一部分。"

#: ../../howto/isolating-extensions.rst:142
msgid ""
"The goal is to make extension modules safe at the C level, not to make hacks"
" behave intuitively. Mutating ``sys.modules`` \"manually\" counts as a hack."
msgstr "最终目标是让扩展模块在 C 层级上保持安全，使破坏不容易实现。 “手动”改变 ``sys.modules`` 被视为是破坏行为。"

#: ../../howto/isolating-extensions.rst:148
msgid "Making Modules Safe with Multiple Interpreters"
msgstr "让多解释器下模块保持安全"

#: ../../howto/isolating-extensions.rst:152
msgid "Managing Global State"
msgstr "管理全局状态"

#: ../../howto/isolating-extensions.rst:154
msgid ""
"Sometimes, the state associated with a Python module is not specific to that"
" module, but to the entire process (or something else \"more global\" than a"
" module). For example:"
msgstr "有时，与一个 Python 模块相关联的状态并不是该模块专属的，而是整个进程（或者比模块“更全局化”的其他东西）共享。 例如:"

#: ../../howto/isolating-extensions.rst:158
msgid "The ``readline`` module manages *the* terminal."
msgstr "``readline`` 模块管理 *一个* 终端。"

#: ../../howto/isolating-extensions.rst:159
msgid ""
"A module running on a circuit board wants to control *the* on-board LED."
msgstr "在电路板上运行的模块想要控制 *一个* 板载 LED。"

#: ../../howto/isolating-extensions.rst:162
msgid ""
"In these cases, the Python module should provide *access* to the global "
"state, rather than *own* it. If possible, write the module so that multiple "
"copies of it can access the state independently (along with other libraries,"
" whether for Python or other languages). If that is not possible, consider "
"explicit locking."
msgstr ""
"在这些情况下，Python 模块应当提供对全局状态的 *访问*，而不是 *拥有* 它。 "
"如果可能，编写模块时要让它的多个副本可以独立地访问全局状态（能配合其它的库，不论它们是使用 Python 还是其他语言）。 "
"如果这无法做到，可考虑显式加锁。"

#: ../../howto/isolating-extensions.rst:168
msgid ""
"If it is necessary to use process-global state, the simplest way to avoid "
"issues with multiple interpreters is to explicitly prevent a module from "
"being loaded more than once per process—see :ref:`isolating-extensions-"
"optout`."
msgstr ""
"如果有必要使用进程级全局状态，那么避免多解释器相关问题的最简单方式是显式地阻止模块在一个进程中被多次加载 — 参见 :ref:`isolating-"
"extensions-optout`。"

#: ../../howto/isolating-extensions.rst:175
msgid "Managing Per-Module State"
msgstr "管理模块级状态"

#: ../../howto/isolating-extensions.rst:177
msgid ""
"To use per-module state, use :ref:`multi-phase extension module "
"initialization <multi-phase-initialization>`. This signals that your module "
"supports multiple interpreters correctly."
msgstr ""
"要使用模块级状态，请使用 :ref:`多阶段扩展模块初始化 <multi-phase-initialization>`。 "
"这将标示你的模块能正确地支持多解释器。"

#: ../../howto/isolating-extensions.rst:181
msgid ""
"Set ``PyModuleDef.m_size`` to a positive number to request that many bytes "
"of storage local to the module. Usually, this will be set to the size of "
"some module-specific ``struct``, which can store all of the module's C-level"
" state. In particular, it is where you should put pointers to classes "
"(including exceptions, but excluding static types) and settings (e.g. "
"``csv``'s :py:data:`~csv.field_size_limit`) which the C code needs to "
"function."
msgstr ""
"将 ``PyModuleDef.m_size`` 设为一个正数来为模块请求指定字节的本地存储。 通常，这将被设为某个模块专属 ``struct`` "
"的大小，它可以保存模块的所有 C 层级状态。 特别地，它应当是你存放类指针（包括异常，但不包括静态类型）和 C 代码正常运作所需设置（如 ``csv``"
" 的 :py:data:`~csv.field_size_limit` 等）的地方。"

#: ../../howto/isolating-extensions.rst:190
msgid ""
"Another option is to store state in the module's ``__dict__``, but you must "
"avoid crashing when users modify ``__dict__`` from Python code. This usually"
" means error- and type-checking at the C level, which is easy to get wrong "
"and hard to test sufficiently."
msgstr ""
"另一个选项是将状态保存在模块的 ``__dict__`` 中，但你必须避免当用户从 Python 代码中修改 ``__dict__`` 导致的程序崩溃。"
" 这通常意味着要在 C 层级上进行错误和类型检查，很容易弄错又很难充分测试。"

#: ../../howto/isolating-extensions.rst:195
msgid ""
"However, if module state is not needed in C code, storing it in ``__dict__``"
" only is a good idea."
msgstr "但是，如果 C 代码不需要模块状态，则仅将其保存在 ``__dict__`` 中就是一个好主意。"

#: ../../howto/isolating-extensions.rst:198
msgid ""
"If the module state includes ``PyObject`` pointers, the module object must "
"hold references to those objects and implement the module-level hooks "
"``m_traverse``, ``m_clear`` and ``m_free``. These work like ``tp_traverse``,"
" ``tp_clear`` and ``tp_free`` of a class. Adding them will require some work"
" and make the code longer; this is the price for modules which can be "
"unloaded cleanly."
msgstr ""
"如果模块状态包括 ``PyObject`` 指针，则模块对象必须持有对这些对象的引用并实现模块层级的钩子 ``m_traverse``, "
"``m_clear`` 和 ``m_free``。 它们的作用方式很像类的 ``tp_traverse``, ``tp_clear`` 和 "
"``tp_free``。 添加它们将会增加工作量并使代码更冗长；这是为了让模块能干净地卸载所需的代价。"

#: ../../howto/isolating-extensions.rst:205
msgid ""
"An example of a module with per-module state is currently available as "
"`xxlimited "
"<https://github.com/python/cpython/blob/master/Modules/xxlimited.c>`__; "
"example module initialization shown at the bottom of the file."
msgstr ""
"带有模块级状态的模块示例目前可在 `xxlimited "
"<https://github.com/python/cpython/blob/master/Modules/xxlimited.c>`__ "
"获取；模块初始化的示例见文件的末尾部分。"

#: ../../howto/isolating-extensions.rst:213
msgid "Opt-Out: Limiting to One Module Object per Process"
msgstr "回退选项：每个进程限一个模块对象"

#: ../../howto/isolating-extensions.rst:215
msgid ""
"A non-negative ``PyModuleDef.m_size`` signals that a module supports "
"multiple interpreters correctly. If this is not yet the case for your "
"module, you can explicitly make your module loadable only once per process. "
"For example::"
msgstr ""
"非负的 ``PyModuleDef.m_size`` 值表示一个模块能正确地支持多解释器。 "
"如果你的模块还不能做到这样，你可以显式地设置你的模块在每个进程中只能加载一次。 例如::"

#: ../../howto/isolating-extensions.rst:220
msgid ""
"// A process-wide flag\n"
"static int loaded = 0;\n"
"\n"
"// Mutex to provide thread safety (only needed for free-threaded Python)\n"
"static PyMutex modinit_mutex = {0};\n"
"\n"
"static int\n"
"exec_module(PyObject* module)\n"
"{\n"
"    PyMutex_Lock(&modinit_mutex);\n"
"    if (loaded) {\n"
"        PyMutex_Unlock(&modinit_mutex);\n"
"        PyErr_SetString(PyExc_ImportError,\n"
"                        \"cannot load module more than once per process\");\n"
"        return -1;\n"
"    }\n"
"    loaded = 1;\n"
"    PyMutex_Unlock(&modinit_mutex);\n"
"    // ... rest of initialization\n"
"}"
msgstr ""
"// 作用于进程的旗标\n"
"static int loaded = 0;\n"
"\n"
"// 提供线程安全的互斥锁（仅在自由线程版 Python 中需要）\n"
"\n"
"static int\n"
"exec_module(PyObject* module)\n"
"{\n"
"    PyMutex_Lock(&modinit_mutex);\n"
"    if (loaded) {\n"
"        PyMutex_Unlock(&modinit_mutex);\n"
"        PyErr_SetString(PyExc_ImportError,\n"
"                        \"cannot load module more than once per process\");\n"
"        return -1;\n"
"    }\n"
"    loaded = 1;\n"
"    PyMutex_Unlock(&modinit_mutex);\n"
"    // ... 初始化的其余部分"

#: ../../howto/isolating-extensions.rst:242
msgid ""
"If your module's :c:member:`PyModuleDef.m_clear` function is able to prepare"
" for future re-initialization, it should clear the ``loaded`` flag. In this "
"case, your module won't support multiple instances existing *concurrently*, "
"but it will, for example, support being loaded after Python runtime shutdown"
" (:c:func:`Py_FinalizeEx`) and re-initialization (:c:func:`Py_Initialize`)."
msgstr ""
"如果你的模块的 :c:member:`PyModuleDef.m_clear` 函数能够为将来的重新初始化做好准备，它应当清除 ``loaded`` "
"旗标。 在此情况下，你的模块将不支持多个实例 *并发地* 存在，但举例来说，它将支持在 Python 运行时关闭 "
"(:c:func:`Py_FinalizeEx`) 和重新初始化 (:c:func:`Py_Initialize`) 之后被加载。"

#: ../../howto/isolating-extensions.rst:251
msgid "Module State Access from Functions"
msgstr "函数对模块状态的访问"

#: ../../howto/isolating-extensions.rst:253
msgid ""
"Accessing the state from module-level functions is straightforward. "
"Functions get the module object as their first argument; for extracting the "
"state, you can use ``PyModule_GetState``::"
msgstr ""
"从模块层级的函数访问状态是相当直观的。 函数通过它们的第一个参数获得模块对象；要提取状态，你可以使用 ``PyModule_GetState``::"

#: ../../howto/isolating-extensions.rst:257
msgid ""
"static PyObject *\n"
"func(PyObject *module, PyObject *args)\n"
"{\n"
"    my_struct *state = (my_struct*)PyModule_GetState(module);\n"
"    if (state == NULL) {\n"
"        return NULL;\n"
"    }\n"
"    // ... rest of logic\n"
"}"
msgstr ""
"static PyObject *\n"
"func(PyObject *module, PyObject *args)\n"
"{\n"
"    my_struct *state = (my_struct*)PyModule_GetState(module);\n"
"    if (state == NULL) {\n"
"        return NULL;\n"
"    }\n"
"    // ... 其余的逻辑\n"
"}"

#: ../../howto/isolating-extensions.rst:268
msgid ""
"``PyModule_GetState`` may return ``NULL`` without setting an exception if "
"there is no module state, i.e. ``PyModuleDef.m_size`` was zero. In your own "
"module, you're in control of ``m_size``, so this is easy to prevent."
msgstr ""
"如果模块状态不存在则 ``PyModule_GetState`` 可能返回 ``NULL`` 而不设置异常，即 "
"``PyModuleDef.m_size`` 为零。 在你自己的模块中，你可以任意控制 ``m_size``，因此这很容易避免。"

#: ../../howto/isolating-extensions.rst:275
msgid "Heap Types"
msgstr "堆类型"

#: ../../howto/isolating-extensions.rst:277
msgid ""
"Traditionally, types defined in C code are *static*; that is, ``static "
"PyTypeObject`` structures defined directly in code and initialized using "
"``PyType_Ready()``."
msgstr ""
"在传统上，在 C 代码中定义的类型都是 *静态的*；也就是说，``static PyTypeObject`` 结构体在代码中直接定义并使用 "
"``PyType_Ready()`` 来初始化。"

#: ../../howto/isolating-extensions.rst:281
msgid ""
"Such types are necessarily shared across the process. Sharing them between "
"module objects requires paying attention to any state they own or access. To"
" limit the possible issues, static types are immutable at the Python level: "
"for example, you can't set ``str.myattribute = 123``."
msgstr ""
"这样的类型必须在进程范围内共享。 在模块对象之间共享它们需要注意它们所拥有或访问的任何状态。 要限制可能出现的问题，静态类型在 Python "
"层级上是不可变的：例如，你无法设置 ``str.myattribute = 123``。"

#: ../../howto/isolating-extensions.rst:287
msgid ""
"Sharing truly immutable objects between interpreters is fine, as long as "
"they don't provide access to mutable objects. However, in CPython, every "
"Python object has a mutable implementation detail: the reference count. "
"Changes to the refcount are guarded by the GIL. Thus, code that shares any "
"Python objects across interpreters implicitly depends on CPython's current, "
"process-wide GIL."
msgstr ""
"在解释器之间共享真正不可变的对象是可行的，只要它们不提供对可变对象的访问。 但是，在 CPython 中，每个 Python "
"对象都有一个可变的实现细节：引用计数。 对引用计数的更改是由 GIL 来保护的。 因此，跨解释器共享任何 Python 对象的代码都隐式地依赖于 "
"CPython 现有的、进程级的 GIL。"

#: ../../howto/isolating-extensions.rst:294
msgid ""
"Because they are immutable and process-global, static types cannot access "
"\"their\" module state. If any method of such a type requires access to "
"module state, the type must be converted to a *heap-allocated type*, or "
"*heap type* for short. These correspond more closely to classes created by "
"Python's ``class`` statement."
msgstr ""
"因为它们是不可变的进程级全局对象，所以静态类型无法访问“它们的”模块状态。 如果任何此种类型的方法需要访问模块状态，则该类型必须被转换为 "
"*堆分配类型*，或者简称为 *堆类型*。 此种类型相对更接近由 Python 的 ``class`` 语句所创建的类。"

#: ../../howto/isolating-extensions.rst:301
msgid "For new modules, using heap types by default is a good rule of thumb."
msgstr "对于新模块，默认使用堆类型是一个很好的经验法则。"

#: ../../howto/isolating-extensions.rst:305
msgid "Changing Static Types to Heap Types"
msgstr "将静态类型改为堆类型"

#: ../../howto/isolating-extensions.rst:307
msgid ""
"Static types can be converted to heap types, but note that the heap type API"
" was not designed for \"lossless\" conversion from static types—that is, "
"creating a type that works exactly like a given static type. So, when "
"rewriting the class definition in a new API, you are likely to "
"unintentionally change a few details (e.g. pickleability or inherited "
"slots). Always test the details that are important to you."
msgstr ""
"静态类型可以转换为堆类型，但要注意堆类型 API 并非针对静态类型的“无损”转换 — 也就是说，创建与给定静态类型完全一致的类型来设计的。 "
"因此，当在新的 API 中重写类定义时，你很容易在无意中改变一些细节（例如可封存性或所继承的槽位等）。 请始终确保测试对你来说重要的细节。"

#: ../../howto/isolating-extensions.rst:316
msgid ""
"Watch out for the following two points in particular (but note that this is "
"not a comprehensive list):"
msgstr "特别要关注以下两点（但请注意这并非一个完整的列表）:"

#: ../../howto/isolating-extensions.rst:319
msgid ""
"Unlike static types, heap type objects are mutable by default. Use the "
":c:macro:`Py_TPFLAGS_IMMUTABLETYPE` flag to prevent mutability."
msgstr ""
"不同于静态类型，堆类型对象默认是可变的。 请使用 :c:macro:`Py_TPFLAGS_IMMUTABLETYPE` 旗标来防止可变性。"

#: ../../howto/isolating-extensions.rst:321
msgid ""
"Heap types inherit :c:member:`~PyTypeObject.tp_new` by default, so it may "
"become possible to instantiate them from Python code. You can prevent this "
"with the :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION` flag."
msgstr ""
"堆类型默认继承 :c:member:`~PyTypeObject.tp_new`，因此有可能通过 Python 代码来初始化它们。 你可以使用 "
":c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION` 旗标来防止此特性。"

#: ../../howto/isolating-extensions.rst:327
msgid "Defining Heap Types"
msgstr "定义堆类型"

#: ../../howto/isolating-extensions.rst:329
msgid ""
"Heap types can be created by filling a :c:struct:`PyType_Spec` structure, a "
"description or \"blueprint\" of a class, and calling "
":c:func:`PyType_FromModuleAndSpec` to construct a new class object."
msgstr ""
"堆类型可以通过填充 :c:struct:`PyType_Spec` 结构体来创建，它是对于特定类的描述或“蓝图”，并调用 "
":c:func:`PyType_FromModuleAndSpec` 来构造新的类对象。to construct a new class object."

#: ../../howto/isolating-extensions.rst:334
msgid ""
"Other functions, like :c:func:`PyType_FromSpec`, can also create heap types,"
" but :c:func:`PyType_FromModuleAndSpec` associates the module with the "
"class, allowing access to the module state from methods."
msgstr ""
"其他的函数，如 :c:func:`PyType_FromSpec`，也可以创建堆类型，但 "
":c:func:`PyType_FromModuleAndSpec` 会将模块关联到类，以允许从方法访问模块状态。"

#: ../../howto/isolating-extensions.rst:338
msgid ""
"The class should generally be stored in *both* the module state (for safe "
"access from C) and the module's ``__dict__`` (for access from Python code)."
msgstr ""
"类通常应当 *同时* 保存在模块的状态（用于从 C 中安全地访问）和模块的 ``__dict__`` 中（用于从 Python 代码中访问）。"

#: ../../howto/isolating-extensions.rst:344
msgid "Garbage-Collection Protocol"
msgstr "垃圾回收协议"

#: ../../howto/isolating-extensions.rst:346
msgid ""
"Instances of heap types hold a reference to their type. This ensures that "
"the type isn't destroyed before all its instances are, but may result in "
"reference cycles that need to be broken by the garbage collector."
msgstr "堆类型的实例会持有一个指向其类型的引用。 这能确保类型的销毁不会发生在其实例之前，但可能会导致需要由垃圾回收器来打破的引用循环。"

#: ../../howto/isolating-extensions.rst:351
msgid ""
"To avoid memory leaks, instances of heap types must implement the garbage "
"collection protocol. That is, heap types should:"
msgstr "要避免内存泄漏，堆类型的实例必须实现垃圾回收协议。 也就是说，堆类型应当:"

#: ../../howto/isolating-extensions.rst:355
msgid "Have the :c:macro:`Py_TPFLAGS_HAVE_GC` flag."
msgstr "具有 :c:macro:`Py_TPFLAGS_HAVE_GC` 旗标。"

#: ../../howto/isolating-extensions.rst:356
msgid ""
"Define a traverse function using ``Py_tp_traverse``, which visits the type "
"(e.g. using ``Py_VISIT(Py_TYPE(self))``)."
msgstr ""
"定义一个使用 ``Py_tp_traverse`` 的遍历函数，它将访问该类型 (例如使用 ``Py_VISIT(Py_TYPE(self))``)。"

#: ../../howto/isolating-extensions.rst:359
msgid ""
"Please refer to the documentation of :c:macro:`Py_TPFLAGS_HAVE_GC` and "
":c:member:`~PyTypeObject.tp_traverse` for additional considerations."
msgstr ""
"请参阅 :c:macro:`Py_TPFLAGS_HAVE_GC` 和 :c:member:`~PyTypeObject.tp_traverse` "
"的文档以获取更多说明。"

#: ../../howto/isolating-extensions.rst:363
msgid ""
"The API for defining heap types grew organically, leaving it somewhat "
"awkward to use in its current state. The following sections will guide you "
"through common issues."
msgstr "定义堆类型的 API 在有机地增长，使得它目前的使用状况有些尴尬。 以下章节将引导您解决常见的问题。"

#: ../../howto/isolating-extensions.rst:369
msgid "``tp_traverse`` in Python 3.8 and lower"
msgstr "``tp_traverse`` 在 Python 3.8 及更低的版本中"

#: ../../howto/isolating-extensions.rst:371
msgid ""
"The requirement to visit the type from ``tp_traverse`` was added in Python "
"3.9. If you support Python 3.8 and lower, the traverse function must *not* "
"visit the type, so it must be more complicated::"
msgstr ""
"从``tp_traverse`` 访问类型的要求是在 Python 3.9 中添加的。 如果你要支持 Python 3.8 及更低版本，则遍历函数 "
"*不可* 访问类型，因此必须使用更复杂的方式::"

#: ../../howto/isolating-extensions.rst:375
msgid ""
"static int my_traverse(PyObject *self, visitproc visit, void *arg)\n"
"{\n"
"    if (Py_Version >= 0x03090000) {\n"
"        Py_VISIT(Py_TYPE(self));\n"
"    }\n"
"    return 0;\n"
"}"
msgstr ""
"static int my_traverse(PyObject *self, visitproc visit, void *arg)\n"
"{\n"
"    if (Py_Version >= 0x03090000) {\n"
"        Py_VISIT(Py_TYPE(self));\n"
"    }\n"
"    return 0;\n"
"}"

#: ../../howto/isolating-extensions.rst:383
msgid ""
"Unfortunately, :c:data:`Py_Version` was only added in Python 3.11. As a "
"replacement, use:"
msgstr "不幸的是，:c:data:`Py_Version` 直到 Python 3.11 才被加入。 作为替代，请使用："

#: ../../howto/isolating-extensions.rst:386
msgid ":c:macro:`PY_VERSION_HEX`, if not using the stable ABI, or"
msgstr ":c:macro:`PY_VERSION_HEX`，如果不使用稳定 ABI 的话，或者"

#: ../../howto/isolating-extensions.rst:387
msgid ""
":py:data:`sys.version_info` (via :c:func:`PySys_GetObject` and "
":c:func:`PyArg_ParseTuple`)."
msgstr ""
":py:data:`sys.version_info` (通过 :c:func:`PySys_GetObject` 和 "
":c:func:`PyArg_ParseTuple`)。"

#: ../../howto/isolating-extensions.rst:392
msgid "Delegating ``tp_traverse``"
msgstr "委托 ``tp_traverse``"

#: ../../howto/isolating-extensions.rst:394
msgid ""
"If your traverse function delegates to the "
":c:member:`~PyTypeObject.tp_traverse` of its base class (or another type), "
"ensure that ``Py_TYPE(self)`` is visited only once. Note that only heap type"
" are expected to visit the type in ``tp_traverse``."
msgstr ""
"如果你的遍历函数委托给了其基类（或另一个类型）的 :c:member:`~PyTypeObject.tp_traverse`，请确保 "
"``Py_TYPE(self)`` 只被访问一次。 请注意只有堆类型会被预期访问 ``tp_traverse`` 中的类型。"

#: ../../howto/isolating-extensions.rst:399
msgid "For example, if your traverse function includes::"
msgstr "举例来说，如果你的遍历函数包括::"

#: ../../howto/isolating-extensions.rst:401
msgid "base->tp_traverse(self, visit, arg)"
msgstr "base->tp_traverse(self, visit, arg)"

#: ../../howto/isolating-extensions.rst:403
msgid "...and ``base`` may be a static type, then it should also include::"
msgstr "... 并且 ``base`` 可能是一个静态类型，则它也应当包括::"

#: ../../howto/isolating-extensions.rst:405
msgid ""
"if (base->tp_flags & Py_TPFLAGS_HEAPTYPE) {\n"
"    // a heap type's tp_traverse already visited Py_TYPE(self)\n"
"} else {\n"
"    if (Py_Version >= 0x03090000) {\n"
"        Py_VISIT(Py_TYPE(self));\n"
"    }\n"
"}"
msgstr ""
"if (base->tp_flags & Py_TPFLAGS_HEAPTYPE) {\n"
"    // 一个堆类型的 tp_traverse 已经访问了 Py_TYPE(self)\n"
"} else {\n"
"    if (Py_Version >= 0x03090000) {\n"
"        Py_VISIT(Py_TYPE(self));\n"
"    }\n"
"}"

#: ../../howto/isolating-extensions.rst:413
msgid ""
"It is not necessary to handle the type's reference count in "
":c:member:`~PyTypeObject.tp_new` and :c:member:`~PyTypeObject.tp_clear`."
msgstr ""
"不需要在 :c:member:`~PyTypeObject.tp_new` 和 :c:member:`~PyTypeObject.tp_clear` "
"中处理该类型的引用计数。"

#: ../../howto/isolating-extensions.rst:418
msgid "Defining ``tp_dealloc``"
msgstr "定义 ``tp_dealloc``"

#: ../../howto/isolating-extensions.rst:420
msgid ""
"If your type has a custom :c:member:`~PyTypeObject.tp_dealloc` function, it "
"needs to:"
msgstr "如果你的类型有自定义的 :c:member:`~PyTypeObject.tp_dealloc` 函数，则它需要："

#: ../../howto/isolating-extensions.rst:423
msgid ""
"call :c:func:`PyObject_GC_UnTrack` before any fields are invalidated, and"
msgstr "在任何字段失效之前调用 :c:func:`PyObject_GC_UnTrack`，并且"

#: ../../howto/isolating-extensions.rst:424
msgid "decrement the reference count of the type."
msgstr "递减该类型的引用计数。"

#: ../../howto/isolating-extensions.rst:426
msgid ""
"To keep the type valid while ``tp_free`` is called, the type's refcount "
"needs to be decremented *after* the instance is deallocated. For example::"
msgstr "要在 ``tp_free`` 被调用时保持类型有效，必须在撤销分配实例 *之后* 递减该类型的引用计数。 例如::"

#: ../../howto/isolating-extensions.rst:429
msgid ""
"static void my_dealloc(PyObject *self)\n"
"{\n"
"    PyObject_GC_UnTrack(self);\n"
"    ...\n"
"    PyTypeObject *type = Py_TYPE(self);\n"
"    type->tp_free(self);\n"
"    Py_DECREF(type);\n"
"}"
msgstr ""
"static void my_dealloc(PyObject *self)\n"
"{\n"
"    PyObject_GC_UnTrack(self);\n"
"    ...\n"
"    PyTypeObject *type = Py_TYPE(self);\n"
"    type->tp_free(self);\n"
"    Py_DECREF(type);\n"
"}"

#: ../../howto/isolating-extensions.rst:438
msgid ""
"The default ``tp_dealloc`` function does this, so if your type does *not* "
"override ``tp_dealloc`` you don't need to add it."
msgstr "默认的 ``tp_dealloc`` 函数会执行此操作，因此如果你的类型 *没有* 重载 ``tp_dealloc`` 你就不需要添加它。"

#: ../../howto/isolating-extensions.rst:444
msgid "Not overriding ``tp_free``"
msgstr "没有重载 ``tp_free``"

#: ../../howto/isolating-extensions.rst:446
msgid ""
"The :c:member:`~PyTypeObject.tp_free` slot of a heap type must be set to "
":c:func:`PyObject_GC_Del`. This is the default; do not override it."
msgstr ""
"堆类型的 :c:member:`~PyTypeObject.tp_free` 槽位必须设为 :c:func:`PyObject_GC_Del`。 "
"这是默认的设置；请不要重载它。"

#: ../../howto/isolating-extensions.rst:452
msgid "Avoiding ``PyObject_New``"
msgstr "避免 ``PyObject_New``"

#: ../../howto/isolating-extensions.rst:454
msgid "GC-tracked objects need to be allocated using GC-aware functions."
msgstr "带 GC 追踪的对象需要使用带 GC 感知的函数来分配。"

#: ../../howto/isolating-extensions.rst:456
msgid "If you use :c:func:`PyObject_New` or :c:func:`PyObject_NewVar`:"
msgstr "如果你使用 :c:func:`PyObject_New` 或 :c:func:`PyObject_NewVar`:"

#: ../../howto/isolating-extensions.rst:458
msgid ""
"Get and call type's :c:member:`~PyTypeObject.tp_alloc` slot, if possible. "
"That is, replace ``TYPE *o = PyObject_New(TYPE, typeobj)`` with::"
msgstr ""
"如有可能，请获取并调用类型的 :c:member:`~PyTypeObject.tp_alloc` 槽位。 也就是说，将 ``TYPE *o = "
"PyObject_New(TYPE, typeobj)`` 替换为::"

#: ../../howto/isolating-extensions.rst:461
msgid "TYPE *o = typeobj->tp_alloc(typeobj, 0);"
msgstr "TYPE *o = typeobj->tp_alloc(typeobj, 0);"

#: ../../howto/isolating-extensions.rst:463
msgid ""
"Replace ``o = PyObject_NewVar(TYPE, typeobj, size)`` with the same, but use "
"size instead of the 0."
msgstr "同样地替换 ``o = PyObject_NewVar(TYPE, typeobj, size)``，但要使用指定大小而不是 0。"

#: ../../howto/isolating-extensions.rst:466
msgid ""
"If the above is not possible (e.g. inside a custom ``tp_alloc``), call "
":c:func:`PyObject_GC_New` or :c:func:`PyObject_GC_NewVar`::"
msgstr ""
"如果无法执行以上操作（例如在自定义的 ``tp_alloc`` 中），请调用 :c:func:`PyObject_GC_New` 或 "
":c:func:`PyObject_GC_NewVar`::"

#: ../../howto/isolating-extensions.rst:469
msgid ""
"TYPE *o = PyObject_GC_New(TYPE, typeobj);\n"
"\n"
"TYPE *o = PyObject_GC_NewVar(TYPE, typeobj, size);"
msgstr ""
"TYPE *o = PyObject_GC_New(TYPE, typeobj);\n"
"\n"
"TYPE *o = PyObject_GC_NewVar(TYPE, typeobj, size);"

#: ../../howto/isolating-extensions.rst:475
msgid "Module State Access from Classes"
msgstr "类对模块状态的访问"

#: ../../howto/isolating-extensions.rst:477
msgid ""
"If you have a type object defined with :c:func:`PyType_FromModuleAndSpec`, "
"you can call :c:func:`PyType_GetModule` to get the associated module, and "
"then :c:func:`PyModule_GetState` to get the module's state."
msgstr ""
"如果你有一个使用 :c:func:`PyType_FromModuleAndSpec` 定义的类型对象，你可以调用 "
":c:func:`PyType_GetModule` 来获取关联的模块，然后调用 :c:func:`PyModule_GetState` "
"来获取模块的状态。to get the module's state."

#: ../../howto/isolating-extensions.rst:481
msgid ""
"To save a some tedious error-handling boilerplate code, you can combine "
"these two steps with :c:func:`PyType_GetModuleState`, resulting in::"
msgstr "要省略一些繁琐的错误处理样板代码，你可以使用 :c:func:`PyType_GetModuleState` 来合并这两步，得到::"

#: ../../howto/isolating-extensions.rst:484
msgid ""
"my_struct *state = (my_struct*)PyType_GetModuleState(type);\n"
"if (state == NULL) {\n"
"    return NULL;\n"
"}"
msgstr ""
"my_struct *state = (my_struct*)PyType_GetModuleState(type);\n"
"if (state == NULL) {\n"
"    return NULL;\n"
"}"

#: ../../howto/isolating-extensions.rst:491
msgid "Module State Access from Regular Methods"
msgstr "常规方法对模块状态的访问"

#: ../../howto/isolating-extensions.rst:493
msgid ""
"Accessing the module-level state from methods of a class is somewhat more "
"complicated, but is possible thanks to API introduced in Python 3.9. To get "
"the state, you need to first get the *defining class*, and then get the "
"module state from it."
msgstr ""
"从一个类的方法访问模块层级的状态在某些方面会更为复杂，但通过 Python 3.9 所引入的 API 这是可能做到的。 为了获取状态，你需要首先获取 "
"*定义的类*，然后从中获取模块状态。"

#: ../../howto/isolating-extensions.rst:498
msgid ""
"The largest roadblock is getting *the class a method was defined in*, or "
"that method's \"defining class\" for short. The defining class can have a "
"reference to the module it is part of."
msgstr "最大的障碍是获取 *方法定义所在的类*，简称为方法“定义的类”。 定义的类可以拥有一个指向作为其组成部分的方法的引用。"

#: ../../howto/isolating-extensions.rst:502
msgid ""
"Do not confuse the defining class with ``Py_TYPE(self)``. If the method is "
"called on a *subclass* of your type, ``Py_TYPE(self)`` will refer to that "
"subclass, which may be defined in different module than yours."
msgstr ""
"不要混淆定义的类和 ``Py_TYPE(self)``。 如果方法是在你的类型的一个 *子类* 上被调用的，则 ``Py_TYPE(self)`` "
"将指向该子类，它可能是在另一个模块中定义的。"

#: ../../howto/isolating-extensions.rst:507
msgid ""
"The following Python code can illustrate the concept. "
"``Base.get_defining_class`` returns ``Base`` even if ``type(self) == Sub``:"
msgstr ""
"下面的 Python 代码可以演示这一概念。 ``Base.get_defining_class`` 将返回 ``Base``，即使 "
"``type(self) == Sub``:"

#: ../../howto/isolating-extensions.rst:511
msgid ""
"class Base:\n"
"    def get_type_of_self(self):\n"
"        return type(self)\n"
"\n"
"    def get_defining_class(self):\n"
"        return __class__\n"
"\n"
"class Sub(Base):\n"
"    pass"
msgstr ""
"class Base:\n"
"    def get_type_of_self(self):\n"
"        return type(self)\n"
"\n"
"    def get_defining_class(self):\n"
"        return __class__\n"
"\n"
"class Sub(Base):\n"
"    pass"

#: ../../howto/isolating-extensions.rst:523
msgid ""
"For a method to get its \"defining class\", it must use the "
":ref:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-"
"METH_FASTCALL-METH_KEYWORDS>` :c:type:`calling convention <PyMethodDef>` and"
" the corresponding :c:type:`PyCMethod` signature::"
msgstr ""
"对于要获取其“定义方类”的方法，它必须使用 :ref:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS "
"<METH_METHOD-METH_FASTCALL-METH_KEYWORDS>` :c:type:`调用惯例 <PyMethodDef>` "
"以及相应的 :c:type:`PyCMethod` 签名::"

#: ../../howto/isolating-extensions.rst:528
msgid ""
"PyObject *PyCMethod(\n"
"    PyObject *self,               // object the method was called on\n"
"    PyTypeObject *defining_class, // defining class\n"
"    PyObject *const *args,        // C array of arguments\n"
"    Py_ssize_t nargs,             // length of \"args\"\n"
"    PyObject *kwnames)            // NULL, or dict of keyword arguments"
msgstr ""
"PyObject *PyCMethod(\n"
"    PyObject *self,               // 方法调用所在的对象\n"
"    PyTypeObject *defining_class, // 定义的类\n"
"    PyObject *const *args,        // 由参数组成的 C 数组\n"
"    Py_ssize_t nargs,             // \"args\" 的长度\n"
"    PyObject *kwnames)            // NULL，或由关键字参数组成的字典"

#: ../../howto/isolating-extensions.rst:535
msgid ""
"Once you have the defining class, call :c:func:`PyType_GetModuleState` to "
"get the state of its associated module."
msgstr "一旦你得到了定义的类，即可调用 :c:func:`PyType_GetModuleState` 来获取它所关联的模块的状态。"

#: ../../howto/isolating-extensions.rst:538
msgid "For example::"
msgstr "例如："

#: ../../howto/isolating-extensions.rst:540
msgid ""
"static PyObject *\n"
"example_method(PyObject *self,\n"
"        PyTypeObject *defining_class,\n"
"        PyObject *const *args,\n"
"        Py_ssize_t nargs,\n"
"        PyObject *kwnames)\n"
"{\n"
"    my_struct *state = (my_struct*)PyType_GetModuleState(defining_class);\n"
"    if (state == NULL) {\n"
"        return NULL;\n"
"    }\n"
"    ... // rest of logic\n"
"}\n"
"\n"
"PyDoc_STRVAR(example_method_doc, \"...\");\n"
"\n"
"static PyMethodDef my_methods[] = {\n"
"    {\"example_method\",\n"
"      (PyCFunction)(void(*)(void))example_method,\n"
"      METH_METHOD|METH_FASTCALL|METH_KEYWORDS,\n"
"      example_method_doc}\n"
"    {NULL},\n"
"}"
msgstr ""
"static PyObject *\n"
"example_method(PyObject *self,\n"
"        PyTypeObject *defining_class,\n"
"        PyObject *const *args,\n"
"        Py_ssize_t nargs,\n"
"        PyObject *kwnames)\n"
"{\n"
"    my_struct *state = (my_struct*)PyType_GetModuleState(defining_class);\n"
"    if (state == NULL) {\n"
"        return NULL;\n"
"    }\n"
"    ... // rest of logic\n"
"}\n"
"\n"
"PyDoc_STRVAR(example_method_doc, \"...\");\n"
"\n"
"static PyMethodDef my_methods[] = {\n"
"    {\"example_method\",\n"
"      (PyCFunction)(void(*)(void))example_method,\n"
"      METH_METHOD|METH_FASTCALL|METH_KEYWORDS,\n"
"      example_method_doc}\n"
"    {NULL},\n"
"}"

#: ../../howto/isolating-extensions.rst:566
msgid "Module State Access from Slot Methods, Getters and Setters"
msgstr "槽位方法、读取方法和设置方法对模块状态的访问"

#: ../../howto/isolating-extensions.rst:570
msgid "This is new in Python 3.11."
msgstr "这是 Python 3.11 的新增特性。"

#: ../../howto/isolating-extensions.rst:578
msgid ""
"Slot methods—the fast C equivalents for special methods, such as "
":c:member:`~PyNumberMethods.nb_add` for :py:attr:`~object.__add__` or "
":c:member:`~PyTypeObject.tp_new` for initialization—have a very simple API "
"that doesn't allow passing in the defining class, unlike with "
":c:type:`PyCMethod`. The same goes for getters and setters defined with "
":c:type:`PyGetSetDef`."
msgstr ""
"槽位方法 — 即特殊方法的 C 快速等价物，如 :c:member:`~PyNumberMethods.nb_add` 对应 "
":py:attr:`~object.__add__` 而 :c:member:`~PyTypeObject.tp_new` 对应初始化方法 — "
"具有不允许传入定义类的非常简单的 API，这不同于 :c:type:`PyCMethod`。 同样的机制也适用于通过 "
":c:type:`PyGetSetDef` 定义的读取方法和设置方法。"

#: ../../howto/isolating-extensions.rst:585
msgid ""
"To access the module state in these cases, use the "
":c:func:`PyType_GetModuleByDef` function, and pass in the module definition."
" Once you have the module, call :c:func:`PyModule_GetState` to get the "
"state::"
msgstr ""
"要在这些场景下访问模块状态，请使用 :c:func:`PyType_GetModuleByDef` 函数，并传入模块定义。 一旦你得到该模块，即可调用 "
":c:func:`PyModule_GetState` 来获取状态::"

#: ../../howto/isolating-extensions.rst:590
msgid ""
"PyObject *module = PyType_GetModuleByDef(Py_TYPE(self), &module_def);\n"
"my_struct *state = (my_struct*)PyModule_GetState(module);\n"
"if (state == NULL) {\n"
"    return NULL;\n"
"}"
msgstr ""
"PyObject *module = PyType_GetModuleByDef(Py_TYPE(self), &module_def);\n"
"my_struct *state = (my_struct*)PyModule_GetState(module);\n"
"if (state == NULL) {\n"
"    return NULL;\n"
"}"

#: ../../howto/isolating-extensions.rst:596
msgid ""
":c:func:`!PyType_GetModuleByDef` works by searching the :term:`method "
"resolution order` (i.e. all superclasses) for the first superclass that has "
"a corresponding module."
msgstr ""
":c:func:`!PyType_GetModuleByDef` 的作用方式是通过搜索 :term:`method resolution order` "
"(即所有超类) 来找到具有相应模块的第一个超类。"

#: ../../howto/isolating-extensions.rst:602
msgid ""
"In very exotic cases (inheritance chains spanning multiple modules created "
"from the same definition), :c:func:`!PyType_GetModuleByDef` might not return"
" the module of the true defining class. However, it will always return a "
"module with the same definition, ensuring a compatible C memory layout."
msgstr ""
"在非常特别的情况下（继承链跨越由同样定义创建的多个模块），:c:func:`!PyType_GetModuleByDef` "
"可能不会返回真正定义方法的类。 但是，它总是会返回一个具有同样定义的模块，这将确保具有兼容的 C 内存布局。"

#: ../../howto/isolating-extensions.rst:610
msgid "Lifetime of the Module State"
msgstr "模块状态的生命期"

#: ../../howto/isolating-extensions.rst:612
msgid ""
"When a module object is garbage-collected, its module state is freed. For "
"each pointer to (a part of) the module state, you must hold a reference to "
"the module object."
msgstr "当一个模块对象被当作垃圾回收时，它的模块状态将被释放。 对于每个指向（一部分）模块状态的指针来说，你必须持有一个对模块对象的引用。"

#: ../../howto/isolating-extensions.rst:616
msgid ""
"Usually this is not an issue, because types created with "
":c:func:`PyType_FromModuleAndSpec`, and their instances, hold a reference to"
" the module. However, you must be careful in reference counting when you "
"reference module state from other places, such as callbacks for external "
"libraries."
msgstr ""
"通常这不会有问题，因为使用 :c:func:`PyType_FromModuleAndSpec` 创建的类型，以及它们的实例，都持有对模块的引用。 "
"但是，当你从其他地方，例如对外部库的回调引用模块状态时必须小心谨慎。"

#: ../../howto/isolating-extensions.rst:625
msgid "Open Issues"
msgstr "未解决的问题"

#: ../../howto/isolating-extensions.rst:627
msgid "Several issues around per-module state and heap types are still open."
msgstr "围绕模块级状态和堆类型仍然存在一些未解决的问题。"

#: ../../howto/isolating-extensions.rst:629
msgid ""
"Discussions about improving the situation are best held on the `capi-sig "
"mailing list <https://mail.python.org/mailman3/lists/capi-"
"sig.python.org/>`__."
msgstr ""
"改善此状况最好的讨论是在 `capi-sig 邮件列表 <https://mail.python.org/mailman3/lists/capi-"
"sig.python.org/>`__ 进行的。"

#: ../../howto/isolating-extensions.rst:634
msgid "Per-Class Scope"
msgstr "类级作用域"

#: ../../howto/isolating-extensions.rst:636
msgid ""
"It is currently (as of Python 3.11) not possible to attach state to "
"individual *types* without relying on CPython implementation details (which "
"may change in the future—perhaps, ironically, to allow a proper solution for"
" per-class scope)."
msgstr ""
"目前（即 Python 3.11）还无法将状态关联到单个 *类型* 而不依赖于 CPython 实现细节（这在未来可能发生改变 — "
"或许，会怪异地允许采用适当的类级作用域解决方案）。"

#: ../../howto/isolating-extensions.rst:643
msgid "Lossless Conversion to Heap Types"
msgstr "无损转换为堆类型"

#: ../../howto/isolating-extensions.rst:645
msgid ""
"The heap type API was not designed for \"lossless\" conversion from static "
"types; that is, creating a type that works exactly like a given static type."
msgstr "堆类型 API 没有从静态类型进行“无损”转换的设计；所谓无损转换，就是创建与给定静态类型完全一致的类型。"
