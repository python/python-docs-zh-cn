# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Shengjing Zhu <zsj950618@gmail.com>, 2021
# ww song <sww4718168@gmail.com>, 2021
# 欢 王 <whthu168@163.com>, 2021
# MuSheng Chen <sheng.2179@gmail.com>, 2021
# 浩听 王 <wht_andrew@163.com>, 2021
# 非法操作 <ultrahe@gmail.com>, 2021
# Dai Xu <daixu61@hotmail.com>, 2021
# Alpha Du <alphanow@gmail.com>, 2022
# cdarlint <cdarling@126.com>, 2022
# ProgramRipper, 2023
# 乐成 王, 2023
# WH-2099 <wh2099@outlook.com>, 2024
# Freesand Leo <yuqinju@163.com>, 2024
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-08 14:16+0000\n"
"PO-Revision-Date: 2021-06-28 00:53+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2024\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/logging-cookbook.rst:5
msgid "Logging Cookbook"
msgstr "日志专题手册"

#: ../../howto/logging-cookbook.rst:0
msgid "Author"
msgstr "作者"

#: ../../howto/logging-cookbook.rst:7
msgid "Vinay Sajip <vinay_sajip at red-dove dot com>"
msgstr "Vinay Sajip <vinay_sajip at red-dove dot com>"

#: ../../howto/logging-cookbook.rst:9
msgid ""
"This page contains a number of recipes related to logging, which have been "
"found useful in the past. For links to tutorial and reference information, "
"please see :ref:`cookbook-ref-links`."
msgstr "本页面包含多个与日志相关的专题，历史证明它们是很有用的。教程和参考信息的链接另见 :ref:`cookbook-ref-links`。"

#: ../../howto/logging-cookbook.rst:16
msgid "Using logging in multiple modules"
msgstr "在多模块中使用日志"

#: ../../howto/logging-cookbook.rst:18
msgid ""
"Multiple calls to ``logging.getLogger('someLogger')`` return a reference to "
"the same logger object.  This is true not only within the same module, but "
"also across modules as long as it is in the same Python interpreter process."
"  It is true for references to the same object; additionally, application "
"code can define and configure a parent logger in one module and create (but "
"not configure) a child logger in a separate module, and all logger calls to "
"the child will pass up to the parent.  Here is a main module::"
msgstr ""
"无论对 ``logging.getLogger('someLogger')`` 进行多少次调用，都会返回同一个 logger "
"对象的引用。不仅在同一个模块内如此，只要是在同一个 Python "
"解释器进程中，跨模块调用也是一样。同样是引用同一个对象，应用程序也可以在一个模块中定义和配置一个父 "
"logger，而在另一个单独的模块中创建（但不配置）子 logger，对于子 logger 的所有调用都会传给父 logger。以下是主模块："

#: ../../howto/logging-cookbook.rst:26
msgid ""
"import logging\n"
"import auxiliary_module\n"
"\n"
"# create logger with 'spam_application'\n"
"logger = logging.getLogger('spam_application')\n"
"logger.setLevel(logging.DEBUG)\n"
"# create file handler which logs even debug messages\n"
"fh = logging.FileHandler('spam.log')\n"
"fh.setLevel(logging.DEBUG)\n"
"# create console handler with a higher log level\n"
"ch = logging.StreamHandler()\n"
"ch.setLevel(logging.ERROR)\n"
"# create formatter and add it to the handlers\n"
"formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n"
"fh.setFormatter(formatter)\n"
"ch.setFormatter(formatter)\n"
"# add the handlers to the logger\n"
"logger.addHandler(fh)\n"
"logger.addHandler(ch)\n"
"\n"
"logger.info('creating an instance of auxiliary_module.Auxiliary')\n"
"a = auxiliary_module.Auxiliary()\n"
"logger.info('created an instance of auxiliary_module.Auxiliary')\n"
"logger.info('calling auxiliary_module.Auxiliary.do_something')\n"
"a.do_something()\n"
"logger.info('finished auxiliary_module.Auxiliary.do_something')\n"
"logger.info('calling auxiliary_module.some_function()')\n"
"auxiliary_module.some_function()\n"
"logger.info('done with auxiliary_module.some_function()')"
msgstr ""

#: ../../howto/logging-cookbook.rst:56
msgid "Here is the auxiliary module::"
msgstr "以下是辅助模块："

#: ../../howto/logging-cookbook.rst:58
msgid ""
"import logging\n"
"\n"
"# create logger\n"
"module_logger = logging.getLogger('spam_application.auxiliary')\n"
"\n"
"class Auxiliary:\n"
"    def __init__(self):\n"
"        self.logger = logging.getLogger('spam_application.auxiliary.Auxiliary')\n"
"        self.logger.info('creating an instance of Auxiliary')\n"
"\n"
"    def do_something(self):\n"
"        self.logger.info('doing something')\n"
"        a = 1 + 1\n"
"        self.logger.info('done doing something')\n"
"\n"
"def some_function():\n"
"    module_logger.info('received a call to \"some_function\"')"
msgstr ""
"import logging\n"
"\n"
"# 创建日志记录器\n"
"module_logger = logging.getLogger('spam_application.auxiliary')\n"
"\n"
"class Auxiliary:\n"
"    def __init__(self):\n"
"        self.logger = logging.getLogger('spam_application.auxiliary.Auxiliary')\n"
"        self.logger.info('creating an instance of Auxiliary')\n"
"\n"
"    def do_something(self):\n"
"        self.logger.info('doing something')\n"
"        a = 1 + 1\n"
"        self.logger.info('done doing something')\n"
"\n"
"def some_function():\n"
"    module_logger.info('received a call to \"some_function\"')"

#: ../../howto/logging-cookbook.rst:76
msgid "The output looks like this:"
msgstr "输出结果会像这样:"

#: ../../howto/logging-cookbook.rst:78
msgid ""
"2005-03-23 23:47:11,663 - spam_application - INFO -\n"
"   creating an instance of auxiliary_module.Auxiliary\n"
"2005-03-23 23:47:11,665 - spam_application.auxiliary.Auxiliary - INFO -\n"
"   creating an instance of Auxiliary\n"
"2005-03-23 23:47:11,665 - spam_application - INFO -\n"
"   created an instance of auxiliary_module.Auxiliary\n"
"2005-03-23 23:47:11,668 - spam_application - INFO -\n"
"   calling auxiliary_module.Auxiliary.do_something\n"
"2005-03-23 23:47:11,668 - spam_application.auxiliary.Auxiliary - INFO -\n"
"   doing something\n"
"2005-03-23 23:47:11,669 - spam_application.auxiliary.Auxiliary - INFO -\n"
"   done doing something\n"
"2005-03-23 23:47:11,670 - spam_application - INFO -\n"
"   finished auxiliary_module.Auxiliary.do_something\n"
"2005-03-23 23:47:11,671 - spam_application - INFO -\n"
"   calling auxiliary_module.some_function()\n"
"2005-03-23 23:47:11,672 - spam_application.auxiliary - INFO -\n"
"   received a call to 'some_function'\n"
"2005-03-23 23:47:11,673 - spam_application - INFO -\n"
"   done with auxiliary_module.some_function()"
msgstr ""
"2005-03-23 23:47:11,663 - spam_application - INFO -\n"
"   creating an instance of auxiliary_module.Auxiliary\n"
"2005-03-23 23:47:11,665 - spam_application.auxiliary.Auxiliary - INFO -\n"
"   creating an instance of Auxiliary\n"
"2005-03-23 23:47:11,665 - spam_application - INFO -\n"
"   created an instance of auxiliary_module.Auxiliary\n"
"2005-03-23 23:47:11,668 - spam_application - INFO -\n"
"   calling auxiliary_module.Auxiliary.do_something\n"
"2005-03-23 23:47:11,668 - spam_application.auxiliary.Auxiliary - INFO -\n"
"   doing something\n"
"2005-03-23 23:47:11,669 - spam_application.auxiliary.Auxiliary - INFO -\n"
"   done doing something\n"
"2005-03-23 23:47:11,670 - spam_application - INFO -\n"
"   finished auxiliary_module.Auxiliary.do_something\n"
"2005-03-23 23:47:11,671 - spam_application - INFO -\n"
"   calling auxiliary_module.some_function()\n"
"2005-03-23 23:47:11,672 - spam_application.auxiliary - INFO -\n"
"   received a call to 'some_function'\n"
"2005-03-23 23:47:11,673 - spam_application - INFO -\n"
"   done with auxiliary_module.some_function()"

#: ../../howto/logging-cookbook.rst:102
msgid "Logging from multiple threads"
msgstr "在多个线程中记录日志"

#: ../../howto/logging-cookbook.rst:104
msgid ""
"Logging from multiple threads requires no special effort. The following "
"example shows logging from the main (initial) thread and another thread::"
msgstr "多线程记录日志并不需要特殊处理，以下示例演示了在主线程（起始线程）和其他线程中记录日志的过程："

#: ../../howto/logging-cookbook.rst:107
msgid ""
"import logging\n"
"import threading\n"
"import time\n"
"\n"
"def worker(arg):\n"
"    while not arg['stop']:\n"
"        logging.debug('Hi from myfunc')\n"
"        time.sleep(0.5)\n"
"\n"
"def main():\n"
"    logging.basicConfig(level=logging.DEBUG, format='%(relativeCreated)6d %(threadName)s %(message)s')\n"
"    info = {'stop': False}\n"
"    thread = threading.Thread(target=worker, args=(info,))\n"
"    thread.start()\n"
"    while True:\n"
"        try:\n"
"            logging.debug('Hello from main')\n"
"            time.sleep(0.75)\n"
"        except KeyboardInterrupt:\n"
"            info['stop'] = True\n"
"            break\n"
"    thread.join()\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""
"import logging\n"
"import threading\n"
"import time\n"
"\n"
"def worker(arg):\n"
"    while not arg['stop']:\n"
"        logging.debug('Hi from myfunc')\n"
"        time.sleep(0.5)\n"
"\n"
"def main():\n"
"    logging.basicConfig(level=logging.DEBUG, format='%(relativeCreated)6d %(threadName)s %(message)s')\n"
"    info = {'stop': False}\n"
"    thread = threading.Thread(target=worker, args=(info,))\n"
"    thread.start()\n"
"    while True:\n"
"        try:\n"
"            logging.debug('Hello from main')\n"
"            time.sleep(0.75)\n"
"        except KeyboardInterrupt:\n"
"            info['stop'] = True\n"
"            break\n"
"    thread.join()\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"

#: ../../howto/logging-cookbook.rst:133
msgid "When run, the script should print something like the following:"
msgstr "脚本会运行输出类似下面的内容:"

#: ../../howto/logging-cookbook.rst:135
msgid ""
"   0 Thread-1 Hi from myfunc\n"
"   3 MainThread Hello from main\n"
" 505 Thread-1 Hi from myfunc\n"
" 755 MainThread Hello from main\n"
"1007 Thread-1 Hi from myfunc\n"
"1507 MainThread Hello from main\n"
"1508 Thread-1 Hi from myfunc\n"
"2010 Thread-1 Hi from myfunc\n"
"2258 MainThread Hello from main\n"
"2512 Thread-1 Hi from myfunc\n"
"3009 MainThread Hello from main\n"
"3013 Thread-1 Hi from myfunc\n"
"3515 Thread-1 Hi from myfunc\n"
"3761 MainThread Hello from main\n"
"4017 Thread-1 Hi from myfunc\n"
"4513 MainThread Hello from main\n"
"4518 Thread-1 Hi from myfunc"
msgstr ""
"   0 Thread-1 Hi from myfunc\n"
"   3 MainThread Hello from main\n"
" 505 Thread-1 Hi from myfunc\n"
" 755 MainThread Hello from main\n"
"1007 Thread-1 Hi from myfunc\n"
"1507 MainThread Hello from main\n"
"1508 Thread-1 Hi from myfunc\n"
"2010 Thread-1 Hi from myfunc\n"
"2258 MainThread Hello from main\n"
"2512 Thread-1 Hi from myfunc\n"
"3009 MainThread Hello from main\n"
"3013 Thread-1 Hi from myfunc\n"
"3515 Thread-1 Hi from myfunc\n"
"3761 MainThread Hello from main\n"
"4017 Thread-1 Hi from myfunc\n"
"4513 MainThread Hello from main\n"
"4518 Thread-1 Hi from myfunc"

#: ../../howto/logging-cookbook.rst:155
msgid ""
"This shows the logging output interspersed as one might expect. This "
"approach works for more threads than shown here, of course."
msgstr "以上如期显示了不同线程的日志是交替输出的。当然更多的线程也会如此。"

#: ../../howto/logging-cookbook.rst:159
msgid "Multiple handlers and formatters"
msgstr "多个 handler 和多种 formatter"

#: ../../howto/logging-cookbook.rst:161
msgid ""
"Loggers are plain Python objects.  The :meth:`~Logger.addHandler` method has"
" no minimum or maximum quota for the number of handlers you may add.  "
"Sometimes it will be beneficial for an application to log all messages of "
"all severities to a text file while simultaneously logging errors or above "
"to the console.  To set this up, simply configure the appropriate handlers."
"  The logging calls in the application code will remain unchanged.  Here is "
"a slight modification to the previous simple module-based configuration "
"example::"
msgstr ""
"日志是个普通的 Python 对象。 :meth:`~Logger.addHandler` 方法可加入不限数量的日志 "
"handler。有时候，应用程序需把严重错误信息记入文本文件，而将一般错误或其他级别的信息输出到控制台。若要进行这样的设定，只需多配置几个日志 "
"handler 即可，应用程序的日志调用代码可以保持不变。下面对之前的分模块日志示例略做修改："

#: ../../howto/logging-cookbook.rst:169
msgid ""
"import logging\n"
"\n"
"logger = logging.getLogger('simple_example')\n"
"logger.setLevel(logging.DEBUG)\n"
"# create file handler which logs even debug messages\n"
"fh = logging.FileHandler('spam.log')\n"
"fh.setLevel(logging.DEBUG)\n"
"# create console handler with a higher log level\n"
"ch = logging.StreamHandler()\n"
"ch.setLevel(logging.ERROR)\n"
"# create formatter and add it to the handlers\n"
"formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n"
"ch.setFormatter(formatter)\n"
"fh.setFormatter(formatter)\n"
"# add the handlers to logger\n"
"logger.addHandler(ch)\n"
"logger.addHandler(fh)\n"
"\n"
"# 'application' code\n"
"logger.debug('debug message')\n"
"logger.info('info message')\n"
"logger.warning('warn message')\n"
"logger.error('error message')\n"
"logger.critical('critical message')"
msgstr ""

#: ../../howto/logging-cookbook.rst:194
msgid ""
"Notice that the 'application' code does not care about multiple handlers.  "
"All that changed was the addition and configuration of a new handler named "
"*fh*."
msgstr ""
"需要注意的是，“应用程序”内的代码并不关心是否存在多个日志 handler。示例中所做的改变，只是新加入并配置了一个名为 *fh* 的 handler。"

#: ../../howto/logging-cookbook.rst:197
msgid ""
"The ability to create new handlers with higher- or lower-severity filters "
"can be very helpful when writing and testing an application.  Instead of "
"using many ``print`` statements for debugging, use ``logger.debug``: Unlike "
"the print statements, which you will have to delete or comment out later, "
"the logger.debug statements can remain intact in the source code and remain "
"dormant until you need them again.  At that time, the only change that needs"
" to happen is to modify the severity level of the logger and/or handler to "
"debug."
msgstr ""
"在编写和测试应用程序时，若能创建日志 handler 对不同严重级别的日志信息进行过滤，这将十分有用。调试时无需用多条 ``print`` "
"语句，而是采用 ``logger.debug`` ：print 语句以后还得注释或删掉，而 logger.debug  "
"语句可以原样留在源码中保持静默。当需要再次调试时，只要改变日志对象或  handler 的严重级别即可。"

#: ../../howto/logging-cookbook.rst:208
msgid "Logging to multiple destinations"
msgstr "在多个地方记录日志"

#: ../../howto/logging-cookbook.rst:210
msgid ""
"Let's say you want to log to console and file with different message formats"
" and in differing circumstances. Say you want to log messages with levels of"
" DEBUG and higher to file, and those messages at level INFO and higher to "
"the console. Let's also assume that the file should contain timestamps, but "
"the console messages should not. Here's how you can achieve this::"
msgstr ""
"假定要根据不同的情况将日志以不同的格式写入控制台和文件。比如把 DEBUG 以上级别的日志信息写于文件，并且把 INFO "
"以上的日志信息输出到控制台。再假设日志文件需要包含时间戳，控制台信息则不需要。以下演示了做法："

#: ../../howto/logging-cookbook.rst:216
msgid ""
"import logging\n"
"\n"
"# set up logging to file - see previous section for more details\n"
"logging.basicConfig(level=logging.DEBUG,\n"
"                    format='%(asctime)s %(name)-12s %(levelname)-8s %(message)s',\n"
"                    datefmt='%m-%d %H:%M',\n"
"                    filename='/tmp/myapp.log',\n"
"                    filemode='w')\n"
"# define a Handler which writes INFO messages or higher to the sys.stderr\n"
"console = logging.StreamHandler()\n"
"console.setLevel(logging.INFO)\n"
"# set a format which is simpler for console use\n"
"formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')\n"
"# tell the handler to use this format\n"
"console.setFormatter(formatter)\n"
"# add the handler to the root logger\n"
"logging.getLogger('').addHandler(console)\n"
"\n"
"# Now, we can log to the root logger, or any other logger. First the root...\n"
"logging.info('Jackdaws love my big sphinx of quartz.')\n"
"\n"
"# Now, define a couple of other loggers which might represent areas in your\n"
"# application:\n"
"\n"
"logger1 = logging.getLogger('myapp.area1')\n"
"logger2 = logging.getLogger('myapp.area2')\n"
"\n"
"logger1.debug('Quick zephyrs blow, vexing daft Jim.')\n"
"logger1.info('How quickly daft jumping zebras vex.')\n"
"logger2.warning('Jail zesty vixen who grabbed pay from quack.')\n"
"logger2.error('The five boxing wizards jump quickly.')"
msgstr ""

#: ../../howto/logging-cookbook.rst:248
msgid "When you run this, on the console you will see"
msgstr "当运行后，你会看到控制台如下所示"

#: ../../howto/logging-cookbook.rst:250
msgid ""
"root        : INFO     Jackdaws love my big sphinx of quartz.\n"
"myapp.area1 : INFO     How quickly daft jumping zebras vex.\n"
"myapp.area2 : WARNING  Jail zesty vixen who grabbed pay from quack.\n"
"myapp.area2 : ERROR    The five boxing wizards jump quickly."
msgstr ""
"root        : INFO     Jackdaws love my big sphinx of quartz.\n"
"myapp.area1 : INFO     How quickly daft jumping zebras vex.\n"
"myapp.area2 : WARNING  Jail zesty vixen who grabbed pay from quack.\n"
"myapp.area2 : ERROR    The five boxing wizards jump quickly."

#: ../../howto/logging-cookbook.rst:257
msgid "and in the file you will see something like"
msgstr "而日志文件将如下所示："

#: ../../howto/logging-cookbook.rst:259
msgid ""
"10-22 22:19 root         INFO     Jackdaws love my big sphinx of quartz.\n"
"10-22 22:19 myapp.area1  DEBUG    Quick zephyrs blow, vexing daft Jim.\n"
"10-22 22:19 myapp.area1  INFO     How quickly daft jumping zebras vex.\n"
"10-22 22:19 myapp.area2  WARNING  Jail zesty vixen who grabbed pay from quack.\n"
"10-22 22:19 myapp.area2  ERROR    The five boxing wizards jump quickly."
msgstr ""
"10-22 22:19 root         INFO     Jackdaws love my big sphinx of quartz.\n"
"10-22 22:19 myapp.area1  DEBUG    Quick zephyrs blow, vexing daft Jim.\n"
"10-22 22:19 myapp.area1  INFO     How quickly daft jumping zebras vex.\n"
"10-22 22:19 myapp.area2  WARNING  Jail zesty vixen who grabbed pay from quack.\n"
"10-22 22:19 myapp.area2  ERROR    The five boxing wizards jump quickly."

#: ../../howto/logging-cookbook.rst:267
msgid ""
"As you can see, the DEBUG message only shows up in the file. The other "
"messages are sent to both destinations."
msgstr "如您所见，DEBUG 级别的日志信息只出现在了文件中，而其他信息则两个地方都会输出。"

#: ../../howto/logging-cookbook.rst:270
msgid ""
"This example uses console and file handlers, but you can use any number and "
"combination of handlers you choose."
msgstr "上述示例只用到了控制台和文件 handler，当然还可以自由组合任意数量的日志 handler。"

#: ../../howto/logging-cookbook.rst:273
msgid ""
"Note that the above choice of log filename ``/tmp/myapp.log`` implies use of"
" a standard location for temporary files on POSIX systems. On Windows, you "
"may need to choose a different directory name for the log - just ensure that"
" the directory exists and that you have the permissions to create and update"
" files in it."
msgstr ""
"请注意上面选择的日志文件名 ``/tmp/myapp.log`` 表示在 POSIX 系统上使用临时文件的标准位置。 在 Windows "
"上，你可能需要为日志选择不同的目录名称 —— 只要确保该目录存在并且你有在其中创建和更新文件的权限。"

#: ../../howto/logging-cookbook.rst:282
msgid "Custom handling of levels"
msgstr "自定义处理级别"

#: ../../howto/logging-cookbook.rst:284
msgid ""
"Sometimes, you might want to do something slightly different from the "
"standard handling of levels in handlers, where all levels above a threshold "
"get processed by a handler. To do this, you need to use filters. Let's look "
"at a scenario where you want to arrange things as follows:"
msgstr ""
"有时，你想要做的可能略微不同于处理器中标准的级别处理方式，即某个界限以上的所有级别都会被处理器所处理。 要做到这一点，你需要使用过滤器。 "
"让我们来看一个假设你想要执行如下安排的场景:"

#: ../../howto/logging-cookbook.rst:289
msgid "Send messages of severity ``INFO`` and ``WARNING`` to ``sys.stdout``"
msgstr "将严重级别为 ``INFO`` 和 ``WARNING`` 的消息发送到 ``sys.stdout``"

#: ../../howto/logging-cookbook.rst:290
msgid "Send messages of severity ``ERROR`` and above to ``sys.stderr``"
msgstr "将严重级别为 ``ERROR`` 及以上的消息发送到 ``sys.stderr``"

#: ../../howto/logging-cookbook.rst:291
msgid "Send messages of severity ``DEBUG`` and above to file ``app.log``"
msgstr "将严重级别为 ``DEBUG`` 及以上的消息发送到文件 ``app.log``"

#: ../../howto/logging-cookbook.rst:293
msgid "Suppose you configure logging with the following JSON:"
msgstr "假定你使用以下 JSON 来配置日志记录:"

#: ../../howto/logging-cookbook.rst:295
msgid ""
"{\n"
"    \"version\": 1,\n"
"    \"disable_existing_loggers\": false,\n"
"    \"formatters\": {\n"
"        \"simple\": {\n"
"            \"format\": \"%(levelname)-8s - %(message)s\"\n"
"        }\n"
"    },\n"
"    \"handlers\": {\n"
"        \"stdout\": {\n"
"            \"class\": \"logging.StreamHandler\",\n"
"            \"level\": \"INFO\",\n"
"            \"formatter\": \"simple\",\n"
"            \"stream\": \"ext://sys.stdout\"\n"
"        },\n"
"        \"stderr\": {\n"
"            \"class\": \"logging.StreamHandler\",\n"
"            \"level\": \"ERROR\",\n"
"            \"formatter\": \"simple\",\n"
"            \"stream\": \"ext://sys.stderr\"\n"
"        },\n"
"        \"file\": {\n"
"            \"class\": \"logging.FileHandler\",\n"
"            \"formatter\": \"simple\",\n"
"            \"filename\": \"app.log\",\n"
"            \"mode\": \"w\"\n"
"        }\n"
"    },\n"
"    \"root\": {\n"
"        \"level\": \"DEBUG\",\n"
"        \"handlers\": [\n"
"            \"stderr\",\n"
"            \"stdout\",\n"
"            \"file\"\n"
"        ]\n"
"    }\n"
"}"
msgstr ""
"{\n"
"    \"version\": 1,\n"
"    \"disable_existing_loggers\": false,\n"
"    \"formatters\": {\n"
"        \"simple\": {\n"
"            \"format\": \"%(levelname)-8s - %(message)s\"\n"
"        }\n"
"    },\n"
"    \"handlers\": {\n"
"        \"stdout\": {\n"
"            \"class\": \"logging.StreamHandler\",\n"
"            \"level\": \"INFO\",\n"
"            \"formatter\": \"simple\",\n"
"            \"stream\": \"ext://sys.stdout\"\n"
"        },\n"
"        \"stderr\": {\n"
"            \"class\": \"logging.StreamHandler\",\n"
"            \"level\": \"ERROR\",\n"
"            \"formatter\": \"simple\",\n"
"            \"stream\": \"ext://sys.stderr\"\n"
"        },\n"
"        \"file\": {\n"
"            \"class\": \"logging.FileHandler\",\n"
"            \"formatter\": \"simple\",\n"
"            \"filename\": \"app.log\",\n"
"            \"mode\": \"w\"\n"
"        }\n"
"    },\n"
"    \"root\": {\n"
"        \"level\": \"DEBUG\",\n"
"        \"handlers\": [\n"
"            \"stderr\",\n"
"            \"stdout\",\n"
"            \"file\"\n"
"        ]\n"
"    }\n"
"}"

#: ../../howto/logging-cookbook.rst:335
msgid ""
"This configuration does *almost* what we want, except that ``sys.stdout`` "
"would show messages of severity ``ERROR`` and only events of this severity "
"and higher will be tracked as well as ``INFO`` and ``WARNING`` messages. To "
"prevent this, we can set up a filter which excludes those messages and add "
"it to the relevant handler. This can be configured by adding a ``filters`` "
"section parallel to ``formatters`` and ``handlers``:"
msgstr ""
"这个配置 *几乎* 能做到我们想要的，但是除了 ``sys.stdout`` 在 ``INFO`` 和 ``WARNING`` 消息之外会只显示严重程度"
" ``ERROR`` 及以上的消息。 为了防止这种情况，我们可以设置一个排除掉这些消息的过滤器并将其添加到相应的处理器中。 这可以通过添加一个平行于 "
"``formatters`` 和 ``handlers`` 的 ``filters`` 节来配置："

#: ../../howto/logging-cookbook.rst:341
msgid ""
"{\n"
"    \"filters\": {\n"
"        \"warnings_and_below\": {\n"
"            \"()\" : \"__main__.filter_maker\",\n"
"            \"level\": \"WARNING\"\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"{\n"
"    \"filters\": {\n"
"        \"warnings_and_below\": {\n"
"            \"()\" : \"__main__.filter_maker\",\n"
"            \"level\": \"WARNING\"\n"
"        }\n"
"    }\n"
"}"

#: ../../howto/logging-cookbook.rst:352
msgid "and changing the section on the ``stdout`` handler to add it:"
msgstr "并修改 ``stdout`` 处理器上的节来添加它:"

#: ../../howto/logging-cookbook.rst:354
msgid ""
"{\n"
"    \"stdout\": {\n"
"        \"class\": \"logging.StreamHandler\",\n"
"        \"level\": \"INFO\",\n"
"        \"formatter\": \"simple\",\n"
"        \"stream\": \"ext://sys.stdout\",\n"
"        \"filters\": [\"warnings_and_below\"]\n"
"    }\n"
"}"
msgstr ""
"{\n"
"    \"stdout\": {\n"
"        \"class\": \"logging.StreamHandler\",\n"
"        \"level\": \"INFO\",\n"
"        \"formatter\": \"simple\",\n"
"        \"stream\": \"ext://sys.stdout\",\n"
"        \"filters\": [\"warnings_and_below\"]\n"
"    }\n"
"}"

#: ../../howto/logging-cookbook.rst:366
msgid ""
"A filter is just a function, so we can define the ``filter_maker`` (a "
"factory function) as follows:"
msgstr "过滤器就是一个函数，因此我们可以定义 ``filter_maker`` (工厂函数) 如下:"

#: ../../howto/logging-cookbook.rst:369
msgid ""
"def filter_maker(level):\n"
"    level = getattr(logging, level)\n"
"\n"
"    def filter(record):\n"
"        return record.levelno <= level\n"
"\n"
"    return filter"
msgstr ""
"def filter_maker(level):\n"
"    level = getattr(logging, level)\n"
"\n"
"    def filter(record):\n"
"        return record.levelno <= level\n"
"\n"
"    return filter"

#: ../../howto/logging-cookbook.rst:379
msgid ""
"This converts the string argument passed in to a numeric level, and returns "
"a function which only returns ``True`` if the level of the passed in record "
"is at or below the specified level. Note that in this example I have defined"
" the ``filter_maker`` in a test script ``main.py`` that I run from the "
"command line, so its module will be ``__main__`` - hence the "
"``__main__.filter_maker`` in the filter configuration. You will need to "
"change that if you define it in a different module."
msgstr ""
"此函数将传入的字符串参数转换为数字级别，并返回一个仅在传入等于或低于指定数字级别的级别时返回 ``True`` 的函数。 请注意在这个示例中我是将 "
"``filter_maker`` 定义在一个从命令行运行的测试脚本 ``main.py`` 中，因此其所属模块将为 ``__main__`` —— "
"即在过滤器配置中写作 ``__main__.filter_maker``。 如果你在不同的模块中定义它则需要加以修改。"

#: ../../howto/logging-cookbook.rst:387
msgid "With the filter added, we can run ``main.py``, which in full is:"
msgstr "在添加该过滤器后，我们就可以运行 ``main.py``，完整代码如下:"

#: ../../howto/logging-cookbook.rst:389
msgid ""
"import json\n"
"import logging\n"
"import logging.config\n"
"\n"
"CONFIG = '''\n"
"{\n"
"    \"version\": 1,\n"
"    \"disable_existing_loggers\": false,\n"
"    \"formatters\": {\n"
"        \"simple\": {\n"
"            \"format\": \"%(levelname)-8s - %(message)s\"\n"
"        }\n"
"    },\n"
"    \"filters\": {\n"
"        \"warnings_and_below\": {\n"
"            \"()\" : \"__main__.filter_maker\",\n"
"            \"level\": \"WARNING\"\n"
"        }\n"
"    },\n"
"    \"handlers\": {\n"
"        \"stdout\": {\n"
"            \"class\": \"logging.StreamHandler\",\n"
"            \"level\": \"INFO\",\n"
"            \"formatter\": \"simple\",\n"
"            \"stream\": \"ext://sys.stdout\",\n"
"            \"filters\": [\"warnings_and_below\"]\n"
"        },\n"
"        \"stderr\": {\n"
"            \"class\": \"logging.StreamHandler\",\n"
"            \"level\": \"ERROR\",\n"
"            \"formatter\": \"simple\",\n"
"            \"stream\": \"ext://sys.stderr\"\n"
"        },\n"
"        \"file\": {\n"
"            \"class\": \"logging.FileHandler\",\n"
"            \"formatter\": \"simple\",\n"
"            \"filename\": \"app.log\",\n"
"            \"mode\": \"w\"\n"
"        }\n"
"    },\n"
"    \"root\": {\n"
"        \"level\": \"DEBUG\",\n"
"        \"handlers\": [\n"
"            \"stderr\",\n"
"            \"stdout\",\n"
"            \"file\"\n"
"        ]\n"
"    }\n"
"}\n"
"'''\n"
"\n"
"def filter_maker(level):\n"
"    level = getattr(logging, level)\n"
"\n"
"    def filter(record):\n"
"        return record.levelno <= level\n"
"\n"
"    return filter\n"
"\n"
"logging.config.dictConfig(json.loads(CONFIG))\n"
"logging.debug('A DEBUG message')\n"
"logging.info('An INFO message')\n"
"logging.warning('A WARNING message')\n"
"logging.error('An ERROR message')\n"
"logging.critical('A CRITICAL message')"
msgstr ""
"import json\n"
"import logging\n"
"import logging.config\n"
"\n"
"CONFIG = '''\n"
"{\n"
"    \"version\": 1,\n"
"    \"disable_existing_loggers\": false,\n"
"    \"formatters\": {\n"
"        \"simple\": {\n"
"            \"format\": \"%(levelname)-8s - %(message)s\"\n"
"        }\n"
"    },\n"
"    \"filters\": {\n"
"        \"warnings_and_below\": {\n"
"            \"()\" : \"__main__.filter_maker\",\n"
"            \"level\": \"WARNING\"\n"
"        }\n"
"    },\n"
"    \"handlers\": {\n"
"        \"stdout\": {\n"
"            \"class\": \"logging.StreamHandler\",\n"
"            \"level\": \"INFO\",\n"
"            \"formatter\": \"simple\",\n"
"            \"stream\": \"ext://sys.stdout\",\n"
"            \"filters\": [\"warnings_and_below\"]\n"
"        },\n"
"        \"stderr\": {\n"
"            \"class\": \"logging.StreamHandler\",\n"
"            \"level\": \"ERROR\",\n"
"            \"formatter\": \"simple\",\n"
"            \"stream\": \"ext://sys.stderr\"\n"
"        },\n"
"        \"file\": {\n"
"            \"class\": \"logging.FileHandler\",\n"
"            \"formatter\": \"simple\",\n"
"            \"filename\": \"app.log\",\n"
"            \"mode\": \"w\"\n"
"        }\n"
"    },\n"
"    \"root\": {\n"
"        \"level\": \"DEBUG\",\n"
"        \"handlers\": [\n"
"            \"stderr\",\n"
"            \"stdout\",\n"
"            \"file\"\n"
"        ]\n"
"    }\n"
"}\n"
"'''\n"
"\n"
"def filter_maker(level):\n"
"    level = getattr(logging, level)\n"
"\n"
"    def filter(record):\n"
"        return record.levelno <= level\n"
"\n"
"    return filter\n"
"\n"
"logging.config.dictConfig(json.loads(CONFIG))\n"
"logging.debug('A DEBUG message')\n"
"logging.info('An INFO message')\n"
"logging.warning('A WARNING message')\n"
"logging.error('An ERROR message')\n"
"logging.critical('A CRITICAL message')"

#: ../../howto/logging-cookbook.rst:457
msgid "And after running it like this:"
msgstr "使用这样的命令运行它之后:"

#: ../../howto/logging-cookbook.rst:459
msgid "python main.py 2>stderr.log >stdout.log"
msgstr "python main.py 2>stderr.log >stdout.log"

#: ../../howto/logging-cookbook.rst:463
msgid "We can see the results are as expected:"
msgstr "我们可以看到结果是符合预期的:"

#: ../../howto/logging-cookbook.rst:465
msgid ""
"$ more *.log\n"
"::::::::::::::\n"
"app.log\n"
"::::::::::::::\n"
"DEBUG    - A DEBUG message\n"
"INFO     - An INFO message\n"
"WARNING  - A WARNING message\n"
"ERROR    - An ERROR message\n"
"CRITICAL - A CRITICAL message\n"
"::::::::::::::\n"
"stderr.log\n"
"::::::::::::::\n"
"ERROR    - An ERROR message\n"
"CRITICAL - A CRITICAL message\n"
"::::::::::::::\n"
"stdout.log\n"
"::::::::::::::\n"
"INFO     - An INFO message\n"
"WARNING  - A WARNING message"
msgstr ""
"$ more *.log\n"
"::::::::::::::\n"
"app.log\n"
"::::::::::::::\n"
"DEBUG    - A DEBUG message\n"
"INFO     - An INFO message\n"
"WARNING  - A WARNING message\n"
"ERROR    - An ERROR message\n"
"CRITICAL - A CRITICAL message\n"
"::::::::::::::\n"
"stderr.log\n"
"::::::::::::::\n"
"ERROR    - An ERROR message\n"
"CRITICAL - A CRITICAL message\n"
"::::::::::::::\n"
"stdout.log\n"
"::::::::::::::\n"
"INFO     - An INFO message\n"
"WARNING  - A WARNING message"

#: ../../howto/logging-cookbook.rst:489
msgid "Configuration server example"
msgstr "日志配置服务器示例"

#: ../../howto/logging-cookbook.rst:491
msgid ""
"Here is an example of a module using the logging configuration server::"
msgstr "以下是一个用到了日志配置服务器的模块示例："

#: ../../howto/logging-cookbook.rst:493
msgid ""
"import logging\n"
"import logging.config\n"
"import time\n"
"import os\n"
"\n"
"# read initial config file\n"
"logging.config.fileConfig('logging.conf')\n"
"\n"
"# create and start listener on port 9999\n"
"t = logging.config.listen(9999)\n"
"t.start()\n"
"\n"
"logger = logging.getLogger('simpleExample')\n"
"\n"
"try:\n"
"    # loop through logging calls to see the difference\n"
"    # new configurations make, until Ctrl+C is pressed\n"
"    while True:\n"
"        logger.debug('debug message')\n"
"        logger.info('info message')\n"
"        logger.warning('warn message')\n"
"        logger.error('error message')\n"
"        logger.critical('critical message')\n"
"        time.sleep(5)\n"
"except KeyboardInterrupt:\n"
"    # cleanup\n"
"    logging.config.stopListening()\n"
"    t.join()"
msgstr ""

#: ../../howto/logging-cookbook.rst:522
msgid ""
"And here is a script that takes a filename and sends that file to the "
"server, properly preceded with the binary-encoded length, as the new logging"
" configuration::"
msgstr "以下脚本将接受文件名作为参数，然后将此文件发送到服务器，前面加上文件的二进制编码长度，做为新的日志配置："

#: ../../howto/logging-cookbook.rst:526
msgid ""
"#!/usr/bin/env python\n"
"import socket, sys, struct\n"
"\n"
"with open(sys.argv[1], 'rb') as f:\n"
"    data_to_send = f.read()\n"
"\n"
"HOST = 'localhost'\n"
"PORT = 9999\n"
"s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"print('connecting...')\n"
"s.connect((HOST, PORT))\n"
"print('sending config...')\n"
"s.send(struct.pack('>L', len(data_to_send)))\n"
"s.send(data_to_send)\n"
"s.close()\n"
"print('complete')"
msgstr ""
"#!/usr/bin/env python\n"
"import socket, sys, struct\n"
"\n"
"with open(sys.argv[1], 'rb') as f:\n"
"    data_to_send = f.read()\n"
"\n"
"HOST = 'localhost'\n"
"PORT = 9999\n"
"s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"print('connecting...')\n"
"s.connect((HOST, PORT))\n"
"print('sending config...')\n"
"s.send(struct.pack('>L', len(data_to_send)))\n"
"s.send(data_to_send)\n"
"s.close()\n"
"print('complete')"

#: ../../howto/logging-cookbook.rst:547
msgid "Dealing with handlers that block"
msgstr "处理日志 handler 的阻塞"

#: ../../howto/logging-cookbook.rst:551
msgid ""
"Sometimes you have to get your logging handlers to do their work without "
"blocking the thread you're logging from. This is common in web applications,"
" though of course it also occurs in other scenarios."
msgstr "有时你必须让日志记录处理程序的运行不会阻塞你要记录日志的线程。 这在 Web 应用程序中是很常见，当然在其他场景中也可能发生。"

#: ../../howto/logging-cookbook.rst:555
msgid ""
"A common culprit which demonstrates sluggish behaviour is the "
":class:`SMTPHandler`: sending emails can take a long time, for a number of "
"reasons outside the developer's control (for example, a poorly performing "
"mail or network infrastructure). But almost any network-based handler can "
"block: Even a :class:`SocketHandler` operation may do a DNS query under the "
"hood which is too slow (and this query can be deep in the socket library "
"code, below the Python layer, and outside your control)."
msgstr ""
"有一种原因往往会让程序表现迟钝，这就是 "
":class:`SMTPHandler`：由于很多因素是开发人员无法控制的（例如邮件或网络基础设施的性能不佳），发送电子邮件可能需要很长时间。不过几乎所有网络"
"  handler 都可能会发生阻塞：即使是 :class:`SocketHandler` 操作也可能在后台执行 DNS "
"查询，而这种查询实在太慢了（并且 DNS 查询还可能在很底层的套接字库代码中，位于 Python 层之下，超出了可控范围）。"

#: ../../howto/logging-cookbook.rst:563
msgid ""
"One solution is to use a two-part approach. For the first part, attach only "
"a :class:`QueueHandler` to those loggers which are accessed from "
"performance-critical threads. They simply write to their queue, which can be"
" sized to a large enough capacity or initialized with no upper bound to "
"their size. The write to the queue will typically be accepted quickly, "
"though you will probably need to catch the :exc:`queue.Full` exception as a "
"precaution in your code. If you are a library developer who has performance-"
"critical threads in their code, be sure to document this (together with a "
"suggestion to attach only ``QueueHandlers`` to your loggers) for the benefit"
" of other developers who will use your code."
msgstr ""
"有一种解决方案是分成两部分实现。第一部分，针对那些对性能有要求的关键线程，只为日志对象连接一个 "
":class:`QueueHandler`。日志对象只需简单地写入队列即可，可为队列设置足够大的容量，或者可以在初始化时不设置容量上限。尽管为以防万一，可能需要在代码中捕获"
" :exc:`queue.Full` "
"异常,不过队列写入操作通常会很快得以处理。如果要开发库代码，包含性能要求较高的线程，为了让使用该库的开发人员受益，请务必在开发文档中进行标明（包括建议仅连接"
" ``QueueHandlers`` ）。"

#: ../../howto/logging-cookbook.rst:574
msgid ""
"The second part of the solution is :class:`QueueListener`, which has been "
"designed as the counterpart to :class:`QueueHandler`.  A "
":class:`QueueListener` is very simple: it's passed a queue and some "
"handlers, and it fires up an internal thread which listens to its queue for "
"LogRecords sent from ``QueueHandlers`` (or any other source of "
"``LogRecords``, for that matter). The ``LogRecords`` are removed from the "
"queue and passed to the handlers for processing."
msgstr ""
"解决方案的另一部分就是 :class:`QueueListener`，它被设计为 :class:`QueueHandler` "
"的对应部分。:class:`QueueListener` 非常简单：传入一个队列和一些 handler，并启动一个内部线程，用于侦听 "
"``QueueHandlers`` （或其他 ``LogRecords`` 源）发送的 LogRecord 队列。``LogRecords`` "
"会从队列中移除并传给 handler 处理。"

#: ../../howto/logging-cookbook.rst:582
msgid ""
"The advantage of having a separate :class:`QueueListener` class is that you "
"can use the same instance to service multiple ``QueueHandlers``. This is "
"more resource-friendly than, say, having threaded versions of the existing "
"handler classes, which would eat up one thread per handler for no particular"
" benefit."
msgstr ""
":class:`QueueListener` 作为单独的类，好处就是可以用同一个实例为多个 ``QueueHandlers`` 服务。这比把现有 "
"handler 类线程化更加资源友好，后者会每个 handler 会占用一个线程，却没有特别的好处。"

#: ../../howto/logging-cookbook.rst:587
msgid "An example of using these two classes follows (imports omitted)::"
msgstr "以下是这两个类的运用示例（省略了 import 语句）："

#: ../../howto/logging-cookbook.rst:589
msgid ""
"que = queue.Queue(-1)  # no limit on size\n"
"queue_handler = QueueHandler(que)\n"
"handler = logging.StreamHandler()\n"
"listener = QueueListener(que, handler)\n"
"root = logging.getLogger()\n"
"root.addHandler(queue_handler)\n"
"formatter = logging.Formatter('%(threadName)s: %(message)s')\n"
"handler.setFormatter(formatter)\n"
"listener.start()\n"
"# The log output will display the thread which generated\n"
"# the event (the main thread) rather than the internal\n"
"# thread which monitors the internal queue. This is what\n"
"# you want to happen.\n"
"root.warning('Look out!')\n"
"listener.stop()"
msgstr ""
"que = queue.Queue(-1)  # 对大小没有限制\n"
"queue_handler = QueueHandler(que)\n"
"handler = logging.StreamHandler()\n"
"listener = QueueListener(que, handler)\n"
"root = logging.getLogger()\n"
"root.addHandler(queue_handler)\n"
"formatter = logging.Formatter('%(threadName)s: %(message)s')\n"
"handler.setFormatter(formatter)\n"
"listener.start()\n"
"# 日志输出将显示生成事件的线程（主线程）\n"
"# 而不是监控内部队列的内部线程。这也正是\n"
"# 你所希望的。\n"
"root.warning('Look out!')\n"
"listener.stop()"

#: ../../howto/logging-cookbook.rst:605
msgid "which, when run, will produce:"
msgstr "在运行后会产生:"

#: ../../howto/logging-cookbook.rst:607
msgid "MainThread: Look out!"
msgstr "MainThread: Look out!"

#: ../../howto/logging-cookbook.rst:611
msgid ""
"Although the earlier discussion wasn't specifically talking about async "
"code, but rather about slow logging handlers, it should be noted that when "
"logging from async code, network and even file handlers could lead to "
"problems (blocking the event loop) because some logging is done from "
":mod:`asyncio` internals. It might be best, if any async code is used in an "
"application, to use the above approach for logging, so that any blocking "
"code runs only in the ``QueueListener`` thread."
msgstr ""
"虽然前面的讨论没有专门提及异步代码，但需要注意当在异步代码中记录日志时，网络甚至文件处理器都可能会导致问题（阻塞事件循环）因为某些日志记录是在 "
":mod:`asyncio` 内部完成的。 如果在应用程序中使用了任何异步代码，最好的做法是使用上面的日志记录方式，这样任何阻塞式代码都将只在 "
"``QueueListener`` 线程中运行。"

#: ../../howto/logging-cookbook.rst:619
msgid ""
"Prior to Python 3.5, the :class:`QueueListener` always passed every message "
"received from the queue to every handler it was initialized with. (This was "
"because it was assumed that level filtering was all done on the other side, "
"where the queue is filled.) From 3.5 onwards, this behaviour can be changed "
"by passing a keyword argument ``respect_handler_level=True`` to the "
"listener's constructor. When this is done, the listener compares the level "
"of each message with the handler's level, and only passes a message to a "
"handler if it's appropriate to do so."
msgstr ""
"在 Python 3.5 之前，:class:`QueueListener` "
"总会把由队列接收到的每条信息都传递给已初始化的每个处理程序。（因为这里假定级别过滤操作已在写入队列时完成了。）从 3.5 "
"版开始，可以修改这种处理方式，只要将关键字参数 ``respect_handler_level=True`` "
"传给侦听器的构造函数即可。这样侦听器将会把每条信息的级别与 handler 的级别进行比较，只在适配时才会将信息传给 handler 。"

#: ../../howto/logging-cookbook.rst:632
msgid "Sending and receiving logging events across a network"
msgstr "通过网络收发日志事件"

#: ../../howto/logging-cookbook.rst:634
msgid ""
"Let's say you want to send logging events across a network, and handle them "
"at the receiving end. A simple way of doing this is attaching a "
":class:`SocketHandler` instance to the root logger at the sending end::"
msgstr ""
"假定现在要通过网络发送日志事件，并在接收端进行处理。有一种简单的方案，就是在发送端的根日志对象连接一个 :class:`SocketHandler` "
"实例："

#: ../../howto/logging-cookbook.rst:638
msgid ""
"import logging, logging.handlers\n"
"\n"
"rootLogger = logging.getLogger('')\n"
"rootLogger.setLevel(logging.DEBUG)\n"
"socketHandler = logging.handlers.SocketHandler('localhost',\n"
"                    logging.handlers.DEFAULT_TCP_LOGGING_PORT)\n"
"# don't bother with a formatter, since a socket handler sends the event as\n"
"# an unformatted pickle\n"
"rootLogger.addHandler(socketHandler)\n"
"\n"
"# Now, we can log to the root logger, or any other logger. First the root...\n"
"logging.info('Jackdaws love my big sphinx of quartz.')\n"
"\n"
"# Now, define a couple of other loggers which might represent areas in your\n"
"# application:\n"
"\n"
"logger1 = logging.getLogger('myapp.area1')\n"
"logger2 = logging.getLogger('myapp.area2')\n"
"\n"
"logger1.debug('Quick zephyrs blow, vexing daft Jim.')\n"
"logger1.info('How quickly daft jumping zebras vex.')\n"
"logger2.warning('Jail zesty vixen who grabbed pay from quack.')\n"
"logger2.error('The five boxing wizards jump quickly.')"
msgstr ""

#: ../../howto/logging-cookbook.rst:662
msgid ""
"At the receiving end, you can set up a receiver using the "
":mod:`socketserver` module. Here is a basic working example::"
msgstr "在接收端，可以用 :mod:`socketserver` 模块设置一个接收器。简要示例如下："

#: ../../howto/logging-cookbook.rst:665
msgid ""
"import pickle\n"
"import logging\n"
"import logging.handlers\n"
"import socketserver\n"
"import struct\n"
"\n"
"\n"
"class LogRecordStreamHandler(socketserver.StreamRequestHandler):\n"
"    \"\"\"Handler for a streaming logging request.\n"
"\n"
"    This basically logs the record using whatever logging policy is\n"
"    configured locally.\n"
"    \"\"\"\n"
"\n"
"    def handle(self):\n"
"        \"\"\"\n"
"        Handle multiple requests - each expected to be a 4-byte length,\n"
"        followed by the LogRecord in pickle format. Logs the record\n"
"        according to whatever policy is configured locally.\n"
"        \"\"\"\n"
"        while True:\n"
"            chunk = self.connection.recv(4)\n"
"            if len(chunk) < 4:\n"
"                break\n"
"            slen = struct.unpack('>L', chunk)[0]\n"
"            chunk = self.connection.recv(slen)\n"
"            while len(chunk) < slen:\n"
"                chunk = chunk + self.connection.recv(slen - len(chunk))\n"
"            obj = self.unPickle(chunk)\n"
"            record = logging.makeLogRecord(obj)\n"
"            self.handleLogRecord(record)\n"
"\n"
"    def unPickle(self, data):\n"
"        return pickle.loads(data)\n"
"\n"
"    def handleLogRecord(self, record):\n"
"        # if a name is specified, we use the named logger rather than the one\n"
"        # implied by the record.\n"
"        if self.server.logname is not None:\n"
"            name = self.server.logname\n"
"        else:\n"
"            name = record.name\n"
"        logger = logging.getLogger(name)\n"
"        # N.B. EVERY record gets logged. This is because Logger.handle\n"
"        # is normally called AFTER logger-level filtering. If you want\n"
"        # to do filtering, do it at the client end to save wasting\n"
"        # cycles and network bandwidth!\n"
"        logger.handle(record)\n"
"\n"
"class LogRecordSocketReceiver(socketserver.ThreadingTCPServer):\n"
"    \"\"\"\n"
"    Simple TCP socket-based logging receiver suitable for testing.\n"
"    \"\"\"\n"
"\n"
"    allow_reuse_address = True\n"
"\n"
"    def __init__(self, host='localhost',\n"
"                 port=logging.handlers.DEFAULT_TCP_LOGGING_PORT,\n"
"                 handler=LogRecordStreamHandler):\n"
"        socketserver.ThreadingTCPServer.__init__(self, (host, port), handler)\n"
"        self.abort = 0\n"
"        self.timeout = 1\n"
"        self.logname = None\n"
"\n"
"    def serve_until_stopped(self):\n"
"        import select\n"
"        abort = 0\n"
"        while not abort:\n"
"            rd, wr, ex = select.select([self.socket.fileno()],\n"
"                                       [], [],\n"
"                                       self.timeout)\n"
"            if rd:\n"
"                self.handle_request()\n"
"            abort = self.abort\n"
"\n"
"def main():\n"
"    logging.basicConfig(\n"
"        format='%(relativeCreated)5d %(name)-15s %(levelname)-8s %(message)s')\n"
"    tcpserver = LogRecordSocketReceiver()\n"
"    print('About to start TCP server...')\n"
"    tcpserver.serve_until_stopped()\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""

#: ../../howto/logging-cookbook.rst:750
msgid ""
"First run the server, and then the client. On the client side, nothing is "
"printed on the console; on the server side, you should see something like:"
msgstr "先运行服务端，再运行客户端。客户端控制台不会显示什么信息；在服务端应该会看到如下内容："

#: ../../howto/logging-cookbook.rst:753
msgid ""
"About to start TCP server...\n"
"   59 root            INFO     Jackdaws love my big sphinx of quartz.\n"
"   59 myapp.area1     DEBUG    Quick zephyrs blow, vexing daft Jim.\n"
"   69 myapp.area1     INFO     How quickly daft jumping zebras vex.\n"
"   69 myapp.area2     WARNING  Jail zesty vixen who grabbed pay from quack.\n"
"   69 myapp.area2     ERROR    The five boxing wizards jump quickly."
msgstr ""
"About to start TCP server...\n"
"   59 root            INFO     Jackdaws love my big sphinx of quartz.\n"
"   59 myapp.area1     DEBUG    Quick zephyrs blow, vexing daft Jim.\n"
"   69 myapp.area1     INFO     How quickly daft jumping zebras vex.\n"
"   69 myapp.area2     WARNING  Jail zesty vixen who grabbed pay from quack.\n"
"   69 myapp.area2     ERROR    The five boxing wizards jump quickly."

#: ../../howto/logging-cookbook.rst:762
msgid ""
"Note that there are some security issues with pickle in some scenarios. If "
"these affect you, you can use an alternative serialization scheme by "
"overriding the :meth:`~SocketHandler.makePickle` method and implementing "
"your alternative there, as well as adapting the above script to use your "
"alternative serialization."
msgstr ""
"请注意在某些情况下 pickle 会存在一些安全问题。 如果这些问题对你有影响，你可以换用自己的替代序列化方案，只要重写 "
":meth:`~SocketHandler.makePickle` 方法并在其中实现你的替代方案，并调整上述脚本以使用这个替代方案。"

#: ../../howto/logging-cookbook.rst:770
msgid "Running a logging socket listener in production"
msgstr "在生产中运行日志套接字侦听器"

#: ../../howto/logging-cookbook.rst:774
msgid ""
"To run a logging listener in production, you may need to use a process-"
"management tool such as `Supervisor <http://supervisord.org/>`_. `Here is a "
"Gist <socket-listener-gist_>`__ which provides the bare-bones files to run "
"the above functionality using Supervisor. It consists of the following "
"files:"
msgstr ""
"要在生产环境中运行日志记录监听器，你可能需要使用一个进程管理工具如 `Supervisor <http://supervisord.org/>`_。 "
"`这个 Gist <socket-listener-gist_>`__ 提供了使用 Supervisor 来运行上述功能的基本框架文件。 "
"它由以下文件组成:"

#: ../../howto/logging-cookbook.rst:781
msgid "File"
msgstr "文件"

#: ../../howto/logging-cookbook.rst:781
msgid "Purpose"
msgstr "目的"

#: ../../howto/logging-cookbook.rst:783
msgid ":file:`prepare.sh`"
msgstr ":file:`prepare.sh`"

#: ../../howto/logging-cookbook.rst:783
msgid "A Bash script to prepare the environment for testing"
msgstr "用于准备针对测试的环境的 Bash 脚本"

#: ../../howto/logging-cookbook.rst:786
msgid ":file:`supervisor.conf`"
msgstr ":file:`supervisor.conf`"

#: ../../howto/logging-cookbook.rst:786
msgid ""
"The Supervisor configuration file, which has entries for the listener and a "
"multi-process web application"
msgstr "Supervisor 配置文件，其中有用于侦听器和多进程 Web 应用程序的条目"

#: ../../howto/logging-cookbook.rst:790
msgid ":file:`ensure_app.sh`"
msgstr ":file:`ensure_app.sh`"

#: ../../howto/logging-cookbook.rst:790
msgid ""
"A Bash script to ensure that Supervisor is running with the above "
"configuration"
msgstr "用于确保 Supervisor 在使用上述配置运行的 Bash 脚本"

#: ../../howto/logging-cookbook.rst:793
msgid ":file:`log_listener.py`"
msgstr ":file:`log_listener.py`"

#: ../../howto/logging-cookbook.rst:793
msgid ""
"The socket listener program which receives log events and records them to a "
"file"
msgstr "接收日志事件并将其记录到文件中的套接字监听器"

#: ../../howto/logging-cookbook.rst:796
msgid ":file:`main.py`"
msgstr ":file:`main.py`"

#: ../../howto/logging-cookbook.rst:796
msgid ""
"A simple web application which performs logging via a socket connected to "
"the listener"
msgstr "一个通过连接到监听器的套接字来执行日志记录的简单 Web 应用程序"

#: ../../howto/logging-cookbook.rst:799
msgid ":file:`webapp.json`"
msgstr ":file:`webapp.json`"

#: ../../howto/logging-cookbook.rst:799
msgid "A JSON configuration file for the web application"
msgstr "一个针对 Web 应用程序的 JSON 配置文件"

#: ../../howto/logging-cookbook.rst:801
msgid ":file:`client.py`"
msgstr ":file:`client.py`"

#: ../../howto/logging-cookbook.rst:801
msgid "A Python script to exercise the web application"
msgstr "使用 Web 应用程序的 Python 脚本"

#: ../../howto/logging-cookbook.rst:804
msgid ""
"The web application uses `Gunicorn <https://gunicorn.org/>`_, which is a "
"popular web application server that starts multiple worker processes to "
"handle requests. This example setup shows how the workers can write to the "
"same log file without conflicting with one another --- they all go through "
"the socket listener."
msgstr ""
"该 Web 应用程序使用了 `Gunicorn <https://gunicorn.org/>`_，这个流行的 Web "
"应用服务器可启动多个工作进程来处理请求。 这个示例设置演示了多个工作进程是如何写入相同的日志文件而不会相互冲突的 --- "
"它们都通过套接字监听器进程操作。"

#: ../../howto/logging-cookbook.rst:809
msgid "To test these files, do the following in a POSIX environment:"
msgstr "要测试这些文件，请在 POSIX 环境中执行以下操作:"

#: ../../howto/logging-cookbook.rst:811
msgid ""
"Download `the Gist <socket-listener-gist_>`__ as a ZIP archive using the "
":guilabel:`Download ZIP` button."
msgstr ""
"使用 :guilabel:`Download ZIP` 按钮将 `此 Gist <socket-listener-gist_>`__ 下载为 ZIP "
"归档文件。"

#: ../../howto/logging-cookbook.rst:814
msgid "Unzip the above files from the archive into a scratch directory."
msgstr "将上述文件从归档解压缩到一个初始目录中。"

#: ../../howto/logging-cookbook.rst:816
msgid ""
"In the scratch directory, run ``bash prepare.sh`` to get things ready. This "
"creates a :file:`run` subdirectory to contain Supervisor-related and log "
"files, and a :file:`venv` subdirectory to contain a virtual environment into"
" which ``bottle``, ``gunicorn`` and ``supervisor`` are installed."
msgstr ""
"在初始目录中，运行 ``bash prepare.sh`` 完成准备工作。 这将创建一个 :file:`run` 子目录来包含 Supervisor "
"相关文件和日志文件，以及一个 :file:`venv` 子目录来包含安装了 ``bottle``, ``gunicorn`` 和 "
"``supervisor`` 的虚拟环境。"

#: ../../howto/logging-cookbook.rst:821
msgid ""
"Run ``bash ensure_app.sh`` to ensure that Supervisor is running with the "
"above configuration."
msgstr "运行 ``bash ensure_app.sh`` 以确保 Supervisor 正在使用上述配置运行。"

#: ../../howto/logging-cookbook.rst:824
msgid ""
"Run ``venv/bin/python client.py`` to exercise the web application, which "
"will lead to records being written to the log."
msgstr "运行 ``venv/bin/python client.py`` 来使用 Web 应用程序，这将使得记录被写入到日志中。"

#: ../../howto/logging-cookbook.rst:827
msgid ""
"Inspect the log files in the :file:`run` subdirectory. You should see the "
"most recent log lines in files matching the pattern :file:`app.log*`. They "
"won't be in any particular order, since they have been handled concurrently "
"by different worker processes in a non-deterministic way."
msgstr ""
"检查 :file:`run` 子目录中的日志文件。 你应当看到匹配模式为 :file:`app.log*` 的文件中最新的日志记录行。 "
"它们不会有任何特定的顺序，因为它们是由不同的工作进程以不确定的方式并发地处理的。"

#: ../../howto/logging-cookbook.rst:832
msgid ""
"You can shut down the listener and the web application by running "
"``venv/bin/supervisorctl -c supervisor.conf shutdown``."
msgstr ""
"你可以通过运行 ``venv/bin/supervisorctl -c supervisor.conf shutdown`` 来关闭监听器和 Web "
"应用程序。"

#: ../../howto/logging-cookbook.rst:835
msgid ""
"You may need to tweak the configuration files in the unlikely event that the"
" configured ports clash with something else in your test environment."
msgstr "你可能需要在配置的端口与你的测试环境中其他程序发生意外冲突的情况下调整配置文件。"

#: ../../howto/logging-cookbook.rst:843
msgid "Adding contextual information to your logging output"
msgstr "在自己的输出日志中添加上下文信息"

#: ../../howto/logging-cookbook.rst:845
msgid ""
"Sometimes you want logging output to contain contextual information in "
"addition to the parameters passed to the logging call. For example, in a "
"networked application, it may be desirable to log client-specific "
"information in the log (e.g. remote client's username, or IP address). "
"Although you could use the *extra* parameter to achieve this, it's not "
"always convenient to pass the information in this way. While it might be "
"tempting to create :class:`Logger` instances on a per-connection basis, this"
" is not a good idea because these instances are not garbage collected. While"
" this is not a problem in practice, when the number of :class:`Logger` "
"instances is dependent on the level of granularity you want to use in "
"logging an application, it could be hard to manage if the number of "
":class:`Logger` instances becomes effectively unbounded."
msgstr ""
"有时，除了调用日志对象时传入的参数之外，还希望日志输出中能包含上下文信息。 "
"比如在网络应用程序中，可能需要在日志中记录某客户端的信息（如远程客户端的用户名或 IP 地址）。 这虽然可以用 *extra* "
"参数实现，但传递起来并不总是很方便。 虽然为每个网络连接都创建 :class:`Logger`  "
"实例貌似不错，但并不是个好主意，因为这些实例不会被垃圾回收。 虽然在实践中不是问题，但当 :class:`Logger` "
"实例的数量取决于应用程序要采用的日志粒度时，如果 :class:`Logger` 实例的数量实际上是无限的，则有可能难以管理。"

#: ../../howto/logging-cookbook.rst:860
msgid "Using LoggerAdapters to impart contextual information"
msgstr "利用 LoggerAdapter 传递上下文信息"

#: ../../howto/logging-cookbook.rst:862
msgid ""
"An easy way in which you can pass contextual information to be output along "
"with logging event information is to use the :class:`LoggerAdapter` class. "
"This class is designed to look like a :class:`Logger`, so that you can call "
":meth:`debug`, :meth:`info`, :meth:`warning`, :meth:`error`, "
":meth:`exception`, :meth:`critical` and :meth:`log`. These methods have the "
"same signatures as their counterparts in :class:`Logger`, so you can use the"
" two types of instances interchangeably."
msgstr ""
"要传递上下文信息和日志事件信息，有一种简单方案是利用 :class:`LoggerAdapter` 类。这个类设计得类似 "
":class:`Logger`，所以可以直接调用 :meth:`debug`、:meth:`info`、 :meth:`warning`、 "
":meth:`error`、:meth:`exception`、 :meth:`critical` 和 :meth:`log`。这些方法的签名与 "
":class:`Logger` 对应的方法相同，所以这两类实例可以交换使用。"

#: ../../howto/logging-cookbook.rst:870
msgid ""
"When you create an instance of :class:`LoggerAdapter`, you pass it a "
":class:`Logger` instance and a dict-like object which contains your "
"contextual information. When you call one of the logging methods on an "
"instance of :class:`LoggerAdapter`, it delegates the call to the underlying "
"instance of :class:`Logger` passed to its constructor, and arranges to pass "
"the contextual information in the delegated call. Here's a snippet from the "
"code of :class:`LoggerAdapter`::"
msgstr ""
"当你创建一个 :class:`LoggerAdapter` 的实例时，你会传入一个 :class:`Logger` "
"的实例和一个包含了上下文信息的字典对象。当你调用一个 :class:`LoggerAdapter` 实例的方法时，它会把调用委托给内部的 "
":class:`Logger` 的实例，并为其整理相关的上下文信息。这是 :class:`LoggerAdapter` 的一个代码片段::"

#: ../../howto/logging-cookbook.rst:878
msgid ""
"def debug(self, msg, /, *args, **kwargs):\n"
"    \"\"\"\n"
"    Delegate a debug call to the underlying logger, after adding\n"
"    contextual information from this adapter instance.\n"
"    \"\"\"\n"
"    msg, kwargs = self.process(msg, kwargs)\n"
"    self.logger.debug(msg, *args, **kwargs)"
msgstr ""
"def debug(self, msg, /, *args, **kwargs):\n"
"    \"\"\"\n"
"    在添加来自这个适配器实例的上下文信息之后，\n"
"    将调试调用委托给下层的日志记录器。\n"
"    \"\"\"\n"
"    msg, kwargs = self.process(msg, kwargs)\n"
"    self.logger.debug(msg, *args, **kwargs)"

#: ../../howto/logging-cookbook.rst:886
msgid ""
"The :meth:`~LoggerAdapter.process` method of :class:`LoggerAdapter` is where"
" the contextual information is added to the logging output. It's passed the "
"message and keyword arguments of the logging call, and it passes back "
"(potentially) modified versions of these to use in the call to the "
"underlying logger. The default implementation of this method leaves the "
"message alone, but inserts an 'extra' key in the keyword argument whose "
"value is the dict-like object passed to the constructor. Of course, if you "
"had passed an 'extra' keyword argument in the call to the adapter, it will "
"be silently overwritten."
msgstr ""
":class:`LoggerAdapter` 的 :meth:`~LoggerAdapter.process` 方法是将上下文信息添加到日志的输出中。 "
"它传入日志消息和日志调用的关键字参数，并传回（隐式的）这些修改后的内容去调用底层的日志记录器。此方法的默认参数只是一个消息字段，但留有一个 "
"'extra' 的字段作为关键字参数传给构造器。当然，如果你在调用适配器时传入了一个 'extra' 字段的参数，它会被静默覆盖。"

#: ../../howto/logging-cookbook.rst:895
msgid ""
"The advantage of using 'extra' is that the values in the dict-like object "
"are merged into the :class:`LogRecord` instance's __dict__, allowing you to "
"use customized strings with your :class:`Formatter` instances which know "
"about the keys of the dict-like object. If you need a different method, e.g."
" if you want to prepend or append the contextual information to the message "
"string, you just need to subclass :class:`LoggerAdapter` and override "
":meth:`~LoggerAdapter.process` to do what you need. Here is a simple "
"example::"
msgstr ""
"使用 'extra' 的优点是这些键值对会被传入 :class:`LogRecord` 实例的 __dict__ 中，让你通过 "
":class:`Formatter` 的实例直接使用定制的字符串，实例能找到这个字典类对象的键。 "
"如果你需要一个其他的方法，比如说，想要在消息字符串前后增加上下文信息，你只需要创建一个 :class:`LoggerAdapter` 的子类，并覆盖它的"
" :meth:`~LoggerAdapter.process` 方法来做你想做的事情，以下是一个简单的示例::"

#: ../../howto/logging-cookbook.rst:903
msgid ""
"class CustomAdapter(logging.LoggerAdapter):\n"
"    \"\"\"\n"
"    This example adapter expects the passed in dict-like object to have a\n"
"    'connid' key, whose value in brackets is prepended to the log message.\n"
"    \"\"\"\n"
"    def process(self, msg, kwargs):\n"
"        return '[%s] %s' % (self.extra['connid'], msg), kwargs"
msgstr ""

#: ../../howto/logging-cookbook.rst:911
msgid "which you can use like this::"
msgstr "你可以这样使用::"

#: ../../howto/logging-cookbook.rst:913
msgid ""
"logger = logging.getLogger(__name__)\n"
"adapter = CustomAdapter(logger, {'connid': some_conn_id})"
msgstr ""
"logger = logging.getLogger(__name__)\n"
"adapter = CustomAdapter(logger, {'connid': some_conn_id})"

#: ../../howto/logging-cookbook.rst:916
msgid ""
"Then any events that you log to the adapter will have the value of "
"``some_conn_id`` prepended to the log messages."
msgstr "然后，你记录在适配器中的任何事件消息前将添加 ``some_conn_id`` 的值。"

#: ../../howto/logging-cookbook.rst:920
msgid "Using objects other than dicts to pass contextual information"
msgstr "使用除字典之外的其它对象传递上下文信息"

#: ../../howto/logging-cookbook.rst:922
msgid ""
"You don't need to pass an actual dict to a :class:`LoggerAdapter` - you "
"could pass an instance of a class which implements ``__getitem__`` and "
"``__iter__`` so that it looks like a dict to logging. This would be useful "
"if you want to generate values dynamically (whereas the values in a dict "
"would be constant)."
msgstr ""
"你不需要将一个实际的字典传递给 :class:`LoggerAdapter`-你可以传入一个实现了 ``__getitem__`` 和 "
"``__iter__`` 的类的实例，这样它就像是一个字典。这对于你想动态生成值（而字典中的值往往是常量）将很有帮助。"

#: ../../howto/logging-cookbook.rst:931
msgid "Using Filters to impart contextual information"
msgstr "使用过滤器传递上下文信息"

#: ../../howto/logging-cookbook.rst:933
msgid ""
"You can also add contextual information to log output using a user-defined "
":class:`Filter`. ``Filter`` instances are allowed to modify the "
"``LogRecords`` passed to them, including adding additional attributes which "
"can then be output using a suitable format string, or if needed a custom "
":class:`Formatter`."
msgstr ""
"你也可以使用一个用户定义的类 :class:`Filter` 在日志输出中添加上下文信息。``Filter`` 的实例是被允许修改传入的 "
"``LogRecords``，包括添加其他的属性，然后可以使用合适的格式化字符串输出，或者可以使用一个自定义的类 :class:`Formatter`。"

#: ../../howto/logging-cookbook.rst:938
msgid ""
"For example in a web application, the request being processed (or at least, "
"the interesting parts of it) can be stored in a threadlocal "
"(:class:`threading.local`) variable, and then accessed from a ``Filter`` to "
"add, say, information from the request - say, the remote IP address and "
"remote user's username - to the ``LogRecord``, using the attribute names "
"'ip' and 'user' as in the ``LoggerAdapter`` example above. In that case, the"
" same format string can be used to get similar output to that shown above. "
"Here's an example script::"
msgstr ""
"例如，在一个web应用程序中，正在处理的请求（或者至少是请求的一部分），可以存储在一个线程本地 (:class:`threading.local`) "
"变量中，然后从 ``Filter`` 中去访问。请求中的信息，如IP地址和用户名将被存储在 ``LogRecord`` 中，使用上例 "
"``LoggerAdapter`` 中的 'ip' 和 'user' "
"属性名。在这种情况下，可以使用相同的格式化字符串来得到上例中类似的输出结果。这是一段示例代码::"

#: ../../howto/logging-cookbook.rst:947
msgid ""
"import logging\n"
"from random import choice\n"
"\n"
"class ContextFilter(logging.Filter):\n"
"    \"\"\"\n"
"    This is a filter which injects contextual information into the log.\n"
"\n"
"    Rather than use actual contextual information, we just use random\n"
"    data in this demo.\n"
"    \"\"\"\n"
"\n"
"    USERS = ['jim', 'fred', 'sheila']\n"
"    IPS = ['123.231.231.123', '127.0.0.1', '192.168.0.1']\n"
"\n"
"    def filter(self, record):\n"
"\n"
"        record.ip = choice(ContextFilter.IPS)\n"
"        record.user = choice(ContextFilter.USERS)\n"
"        return True\n"
"\n"
"if __name__ == '__main__':\n"
"    levels = (logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR, logging.CRITICAL)\n"
"    logging.basicConfig(level=logging.DEBUG,\n"
"                        format='%(asctime)-15s %(name)-5s %(levelname)-8s IP: %(ip)-15s User: %(user)-8s %(message)s')\n"
"    a1 = logging.getLogger('a.b.c')\n"
"    a2 = logging.getLogger('d.e.f')\n"
"\n"
"    f = ContextFilter()\n"
"    a1.addFilter(f)\n"
"    a2.addFilter(f)\n"
"    a1.debug('A debug message')\n"
"    a1.info('An info message with %s', 'some parameters')\n"
"    for x in range(10):\n"
"        lvl = choice(levels)\n"
"        lvlname = logging.getLevelName(lvl)\n"
"        a2.log(lvl, 'A message at %s level with %d %s', lvlname, 2, 'parameters')"
msgstr ""

#: ../../howto/logging-cookbook.rst:984
msgid "which, when run, produces something like:"
msgstr "在运行时，产生如下内容:"

#: ../../howto/logging-cookbook.rst:986
msgid ""
"2010-09-06 22:38:15,292 a.b.c DEBUG    IP: 123.231.231.123 User: fred     A debug message\n"
"2010-09-06 22:38:15,300 a.b.c INFO     IP: 192.168.0.1     User: sheila   An info message with some parameters\n"
"2010-09-06 22:38:15,300 d.e.f CRITICAL IP: 127.0.0.1       User: sheila   A message at CRITICAL level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f ERROR    IP: 127.0.0.1       User: jim      A message at ERROR level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f DEBUG    IP: 127.0.0.1       User: sheila   A message at DEBUG level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f ERROR    IP: 123.231.231.123 User: fred     A message at ERROR level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f CRITICAL IP: 192.168.0.1     User: jim      A message at CRITICAL level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f CRITICAL IP: 127.0.0.1       User: sheila   A message at CRITICAL level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f DEBUG    IP: 192.168.0.1     User: jim      A message at DEBUG level with 2 parameters\n"
"2010-09-06 22:38:15,301 d.e.f ERROR    IP: 127.0.0.1       User: sheila   A message at ERROR level with 2 parameters\n"
"2010-09-06 22:38:15,301 d.e.f DEBUG    IP: 123.231.231.123 User: fred     A message at DEBUG level with 2 parameters\n"
"2010-09-06 22:38:15,301 d.e.f INFO     IP: 123.231.231.123 User: fred     A message at INFO level with 2 parameters"
msgstr ""
"2010-09-06 22:38:15,292 a.b.c DEBUG    IP: 123.231.231.123 User: fred     A debug message\n"
"2010-09-06 22:38:15,300 a.b.c INFO     IP: 192.168.0.1     User: sheila   An info message with some parameters\n"
"2010-09-06 22:38:15,300 d.e.f CRITICAL IP: 127.0.0.1       User: sheila   A message at CRITICAL level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f ERROR    IP: 127.0.0.1       User: jim      A message at ERROR level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f DEBUG    IP: 127.0.0.1       User: sheila   A message at DEBUG level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f ERROR    IP: 123.231.231.123 User: fred     A message at ERROR level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f CRITICAL IP: 192.168.0.1     User: jim      A message at CRITICAL level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f CRITICAL IP: 127.0.0.1       User: sheila   A message at CRITICAL level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f DEBUG    IP: 192.168.0.1     User: jim      A message at DEBUG level with 2 parameters\n"
"2010-09-06 22:38:15,301 d.e.f ERROR    IP: 127.0.0.1       User: sheila   A message at ERROR level with 2 parameters\n"
"2010-09-06 22:38:15,301 d.e.f DEBUG    IP: 123.231.231.123 User: fred     A message at DEBUG level with 2 parameters\n"
"2010-09-06 22:38:15,301 d.e.f INFO     IP: 123.231.231.123 User: fred     A message at INFO level with 2 parameters"

#: ../../howto/logging-cookbook.rst:1002
msgid "Use of ``contextvars``"
msgstr "``contextvars`` 的使用"

#: ../../howto/logging-cookbook.rst:1004
msgid ""
"Since Python 3.7, the :mod:`contextvars` module has provided context-local "
"storage which works for both :mod:`threading` and :mod:`asyncio` processing "
"needs. This type of storage may thus be generally preferable to thread-"
"locals. The following example shows how, in a multi-threaded environment, "
"logs can populated with contextual information such as, for example, request"
" attributes handled by web applications."
msgstr ""
"自 Python 3.7 起，:mod:`contextvars` 模块提供了同时适用于 :mod:`threading` 和 "
":mod:`asyncio` 处理需求的上下文本地存储。 因此这种存储类型通常要比线程本地存储更好。 "
"下面的例子演示了在多线程环境中日志如何用上下文信息来填充内容，例如 Web 应用程序所处理的请求属性。"

#: ../../howto/logging-cookbook.rst:1010
msgid ""
"For the purposes of illustration, say that you have different web "
"applications, each independent of the other but running in the same Python "
"process and using a library common to them. How can each of these "
"applications have their own log, where all logging messages from the library"
" (and other request processing code) are directed to the appropriate "
"application's log file, while including in the log additional contextual "
"information such as client IP, HTTP request method and client username?"
msgstr ""
"出于说明的目的，比方说你有几个不同的 Web 应用程序，彼此都保持独立状态但运行在同一个 Python 进程中并且它们共同使用了某个库。 "
"这些应用程序要如何拥有各自的日志记录，其中来自这个库的日志消息（以及其他请求处理代码）会发到对应的应用程序的日志文件，同时在日志中包括额外的上下文信息如客户端"
" IP、HTTP 请求方法和客户端用户名呢？"

#: ../../howto/logging-cookbook.rst:1017
msgid "Let's assume that the library can be simulated by the following code:"
msgstr "让我们假定这个库可以通过以下代码来模拟:"

#: ../../howto/logging-cookbook.rst:1019
msgid ""
"# webapplib.py\n"
"import logging\n"
"import time\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"def useful():\n"
"    # Just a representative event logged from the library\n"
"    logger.debug('Hello from webapplib!')\n"
"    # Just sleep for a bit so other threads get to run\n"
"    time.sleep(0.01)"
msgstr ""
"# webapplib.py\n"
"import logging\n"
"import time\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"def useful():\n"
"    # 一条从库中记录的代表性事件\n"
"    logger.debug('Hello from webapplib!')\n"
"    # 休眠一下以便其他线程能够运行\n"
"    time.sleep(0.01)"

#: ../../howto/logging-cookbook.rst:1033
msgid ""
"We can simulate the multiple web applications by means of two simple "
"classes, ``Request`` and ``WebApp``. These simulate how real threaded web "
"applications work - each request is handled by a thread:"
msgstr ""
"我们可以通过两个简单的类 ``Request`` 和 ``WebApp`` 来模拟多个 Web 应用程序。 它们模拟了真正的多线程 Web "
"应用程序是如何工作的 —— 每个请求均由单独的线程来处理:"

#: ../../howto/logging-cookbook.rst:1037
msgid ""
"# main.py\n"
"import argparse\n"
"from contextvars import ContextVar\n"
"import logging\n"
"import os\n"
"from random import choice\n"
"import threading\n"
"import webapplib\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"root = logging.getLogger()\n"
"root.setLevel(logging.DEBUG)\n"
"\n"
"class Request:\n"
"    \"\"\"\n"
"    A simple dummy request class which just holds dummy HTTP request method,\n"
"    client IP address and client username\n"
"    \"\"\"\n"
"    def __init__(self, method, ip, user):\n"
"        self.method = method\n"
"        self.ip = ip\n"
"        self.user = user\n"
"\n"
"# A dummy set of requests which will be used in the simulation - we'll just pick\n"
"# from this list randomly. Note that all GET requests are from 192.168.2.XXX\n"
"# addresses, whereas POST requests are from 192.16.3.XXX addresses. Three users\n"
"# are represented in the sample requests.\n"
"\n"
"REQUESTS = [\n"
"    Request('GET', '192.168.2.20', 'jim'),\n"
"    Request('POST', '192.168.3.20', 'fred'),\n"
"    Request('GET', '192.168.2.21', 'sheila'),\n"
"    Request('POST', '192.168.3.21', 'jim'),\n"
"    Request('GET', '192.168.2.22', 'fred'),\n"
"    Request('POST', '192.168.3.22', 'sheila'),\n"
"]\n"
"\n"
"# Note that the format string includes references to request context information\n"
"# such as HTTP method, client IP and username\n"
"\n"
"formatter = logging.Formatter('%(threadName)-11s %(appName)s %(name)-9s %(user)-6s %(ip)s %(method)-4s %(message)s')\n"
"\n"
"# Create our context variables. These will be filled at the start of request\n"
"# processing, and used in the logging that happens during that processing\n"
"\n"
"ctx_request = ContextVar('request')\n"
"ctx_appname = ContextVar('appname')\n"
"\n"
"class InjectingFilter(logging.Filter):\n"
"    \"\"\"\n"
"    A filter which injects context-specific information into logs and ensures\n"
"    that only information for a specific webapp is included in its log\n"
"    \"\"\"\n"
"    def __init__(self, app):\n"
"        self.app = app\n"
"\n"
"    def filter(self, record):\n"
"        request = ctx_request.get()\n"
"        record.method = request.method\n"
"        record.ip = request.ip\n"
"        record.user = request.user\n"
"        record.appName = appName = ctx_appname.get()\n"
"        return appName == self.app.name\n"
"\n"
"class WebApp:\n"
"    \"\"\"\n"
"    A dummy web application class which has its own handler and filter for a\n"
"    webapp-specific log.\n"
"    \"\"\"\n"
"    def __init__(self, name):\n"
"        self.name = name\n"
"        handler = logging.FileHandler(name + '.log', 'w')\n"
"        f = InjectingFilter(self)\n"
"        handler.setFormatter(formatter)\n"
"        handler.addFilter(f)\n"
"        root.addHandler(handler)\n"
"        self.num_requests = 0\n"
"\n"
"    def process_request(self, request):\n"
"        \"\"\"\n"
"        This is the dummy method for processing a request. It's called on a\n"
"        different thread for every request. We store the context information into\n"
"        the context vars before doing anything else.\n"
"        \"\"\"\n"
"        ctx_request.set(request)\n"
"        ctx_appname.set(self.name)\n"
"        self.num_requests += 1\n"
"        logger.debug('Request processing started')\n"
"        webapplib.useful()\n"
"        logger.debug('Request processing finished')\n"
"\n"
"def main():\n"
"    fn = os.path.splitext(os.path.basename(__file__))[0]\n"
"    adhf = argparse.ArgumentDefaultsHelpFormatter\n"
"    ap = argparse.ArgumentParser(formatter_class=adhf, prog=fn,\n"
"                                 description='Simulate a couple of web '\n"
"                                             'applications handling some '\n"
"                                             'requests, showing how request '\n"
"                                             'context can be used to '\n"
"                                             'populate logs')\n"
"    aa = ap.add_argument\n"
"    aa('--count', '-c', type=int, default=100, help='How many requests to simulate')\n"
"    options = ap.parse_args()\n"
"\n"
"    # Create the dummy webapps and put them in a list which we can use to select\n"
"    # from randomly\n"
"    app1 = WebApp('app1')\n"
"    app2 = WebApp('app2')\n"
"    apps = [app1, app2]\n"
"    threads = []\n"
"    # Add a common handler which will capture all events\n"
"    handler = logging.FileHandler('app.log', 'w')\n"
"    handler.setFormatter(formatter)\n"
"    root.addHandler(handler)\n"
"\n"
"    # Generate calls to process requests\n"
"    for i in range(options.count):\n"
"        try:\n"
"            # Pick an app at random and a request for it to process\n"
"            app = choice(apps)\n"
"            request = choice(REQUESTS)\n"
"            # Process the request in its own thread\n"
"            t = threading.Thread(target=app.process_request, args=(request,))\n"
"            threads.append(t)\n"
"            t.start()\n"
"        except KeyboardInterrupt:\n"
"            break\n"
"\n"
"    # Wait for the threads to terminate\n"
"    for t in threads:\n"
"        t.join()\n"
"\n"
"    for app in apps:\n"
"        print('%s processed %s requests' % (app.name, app.num_requests))\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""

#: ../../howto/logging-cookbook.rst:1177
msgid ""
"If you run the above, you should find that roughly half the requests go into"
" :file:`app1.log` and the rest into :file:`app2.log`, and the all the "
"requests are logged to :file:`app.log`. Each webapp-specific log will "
"contain only log entries for only that webapp, and the request information "
"will be displayed consistently in the log (i.e. the information in each "
"dummy request will always appear together in a log line). This is "
"illustrated by the following shell output:"
msgstr ""
"如果你运行上面的代码，你将会发现约有半数请求是发给 :file:`app1.log` 而其余的则是发给 "
":file:`app2.log`，并且所有请求都会被记录至 :file:`app.log`。 每个 Web 应用专属的日志将只包含该 Web "
"应用的日志条目，请求信息也将以一致的方式显示在日志里（即每个模拟请求中的信息将总是在一个日志行中一起显示）。 如下面的 shell 输出所示:"

#: ../../howto/logging-cookbook.rst:1184
msgid ""
"~/logging-contextual-webapp$ python main.py\n"
"app1 processed 51 requests\n"
"app2 processed 49 requests\n"
"~/logging-contextual-webapp$ wc -l *.log\n"
"  153 app1.log\n"
"  147 app2.log\n"
"  300 app.log\n"
"  600 total\n"
"~/logging-contextual-webapp$ head -3 app1.log\n"
"Thread-3 (process_request) app1 __main__  jim    192.168.3.21 POST Request processing started\n"
"Thread-3 (process_request) app1 webapplib jim    192.168.3.21 POST Hello from webapplib!\n"
"Thread-5 (process_request) app1 __main__  jim    192.168.3.21 POST Request processing started\n"
"~/logging-contextual-webapp$ head -3 app2.log\n"
"Thread-1 (process_request) app2 __main__  sheila 192.168.2.21 GET  Request processing started\n"
"Thread-1 (process_request) app2 webapplib sheila 192.168.2.21 GET  Hello from webapplib!\n"
"Thread-2 (process_request) app2 __main__  jim    192.168.2.20 GET  Request processing started\n"
"~/logging-contextual-webapp$ head app.log\n"
"Thread-1 (process_request) app2 __main__  sheila 192.168.2.21 GET  Request processing started\n"
"Thread-1 (process_request) app2 webapplib sheila 192.168.2.21 GET  Hello from webapplib!\n"
"Thread-2 (process_request) app2 __main__  jim    192.168.2.20 GET  Request processing started\n"
"Thread-3 (process_request) app1 __main__  jim    192.168.3.21 POST Request processing started\n"
"Thread-2 (process_request) app2 webapplib jim    192.168.2.20 GET  Hello from webapplib!\n"
"Thread-3 (process_request) app1 webapplib jim    192.168.3.21 POST Hello from webapplib!\n"
"Thread-4 (process_request) app2 __main__  fred   192.168.2.22 GET  Request processing started\n"
"Thread-5 (process_request) app1 __main__  jim    192.168.3.21 POST Request processing started\n"
"Thread-4 (process_request) app2 webapplib fred   192.168.2.22 GET  Hello from webapplib!\n"
"Thread-6 (process_request) app1 __main__  jim    192.168.3.21 POST Request processing started\n"
"~/logging-contextual-webapp$ grep app1 app1.log | wc -l\n"
"153\n"
"~/logging-contextual-webapp$ grep app2 app2.log | wc -l\n"
"147\n"
"~/logging-contextual-webapp$ grep app1 app.log | wc -l\n"
"153\n"
"~/logging-contextual-webapp$ grep app2 app.log | wc -l\n"
"147"
msgstr ""
"~/logging-contextual-webapp$ python main.py\n"
"app1 processed 51 requests\n"
"app2 processed 49 requests\n"
"~/logging-contextual-webapp$ wc -l *.log\n"
"  153 app1.log\n"
"  147 app2.log\n"
"  300 app.log\n"
"  600 total\n"
"~/logging-contextual-webapp$ head -3 app1.log\n"
"Thread-3 (process_request) app1 __main__  jim    192.168.3.21 POST Request processing started\n"
"Thread-3 (process_request) app1 webapplib jim    192.168.3.21 POST Hello from webapplib!\n"
"Thread-5 (process_request) app1 __main__  jim    192.168.3.21 POST Request processing started\n"
"~/logging-contextual-webapp$ head -3 app2.log\n"
"Thread-1 (process_request) app2 __main__  sheila 192.168.2.21 GET  Request processing started\n"
"Thread-1 (process_request) app2 webapplib sheila 192.168.2.21 GET  Hello from webapplib!\n"
"Thread-2 (process_request) app2 __main__  jim    192.168.2.20 GET  Request processing started\n"
"~/logging-contextual-webapp$ head app.log\n"
"Thread-1 (process_request) app2 __main__  sheila 192.168.2.21 GET  Request processing started\n"
"Thread-1 (process_request) app2 webapplib sheila 192.168.2.21 GET  Hello from webapplib!\n"
"Thread-2 (process_request) app2 __main__  jim    192.168.2.20 GET  Request processing started\n"
"Thread-3 (process_request) app1 __main__  jim    192.168.3.21 POST Request processing started\n"
"Thread-2 (process_request) app2 webapplib jim    192.168.2.20 GET  Hello from webapplib!\n"
"Thread-3 (process_request) app1 webapplib jim    192.168.3.21 POST Hello from webapplib!\n"
"Thread-4 (process_request) app2 __main__  fred   192.168.2.22 GET  Request processing started\n"
"Thread-5 (process_request) app1 __main__  jim    192.168.3.21 POST Request processing started\n"
"Thread-4 (process_request) app2 webapplib fred   192.168.2.22 GET  Hello from webapplib!\n"
"Thread-6 (process_request) app1 __main__  jim    192.168.3.21 POST Request processing started\n"
"~/logging-contextual-webapp$ grep app1 app1.log | wc -l\n"
"153\n"
"~/logging-contextual-webapp$ grep app2 app2.log | wc -l\n"
"147\n"
"~/logging-contextual-webapp$ grep app1 app.log | wc -l\n"
"153\n"
"~/logging-contextual-webapp$ grep app2 app.log | wc -l\n"
"147"

#: ../../howto/logging-cookbook.rst:1224
msgid "Imparting contextual information in handlers"
msgstr "在处理器中传递上下文信息"

#: ../../howto/logging-cookbook.rst:1226
msgid ""
"Each :class:`~Handler` has its own chain of filters. If you want to add "
"contextual information to a :class:`LogRecord` without leaking it to other "
"handlers, you can use a filter that returns a new :class:`~LogRecord` "
"instead of modifying it in-place, as shown in the following script::"
msgstr ""
"每个 :class:`~Handler` 都有自己的过滤器链。 如果你想向一个 :class:`LogRecord` "
"添加上下文信息而不使其泄露给其它处理器，你可以使用一个返回新 :class:`~LogRecord` 而不是原地修改它的过滤器，如下面的脚本所示::"

#: ../../howto/logging-cookbook.rst:1231
msgid ""
"import copy\n"
"import logging\n"
"\n"
"def filter(record: logging.LogRecord):\n"
"    record = copy.copy(record)\n"
"    record.user = 'jim'\n"
"    return record\n"
"\n"
"if __name__ == '__main__':\n"
"    logger = logging.getLogger()\n"
"    logger.setLevel(logging.INFO)\n"
"    handler = logging.StreamHandler()\n"
"    formatter = logging.Formatter('%(message)s from %(user)-8s')\n"
"    handler.setFormatter(formatter)\n"
"    handler.addFilter(filter)\n"
"    logger.addHandler(handler)\n"
"\n"
"    logger.info('A log message')"
msgstr ""
"import copy\n"
"import logging\n"
"\n"
"def filter(record: logging.LogRecord):\n"
"    record = copy.copy(record)\n"
"    record.user = 'jim'\n"
"    return record\n"
"\n"
"if __name__ == '__main__':\n"
"    logger = logging.getLogger()\n"
"    logger.setLevel(logging.INFO)\n"
"    handler = logging.StreamHandler()\n"
"    formatter = logging.Formatter('%(message)s from %(user)-8s')\n"
"    handler.setFormatter(formatter)\n"
"    handler.addFilter(filter)\n"
"    logger.addHandler(handler)\n"
"\n"
"    logger.info('A log message')"

#: ../../howto/logging-cookbook.rst:1253
msgid "Logging to a single file from multiple processes"
msgstr "从多个进程记录至单个文件"

#: ../../howto/logging-cookbook.rst:1255
msgid ""
"Although logging is thread-safe, and logging to a single file from multiple "
"threads in a single process *is* supported, logging to a single file from "
"*multiple processes* is *not* supported, because there is no standard way to"
" serialize access to a single file across multiple processes in Python. If "
"you need to log to a single file from multiple processes, one way of doing "
"this is to have all the processes log to a :class:`~handlers.SocketHandler`,"
" and have a separate process which implements a socket server which reads "
"from the socket and logs to file. (If you prefer, you can dedicate one "
"thread in one of the existing processes to perform this function.) "
":ref:`This section <network-logging>` documents this approach in more detail"
" and includes a working socket receiver which can be used as a starting "
"point for you to adapt in your own applications."
msgstr ""
"尽管 logging 是线程安全的，将单个进程中的多个线程日志记录至单个文件也 *是* 受支持的，但将 *多个进程* 中的日志记录至单个文件则 *不是*"
" 受支持的，因为在 Python 中并没有在多个进程中实现对单个文件访问的序列化的标准方案。 "
"如果你需要将多个进程中的日志记录至单个文件，有一个方案是让所有进程都将日志记录至一个 "
":class:`~handlers.SocketHandler`，然后用一个实现了套接字服务器的单独进程一边从套接字中读取一边将日志记录至文件。 "
"（如果愿意的话，你可以在一个现有进程中专门开一个线程来执行此项功能。） :ref:`这一部分 <network-logging>` "
"文档对此方式有更详细的介绍，并包含一个可用的套接字接收器，你自己的应用可以在此基础上进行适配。"

#: ../../howto/logging-cookbook.rst:1268
msgid ""
"You could also write your own handler which uses the "
":class:`~multiprocessing.Lock` class from the :mod:`multiprocessing` module "
"to serialize access to the file from your processes. The stdlib "
":class:`FileHandler` and subclasses do not make use of "
":mod:`multiprocessing`."
msgstr ""

#: ../../howto/logging-cookbook.rst:1275
msgid ""
"Alternatively, you can use a ``Queue`` and a :class:`QueueHandler` to send "
"all logging events to one of the processes in your multi-process "
"application. The following example script demonstrates how you can do this; "
"in the example a separate listener process listens for events sent by other "
"processes and logs them according to its own logging configuration. Although"
" the example only demonstrates one way of doing it (for example, you may "
"want to use a listener thread rather than a separate listener process -- the"
" implementation would be analogous) it does allow for completely different "
"logging configurations for the listener and the other processes in your "
"application, and can be used as the basis for code meeting your own specific"
" requirements::"
msgstr ""
"或者，你也可以使用 ``Queue`` 和 :class:`QueueHandler` 将所有的日志事件发送至你的多进程应用的一个进程中。 "
"以下示例脚本演示了如何执行此操作。 在示例中，一个单独的监听进程负责监听其他进程的日志事件，并根据自己的配置记录。 "
"尽管示例只演示了这种方法（例如你可能希望使用单独的监听线程而非监听进程 —— "
"它们的实现是类似的），但你也可以在应用程序的监听进程和其他进程使用不同的配置，它可以作为满足你特定需求的一个基础::"

#: ../../howto/logging-cookbook.rst:1286
msgid ""
"# You'll need these imports in your own code\n"
"import logging\n"
"import logging.handlers\n"
"import multiprocessing\n"
"\n"
"# Next two import lines for this demo only\n"
"from random import choice, random\n"
"import time\n"
"\n"
"#\n"
"# Because you'll want to define the logging configurations for listener and workers, the\n"
"# listener and worker process functions take a configurer parameter which is a callable\n"
"# for configuring logging for that process. These functions are also passed the queue,\n"
"# which they use for communication.\n"
"#\n"
"# In practice, you can configure the listener however you want, but note that in this\n"
"# simple example, the listener does not apply level or filter logic to received records.\n"
"# In practice, you would probably want to do this logic in the worker processes, to avoid\n"
"# sending events which would be filtered out between processes.\n"
"#\n"
"# The size of the rotated files is made small so you can see the results easily.\n"
"def listener_configurer():\n"
"    root = logging.getLogger()\n"
"    h = logging.handlers.RotatingFileHandler('mptest.log', 'a', 300, 10)\n"
"    f = logging.Formatter('%(asctime)s %(processName)-10s %(name)s %(levelname)-8s %(message)s')\n"
"    h.setFormatter(f)\n"
"    root.addHandler(h)\n"
"\n"
"# This is the listener process top-level loop: wait for logging events\n"
"# (LogRecords)on the queue and handle them, quit when you get a None for a\n"
"# LogRecord.\n"
"def listener_process(queue, configurer):\n"
"    configurer()\n"
"    while True:\n"
"        try:\n"
"            record = queue.get()\n"
"            if record is None:  # We send this as a sentinel to tell the listener to quit.\n"
"                break\n"
"            logger = logging.getLogger(record.name)\n"
"            logger.handle(record)  # No level or filter logic applied - just do it!\n"
"        except Exception:\n"
"            import sys, traceback\n"
"            print('Whoops! Problem:', file=sys.stderr)\n"
"            traceback.print_exc(file=sys.stderr)\n"
"\n"
"# Arrays used for random selections in this demo\n"
"\n"
"LEVELS = [logging.DEBUG, logging.INFO, logging.WARNING,\n"
"          logging.ERROR, logging.CRITICAL]\n"
"\n"
"LOGGERS = ['a.b.c', 'd.e.f']\n"
"\n"
"MESSAGES = [\n"
"    'Random message #1',\n"
"    'Random message #2',\n"
"    'Random message #3',\n"
"]\n"
"\n"
"# The worker configuration is done at the start of the worker process run.\n"
"# Note that on Windows you can't rely on fork semantics, so each process\n"
"# will run the logging configuration code when it starts.\n"
"def worker_configurer(queue):\n"
"    h = logging.handlers.QueueHandler(queue)  # Just the one handler needed\n"
"    root = logging.getLogger()\n"
"    root.addHandler(h)\n"
"    # send all messages, for demo; no other level or filter logic applied.\n"
"    root.setLevel(logging.DEBUG)\n"
"\n"
"# This is the worker process top-level loop, which just logs ten events with\n"
"# random intervening delays before terminating.\n"
"# The print messages are just so you know it's doing something!\n"
"def worker_process(queue, configurer):\n"
"    configurer(queue)\n"
"    name = multiprocessing.current_process().name\n"
"    print('Worker started: %s' % name)\n"
"    for i in range(10):\n"
"        time.sleep(random())\n"
"        logger = logging.getLogger(choice(LOGGERS))\n"
"        level = choice(LEVELS)\n"
"        message = choice(MESSAGES)\n"
"        logger.log(level, message)\n"
"    print('Worker finished: %s' % name)\n"
"\n"
"# Here's where the demo gets orchestrated. Create the queue, create and start\n"
"# the listener, create ten workers and start them, wait for them to finish,\n"
"# then send a None to the queue to tell the listener to finish.\n"
"def main():\n"
"    queue = multiprocessing.Queue(-1)\n"
"    listener = multiprocessing.Process(target=listener_process,\n"
"                                       args=(queue, listener_configurer))\n"
"    listener.start()\n"
"    workers = []\n"
"    for i in range(10):\n"
"        worker = multiprocessing.Process(target=worker_process,\n"
"                                         args=(queue, worker_configurer))\n"
"        workers.append(worker)\n"
"        worker.start()\n"
"    for w in workers:\n"
"        w.join()\n"
"    queue.put_nowait(None)\n"
"    listener.join()\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""

#: ../../howto/logging-cookbook.rst:1391
msgid ""
"A variant of the above script keeps the logging in the main process, in a "
"separate thread::"
msgstr "上面脚本的一个变种，仍然在主进程中记录日志，但使用一个单独的线程::"

#: ../../howto/logging-cookbook.rst:1394
msgid ""
"import logging\n"
"import logging.config\n"
"import logging.handlers\n"
"from multiprocessing import Process, Queue\n"
"import random\n"
"import threading\n"
"import time\n"
"\n"
"def logger_thread(q):\n"
"    while True:\n"
"        record = q.get()\n"
"        if record is None:\n"
"            break\n"
"        logger = logging.getLogger(record.name)\n"
"        logger.handle(record)\n"
"\n"
"\n"
"def worker_process(q):\n"
"    qh = logging.handlers.QueueHandler(q)\n"
"    root = logging.getLogger()\n"
"    root.setLevel(logging.DEBUG)\n"
"    root.addHandler(qh)\n"
"    levels = [logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR,\n"
"              logging.CRITICAL]\n"
"    loggers = ['foo', 'foo.bar', 'foo.bar.baz',\n"
"               'spam', 'spam.ham', 'spam.ham.eggs']\n"
"    for i in range(100):\n"
"        lvl = random.choice(levels)\n"
"        logger = logging.getLogger(random.choice(loggers))\n"
"        logger.log(lvl, 'Message no. %d', i)\n"
"\n"
"if __name__ == '__main__':\n"
"    q = Queue()\n"
"    d = {\n"
"        'version': 1,\n"
"        'formatters': {\n"
"            'detailed': {\n"
"                'class': 'logging.Formatter',\n"
"                'format': '%(asctime)s %(name)-15s %(levelname)-8s %(processName)-10s %(message)s'\n"
"            }\n"
"        },\n"
"        'handlers': {\n"
"            'console': {\n"
"                'class': 'logging.StreamHandler',\n"
"                'level': 'INFO',\n"
"            },\n"
"            'file': {\n"
"                'class': 'logging.FileHandler',\n"
"                'filename': 'mplog.log',\n"
"                'mode': 'w',\n"
"                'formatter': 'detailed',\n"
"            },\n"
"            'foofile': {\n"
"                'class': 'logging.FileHandler',\n"
"                'filename': 'mplog-foo.log',\n"
"                'mode': 'w',\n"
"                'formatter': 'detailed',\n"
"            },\n"
"            'errors': {\n"
"                'class': 'logging.FileHandler',\n"
"                'filename': 'mplog-errors.log',\n"
"                'mode': 'w',\n"
"                'level': 'ERROR',\n"
"                'formatter': 'detailed',\n"
"            },\n"
"        },\n"
"        'loggers': {\n"
"            'foo': {\n"
"                'handlers': ['foofile']\n"
"            }\n"
"        },\n"
"        'root': {\n"
"            'level': 'DEBUG',\n"
"            'handlers': ['console', 'file', 'errors']\n"
"        },\n"
"    }\n"
"    workers = []\n"
"    for i in range(5):\n"
"        wp = Process(target=worker_process, name='worker %d' % (i + 1), args=(q,))\n"
"        workers.append(wp)\n"
"        wp.start()\n"
"    logging.config.dictConfig(d)\n"
"    lp = threading.Thread(target=logger_thread, args=(q,))\n"
"    lp.start()\n"
"    # At this point, the main process could do some useful work of its own\n"
"    # Once it's done that, it can wait for the workers to terminate...\n"
"    for wp in workers:\n"
"        wp.join()\n"
"    # And now tell the logging thread to finish up, too\n"
"    q.put(None)\n"
"    lp.join()"
msgstr ""

#: ../../howto/logging-cookbook.rst:1486
msgid ""
"This variant shows how you can e.g. apply configuration for particular "
"loggers - e.g. the ``foo`` logger has a special handler which stores all "
"events in the ``foo`` subsystem in a file ``mplog-foo.log``. This will be "
"used by the logging machinery in the main process (even though the logging "
"events are generated in the worker processes) to direct the messages to the "
"appropriate destinations."
msgstr ""
"这段变种的代码展示了如何使用特定的日志记录配置 - 例如 ``foo`` 记录器使用了特殊的处理程序，将 ``foo`` "
"子系统中所有的事件记录至一个文件 ``mplog-foo.log`` "
"。在主进程（即使是在工作进程中产生的日志事件）的日志记录机制中将直接使用恰当的配置。"

#: ../../howto/logging-cookbook.rst:1493
msgid "Using concurrent.futures.ProcessPoolExecutor"
msgstr "concurrent.futures.ProcessPoolExecutor 的用法"

#: ../../howto/logging-cookbook.rst:1495
msgid ""
"If you want to use :class:`concurrent.futures.ProcessPoolExecutor` to start "
"your worker processes, you need to create the queue slightly differently. "
"Instead of"
msgstr ""
"若要利用 :class:`concurrent.futures.ProcessPoolExecutor` "
"启动工作进程，创建队列的方式应稍有不同。不能是："

#: ../../howto/logging-cookbook.rst:1499
msgid "queue = multiprocessing.Queue(-1)"
msgstr "queue = multiprocessing.Queue(-1)"

#: ../../howto/logging-cookbook.rst:1503
msgid "you should use"
msgstr "而应是："

#: ../../howto/logging-cookbook.rst:1505
msgid ""
"queue = multiprocessing.Manager().Queue(-1)  # also works with the examples "
"above"
msgstr "queue = multiprocessing.Manager().Queue(-1)  # 同样适用于上面的例子"

#: ../../howto/logging-cookbook.rst:1509
msgid "and you can then replace the worker creation from this::"
msgstr "然后就可以将以下工作进程的创建过程："

#: ../../howto/logging-cookbook.rst:1511
msgid ""
"workers = []\n"
"for i in range(10):\n"
"    worker = multiprocessing.Process(target=worker_process,\n"
"                                     args=(queue, worker_configurer))\n"
"    workers.append(worker)\n"
"    worker.start()\n"
"for w in workers:\n"
"    w.join()"
msgstr ""
"workers = []\n"
"for i in range(10):\n"
"    worker = multiprocessing.Process(target=worker_process,\n"
"                                     args=(queue, worker_configurer))\n"
"    workers.append(worker)\n"
"    worker.start()\n"
"for w in workers:\n"
"    w.join()"

#: ../../howto/logging-cookbook.rst:1520
msgid "to this (remembering to first import :mod:`concurrent.futures`)::"
msgstr "改为 (记得要先导入 :mod:`concurrent.futures`)::"

#: ../../howto/logging-cookbook.rst:1522
msgid ""
"with concurrent.futures.ProcessPoolExecutor(max_workers=10) as executor:\n"
"    for i in range(10):\n"
"        executor.submit(worker_process, queue, worker_configurer)"
msgstr ""
"with concurrent.futures.ProcessPoolExecutor(max_workers=10) as executor:\n"
"    for i in range(10):\n"
"        executor.submit(worker_process, queue, worker_configurer)"

#: ../../howto/logging-cookbook.rst:1527
msgid "Deploying Web applications using Gunicorn and uWSGI"
msgstr "使用 Gunicorn 和 uWSGI 来部署 Web 应用程序"

#: ../../howto/logging-cookbook.rst:1529
msgid ""
"When deploying Web applications using `Gunicorn <https://gunicorn.org/>`_ or"
" `uWSGI <https://uwsgi-docs.readthedocs.io/en/latest/>`_ (or similar), "
"multiple worker processes are created to handle client requests. In such "
"environments, avoid creating file-based handlers directly in your web "
"application. Instead, use a :class:`SocketHandler` to log from the web "
"application to a listener in a separate process. This can be set up using a "
"process management tool such as Supervisor - see `Running a logging socket "
"listener in production`_ for more details."
msgstr ""
"当使用 `Gunicorn <https://gunicorn.org/>`_ 或 `uWSGI <https://uwsgi-"
"docs.readthedocs.io/en/latest/>`_ (或其他类似工具) 来部署 Web 应用时，会创建多个工作进程来处理客户端请求。 "
"在这种环境下，要避免在你的 Web 应用中直接创建基于文件的处理器。 而应改为使用一个 :class:`SocketHandler` 将来自 Web "
"应用的日志发送到在单独进程中运行的监听器。 这可以通过使用一个进程管理工具例如 Supervisor 来进行设置 —— 请参阅 `Running a "
"logging socket listener in production`_ 了解详情。"

#: ../../howto/logging-cookbook.rst:1539
msgid "Using file rotation"
msgstr "轮换日志文件"

#: ../../howto/logging-cookbook.rst:1544
msgid ""
"Sometimes you want to let a log file grow to a certain size, then open a new"
" file and log to that. You may want to keep a certain number of these files,"
" and when that many files have been created, rotate the files so that the "
"number of files and the size of the files both remain bounded. For this "
"usage pattern, the logging package provides a :class:`RotatingFileHandler`::"
msgstr ""
"有时您会希望让日志文件增长到一定大小，然后打开一个新的接着记录日志。 "
"您可能希望只保留一定数量的日志文件，当创建文件达到指定数量后将会轮换文件，从而使文件数量和文件大小都保持在一定范围之内。 "
"对于这种使用模式，日志包提供了一个 :class:`RotatingFileHandler`::"

#: ../../howto/logging-cookbook.rst:1550
msgid ""
"import glob\n"
"import logging\n"
"import logging.handlers\n"
"\n"
"LOG_FILENAME = 'logging_rotatingfile_example.out'\n"
"\n"
"# Set up a specific logger with our desired output level\n"
"my_logger = logging.getLogger('MyLogger')\n"
"my_logger.setLevel(logging.DEBUG)\n"
"\n"
"# Add the log message handler to the logger\n"
"handler = logging.handlers.RotatingFileHandler(\n"
"              LOG_FILENAME, maxBytes=20, backupCount=5)\n"
"\n"
"my_logger.addHandler(handler)\n"
"\n"
"# Log some messages\n"
"for i in range(20):\n"
"    my_logger.debug('i = %d' % i)\n"
"\n"
"# See what files are created\n"
"logfiles = glob.glob('%s*' % LOG_FILENAME)\n"
"\n"
"for filename in logfiles:\n"
"    print(filename)"
msgstr ""

#: ../../howto/logging-cookbook.rst:1576
msgid ""
"The result should be 6 separate files, each with part of the log history for"
" the application:"
msgstr "结果应该是6个单独的文件，每个文件都包含了应用程序的部分历史日志:"

#: ../../howto/logging-cookbook.rst:1579
msgid ""
"logging_rotatingfile_example.out\n"
"logging_rotatingfile_example.out.1\n"
"logging_rotatingfile_example.out.2\n"
"logging_rotatingfile_example.out.3\n"
"logging_rotatingfile_example.out.4\n"
"logging_rotatingfile_example.out.5"
msgstr ""
"logging_rotatingfile_example.out\n"
"logging_rotatingfile_example.out.1\n"
"logging_rotatingfile_example.out.2\n"
"logging_rotatingfile_example.out.3\n"
"logging_rotatingfile_example.out.4\n"
"logging_rotatingfile_example.out.5"

#: ../../howto/logging-cookbook.rst:1588
msgid ""
"The most current file is always :file:`logging_rotatingfile_example.out`, "
"and each time it reaches the size limit it is renamed with the suffix "
"``.1``. Each of the existing backup files is renamed to increment the suffix"
" (``.1`` becomes ``.2``, etc.)  and the ``.6`` file is erased."
msgstr ""
"最新的文件始终是 :file:`logging_rotatingfile_example.out`，每次到达大小限制时，都会使用后缀 ``.1`` "
"重命名。每个现有的备份文件都会被重命名并增加其后缀（例如 ``.1`` 变为 ``.2`` ），而 ``.6`` 文件会被删除掉。"

#: ../../howto/logging-cookbook.rst:1593
msgid ""
"Obviously this example sets the log length much too small as an extreme "
"example.  You would want to set *maxBytes* to an appropriate value."
msgstr "显然，这个例子将日志长度设置得太小，这是一个极端的例子。 你可能希望将 *maxBytes* 设置为一个合适的值。"

#: ../../howto/logging-cookbook.rst:1601
msgid "Use of alternative formatting styles"
msgstr "使用其他日志格式化方式"

#: ../../howto/logging-cookbook.rst:1603
msgid ""
"When logging was added to the Python standard library, the only way of "
"formatting messages with variable content was to use the %-formatting "
"method. Since then, Python has gained two new formatting approaches: "
":class:`string.Template` (added in Python 2.4) and :meth:`str.format` (added"
" in Python 2.6)."
msgstr ""
"当日志模块被添加至 Python 标准库时，只有一种格式化消息内容的方法即 %-formatting。 在那之后，Python 又增加了两种格式化方法:"
" :class:`string.Template` (在 Python 2.4 中新增) 和 :meth:`str.format` (在 Python "
"2.6 中新增)。"

#: ../../howto/logging-cookbook.rst:1609
msgid ""
"Logging (as of 3.2) provides improved support for these two additional "
"formatting styles. The :class:`Formatter` class been enhanced to take an "
"additional, optional keyword parameter named ``style``. This defaults to "
"``'%'``, but other possible values are ``'{'`` and ``'$'``, which correspond"
" to the other two formatting styles. Backwards compatibility is maintained "
"by default (as you would expect), but by explicitly specifying a style "
"parameter, you get the ability to specify format strings which work with "
":meth:`str.format` or :class:`string.Template`. Here's an example console "
"session to show the possibilities:"
msgstr ""
"日志（从 3.2 开始）为这两种格式化方式提供了更多支持。:class:`Formatter` 类可以添加一个额外的可选关键字参数 "
"``style``。它的默认值是 ``'%'``，其他的值 ``'{'`` 和 ``'$'`` "
"也支持，对应了其他两种格式化样式。其保持了向后兼容（如您所愿），但通过显示指定样式参数，你可以指定格式化字符串的方式是使用 "
":meth:`str.format` 或 :class:`string.Template`。 这里是一个控制台会话的示例，展示了这些方式："

#: ../../howto/logging-cookbook.rst:1619
msgid ""
">>> import logging\n"
">>> root = logging.getLogger()\n"
">>> root.setLevel(logging.DEBUG)\n"
">>> handler = logging.StreamHandler()\n"
">>> bf = logging.Formatter('{asctime} {name} {levelname:8s} {message}',\n"
"...                        style='{')\n"
">>> handler.setFormatter(bf)\n"
">>> root.addHandler(handler)\n"
">>> logger = logging.getLogger('foo.bar')\n"
">>> logger.debug('This is a DEBUG message')\n"
"2010-10-28 15:11:55,341 foo.bar DEBUG    This is a DEBUG message\n"
">>> logger.critical('This is a CRITICAL message')\n"
"2010-10-28 15:12:11,526 foo.bar CRITICAL This is a CRITICAL message\n"
">>> df = logging.Formatter('$asctime $name ${levelname} $message',\n"
"...                        style='$')\n"
">>> handler.setFormatter(df)\n"
">>> logger.debug('This is a DEBUG message')\n"
"2010-10-28 15:13:06,924 foo.bar DEBUG This is a DEBUG message\n"
">>> logger.critical('This is a CRITICAL message')\n"
"2010-10-28 15:13:11,494 foo.bar CRITICAL This is a CRITICAL message\n"
">>>"
msgstr ""
">>> import logging\n"
">>> root = logging.getLogger()\n"
">>> root.setLevel(logging.DEBUG)\n"
">>> handler = logging.StreamHandler()\n"
">>> bf = logging.Formatter('{asctime} {name} {levelname:8s} {message}',\n"
"...                        style='{')\n"
">>> handler.setFormatter(bf)\n"
">>> root.addHandler(handler)\n"
">>> logger = logging.getLogger('foo.bar')\n"
">>> logger.debug('This is a DEBUG message')\n"
"2010-10-28 15:11:55,341 foo.bar DEBUG    This is a DEBUG message\n"
">>> logger.critical('This is a CRITICAL message')\n"
"2010-10-28 15:12:11,526 foo.bar CRITICAL This is a CRITICAL message\n"
">>> df = logging.Formatter('$asctime $name ${levelname} $message',\n"
"...                        style='$')\n"
">>> handler.setFormatter(df)\n"
">>> logger.debug('This is a DEBUG message')\n"
"2010-10-28 15:13:06,924 foo.bar DEBUG This is a DEBUG message\n"
">>> logger.critical('This is a CRITICAL message')\n"
"2010-10-28 15:13:11,494 foo.bar CRITICAL This is a CRITICAL message\n"
">>>"

#: ../../howto/logging-cookbook.rst:1643
msgid ""
"Note that the formatting of logging messages for final output to logs is "
"completely independent of how an individual logging message is constructed. "
"That can still use %-formatting, as shown here::"
msgstr "请注意最终输出到日志的消息格式完全独立于单条日志消息的构造方式。 它仍然可以使用 %-formatting，如下所示::"

#: ../../howto/logging-cookbook.rst:1647
msgid ""
">>> logger.error('This is an%s %s %s', 'other,', 'ERROR,', 'message')\n"
"2010-10-28 15:19:29,833 foo.bar ERROR This is another, ERROR, message\n"
">>>"
msgstr ""
">>> logger.error('This is an%s %s %s', 'other,', 'ERROR,', 'message')\n"
"2010-10-28 15:19:29,833 foo.bar ERROR This is another, ERROR, message\n"
">>>"

#: ../../howto/logging-cookbook.rst:1651
msgid ""
"Logging calls (``logger.debug()``, ``logger.info()`` etc.) only take "
"positional parameters for the actual logging message itself, with keyword "
"parameters used only for determining options for how to handle the actual "
"logging call (e.g. the ``exc_info`` keyword parameter to indicate that "
"traceback information should be logged, or the ``extra`` keyword parameter "
"to indicate additional contextual information to be added to the log). So "
"you cannot directly make logging calls using :meth:`str.format` or "
":class:`string.Template` syntax, because internally the logging package uses"
" %-formatting to merge the format string and the variable arguments. There "
"would be no changing this while preserving backward compatibility, since all"
" logging calls which are out there in existing code will be using %-format "
"strings."
msgstr ""
"日志调用（``logger.debug()`` 、``logger.info()`` "
"等）接受的位置参数只会用于日志信息本身，而关键字参数仅用于日志调用的可选处理参数（如关键字参数 ``exc_info`` 表示应记录跟踪信息， "
"``extra`` 则标识了需要加入日志的额外上下文信息）。所以不能直接用 :meth:`str.format` 或 "
":class:`string.Template` 语法进行日志调用，因为日志包在内部使用 %-f "
"格式来合并格式串和参数变量。在保持向下兼容性时，这一点不会改变，因为已有代码中的所有日志调用都会使用%-f 格式串。"

#: ../../howto/logging-cookbook.rst:1664
msgid ""
"There is, however, a way that you can use {}- and $- formatting to construct"
" your individual log messages. Recall that for a message you can use an "
"arbitrary object as a message format string, and that the logging package "
"will call ``str()`` on that object to get the actual format string. Consider"
" the following two classes::"
msgstr ""
"还有一种方法可以构建自己的日志信息，就是利用 {}- 和 $- 格式。回想一下，任意对象都可用为日志信息的格式串，日志包将会调用该对象的 "
"``str()`` 方法，以获取最终的格式串。不妨看下一下两个类："

#: ../../howto/logging-cookbook.rst:1670 ../../howto/logging-cookbook.rst:2758
msgid ""
"class BraceMessage:\n"
"    def __init__(self, fmt, /, *args, **kwargs):\n"
"        self.fmt = fmt\n"
"        self.args = args\n"
"        self.kwargs = kwargs\n"
"\n"
"    def __str__(self):\n"
"        return self.fmt.format(*self.args, **self.kwargs)\n"
"\n"
"class DollarMessage:\n"
"    def __init__(self, fmt, /, **kwargs):\n"
"        self.fmt = fmt\n"
"        self.kwargs = kwargs\n"
"\n"
"    def __str__(self):\n"
"        from string import Template\n"
"        return Template(self.fmt).substitute(**self.kwargs)"
msgstr ""
"class BraceMessage:\n"
"    def __init__(self, fmt, /, *args, **kwargs):\n"
"        self.fmt = fmt\n"
"        self.args = args\n"
"        self.kwargs = kwargs\n"
"\n"
"    def __str__(self):\n"
"        return self.fmt.format(*self.args, **self.kwargs)\n"
"\n"
"class DollarMessage:\n"
"    def __init__(self, fmt, /, **kwargs):\n"
"        self.fmt = fmt\n"
"        self.kwargs = kwargs\n"
"\n"
"    def __str__(self):\n"
"        from string import Template\n"
"        return Template(self.fmt).substitute(**self.kwargs)"

#: ../../howto/logging-cookbook.rst:1688
msgid ""
"Either of these can be used in place of a format string, to allow {}- or "
"$-formatting to be used to build the actual \"message\" part which appears "
"in the formatted log output in place of \"%(message)s\" or \"{message}\" or "
"\"$message\". It's a little unwieldy to use the class names whenever you "
"want to log something, but it's quite palatable if you use an alias such as "
"__ (double underscore --- not to be confused with _, the single underscore "
"used as a synonym/alias for :func:`gettext.gettext` or its brethren)."
msgstr ""
"上述两个类均可代替格式串，使得能用 {}- 或 $-formatting 构建最终的“日志信息”部分，这些信息将出现在格式化后的日志输出中，替换 "
"%(message)s 或“{message}”或“$message”。每次写入日志时都要使用类名，有点不大实用，但如果用上 __ "
"之类的别名就相当合适了（双下划线 --- 不要与 _ 混淆，单下划线用作 :func:`gettext.gettext` 或相关函数的同义词/别名 ）。"

#: ../../howto/logging-cookbook.rst:1696
msgid ""
"The above classes are not included in Python, though they're easy enough to "
"copy and paste into your own code. They can be used as follows (assuming "
"that they're declared in a module called ``wherever``):"
msgstr "Python 并没有上述两个类，当然复制粘贴到自己的代码中也很容易。用法可如下所示（假定在名为 ``wherever`` 的模块中声明）："

#: ../../howto/logging-cookbook.rst:1700
msgid ""
">>> from wherever import BraceMessage as __\n"
">>> print(__('Message with {0} {name}', 2, name='placeholders'))\n"
"Message with 2 placeholders\n"
">>> class Point: pass\n"
"...\n"
">>> p = Point()\n"
">>> p.x = 0.5\n"
">>> p.y = 0.5\n"
">>> print(__('Message with coordinates: ({point.x:.2f}, {point.y:.2f})',\n"
"...       point=p))\n"
"Message with coordinates: (0.50, 0.50)\n"
">>> from wherever import DollarMessage as __\n"
">>> print(__('Message with $num $what', num=2, what='placeholders'))\n"
"Message with 2 placeholders\n"
">>>"
msgstr ""
">>> from wherever import BraceMessage as __\n"
">>> print(__('Message with {0} {name}', 2, name='placeholders'))\n"
"Message with 2 placeholders\n"
">>> class Point: pass\n"
"...\n"
">>> p = Point()\n"
">>> p.x = 0.5\n"
">>> p.y = 0.5\n"
">>> print(__('Message with coordinates: ({point.x:.2f}, {point.y:.2f})',\n"
"...       point=p))\n"
"Message with coordinates: (0.50, 0.50)\n"
">>> from wherever import DollarMessage as __\n"
">>> print(__('Message with $num $what', num=2, what='placeholders'))\n"
"Message with 2 placeholders\n"
">>>"

#: ../../howto/logging-cookbook.rst:1718
msgid ""
"While the above examples use ``print()`` to show how the formatting works, "
"you would of course use ``logger.debug()`` or similar to actually log using "
"this approach."
msgstr ""
"上述示例用了 ``print()`` 演示格式化输出的过程，实际记录日志时当然会用类似 ``logger.debug()`` 的方法来应用。"

#: ../../howto/logging-cookbook.rst:1722
msgid ""
"One thing to note is that you pay no significant performance penalty with "
"this approach: the actual formatting happens not when you make the logging "
"call, but when (and if) the logged message is actually about to be output to"
" a log by a handler. So the only slightly unusual thing which might trip you"
" up is that the parentheses go around the format string and the arguments, "
"not just the format string. That's because the __ notation is just syntax "
"sugar for a constructor call to one of the :samp:`{XXX}Message` classes."
msgstr ""
"需要注意的是使用这种方式不会对性能造成明显影响：实际的格式化工作不是在日志记录调用时发生的，而是在（如果）处理器即将把日志消息输出到日志时发生的。 "
"因此，唯一可能令人困惑的不寻常之处在于包裹在格式字符串和参数外面的圆括号，而不仅仅是格式字符串。 这是因为 __ 标记只是对 "
":samp:`{XXX}Message` 类的构造器的调用的语法糖。"

#: ../../howto/logging-cookbook.rst:1730
msgid ""
"If you prefer, you can use a :class:`LoggerAdapter` to achieve a similar "
"effect to the above, as in the following example::"
msgstr "只要愿意，上述类似的效果即可用 :class:`LoggerAdapter` 实现，如下例所示："

#: ../../howto/logging-cookbook.rst:1733
msgid ""
"import logging\n"
"\n"
"class Message:\n"
"    def __init__(self, fmt, args):\n"
"        self.fmt = fmt\n"
"        self.args = args\n"
"\n"
"    def __str__(self):\n"
"        return self.fmt.format(*self.args)\n"
"\n"
"class StyleAdapter(logging.LoggerAdapter):\n"
"    def log(self, level, msg, /, *args, stacklevel=1, **kwargs):\n"
"        if self.isEnabledFor(level):\n"
"            msg, kwargs = self.process(msg, kwargs)\n"
"            self.logger.log(level, Message(msg, args), **kwargs,\n"
"                            stacklevel=stacklevel+1)\n"
"\n"
"logger = StyleAdapter(logging.getLogger(__name__))\n"
"\n"
"def main():\n"
"    logger.debug('Hello, {}', 'world!')\n"
"\n"
"if __name__ == '__main__':\n"
"    logging.basicConfig(level=logging.DEBUG)\n"
"    main()"
msgstr ""
"import logging\n"
"\n"
"class Message:\n"
"    def __init__(self, fmt, args):\n"
"        self.fmt = fmt\n"
"        self.args = args\n"
"\n"
"    def __str__(self):\n"
"        return self.fmt.format(*self.args)\n"
"\n"
"class StyleAdapter(logging.LoggerAdapter):\n"
"    def log(self, level, msg, /, *args, stacklevel=1, **kwargs):\n"
"        if self.isEnabledFor(level):\n"
"            msg, kwargs = self.process(msg, kwargs)\n"
"            self.logger.log(level, Message(msg, args), **kwargs,\n"
"                            stacklevel=stacklevel+1)\n"
"\n"
"logger = StyleAdapter(logging.getLogger(__name__))\n"
"\n"
"def main():\n"
"    logger.debug('Hello, {}', 'world!')\n"
"\n"
"if __name__ == '__main__':\n"
"    logging.basicConfig(level=logging.DEBUG)\n"
"    main()"

#: ../../howto/logging-cookbook.rst:1759
msgid ""
"The above script should log the message ``Hello, world!`` when run with "
"Python 3.8 or later."
msgstr "在用 Python 3.8 以上版本运行时上述脚本应该会将消息 ``Hello, world!`` 写入日志。"

#: ../../howto/logging-cookbook.rst:1768
msgid "Customizing ``LogRecord``"
msgstr "自定义 ``LogRecord``"

#: ../../howto/logging-cookbook.rst:1770
msgid ""
"Every logging event is represented by a :class:`LogRecord` instance. When an"
" event is logged and not filtered out by a logger's level, a "
":class:`LogRecord` is created, populated with information about the event "
"and then passed to the handlers for that logger (and its ancestors, up to "
"and including the logger where further propagation up the hierarchy is "
"disabled). Before Python 3.2, there were only two places where this creation"
" was done:"
msgstr ""
"每条日志事件都由一个  :class:`LogRecord` 实例表示。当某事件要记入日志并且没有被某级别过滤掉时，就会创建一个 "
":class:`LogRecord` 对象，并将有关事件的信息填入，传给该日志对象的 handler（及其祖先，直至对象禁止向上传播为止）。在 "
"Python 3.2 之前，只有两个地方会进行事件的创建："

#: ../../howto/logging-cookbook.rst:1777
msgid ""
":meth:`Logger.makeRecord`, which is called in the normal process of logging "
"an event. This invoked :class:`LogRecord` directly to create an instance."
msgstr ""
":meth:`Logger.makeRecord`，在事件正常记入日志的过程中调用。这会直接调用 :class:`LogRecord` 来创建一个实例。"

#: ../../howto/logging-cookbook.rst:1780
msgid ""
":func:`makeLogRecord`, which is called with a dictionary containing "
"attributes to be added to the LogRecord. This is typically invoked when a "
"suitable dictionary has been received over the network (e.g. in pickle form "
"via a :class:`~handlers.SocketHandler`, or in JSON form via an "
":class:`~handlers.HTTPHandler`)."
msgstr ""
":func:`makeLogRecord`，调用时会带上一个字典参数，其中存放着要加入 LogRecord "
"的属性。这通常在通过网络接收到合适的字典时调用（如通过 :class:`~handlers.SocketHandler` 以 pickle 形式，或通过"
" :class:`~handlers.HTTPHandler` 以 JSON 形式）。"

#: ../../howto/logging-cookbook.rst:1786
msgid ""
"This has usually meant that if you need to do anything special with a "
":class:`LogRecord`, you've had to do one of the following."
msgstr "于是这意味着若要对 :class:`LogRecord` 进行定制，必须进行下述某种操作。"

#: ../../howto/logging-cookbook.rst:1789
msgid ""
"Create your own :class:`Logger` subclass, which overrides "
":meth:`Logger.makeRecord`, and set it using :func:`~logging.setLoggerClass` "
"before any loggers that you care about are instantiated."
msgstr ""
"创建 :class:`Logger`  自定义子类，重写 :meth:`Logger.makeRecord`，并在实例化所需日志对象之前用 "
":func:`~logging.setLoggerClass` 进行设置。"

#: ../../howto/logging-cookbook.rst:1792
msgid ""
"Add a :class:`Filter` to a logger or handler, which does the necessary "
"special manipulation you need when its :meth:`~Filter.filter` method is "
"called."
msgstr ""
"为日志对象添加 :class:`Filter` 或 handler，当其 :meth:`~Filter.filter` "
"方法被调用时，会执行必要的定制操作。"

#: ../../howto/logging-cookbook.rst:1796
msgid ""
"The first approach would be a little unwieldy in the scenario where (say) "
"several different libraries wanted to do different things. Each would "
"attempt to set its own :class:`Logger` subclass, and the one which did this "
"last would win."
msgstr ""
"比如说在有多个不同库要完成不同操作的场景下，第一种方式会有点笨拙。 每次都要尝试设置自己的 :class:`Logger` "
"子类，而起作用的是最后一次尝试。"

#: ../../howto/logging-cookbook.rst:1801
msgid ""
"The second approach works reasonably well for many cases, but does not allow"
" you to e.g. use a specialized subclass of :class:`LogRecord`. Library "
"developers can set a suitable filter on their loggers, but they would have "
"to remember to do this every time they introduced a new logger (which they "
"would do simply by adding new packages or modules and doing ::"
msgstr ""
"第二种方式在多数情况下效果都比较良好，但不允许你使用特殊化的 :class:`LogRecord` 子类。 "
"库开发者可以为他们的日志记录器设置合适的过滤器，但他们应当要记得每次引入新的日志记录器时都需如此（他们只需通过添加新的包或模块并执行以下操作即可）::"

#: ../../howto/logging-cookbook.rst:1807
msgid "logger = logging.getLogger(__name__)"
msgstr "logger = logging.getLogger(__name__)"

#: ../../howto/logging-cookbook.rst:1809
msgid ""
"at module level). It's probably one too many things to think about. "
"Developers could also add the filter to a :class:`~logging.NullHandler` "
"attached to their top-level logger, but this would not be invoked if an "
"application developer attached a handler to a lower-level library logger ---"
" so output from that handler would not reflect the intentions of the library"
" developer."
msgstr ""
"或许这样要顾及太多事情。开发人员还可以将过滤器附加到其顶级日志对象的 :class:`~logging.NullHandler` "
"中，但如果应用程序开发人员将 handler 附加到较底层库的日志对象，则不会调用该过滤器 --- 所以 handler "
"输出的内容不会符合库开发人员的预期。"

#: ../../howto/logging-cookbook.rst:1815
msgid ""
"In Python 3.2 and later, :class:`~logging.LogRecord` creation is done "
"through a factory, which you can specify. The factory is just a callable you"
" can set with :func:`~logging.setLogRecordFactory`, and interrogate with "
":func:`~logging.getLogRecordFactory`. The factory is invoked with the same "
"signature as the :class:`~logging.LogRecord` constructor, as "
":class:`LogRecord` is the default setting for the factory."
msgstr ""
"在 Python 3.2 以上版本中，:class:`~logging.LogRecord` "
"的创建是通过工厂对象完成的，工厂对象可以指定。工厂对象只是一个可调用对象，可以用 "
":func:`~logging.setLogRecordFactory` 进行设置，并用 "
":func:`~logging.getLogRecordFactory` 进行查询。工厂对象的调用参数与 "
":class:`~logging.LogRecord` 的构造函数相同，因为 :class:`LogRecord` 是工厂对象的默认设置。"

#: ../../howto/logging-cookbook.rst:1822
msgid ""
"This approach allows a custom factory to control all aspects of LogRecord "
"creation. For example, you could return a subclass, or just add some "
"additional attributes to the record once created, using a pattern similar to"
" this::"
msgstr ""
"这种方式可以让自定义工厂对象完全控制 LogRecord 的创建过程。比如可以返回一个子类，或者在创建的日志对象中加入一些额外的属性，使用方式如下所示："

#: ../../howto/logging-cookbook.rst:1826
msgid ""
"old_factory = logging.getLogRecordFactory()\n"
"\n"
"def record_factory(*args, **kwargs):\n"
"    record = old_factory(*args, **kwargs)\n"
"    record.custom_attribute = 0xdecafbad\n"
"    return record\n"
"\n"
"logging.setLogRecordFactory(record_factory)"
msgstr ""
"old_factory = logging.getLogRecordFactory()\n"
"\n"
"def record_factory(*args, **kwargs):\n"
"    record = old_factory(*args, **kwargs)\n"
"    record.custom_attribute = 0xdecafbad\n"
"    return record\n"
"\n"
"logging.setLogRecordFactory(record_factory)"

#: ../../howto/logging-cookbook.rst:1835
msgid ""
"This pattern allows different libraries to chain factories together, and as "
"long as they don't overwrite each other's attributes or unintentionally "
"overwrite the attributes provided as standard, there should be no surprises."
" However, it should be borne in mind that each link in the chain adds run-"
"time overhead to all logging operations, and the technique should only be "
"used when the use of a :class:`Filter` does not provide the desired result."
msgstr ""
"这种模式允许不同的库将多个工厂对象链在一起，只要不会覆盖彼此的属性或标准属性，就不会出现意外。但应记住，工厂链中的每个节点都会增加日志操作的运行开销，本技术仅在采用"
" :class:`Filter` 无法达到目标时才应使用。"

#: ../../howto/logging-cookbook.rst:1847
msgid "Subclassing QueueHandler and QueueListener- a ZeroMQ example"
msgstr "子类化 QueueHandler 和 QueueListener - ZeroMQ 示例"

#: ../../howto/logging-cookbook.rst:1850 ../../howto/logging-cookbook.rst:1983
msgid "Subclass ``QueueHandler``"
msgstr "子类 ``QueueHandler``"

#: ../../howto/logging-cookbook.rst:1852
msgid ""
"You can use a :class:`QueueHandler` subclass to send messages to other kinds"
" of queues, for example a ZeroMQ 'publish' socket. In the example below,the "
"socket is created separately and passed to the handler (as its 'queue')::"
msgstr ""
"你可以使用 :class:`QueueHandler` 子类将消息发送给其他类型的队列 ，比如 ZeroMQ 'publish' 套接字。 "
"在以下示例中，套接字将单独创建并传给处理器 (作为它的 'queue')::"

#: ../../howto/logging-cookbook.rst:1856
msgid ""
"import zmq   # using pyzmq, the Python binding for ZeroMQ\n"
"import json  # for serializing records portably\n"
"\n"
"ctx = zmq.Context()\n"
"sock = zmq.Socket(ctx, zmq.PUB)  # or zmq.PUSH, or other suitable value\n"
"sock.bind('tcp://*:5556')        # or wherever\n"
"\n"
"class ZeroMQSocketHandler(QueueHandler):\n"
"    def enqueue(self, record):\n"
"        self.queue.send_json(record.__dict__)\n"
"\n"
"\n"
"handler = ZeroMQSocketHandler(sock)"
msgstr ""
"import zmq   # 使用 pyzmq，这是 ZeroMQ 的 Python 绑定\n"
"import json  # 用于可移植地对记录进行序列化\n"
"\n"
"ctx = zmq.Context()\n"
"sock = zmq.Socket(ctx, zmq.PUB)  # 或 zmq.PUSH，或其他适当的值\n"
"sock.bind('tcp://*:5556')        # 或任何值\n"
"\n"
"class ZeroMQSocketHandler(QueueHandler):\n"
"    def enqueue(self, record):\n"
"        self.queue.send_json(record.__dict__)\n"
"\n"
"\n"
"handler = ZeroMQSocketHandler(sock)"

#: ../../howto/logging-cookbook.rst:1871
msgid ""
"Of course there are other ways of organizing this, for example passing in "
"the data needed by the handler to create the socket::"
msgstr "当然还有其他方案，比如通过 hander 传入所需数据，以创建 socket："

#: ../../howto/logging-cookbook.rst:1874
msgid ""
"class ZeroMQSocketHandler(QueueHandler):\n"
"    def __init__(self, uri, socktype=zmq.PUB, ctx=None):\n"
"        self.ctx = ctx or zmq.Context()\n"
"        socket = zmq.Socket(self.ctx, socktype)\n"
"        socket.bind(uri)\n"
"        super().__init__(socket)\n"
"\n"
"    def enqueue(self, record):\n"
"        self.queue.send_json(record.__dict__)\n"
"\n"
"    def close(self):\n"
"        self.queue.close()"
msgstr ""
"class ZeroMQSocketHandler(QueueHandler):\n"
"    def __init__(self, uri, socktype=zmq.PUB, ctx=None):\n"
"        self.ctx = ctx or zmq.Context()\n"
"        socket = zmq.Socket(self.ctx, socktype)\n"
"        socket.bind(uri)\n"
"        super().__init__(socket)\n"
"\n"
"    def enqueue(self, record):\n"
"        self.queue.send_json(record.__dict__)\n"
"\n"
"    def close(self):\n"
"        self.queue.close()"

#: ../../howto/logging-cookbook.rst:1889 ../../howto/logging-cookbook.rst:1919
msgid "Subclass ``QueueListener``"
msgstr "子类 ``QueueListener``"

#: ../../howto/logging-cookbook.rst:1891
msgid ""
"You can also subclass :class:`QueueListener` to get messages from other "
"kinds of queues, for example a ZeroMQ 'subscribe' socket. Here's an "
"example::"
msgstr ""
"你还可以子类化 :class:`QueueListener` 来从其他类型的队列中获取消息，比如从 ZeroMQ 'subscribe' 套接字。 "
"下面是一个例子::"

#: ../../howto/logging-cookbook.rst:1894
msgid ""
"class ZeroMQSocketListener(QueueListener):\n"
"    def __init__(self, uri, /, *handlers, **kwargs):\n"
"        self.ctx = kwargs.get('ctx') or zmq.Context()\n"
"        socket = zmq.Socket(self.ctx, zmq.SUB)\n"
"        socket.setsockopt_string(zmq.SUBSCRIBE, '')  # subscribe to everything\n"
"        socket.connect(uri)\n"
"        super().__init__(socket, *handlers, **kwargs)\n"
"\n"
"    def dequeue(self):\n"
"        msg = self.queue.recv_json()\n"
"        return logging.makeLogRecord(msg)"
msgstr ""
"class ZeroMQSocketListener(QueueListener):\n"
"    def __init__(self, uri, /, *handlers, **kwargs):\n"
"        self.ctx = kwargs.get('ctx') or zmq.Context()\n"
"        socket = zmq.Socket(self.ctx, zmq.SUB)\n"
"        socket.setsockopt_string(zmq.SUBSCRIBE, '')  # 全部预订\n"
"        socket.connect(uri)\n"
"        super().__init__(socket, *handlers, **kwargs)\n"
"\n"
"    def dequeue(self):\n"
"        msg = self.queue.recv_json()\n"
"        return logging.makeLogRecord(msg)"

#: ../../howto/logging-cookbook.rst:1909
msgid "Subclassing QueueHandler and QueueListener- a ``pynng`` example"
msgstr "子类化 QueueHandler 和 QueueListener - ``pynng`` 示例"

#: ../../howto/logging-cookbook.rst:1911
msgid ""
"In a similar way to the above section, we can implement a listener and "
"handler using :pypi:`pynng`, which is a Python binding to `NNG "
"<https://nng.nanomsg.org/>`_, billed as a spiritual successor to ZeroMQ. The"
" following snippets illustrate -- you can test them in an environment which "
"has ``pynng`` installed. Just for variety, we present the listener first."
msgstr ""
"通过与上一节类似的方式，我们可以使用 :pypi:`pynng` 来实现监听器和处理器，这个包是针对 `NNG "
"<https://nng.nanomsg.org/>`_ 的 Python 绑定，它被确定为 ZeroMQ 的精神后继者。 以下代码片段被用作演示 --"
" 你可以在安装了 ``pynng`` 的环境中测试它们。 为增加变化，我们先编写监听器。"

#: ../../howto/logging-cookbook.rst:1921
msgid ""
"# listener.py\n"
"import json\n"
"import logging\n"
"import logging.handlers\n"
"\n"
"import pynng\n"
"\n"
"DEFAULT_ADDR = \"tcp://localhost:13232\"\n"
"\n"
"interrupted = False\n"
"\n"
"class NNGSocketListener(logging.handlers.QueueListener):\n"
"\n"
"    def __init__(self, uri, /, *handlers, **kwargs):\n"
"        # Have a timeout for interruptability, and open a\n"
"        # subscriber socket\n"
"        socket = pynng.Sub0(listen=uri, recv_timeout=500)\n"
"        # The b'' subscription matches all topics\n"
"        topics = kwargs.pop('topics', None) or b''\n"
"        socket.subscribe(topics)\n"
"        # We treat the socket as a queue\n"
"        super().__init__(socket, *handlers, **kwargs)\n"
"\n"
"    def dequeue(self, block):\n"
"        data = None\n"
"        # Keep looping while not interrupted and no data received over the\n"
"        # socket\n"
"        while not interrupted:\n"
"            try:\n"
"                data = self.queue.recv(block=block)\n"
"                break\n"
"            except pynng.Timeout:\n"
"                pass\n"
"            except pynng.Closed:  # sometimes happens when you hit Ctrl-C\n"
"                break\n"
"        if data is None:\n"
"            return None\n"
"        # Get the logging event sent from a publisher\n"
"        event = json.loads(data.decode('utf-8'))\n"
"        return logging.makeLogRecord(event)\n"
"\n"
"    def enqueue_sentinel(self):\n"
"        # Not used in this implementation, as the socket isn't really a\n"
"        # queue\n"
"        pass\n"
"\n"
"logging.getLogger('pynng').propagate = False\n"
"listener = NNGSocketListener(DEFAULT_ADDR, logging.StreamHandler(), topics=b'')\n"
"listener.start()\n"
"print('Press Ctrl-C to stop.')\n"
"try:\n"
"    while True:\n"
"        pass\n"
"except KeyboardInterrupt:\n"
"    interrupted = True\n"
"finally:\n"
"    listener.stop()"
msgstr ""

#: ../../howto/logging-cookbook.rst:1987
msgid ""
"# sender.py\n"
"import json\n"
"import logging\n"
"import logging.handlers\n"
"import time\n"
"import random\n"
"\n"
"import pynng\n"
"\n"
"DEFAULT_ADDR = \"tcp://localhost:13232\"\n"
"\n"
"class NNGSocketHandler(logging.handlers.QueueHandler):\n"
"\n"
"    def __init__(self, uri):\n"
"        socket = pynng.Pub0(dial=uri, send_timeout=500)\n"
"        super().__init__(socket)\n"
"\n"
"    def enqueue(self, record):\n"
"        # Send the record as UTF-8 encoded JSON\n"
"        d = dict(record.__dict__)\n"
"        data = json.dumps(d)\n"
"        self.queue.send(data.encode('utf-8'))\n"
"\n"
"    def close(self):\n"
"        self.queue.close()\n"
"\n"
"logging.getLogger('pynng').propagate = False\n"
"handler = NNGSocketHandler(DEFAULT_ADDR)\n"
"# Make sure the process ID is in the output\n"
"logging.basicConfig(level=logging.DEBUG,\n"
"                    handlers=[logging.StreamHandler(), handler],\n"
"                    format='%(levelname)-8s %(name)10s %(process)6s %(message)s')\n"
"levels = (logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR,\n"
"          logging.CRITICAL)\n"
"logger_names = ('myapp', 'myapp.lib1', 'myapp.lib2')\n"
"msgno = 1\n"
"while True:\n"
"    # Just randomly select some loggers and levels and log away\n"
"    level = random.choice(levels)\n"
"    logger = logging.getLogger(random.choice(logger_names))\n"
"    logger.log(level, 'Message no. %5d' % msgno)\n"
"    msgno += 1\n"
"    delay = random.random() * 2 + 0.5\n"
"    time.sleep(delay)"
msgstr ""

#: ../../howto/logging-cookbook.rst:2034
msgid ""
"You can run the above two snippets in separate command shells. If we run the"
" listener in one shell and run the sender in two separate shells, we should "
"see something like the following. In the first sender shell:"
msgstr ""
"你可以在不同的命令行 shell 中运行上面两个代码片段。 如果我们在一个 shell 中运行监听器并在两个不同的 shell "
"中运行发送器，我们将看到如下的结果。 在第一个发送器 shell 中："

#: ../../howto/logging-cookbook.rst:2038
msgid ""
"$ python sender.py\n"
"DEBUG         myapp    613 Message no.     1\n"
"WARNING  myapp.lib2    613 Message no.     2\n"
"CRITICAL myapp.lib2    613 Message no.     3\n"
"WARNING  myapp.lib2    613 Message no.     4\n"
"CRITICAL myapp.lib1    613 Message no.     5\n"
"DEBUG         myapp    613 Message no.     6\n"
"CRITICAL myapp.lib1    613 Message no.     7\n"
"INFO     myapp.lib1    613 Message no.     8\n"
"(and so on)"
msgstr ""
"$ python sender.py\n"
"DEBUG         myapp    613 Message no.     1\n"
"WARNING  myapp.lib2    613 Message no.     2\n"
"CRITICAL myapp.lib2    613 Message no.     3\n"
"WARNING  myapp.lib2    613 Message no.     4\n"
"CRITICAL myapp.lib1    613 Message no.     5\n"
"DEBUG         myapp    613 Message no.     6\n"
"CRITICAL myapp.lib1    613 Message no.     7\n"
"INFO     myapp.lib1    613 Message no.     8\n"
"(下略)"

#: ../../howto/logging-cookbook.rst:2051
msgid "In the second sender shell:"
msgstr "在第二个发送器 shell 中："

#: ../../howto/logging-cookbook.rst:2053
msgid ""
"$ python sender.py\n"
"INFO     myapp.lib2    657 Message no.     1\n"
"CRITICAL myapp.lib2    657 Message no.     2\n"
"CRITICAL      myapp    657 Message no.     3\n"
"CRITICAL myapp.lib1    657 Message no.     4\n"
"INFO     myapp.lib1    657 Message no.     5\n"
"WARNING  myapp.lib2    657 Message no.     6\n"
"CRITICAL      myapp    657 Message no.     7\n"
"DEBUG    myapp.lib1    657 Message no.     8\n"
"(and so on)"
msgstr ""
"$ python sender.py\n"
"INFO     myapp.lib2    657 Message no.     1\n"
"CRITICAL myapp.lib2    657 Message no.     2\n"
"CRITICAL      myapp    657 Message no.     3\n"
"CRITICAL myapp.lib1    657 Message no.     4\n"
"INFO     myapp.lib1    657 Message no.     5\n"
"WARNING  myapp.lib2    657 Message no.     6\n"
"CRITICAL      myapp    657 Message no.     7\n"
"DEBUG    myapp.lib1    657 Message no.     8\n"
"(下略)"

#: ../../howto/logging-cookbook.rst:2066
msgid "In the listener shell:"
msgstr "在监听器 shell 中："

#: ../../howto/logging-cookbook.rst:2068
msgid ""
"$ python listener.py\n"
"Press Ctrl-C to stop.\n"
"DEBUG         myapp    613 Message no.     1\n"
"WARNING  myapp.lib2    613 Message no.     2\n"
"INFO     myapp.lib2    657 Message no.     1\n"
"CRITICAL myapp.lib2    613 Message no.     3\n"
"CRITICAL myapp.lib2    657 Message no.     2\n"
"CRITICAL      myapp    657 Message no.     3\n"
"WARNING  myapp.lib2    613 Message no.     4\n"
"CRITICAL myapp.lib1    613 Message no.     5\n"
"CRITICAL myapp.lib1    657 Message no.     4\n"
"INFO     myapp.lib1    657 Message no.     5\n"
"DEBUG         myapp    613 Message no.     6\n"
"WARNING  myapp.lib2    657 Message no.     6\n"
"CRITICAL      myapp    657 Message no.     7\n"
"CRITICAL myapp.lib1    613 Message no.     7\n"
"INFO     myapp.lib1    613 Message no.     8\n"
"DEBUG    myapp.lib1    657 Message no.     8\n"
"(and so on)"
msgstr ""
"$ python listener.py\n"
"Press Ctrl-C to stop.\n"
"DEBUG         myapp    613 Message no.     1\n"
"WARNING  myapp.lib2    613 Message no.     2\n"
"INFO     myapp.lib2    657 Message no.     1\n"
"CRITICAL myapp.lib2    613 Message no.     3\n"
"CRITICAL myapp.lib2    657 Message no.     2\n"
"CRITICAL      myapp    657 Message no.     3\n"
"WARNING  myapp.lib2    613 Message no.     4\n"
"CRITICAL myapp.lib1    613 Message no.     5\n"
"CRITICAL myapp.lib1    657 Message no.     4\n"
"INFO     myapp.lib1    657 Message no.     5\n"
"DEBUG         myapp    613 Message no.     6\n"
"WARNING  myapp.lib2    657 Message no.     6\n"
"CRITICAL      myapp    657 Message no.     7\n"
"CRITICAL myapp.lib1    613 Message no.     7\n"
"INFO     myapp.lib1    613 Message no.     8\n"
"DEBUG    myapp.lib1    657 Message no.     8\n"
"(下略)"

#: ../../howto/logging-cookbook.rst:2090
msgid ""
"As you can see, the logging from the two sender processes is interleaved in "
"the listener's output."
msgstr "如你所见，来自两个发送器进程的日志记录会在监听器的输出中交错出现。"

#: ../../howto/logging-cookbook.rst:2095
msgid "An example dictionary-based configuration"
msgstr "基于字典进行日志配置的示例"

#: ../../howto/logging-cookbook.rst:2097
msgid ""
"Below is an example of a logging configuration dictionary - it's taken from "
"the `documentation on the Django project "
"<https://docs.djangoproject.com/en/stable/topics/logging/#configuring-"
"logging>`_. This dictionary is passed to :func:`~config.dictConfig` to put "
"the configuration into effect::"
msgstr ""
"以下是日志配置字典的一个示例——它取自 Django "
"项目的`文档<https://docs.djangoproject.com/en/stable/topics/logging/#configuring-"
"logging>`_。此字典将被传给 :func:`~config.dictConfig` 以使配置生效:: "

#: ../../howto/logging-cookbook.rst:2101
msgid ""
"LOGGING = {\n"
"    'version': 1,\n"
"    'disable_existing_loggers': False,\n"
"    'formatters': {\n"
"        'verbose': {\n"
"            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',\n"
"            'style': '{',\n"
"        },\n"
"        'simple': {\n"
"            'format': '{levelname} {message}',\n"
"            'style': '{',\n"
"        },\n"
"    },\n"
"    'filters': {\n"
"        'special': {\n"
"            '()': 'project.logging.SpecialFilter',\n"
"            'foo': 'bar',\n"
"        },\n"
"    },\n"
"    'handlers': {\n"
"        'console': {\n"
"            'level': 'INFO',\n"
"            'class': 'logging.StreamHandler',\n"
"            'formatter': 'simple',\n"
"        },\n"
"        'mail_admins': {\n"
"            'level': 'ERROR',\n"
"            'class': 'django.utils.log.AdminEmailHandler',\n"
"            'filters': ['special']\n"
"        }\n"
"    },\n"
"    'loggers': {\n"
"        'django': {\n"
"            'handlers': ['console'],\n"
"            'propagate': True,\n"
"        },\n"
"        'django.request': {\n"
"            'handlers': ['mail_admins'],\n"
"            'level': 'ERROR',\n"
"            'propagate': False,\n"
"        },\n"
"        'myproject.custom': {\n"
"            'handlers': ['console', 'mail_admins'],\n"
"            'level': 'INFO',\n"
"            'filters': ['special']\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"LOGGING = {\n"
"    'version': 1,\n"
"    'disable_existing_loggers': False,\n"
"    'formatters': {\n"
"        'verbose': {\n"
"            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',\n"
"            'style': '{',\n"
"        },\n"
"        'simple': {\n"
"            'format': '{levelname} {message}',\n"
"            'style': '{',\n"
"        },\n"
"    },\n"
"    'filters': {\n"
"        'special': {\n"
"            '()': 'project.logging.SpecialFilter',\n"
"            'foo': 'bar',\n"
"        },\n"
"    },\n"
"    'handlers': {\n"
"        'console': {\n"
"            'level': 'INFO',\n"
"            'class': 'logging.StreamHandler',\n"
"            'formatter': 'simple',\n"
"        },\n"
"        'mail_admins': {\n"
"            'level': 'ERROR',\n"
"            'class': 'django.utils.log.AdminEmailHandler',\n"
"            'filters': ['special']\n"
"        }\n"
"    },\n"
"    'loggers': {\n"
"        'django': {\n"
"            'handlers': ['console'],\n"
"            'propagate': True,\n"
"        },\n"
"        'django.request': {\n"
"            'handlers': ['mail_admins'],\n"
"            'level': 'ERROR',\n"
"            'propagate': False,\n"
"        },\n"
"        'myproject.custom': {\n"
"            'handlers': ['console', 'mail_admins'],\n"
"            'level': 'INFO',\n"
"            'filters': ['special']\n"
"        }\n"
"    }\n"
"}"

#: ../../howto/logging-cookbook.rst:2150
msgid ""
"For more information about this configuration, you can see the `relevant "
"section "
"<https://docs.djangoproject.com/en/stable/topics/logging/#configuring-"
"logging>`_ of the Django documentation."
msgstr ""
"有关本配置的更多信息，请参阅 Django 文档的  `有关章节 "
"<https://docs.djangoproject.com/en/stable/topics/logging/#configuring-"
"logging>`_ 。"

#: ../../howto/logging-cookbook.rst:2157
msgid "Using a rotator and namer to customize log rotation processing"
msgstr "利用 rotator 和 namer 自定义日志轮换操作"

#: ../../howto/logging-cookbook.rst:2159
msgid ""
"An example of how you can define a namer and rotator is given in the "
"following runnable script, which shows gzip compression of the log file::"
msgstr "下面的可运行代码给出了你可以怎样定义命名器和轮换器的例子，其中演示了日志文件的 gzip 压缩过程::"

#: ../../howto/logging-cookbook.rst:2162
msgid ""
"import gzip\n"
"import logging\n"
"import logging.handlers\n"
"import os\n"
"import shutil\n"
"\n"
"def namer(name):\n"
"    return name + \".gz\"\n"
"\n"
"def rotator(source, dest):\n"
"    with open(source, 'rb') as f_in:\n"
"        with gzip.open(dest, 'wb') as f_out:\n"
"            shutil.copyfileobj(f_in, f_out)\n"
"    os.remove(source)\n"
"\n"
"\n"
"rh = logging.handlers.RotatingFileHandler('rotated.log', maxBytes=128, backupCount=5)\n"
"rh.rotator = rotator\n"
"rh.namer = namer\n"
"\n"
"root = logging.getLogger()\n"
"root.setLevel(logging.INFO)\n"
"root.addHandler(rh)\n"
"f = logging.Formatter('%(asctime)s %(message)s')\n"
"rh.setFormatter(f)\n"
"for i in range(1000):\n"
"    root.info(f'Message no. {i + 1}')"
msgstr ""
"import gzip\n"
"import logging\n"
"import logging.handlers\n"
"import os\n"
"import shutil\n"
"\n"
"def namer(name):\n"
"    return name + \".gz\"\n"
"\n"
"def rotator(source, dest):\n"
"    with open(source, 'rb') as f_in:\n"
"        with gzip.open(dest, 'wb') as f_out:\n"
"            shutil.copyfileobj(f_in, f_out)\n"
"    os.remove(source)\n"
"\n"
"\n"
"rh = logging.handlers.RotatingFileHandler('rotated.log', maxBytes=128, backupCount=5)\n"
"rh.rotator = rotator\n"
"rh.namer = namer\n"
"\n"
"root = logging.getLogger()\n"
"root.setLevel(logging.INFO)\n"
"root.addHandler(rh)\n"
"f = logging.Formatter('%(asctime)s %(message)s')\n"
"rh.setFormatter(f)\n"
"for i in range(1000):\n"
"    root.info(f'Message no. {i + 1}')"

#: ../../howto/logging-cookbook.rst:2190
msgid ""
"After running this, you will see six new files, five of which are "
"compressed:"
msgstr "运行此脚本后，你将看到六个新文件，其中五个是已压缩的:"

#: ../../howto/logging-cookbook.rst:2192
msgid ""
"$ ls rotated.log*\n"
"rotated.log       rotated.log.2.gz  rotated.log.4.gz\n"
"rotated.log.1.gz  rotated.log.3.gz  rotated.log.5.gz\n"
"$ zcat rotated.log.1.gz\n"
"2023-01-20 02:28:17,767 Message no. 996\n"
"2023-01-20 02:28:17,767 Message no. 997\n"
"2023-01-20 02:28:17,767 Message no. 998"
msgstr ""
"$ ls rotated.log*\n"
"rotated.log       rotated.log.2.gz  rotated.log.4.gz\n"
"rotated.log.1.gz  rotated.log.3.gz  rotated.log.5.gz\n"
"$ zcat rotated.log.1.gz\n"
"2023-01-20 02:28:17,767 Message no. 996\n"
"2023-01-20 02:28:17,767 Message no. 997\n"
"2023-01-20 02:28:17,767 Message no. 998"

#: ../../howto/logging-cookbook.rst:2203
msgid "A more elaborate multiprocessing example"
msgstr "更加详细的多道处理示例"

#: ../../howto/logging-cookbook.rst:2205
msgid ""
"The following working example shows how logging can be used with "
"multiprocessing using configuration files. The configurations are fairly "
"simple, but serve to illustrate how more complex ones could be implemented "
"in a real multiprocessing scenario."
msgstr "以下可运行的示例显示了如何利用配置文件在多进程中应用日志。这些配置相当简单，但足以说明如何在真实的多进程场景中实现较为复杂的配置。"

#: ../../howto/logging-cookbook.rst:2210
msgid ""
"In the example, the main process spawns a listener process and some worker "
"processes. Each of the main process, the listener and the workers have three"
" separate configurations (the workers all share the same configuration). We "
"can see logging in the main process, how the workers log to a QueueHandler "
"and how the listener implements a QueueListener and a more complex logging "
"configuration, and arranges to dispatch events received via the queue to the"
" handlers specified in the configuration. Note that these configurations are"
" purely illustrative, but you should be able to adapt this example to your "
"own scenario."
msgstr ""
"上述示例中，主进程产生一个侦听器进程和一些工作进程。每个主进程、侦听器进程和工作进程都有三种独立的日志配置（工作进程共享同一套配置）。大家可以看到主进程的日志记录过程、工作线程向"
" QueueHandler 写入日志的过程，以及侦听器实现 QueueListener 和较为复杂的日志配置，如何将由队列接收到的事件分发给配置指定的 "
"handler。请注意，这些配置纯粹用于演示，但应该能调整代码以适用于自己的场景。"

#: ../../howto/logging-cookbook.rst:2220
msgid ""
"Here's the script - the docstrings and the comments hopefully explain how it"
" works::"
msgstr "以下是代码——但愿文档字符串和注释能有助于理解其工作原理："

#: ../../howto/logging-cookbook.rst:2223
msgid ""
"import logging\n"
"import logging.config\n"
"import logging.handlers\n"
"from multiprocessing import Process, Queue, Event, current_process\n"
"import os\n"
"import random\n"
"import time\n"
"\n"
"class MyHandler:\n"
"    \"\"\"\n"
"    A simple handler for logging events. It runs in the listener process and\n"
"    dispatches events to loggers based on the name in the received record,\n"
"    which then get dispatched, by the logging system, to the handlers\n"
"    configured for those loggers.\n"
"    \"\"\"\n"
"\n"
"    def handle(self, record):\n"
"        if record.name == \"root\":\n"
"            logger = logging.getLogger()\n"
"        else:\n"
"            logger = logging.getLogger(record.name)\n"
"\n"
"        if logger.isEnabledFor(record.levelno):\n"
"            # The process name is transformed just to show that it's the listener\n"
"            # doing the logging to files and console\n"
"            record.processName = '%s (for %s)' % (current_process().name, record.processName)\n"
"            logger.handle(record)\n"
"\n"
"def listener_process(q, stop_event, config):\n"
"    \"\"\"\n"
"    This could be done in the main process, but is just done in a separate\n"
"    process for illustrative purposes.\n"
"\n"
"    This initialises logging according to the specified configuration,\n"
"    starts the listener and waits for the main process to signal completion\n"
"    via the event. The listener is then stopped, and the process exits.\n"
"    \"\"\"\n"
"    logging.config.dictConfig(config)\n"
"    listener = logging.handlers.QueueListener(q, MyHandler())\n"
"    listener.start()\n"
"    if os.name == 'posix':\n"
"        # On POSIX, the setup logger will have been configured in the\n"
"        # parent process, but should have been disabled following the\n"
"        # dictConfig call.\n"
"        # On Windows, since fork isn't used, the setup logger won't\n"
"        # exist in the child, so it would be created and the message\n"
"        # would appear - hence the \"if posix\" clause.\n"
"        logger = logging.getLogger('setup')\n"
"        logger.critical('Should not appear, because of disabled logger ...')\n"
"    stop_event.wait()\n"
"    listener.stop()\n"
"\n"
"def worker_process(config):\n"
"    \"\"\"\n"
"    A number of these are spawned for the purpose of illustration. In\n"
"    practice, they could be a heterogeneous bunch of processes rather than\n"
"    ones which are identical to each other.\n"
"\n"
"    This initialises logging according to the specified configuration,\n"
"    and logs a hundred messages with random levels to randomly selected\n"
"    loggers.\n"
"\n"
"    A small sleep is added to allow other processes a chance to run. This\n"
"    is not strictly needed, but it mixes the output from the different\n"
"    processes a bit more than if it's left out.\n"
"    \"\"\"\n"
"    logging.config.dictConfig(config)\n"
"    levels = [logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR,\n"
"              logging.CRITICAL]\n"
"    loggers = ['foo', 'foo.bar', 'foo.bar.baz',\n"
"               'spam', 'spam.ham', 'spam.ham.eggs']\n"
"    if os.name == 'posix':\n"
"        # On POSIX, the setup logger will have been configured in the\n"
"        # parent process, but should have been disabled following the\n"
"        # dictConfig call.\n"
"        # On Windows, since fork isn't used, the setup logger won't\n"
"        # exist in the child, so it would be created and the message\n"
"        # would appear - hence the \"if posix\" clause.\n"
"        logger = logging.getLogger('setup')\n"
"        logger.critical('Should not appear, because of disabled logger ...')\n"
"    for i in range(100):\n"
"        lvl = random.choice(levels)\n"
"        logger = logging.getLogger(random.choice(loggers))\n"
"        logger.log(lvl, 'Message no. %d', i)\n"
"        time.sleep(0.01)\n"
"\n"
"def main():\n"
"    q = Queue()\n"
"    # The main process gets a simple configuration which prints to the console.\n"
"    config_initial = {\n"
"        'version': 1,\n"
"        'handlers': {\n"
"            'console': {\n"
"                'class': 'logging.StreamHandler',\n"
"                'level': 'INFO'\n"
"            }\n"
"        },\n"
"        'root': {\n"
"            'handlers': ['console'],\n"
"            'level': 'DEBUG'\n"
"        }\n"
"    }\n"
"    # The worker process configuration is just a QueueHandler attached to the\n"
"    # root logger, which allows all messages to be sent to the queue.\n"
"    # We disable existing loggers to disable the \"setup\" logger used in the\n"
"    # parent process. This is needed on POSIX because the logger will\n"
"    # be there in the child following a fork().\n"
"    config_worker = {\n"
"        'version': 1,\n"
"        'disable_existing_loggers': True,\n"
"        'handlers': {\n"
"            'queue': {\n"
"                'class': 'logging.handlers.QueueHandler',\n"
"                'queue': q\n"
"            }\n"
"        },\n"
"        'root': {\n"
"            'handlers': ['queue'],\n"
"            'level': 'DEBUG'\n"
"        }\n"
"    }\n"
"    # The listener process configuration shows that the full flexibility of\n"
"    # logging configuration is available to dispatch events to handlers however\n"
"    # you want.\n"
"    # We disable existing loggers to disable the \"setup\" logger used in the\n"
"    # parent process. This is needed on POSIX because the logger will\n"
"    # be there in the child following a fork().\n"
"    config_listener = {\n"
"        'version': 1,\n"
"        'disable_existing_loggers': True,\n"
"        'formatters': {\n"
"            'detailed': {\n"
"                'class': 'logging.Formatter',\n"
"                'format': '%(asctime)s %(name)-15s %(levelname)-8s %(processName)-10s %(message)s'\n"
"            },\n"
"            'simple': {\n"
"                'class': 'logging.Formatter',\n"
"                'format': '%(name)-15s %(levelname)-8s %(processName)-10s %(message)s'\n"
"            }\n"
"        },\n"
"        'handlers': {\n"
"            'console': {\n"
"                'class': 'logging.StreamHandler',\n"
"                'formatter': 'simple',\n"
"                'level': 'INFO'\n"
"            },\n"
"            'file': {\n"
"                'class': 'logging.FileHandler',\n"
"                'filename': 'mplog.log',\n"
"                'mode': 'w',\n"
"                'formatter': 'detailed'\n"
"            },\n"
"            'foofile': {\n"
"                'class': 'logging.FileHandler',\n"
"                'filename': 'mplog-foo.log',\n"
"                'mode': 'w',\n"
"                'formatter': 'detailed'\n"
"            },\n"
"            'errors': {\n"
"                'class': 'logging.FileHandler',\n"
"                'filename': 'mplog-errors.log',\n"
"                'mode': 'w',\n"
"                'formatter': 'detailed',\n"
"                'level': 'ERROR'\n"
"            }\n"
"        },\n"
"        'loggers': {\n"
"            'foo': {\n"
"                'handlers': ['foofile']\n"
"            }\n"
"        },\n"
"        'root': {\n"
"            'handlers': ['console', 'file', 'errors'],\n"
"            'level': 'DEBUG'\n"
"        }\n"
"    }\n"
"    # Log some initial events, just to show that logging in the parent works\n"
"    # normally.\n"
"    logging.config.dictConfig(config_initial)\n"
"    logger = logging.getLogger('setup')\n"
"    logger.info('About to create workers ...')\n"
"    workers = []\n"
"    for i in range(5):\n"
"        wp = Process(target=worker_process, name='worker %d' % (i + 1),\n"
"                     args=(config_worker,))\n"
"        workers.append(wp)\n"
"        wp.start()\n"
"        logger.info('Started worker: %s', wp.name)\n"
"    logger.info('About to create listener ...')\n"
"    stop_event = Event()\n"
"    lp = Process(target=listener_process, name='listener',\n"
"                 args=(q, stop_event, config_listener))\n"
"    lp.start()\n"
"    logger.info('Started listener')\n"
"    # We now hang around for the workers to finish their work.\n"
"    for wp in workers:\n"
"        wp.join()\n"
"    # Workers all done, listening can now stop.\n"
"    # Logging in the parent still works normally.\n"
"    logger.info('Telling listener to stop ...')\n"
"    stop_event.set()\n"
"    lp.join()\n"
"    logger.info('All done.')\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""

#: ../../howto/logging-cookbook.rst:2432
msgid "Inserting a BOM into messages sent to a SysLogHandler"
msgstr "在发送给 SysLogHandler 的信息中插入一个  BOM。"

#: ../../howto/logging-cookbook.rst:2434
msgid ""
":rfc:`5424` requires that a Unicode message be sent to a syslog daemon as a "
"set of bytes which have the following structure: an optional pure-ASCII "
"component, followed by a UTF-8 Byte Order Mark (BOM), followed by Unicode "
"encoded using UTF-8. (See the :rfc:`relevant section of the specification "
"<5424#section-6>`.)"
msgstr ""
":rfc:`5424` 要求，Unicode 信息应采用字节流形式发送到系统 syslog 守护程序，字节流结构如下所示：可选的纯 ASCII部分，后跟"
" UTF-8 字节序标记（BOM），然后是采用 UTF-8 编码的 Unicode。（参见 :rfc:`相关规范<5424#section-6>` 。）"

#: ../../howto/logging-cookbook.rst:2440
msgid ""
"In Python 3.1, code was added to :class:`~logging.handlers.SysLogHandler` to"
" insert a BOM into the message, but unfortunately, it was implemented "
"incorrectly, with the BOM appearing at the beginning of the message and "
"hence not allowing any pure-ASCII component to appear before it."
msgstr ""
"在 Python 3.1 的 :class:`~logging.handlers.SysLogHandler` 中，已加入了在日志信息中插入 BOM "
"的代码，但不幸的是，代码并不正确，BOM 出现在了日志信息的开头，因此在它之前就不允许出现纯 ASCII 内容了。"

#: ../../howto/logging-cookbook.rst:2446
msgid ""
"As this behaviour is broken, the incorrect BOM insertion code is being "
"removed from Python 3.2.4 and later. However, it is not being replaced, and "
"if you want to produce :rfc:`5424`-compliant messages which include a BOM, "
"an optional pure-ASCII sequence before it and arbitrary Unicode after it, "
"encoded using UTF-8, then you need to do the following:"
msgstr ""
"由于无法正常工作， Python 3.2.4 以上版本已删除了出错的插入 BOM 代码。但已有版本的代码不会被替换，若要生成与 :rfc:`5424` "
"兼容的日志信息，包括一个 BOM 符，前面有可选的纯 ASCII 字节流，后面为 UTF-8 编码的任意 Unicode，那么 需要执行以下操作："

#: ../../howto/logging-cookbook.rst:2452
msgid ""
"Attach a :class:`~logging.Formatter` instance to your "
":class:`~logging.handlers.SysLogHandler` instance, with a format string such"
" as::"
msgstr ""
"为 :class:`~logging.handlers.SysLogHandler` 实例串上一个 "
":class:`~logging.Formatter` 实例，格式串可如下："

#: ../../howto/logging-cookbook.rst:2456
msgid "'ASCII section\\ufeffUnicode section'"
msgstr ""

#: ../../howto/logging-cookbook.rst:2458
msgid ""
"The Unicode code point U+FEFF, when encoded using UTF-8, will be encoded as "
"a UTF-8 BOM -- the byte-string ``b'\\xef\\xbb\\xbf'``."
msgstr "用 UTF-8 编码时，Unicode 码位 U+FEFF 将会编码为 UTF-8 BOM——字节串 ``b'\\xef\\xbb\\xbf'`` 。"

#: ../../howto/logging-cookbook.rst:2461
msgid ""
"Replace the ASCII section with whatever placeholders you like, but make sure"
" that the data that appears in there after substitution is always ASCII "
"(that way, it will remain unchanged after UTF-8 encoding)."
msgstr "用任意占位符替换 ASCII 部分，但要保证替换之后的数据一定是 ASCII 码（这样在 UTF-8 编码后就会维持不变）。"

#: ../../howto/logging-cookbook.rst:2465
msgid ""
"Replace the Unicode section with whatever placeholders you like; if the data"
" which appears there after substitution contains characters outside the "
"ASCII range, that's fine -- it will be encoded using UTF-8."
msgstr "用任意占位符替换 Unicode 部分；如果替换后的数据包含超出 ASCII 范围的字符，没问题——他们将用 UTF-8 进行编码。"

#: ../../howto/logging-cookbook.rst:2469
msgid ""
"The formatted message *will* be encoded using UTF-8 encoding by "
"``SysLogHandler``. If you follow the above rules, you should be able to "
"produce :rfc:`5424`-compliant messages. If you don't, logging may not "
"complain, but your messages will not be RFC 5424-compliant, and your syslog "
"daemon may complain."
msgstr ""
"``SysLogHandler`` *将* 对格式化后的日志信息进行 UTF-8 编码。如果遵循上述规则，应能生成符合 :rfc:`5424` "
"的日志信息。否则，日志记录过程可能不会有什么反馈，但日志信息将不与 RFC 5424 兼容，syslog 守护程序可能会有出错反应。"

#: ../../howto/logging-cookbook.rst:2476
msgid "Implementing structured logging"
msgstr "结构化日志的实现代码"

#: ../../howto/logging-cookbook.rst:2478
msgid ""
"Although most logging messages are intended for reading by humans, and thus "
"not readily machine-parseable, there might be circumstances where you want "
"to output messages in a structured format which *is* capable of being parsed"
" by a program (without needing complex regular expressions to parse the log "
"message). This is straightforward to achieve using the logging package. "
"There are a number of ways in which this could be achieved, but the "
"following is a simple approach which uses JSON to serialise the event in a "
"machine-parseable manner::"
msgstr ""
"大多数日志信息是供人阅读的，所以机器解析起来并不容易，但某些时候可能希望以结构化的格式输出，以 *能够* "
"被程序解析（无需用到复杂的正则表达式）。这可以直接用 logging 包实现。实现方式有很多，以下是一种比较简单的方案，利用 JSON "
"以机器可解析的方式对事件信息进行序列化："

#: ../../howto/logging-cookbook.rst:2486
msgid ""
"import json\n"
"import logging\n"
"\n"
"class StructuredMessage:\n"
"    def __init__(self, message, /, **kwargs):\n"
"        self.message = message\n"
"        self.kwargs = kwargs\n"
"\n"
"    def __str__(self):\n"
"        return '%s >>> %s' % (self.message, json.dumps(self.kwargs))\n"
"\n"
"_ = StructuredMessage   # optional, to improve readability\n"
"\n"
"logging.basicConfig(level=logging.INFO, format='%(message)s')\n"
"logging.info(_('message 1', foo='bar', bar='baz', num=123, fnum=123.456))"
msgstr ""
"import json\n"
"import logging\n"
"\n"
"class StructuredMessage:\n"
"    def __init__(self, message, /, **kwargs):\n"
"        self.message = message\n"
"        self.kwargs = kwargs\n"
"\n"
"    def __str__(self):\n"
"        return '%s >>> %s' % (self.message, json.dumps(self.kwargs))\n"
"\n"
"_ = StructuredMessage   # 可选项，用于提升可读性\n"
"\n"
"logging.basicConfig(level=logging.INFO, format='%(message)s')\n"
"logging.info(_('message 1', foo='bar', bar='baz', num=123, fnum=123.456))"

#: ../../howto/logging-cookbook.rst:2502
msgid "If the above script is run, it prints:"
msgstr "上述代码运行后的结果是："

#: ../../howto/logging-cookbook.rst:2504
msgid "message 1 >>> {\"fnum\": 123.456, \"num\": 123, \"bar\": \"baz\", \"foo\": \"bar\"}"
msgstr "message 1 >>> {\"fnum\": 123.456, \"num\": 123, \"bar\": \"baz\", \"foo\": \"bar\"}"

#: ../../howto/logging-cookbook.rst:2508 ../../howto/logging-cookbook.rst:2550
msgid ""
"Note that the order of items might be different according to the version of "
"Python used."
msgstr "请注意，根据 Python 版本的不同，各项数据的输出顺序可能会不一样。"

#: ../../howto/logging-cookbook.rst:2511
msgid ""
"If you need more specialised processing, you can use a custom JSON encoder, "
"as in the following complete example::"
msgstr "若需进行更为定制化的处理，可以使用自定义 JSON 编码对象，下面给出完整示例："

#: ../../howto/logging-cookbook.rst:2514
msgid ""
"import json\n"
"import logging\n"
"\n"
"\n"
"class Encoder(json.JSONEncoder):\n"
"    def default(self, o):\n"
"        if isinstance(o, set):\n"
"            return tuple(o)\n"
"        elif isinstance(o, str):\n"
"            return o.encode('unicode_escape').decode('ascii')\n"
"        return super().default(o)\n"
"\n"
"class StructuredMessage:\n"
"    def __init__(self, message, /, **kwargs):\n"
"        self.message = message\n"
"        self.kwargs = kwargs\n"
"\n"
"    def __str__(self):\n"
"        s = Encoder().encode(self.kwargs)\n"
"        return '%s >>> %s' % (self.message, s)\n"
"\n"
"_ = StructuredMessage   # optional, to improve readability\n"
"\n"
"def main():\n"
"    logging.basicConfig(level=logging.INFO, format='%(message)s')\n"
"    logging.info(_('message 1', set_value={1, 2, 3}, snowman='\\u2603'))\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""
"import json\n"
"import logging\n"
"\n"
"\n"
"class Encoder(json.JSONEncoder):\n"
"    def default(self, o):\n"
"        if isinstance(o, set):\n"
"            return tuple(o)\n"
"        elif isinstance(o, str):\n"
"            return o.encode('unicode_escape').decode('ascii')\n"
"        return super().default(o)\n"
"\n"
"class StructuredMessage:\n"
"    def __init__(self, message, /, **kwargs):\n"
"        self.message = message\n"
"        self.kwargs = kwargs\n"
"\n"
"    def __str__(self):\n"
"        s = Encoder().encode(self.kwargs)\n"
"        return '%s >>> %s' % (self.message, s)\n"
"\n"
"_ = StructuredMessage   # 可选项，用于提升可读性\n"
"\n"
"def main():\n"
"    logging.basicConfig(level=logging.INFO, format='%(message)s')\n"
"    logging.info(_('message 1', set_value={1, 2, 3}, snowman='\\u2603'))\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"

#: ../../howto/logging-cookbook.rst:2544
msgid "When the above script is run, it prints:"
msgstr "上述代码运行后的结果是："

#: ../../howto/logging-cookbook.rst:2546
msgid "message 1 >>> {\"snowman\": \"\\u2603\", \"set_value\": [1, 2, 3]}"
msgstr ""

#: ../../howto/logging-cookbook.rst:2559
msgid "Customizing handlers with :func:`dictConfig`"
msgstr "利用 :func:`dictConfig` 自定义 handler"

#: ../../howto/logging-cookbook.rst:2561
msgid ""
"There are times when you want to customize logging handlers in particular "
"ways, and if you use :func:`dictConfig` you may be able to do this without "
"subclassing. As an example, consider that you may want to set the ownership "
"of a log file. On POSIX, this is easily done using :func:`shutil.chown`, but"
" the file handlers in the stdlib don't offer built-in support. You can "
"customize handler creation using a plain function such as::"
msgstr ""
"有时需要以特定方式自定义日志 handler，如果采用 :func:`dictConfig`，可能无需生成子类就可以做到。比如要设置日志文件的所有权。在"
" POSIX 上，可以利用 :func:`shutil.chown` 轻松完成，但 stdlib 中的文件 handler "
"并不提供内置支持。于是可以用普通函数自定义 handler 的创建，例如："

#: ../../howto/logging-cookbook.rst:2568
msgid ""
"def owned_file_handler(filename, mode='a', encoding=None, owner=None):\n"
"    if owner:\n"
"        if not os.path.exists(filename):\n"
"            open(filename, 'a').close()\n"
"        shutil.chown(filename, *owner)\n"
"    return logging.FileHandler(filename, mode, encoding)"
msgstr ""

#: ../../howto/logging-cookbook.rst:2575
msgid ""
"You can then specify, in a logging configuration passed to "
":func:`dictConfig`, that a logging handler be created by calling this "
"function::"
msgstr "然后，你可以在传给 :func:`dictConfig` 的日志配置中指定通过调用此函数来创建日志处理程序::"

#: ../../howto/logging-cookbook.rst:2578
msgid ""
"LOGGING = {\n"
"    'version': 1,\n"
"    'disable_existing_loggers': False,\n"
"    'formatters': {\n"
"        'default': {\n"
"            'format': '%(asctime)s %(levelname)s %(name)s %(message)s'\n"
"        },\n"
"    },\n"
"    'handlers': {\n"
"        'file':{\n"
"            # The values below are popped from this dictionary and\n"
"            # used to create the handler, set the handler's level and\n"
"            # its formatter.\n"
"            '()': owned_file_handler,\n"
"            'level':'DEBUG',\n"
"            'formatter': 'default',\n"
"            # The values below are passed to the handler creator callable\n"
"            # as keyword arguments.\n"
"            'owner': ['pulse', 'pulse'],\n"
"            'filename': 'chowntest.log',\n"
"            'mode': 'w',\n"
"            'encoding': 'utf-8',\n"
"        },\n"
"    },\n"
"    'root': {\n"
"        'handlers': ['file'],\n"
"        'level': 'DEBUG',\n"
"    },\n"
"}"
msgstr ""

#: ../../howto/logging-cookbook.rst:2608
msgid ""
"In this example I am setting the ownership using the ``pulse`` user and "
"group, just for the purposes of illustration. Putting it together into a "
"working script, ``chowntest.py``::"
msgstr "出于演示目的，以下示例设置用户和用户组为 ``pulse``。代码置于一个可运行的脚本文件 ``chowntest.py`` 中："

#: ../../howto/logging-cookbook.rst:2612
msgid ""
"import logging, logging.config, os, shutil\n"
"\n"
"def owned_file_handler(filename, mode='a', encoding=None, owner=None):\n"
"    if owner:\n"
"        if not os.path.exists(filename):\n"
"            open(filename, 'a').close()\n"
"        shutil.chown(filename, *owner)\n"
"    return logging.FileHandler(filename, mode, encoding)\n"
"\n"
"LOGGING = {\n"
"    'version': 1,\n"
"    'disable_existing_loggers': False,\n"
"    'formatters': {\n"
"        'default': {\n"
"            'format': '%(asctime)s %(levelname)s %(name)s %(message)s'\n"
"        },\n"
"    },\n"
"    'handlers': {\n"
"        'file':{\n"
"            # The values below are popped from this dictionary and\n"
"            # used to create the handler, set the handler's level and\n"
"            # its formatter.\n"
"            '()': owned_file_handler,\n"
"            'level':'DEBUG',\n"
"            'formatter': 'default',\n"
"            # The values below are passed to the handler creator callable\n"
"            # as keyword arguments.\n"
"            'owner': ['pulse', 'pulse'],\n"
"            'filename': 'chowntest.log',\n"
"            'mode': 'w',\n"
"            'encoding': 'utf-8',\n"
"        },\n"
"    },\n"
"    'root': {\n"
"        'handlers': ['file'],\n"
"        'level': 'DEBUG',\n"
"    },\n"
"}\n"
"\n"
"logging.config.dictConfig(LOGGING)\n"
"logger = logging.getLogger('mylogger')\n"
"logger.debug('A debug message')"
msgstr ""

#: ../../howto/logging-cookbook.rst:2655
msgid "To run this, you will probably need to run as ``root``:"
msgstr "可能需要 ``root`` 权限才能运行："

#: ../../howto/logging-cookbook.rst:2657
msgid ""
"$ sudo python3.3 chowntest.py\n"
"$ cat chowntest.log\n"
"2013-11-05 09:34:51,128 DEBUG mylogger A debug message\n"
"$ ls -l chowntest.log\n"
"-rw-r--r-- 1 pulse pulse 55 2013-11-05 09:34 chowntest.log"
msgstr ""
"$ sudo python3.3 chowntest.py\n"
"$ cat chowntest.log\n"
"2013-11-05 09:34:51,128 DEBUG mylogger A debug message\n"
"$ ls -l chowntest.log\n"
"-rw-r--r-- 1 pulse pulse 55 2013-11-05 09:34 chowntest.log"

#: ../../howto/logging-cookbook.rst:2665
msgid ""
"Note that this example uses Python 3.3 because that's where "
":func:`shutil.chown` makes an appearance. This approach should work with any"
" Python version that supports :func:`dictConfig` - namely, Python 2.7, 3.2 "
"or later. With pre-3.3 versions, you would need to implement the actual "
"ownership change using e.g. :func:`os.chown`."
msgstr ""
"请注意此示例用的是 Python 3.3，因为 :func:`shutil.chown` 是从此版本开始出现的。 此方式应当适用于任何支持 "
":func:`dictConfig` 的 Python 版本 —— 例如 Python 2.7, 3.2 或更新的版本。 对于 3.3 "
"之前的版本，你应当使用 :func:`os.chown` 之类的函数来实现实际的所有权修改。"

#: ../../howto/logging-cookbook.rst:2671
msgid ""
"In practice, the handler-creating function may be in a utility module "
"somewhere in your project. Instead of the line in the configuration::"
msgstr "实际应用中，handler 的创建函数可能位于项目的工具模块中。以下配置："

#: ../../howto/logging-cookbook.rst:2674
msgid "'()': owned_file_handler,"
msgstr "'()': owned_file_handler,"

#: ../../howto/logging-cookbook.rst:2676
msgid "you could use e.g.::"
msgstr "应使用："

#: ../../howto/logging-cookbook.rst:2678
msgid "'()': 'ext://project.util.owned_file_handler',"
msgstr "'()': 'ext://project.util.owned_file_handler',"

#: ../../howto/logging-cookbook.rst:2680
msgid ""
"where ``project.util`` can be replaced with the actual name of the package "
"where the function resides. In the above working script, using "
"``'ext://__main__.owned_file_handler'`` should work. Here, the actual "
"callable is resolved by :func:`dictConfig` from the ``ext://`` "
"specification."
msgstr ""
"这里的 ``project.util`` 可以换成函数所在包的实际名称。 在上述的可用脚本中，应该可以使用 "
"``'ext://__main__.owned_file_handler'``。 在这里，实际的可调用对象是由 :func:`dictConfig` 从"
" ``ext://`` 说明中解析出来的。"

#: ../../howto/logging-cookbook.rst:2685
msgid ""
"This example hopefully also points the way to how you could implement other "
"types of file change - e.g. setting specific POSIX permission bits - in the "
"same way, using :func:`os.chmod`."
msgstr "上述示例还指明了其他的文件修改类型的实现方案 —— 比如同样利用 :func:`os.chmod` 设置 POSIX 访问权限位。"

#: ../../howto/logging-cookbook.rst:2689
msgid ""
"Of course, the approach could also be extended to types of handler other "
"than a :class:`~logging.FileHandler` - for example, one of the rotating file"
" handlers, or a different type of handler altogether."
msgstr ""
"当然，以上做法也可以扩展到 :class:`~logging.FileHandler` 之外的其他类型的 handler ——比如某个轮换文件 "
"handler，或类型完全不同的其他 handler。"

#: ../../howto/logging-cookbook.rst:2699
msgid "Using particular formatting styles throughout your application"
msgstr "生效于整个应用程序的格式化样式"

#: ../../howto/logging-cookbook.rst:2701
msgid ""
"In Python 3.2, the :class:`~logging.Formatter` gained a ``style`` keyword "
"parameter which, while defaulting to ``%`` for backward compatibility, "
"allowed the specification of ``{`` or ``$`` to support the formatting "
"approaches supported by :meth:`str.format` and :class:`string.Template`. "
"Note that this governs the formatting of logging messages for final output "
"to logs, and is completely orthogonal to how an individual logging message "
"is constructed."
msgstr ""
"在 Python 3.2 中，:class:`~logging.Formatter` 增加了一个 ``style`` 关键字形参，它默认为 ``%`` "
"以便向下兼容，但是允许采用 ``{`` 或 ``$`` 来支持 :meth:`str.format` 和 "
":class:`string.Template` 所支持的格式化方式。 "
"请注意此形参控制着用用于最终输出到日志的日志消息格式，并且与单独日志消息的构造方式完全无关。"

#: ../../howto/logging-cookbook.rst:2708
msgid ""
"Logging calls (:meth:`~Logger.debug`, :meth:`~Logger.info` etc.) only take "
"positional parameters for the actual logging message itself, with keyword "
"parameters used only for determining options for how to handle the logging "
"call (e.g. the ``exc_info`` keyword parameter to indicate that traceback "
"information should be logged, or the ``extra`` keyword parameter to indicate"
" additional contextual information to be added to the log). So you cannot "
"directly make logging calls using :meth:`str.format` or "
":class:`string.Template` syntax, because internally the logging package uses"
" %-formatting to merge the format string and the variable arguments. There "
"would be no changing this while preserving backward compatibility, since all"
" logging calls which are out there in existing code will be using %-format "
"strings."
msgstr ""
"日志调用 (:meth:`~Logger.debug`, :meth:`~Logger.info` 等) "
"只接受包含实际日志消息自身的位置参数，而关键字参数仅用于确定如何处理日志调用的选项 (例如 ``exc_info`` "
"关键字参数表示应将回溯信息记入日志，而 ``extra`` 关键字参数则指定要添加到日志的额外上下文信息)。 所以你不能直接使用 "
":meth:`str.format` 或 :class:`string.Template` 语法来直接执行日志调用，因为 logging 包在内部是使用"
" % 格式符来合并格式字符串和可变参数的。 这一点不应被改变以保持向下兼容性，因为现有代码中所有的日志调用都将使用 % 格式化字符串。"

#: ../../howto/logging-cookbook.rst:2720
msgid ""
"There have been suggestions to associate format styles with specific "
"loggers, but that approach also runs into backward compatibility problems "
"because any existing code could be using a given logger name and using "
"%-formatting."
msgstr "有人建议将格式化样式与特定的日志对象进行关联，但其实也会遇到向下兼容的问题，因为已有代码可能用到了某日志对象并采用了 %-f 格式串。"

#: ../../howto/logging-cookbook.rst:2724
msgid ""
"For logging to work interoperably between any third-party libraries and your"
" code, decisions about formatting need to be made at the level of the "
"individual logging call. This opens up a couple of ways in which alternative"
" formatting styles can be accommodated."
msgstr "为了让第三方库和自编代码都能够交互使用日志功能，需要决定在单次日志记录调用级别采用什么格式。于是就出现了其他几种格式化样式方案。"

#: ../../howto/logging-cookbook.rst:2731
msgid "Using LogRecord factories"
msgstr "LogRecord 工厂的用法"

#: ../../howto/logging-cookbook.rst:2733
msgid ""
"In Python 3.2, along with the :class:`~logging.Formatter` changes mentioned "
"above, the logging package gained the ability to allow users to set their "
"own :class:`LogRecord` subclasses, using the :func:`setLogRecordFactory` "
"function. You can use this to set your own subclass of :class:`LogRecord`, "
"which does the Right Thing by overriding the :meth:`~LogRecord.getMessage` "
"method. The base class implementation of this method is where the ``msg % "
"args`` formatting happens, and where you can substitute your alternate "
"formatting; however, you should be careful to support all formatting styles "
"and allow %-formatting as the default, to ensure interoperability with other"
" code. Care should also be taken to call ``str(self.msg)``, just as the base"
" implementation does."
msgstr ""
"在 Python 3.2 中，伴随着 :class:`~logging.Formatter` 的上述变化，logging 包增加了允许用户使用 "
":func:`setLogRecordFactory` 函数来。设置自己的 :class:`LogRecord` 子类的功能。 "
"你可以使用此功能来设置自己的 :class:`LogRecord` 子类，它会通过重写 :meth:`~LogRecord.getMessage` "
"方法来完成适当的操作。 ``msg % args`` "
"格式化是在此方法的基类实现中进行的，你可以在那里用你自己的格式化操作来替换；但是，你应当注意要支持全部的格式化样式并允许将 %-formatting "
"作为默认样式，以确保与其他代码进行配合。 还应当注意调用 ``str(self.msg)``，正如基类实现所做的一样。"

#: ../../howto/logging-cookbook.rst:2744
msgid ""
"Refer to the reference documentation on :func:`setLogRecordFactory` and "
":class:`LogRecord` for more information."
msgstr "更多信息请参阅 :func:`setLogRecordFactory` 和 :class:`LogRecord` 的参考文档。"

#: ../../howto/logging-cookbook.rst:2749
msgid "Using custom message objects"
msgstr "自定义信息对象的使用"

#: ../../howto/logging-cookbook.rst:2751
msgid ""
"There is another, perhaps simpler way that you can use {}- and $- formatting"
" to construct your individual log messages. You may recall (from "
":ref:`arbitrary-object-messages`) that when logging you can use an arbitrary"
" object as a message format string, and that the logging package will call "
":func:`str` on that object to get the actual format string. Consider the "
"following two classes::"
msgstr ""
"另一种方案可能更为简单，可以利用 {}- 和 $- 格式构建自己的日志消息。大家或许还记得（来自 :ref:`arbitrary-object-"
"messages`），可以用任意对象作为日志信息的格式串，日志包将调用该对象上 :func:`str` 获取实际的格式串。看下以下两个类："

#: ../../howto/logging-cookbook.rst:2776
msgid ""
"Either of these can be used in place of a format string, to allow {}- or "
"$-formatting to be used to build the actual \"message\" part which appears "
"in the formatted log output in place of “%(message)s” or “{message}” or "
"“$message”. If you find it a little unwieldy to use the class names whenever"
" you want to log something, you can make it more palatable if you use an "
"alias such as ``M`` or ``_`` for the message (or perhaps ``__``, if you are "
"using ``_`` for localization)."
msgstr ""
"以上两个类均都可用于替代格式串，以便用 {}- 或 $-formatting 构建实际的“日志信息”部分，此部分将出现在格式化后的日志输出中，替换 "
"%(message)s 、“{message}”或“$message”。每次要写入日志时都使用类名，如果觉得使用不便，可以采用 ``M`` 或 "
"``_`` 之类的别名（如果将 ``_`` 用于本地化操作，则可用 ``__``）。"

#: ../../howto/logging-cookbook.rst:2784
msgid ""
"Examples of this approach are given below. Firstly, formatting with "
":meth:`str.format`::"
msgstr "下面给出示例。 首先用 :meth:`str.format` 进行格式化："

#: ../../howto/logging-cookbook.rst:2787
msgid ""
">>> __ = BraceMessage\n"
">>> print(__('Message with {0} {1}', 2, 'placeholders'))\n"
"Message with 2 placeholders\n"
">>> class Point: pass\n"
"...\n"
">>> p = Point()\n"
">>> p.x = 0.5\n"
">>> p.y = 0.5\n"
">>> print(__('Message with coordinates: ({point.x:.2f}, {point.y:.2f})', point=p))\n"
"Message with coordinates: (0.50, 0.50)"
msgstr ""
">>> __ = BraceMessage\n"
">>> print(__('Message with {0} {1}', 2, 'placeholders'))\n"
"Message with 2 placeholders\n"
">>> class Point: pass\n"
"...\n"
">>> p = Point()\n"
">>> p.x = 0.5\n"
">>> p.y = 0.5\n"
">>> print(__('Message with coordinates: ({point.x:.2f}, {point.y:.2f})', point=p))\n"
"Message with coordinates: (0.50, 0.50)"

#: ../../howto/logging-cookbook.rst:2798
msgid "Secondly, formatting with :class:`string.Template`::"
msgstr "然后，用 :class:`string.Template` 格式化："

#: ../../howto/logging-cookbook.rst:2800
msgid ""
">>> __ = DollarMessage\n"
">>> print(__('Message with $num $what', num=2, what='placeholders'))\n"
"Message with 2 placeholders\n"
">>>"
msgstr ""
">>> __ = DollarMessage\n"
">>> print(__('Message with $num $what', num=2, what='placeholders'))\n"
"Message with 2 placeholders\n"
">>>"

#: ../../howto/logging-cookbook.rst:2805
msgid ""
"One thing to note is that you pay no significant performance penalty with "
"this approach: the actual formatting happens not when you make the logging "
"call, but when (and if) the logged message is actually about to be output to"
" a log by a handler. So the only slightly unusual thing which might trip you"
" up is that the parentheses go around the format string and the arguments, "
"not just the format string. That’s because the __ notation is just syntax "
"sugar for a constructor call to one of the :samp:`{XXX}Message` classes "
"shown above."
msgstr ""
"需要注意的是使用这种方式不会对性能造成明显影响：实际的格式化工作不是在日志记录调用时发生的，而是在（如果）处理器即将把日志消息输出到日志时发生的。 "
"因此，唯一可能令人困惑的不寻常之处在于包裹在格式字符串和参数外面的圆括号，而不仅仅是格式字符串。 这是因为 __ 符号只是对上面显示的 "
":samp:`{XXX}Message` 类的构造器的调用的语法糖。"

#: ../../howto/logging-cookbook.rst:2819
msgid "Configuring filters with :func:`dictConfig`"
msgstr "利用 :func:`dictConfig` 定义过滤器"

#: ../../howto/logging-cookbook.rst:2821
msgid ""
"You *can* configure filters using :func:`~logging.config.dictConfig`, though"
" it might not be obvious at first glance how to do it (hence this recipe). "
"Since :class:`~logging.Filter` is the only filter class included in the "
"standard library, and it is unlikely to cater to many requirements (it's "
"only there as a base class), you will typically need to define your own "
":class:`~logging.Filter` subclass with an overridden "
":meth:`~logging.Filter.filter` method. To do this, specify the ``()`` key in"
" the configuration dictionary for the filter, specifying a callable which "
"will be used to create the filter (a class is the most obvious, but you can "
"provide any callable which returns a :class:`~logging.Filter` instance). "
"Here is a complete example::"
msgstr ""
"用 :func:`~logging.config.dictConfig` *可以* 对日志过滤器进行设置，尽管乍一看做法并不明显（所以才需要本秘籍）。 "
"由于 :class:`~logging.Filter` 是标准库中唯一的日志过滤器类，不太可能满足众多的要求（它只是作为基类存在），通常需要定义自己的 "
":class:`~logging.Filter` 子类，并重写 :meth:`~logging.Filter.filter` "
"方法。为此，请在过滤器的配置字典中设置 ``()`` "
"键，指定要用于创建过滤器的可调用对象（最明显可用的就是给出一个类，但也可以提供任何一个可调用对象，只要能返回 "
":class:`~logging.Filter` 实例即可）。下面是一个完整的例子："

#: ../../howto/logging-cookbook.rst:2832
msgid ""
"import logging\n"
"import logging.config\n"
"import sys\n"
"\n"
"class MyFilter(logging.Filter):\n"
"    def __init__(self, param=None):\n"
"        self.param = param\n"
"\n"
"    def filter(self, record):\n"
"        if self.param is None:\n"
"            allow = True\n"
"        else:\n"
"            allow = self.param not in record.msg\n"
"        if allow:\n"
"            record.msg = 'changed: ' + record.msg\n"
"        return allow\n"
"\n"
"LOGGING = {\n"
"    'version': 1,\n"
"    'filters': {\n"
"        'myfilter': {\n"
"            '()': MyFilter,\n"
"            'param': 'noshow',\n"
"        }\n"
"    },\n"
"    'handlers': {\n"
"        'console': {\n"
"            'class': 'logging.StreamHandler',\n"
"            'filters': ['myfilter']\n"
"        }\n"
"    },\n"
"    'root': {\n"
"        'level': 'DEBUG',\n"
"        'handlers': ['console']\n"
"    },\n"
"}\n"
"\n"
"if __name__ == '__main__':\n"
"    logging.config.dictConfig(LOGGING)\n"
"    logging.debug('hello')\n"
"    logging.debug('hello - noshow')"
msgstr ""
"import logging\n"
"import logging.config\n"
"import sys\n"
"\n"
"class MyFilter(logging.Filter):\n"
"    def __init__(self, param=None):\n"
"        self.param = param\n"
"\n"
"    def filter(self, record):\n"
"        if self.param is None:\n"
"            allow = True\n"
"        else:\n"
"            allow = self.param not in record.msg\n"
"        if allow:\n"
"            record.msg = 'changed: ' + record.msg\n"
"        return allow\n"
"\n"
"LOGGING = {\n"
"    'version': 1,\n"
"    'filters': {\n"
"        'myfilter': {\n"
"            '()': MyFilter,\n"
"            'param': 'noshow',\n"
"        }\n"
"    },\n"
"    'handlers': {\n"
"        'console': {\n"
"            'class': 'logging.StreamHandler',\n"
"            'filters': ['myfilter']\n"
"        }\n"
"    },\n"
"    'root': {\n"
"        'level': 'DEBUG',\n"
"        'handlers': ['console']\n"
"    },\n"
"}\n"
"\n"
"if __name__ == '__main__':\n"
"    logging.config.dictConfig(LOGGING)\n"
"    logging.debug('hello')\n"
"    logging.debug('hello - noshow')"

#: ../../howto/logging-cookbook.rst:2874
msgid ""
"This example shows how you can pass configuration data to the callable which"
" constructs the instance, in the form of keyword parameters. When run, the "
"above script will print:"
msgstr "以上示例展示了将配置数据传给构造实例的可调用对象，形式是关键字参数。运行后将会输出："

#: ../../howto/logging-cookbook.rst:2878
msgid "changed: hello"
msgstr "changed: hello"

#: ../../howto/logging-cookbook.rst:2882
msgid "which shows that the filter is working as configured."
msgstr "这说明过滤器按照配置的参数生效了。"

#: ../../howto/logging-cookbook.rst:2884
msgid "A couple of extra points to note:"
msgstr "需要额外注意的地方："

#: ../../howto/logging-cookbook.rst:2886
msgid ""
"If you can't refer to the callable directly in the configuration (e.g. if it"
" lives in a different module, and you can't import it directly where the "
"configuration dictionary is), you can use the form ``ext://...`` as "
"described in :ref:`logging-config-dict-externalobj`. For example, you could "
"have used the text ``'ext://__main__.MyFilter'`` instead of ``MyFilter`` in "
"the above example."
msgstr ""
"如果在配置中无法直接引用可调用对象（比如位于不同的模块中，并且不能在配置字典所在的位置直接导入），则可以采用 ``ext://...`` 的形式，正如 "
":ref:`logging-config-dict-externalobj` 所述。例如，在上述示例中可以使用文本 "
"``'ext://__main__.MyFilter'`` 而不是 ``MyFilter`` 对象。"

#: ../../howto/logging-cookbook.rst:2893
msgid ""
"As well as for filters, this technique can also be used to configure custom "
"handlers and formatters. See :ref:`logging-config-dict-userdef` for more "
"information on how logging supports using user-defined objects in its "
"configuration, and see the other cookbook recipe :ref:`custom-handlers` "
"above."
msgstr ""
"与过滤器一样，上述技术还可用于配置自定义 handler 和格式化对象。有关如何在日志配置中使用用户自定义对象的更多信息，请参阅 "
":ref:`logging-config-dict-userdef`，以及上述 :ref:`custom-handlers` 的其他指南。"

#: ../../howto/logging-cookbook.rst:2902
msgid "Customized exception formatting"
msgstr "异常信息的自定义格式化"

#: ../../howto/logging-cookbook.rst:2904
msgid ""
"There might be times when you want to do customized exception formatting - "
"for argument's sake, let's say you want exactly one line per logged event, "
"even when exception information is present. You can do this with a custom "
"formatter class, as shown in the following example::"
msgstr ""
"有时可能需要设置自定义的异常信息格式——考虑到会用到参数，假定要让每条日志事件只占一行，即便存在异常信息也一样。这可以用自定义格式化类来实现，如下所示："

#: ../../howto/logging-cookbook.rst:2909
msgid ""
"import logging\n"
"\n"
"class OneLineExceptionFormatter(logging.Formatter):\n"
"    def formatException(self, exc_info):\n"
"        \"\"\"\n"
"        Format an exception so that it prints on a single line.\n"
"        \"\"\"\n"
"        result = super().formatException(exc_info)\n"
"        return repr(result)  # or format into one line however you want to\n"
"\n"
"    def format(self, record):\n"
"        s = super().format(record)\n"
"        if record.exc_text:\n"
"            s = s.replace('\\n', '') + '|'\n"
"        return s\n"
"\n"
"def configure_logging():\n"
"    fh = logging.FileHandler('output.txt', 'w')\n"
"    f = OneLineExceptionFormatter('%(asctime)s|%(levelname)s|%(message)s|',\n"
"                                  '%d/%m/%Y %H:%M:%S')\n"
"    fh.setFormatter(f)\n"
"    root = logging.getLogger()\n"
"    root.setLevel(logging.DEBUG)\n"
"    root.addHandler(fh)\n"
"\n"
"def main():\n"
"    configure_logging()\n"
"    logging.info('Sample message')\n"
"    try:\n"
"        x = 1 / 0\n"
"    except ZeroDivisionError as e:\n"
"        logging.exception('ZeroDivisionError: %s', e)\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""

#: ../../howto/logging-cookbook.rst:2945
msgid "When run, this produces a file with exactly two lines:"
msgstr "运行后将会生成只有两行信息的文件："

#: ../../howto/logging-cookbook.rst:2947
msgid ""
"28/01/2015 07:21:23|INFO|Sample message|\n"
"28/01/2015 07:21:23|ERROR|ZeroDivisionError: integer division or modulo by zero|'Traceback (most recent call last):\\n  File \"logtest7.py\", line 30, in main\\n    x = 1 / 0\\nZeroDivisionError: integer division or modulo by zero'|"
msgstr ""
"28/01/2015 07:21:23|INFO|Sample message|\n"
"28/01/2015 07:21:23|ERROR|ZeroDivisionError: integer division or modulo by zero|'Traceback (most recent call last):\\n  File \"logtest7.py\", line 30, in main\\n    x = 1 / 0\\nZeroDivisionError: integer division or modulo by zero'|"

#: ../../howto/logging-cookbook.rst:2952
msgid ""
"While the above treatment is simplistic, it points the way to how exception "
"information can be formatted to your liking. The :mod:`traceback` module may"
" be helpful for more specialized needs."
msgstr "虽然上述处理方式很简单，但也给出了根据喜好对异常信息进行格式化输出的方案。或许 :mod:`traceback` 模块能满足更专门的需求。"

#: ../../howto/logging-cookbook.rst:2959
msgid "Speaking logging messages"
msgstr "语音播报日志信息"

#: ../../howto/logging-cookbook.rst:2961
msgid ""
"There might be situations when it is desirable to have logging messages "
"rendered in an audible rather than a visible format. This is easy to do if "
"you have text-to-speech (TTS) functionality available in your system, even "
"if it doesn't have a Python binding. Most TTS systems have a command line "
"program you can run, and this can be invoked from a handler using "
":mod:`subprocess`. It's assumed here that TTS command line programs won't "
"expect to interact with users or take a long time to complete, and that the "
"frequency of logged messages will be not so high as to swamp the user with "
"messages, and that it's acceptable to have the messages spoken one at a time"
" rather than concurrently, The example implementation below waits for one "
"message to be spoken before the next is processed, and this might cause "
"other handlers to be kept waiting. Here is a short example showing the "
"approach, which assumes that the ``espeak`` TTS package is available::"
msgstr ""
"有时可能需要以声音的形式呈现日志消息。如果系统自带了文本转语音 （TTS）功能，即便没与 Python 关联也很容易做到。大多数 TTS "
"系统都有一个可运行的命令行程序，在 handler 中可以用 :mod:`subprocess` 进行调用。这里假定 TTS "
"命令行程序不会与用户交互，或需要很长时间才会执行完毕，写入日志的信息也不会多到影响用户查看，并且可以接受每次播报一条信息，以下示例实现了等一条信息播完再处理下一条，可能会导致其他"
" handler 的等待。这个简短示例仅供演示，假定 ``espeak`` TTS 包已就绪："

#: ../../howto/logging-cookbook.rst:2974
msgid ""
"import logging\n"
"import subprocess\n"
"import sys\n"
"\n"
"class TTSHandler(logging.Handler):\n"
"    def emit(self, record):\n"
"        msg = self.format(record)\n"
"        # Speak slowly in a female English voice\n"
"        cmd = ['espeak', '-s150', '-ven+f3', msg]\n"
"        p = subprocess.Popen(cmd, stdout=subprocess.PIPE,\n"
"                             stderr=subprocess.STDOUT)\n"
"        # wait for the program to finish\n"
"        p.communicate()\n"
"\n"
"def configure_logging():\n"
"    h = TTSHandler()\n"
"    root = logging.getLogger()\n"
"    root.addHandler(h)\n"
"    # the default formatter just returns the message\n"
"    root.setLevel(logging.DEBUG)\n"
"\n"
"def main():\n"
"    logging.info('Hello')\n"
"    logging.debug('Goodbye')\n"
"\n"
"if __name__ == '__main__':\n"
"    configure_logging()\n"
"    sys.exit(main())"
msgstr ""
"import logging\n"
"import subprocess\n"
"import sys\n"
"\n"
"class TTSHandler(logging.Handler):\n"
"    def emit(self, record):\n"
"        msg = self.format(record)\n"
"        # 以女性的英语语音慢速地说话\n"
"        cmd = ['espeak', '-s150', '-ven+f3', msg]\n"
"        p = subprocess.Popen(cmd, stdout=subprocess.PIPE,\n"
"                             stderr=subprocess.STDOUT)\n"
"        # 等待程序结束\n"
"        p.communicate()\n"
"\n"
"def configure_logging():\n"
"    h = TTSHandler()\n"
"    root = logging.getLogger()\n"
"    root.addHandler(h)\n"
"    # 默认格式化器简单地返回消息\n"
"    root.setLevel(logging.DEBUG)\n"
"\n"
"def main():\n"
"    logging.info('Hello')\n"
"    logging.debug('Goodbye')\n"
"\n"
"if __name__ == '__main__':\n"
"    configure_logging()\n"
"    sys.exit(main())"

#: ../../howto/logging-cookbook.rst:3003
msgid ""
"When run, this script should say \"Hello\" and then \"Goodbye\" in a female "
"voice."
msgstr "运行后将会以女声播报“Hello”和“Goodbye”。"

#: ../../howto/logging-cookbook.rst:3005
msgid ""
"The above approach can, of course, be adapted to other TTS systems and even "
"other systems altogether which can process messages via external programs "
"run from a command line."
msgstr "当然，上述方案也适用于其他 TTS 系统，甚至可以通过利用命令行运行的外部程序来处理消息。"

#: ../../howto/logging-cookbook.rst:3013
msgid "Buffering logging messages and outputting them conditionally"
msgstr "缓冲日志消息并有条件地输出它们"

#: ../../howto/logging-cookbook.rst:3015
msgid ""
"There might be situations where you want to log messages in a temporary area"
" and only output them if a certain condition occurs. For example, you may "
"want to start logging debug events in a function, and if the function "
"completes without errors, you don't want to clutter the log with the "
"collected debug information, but if there is an error, you want all the "
"debug information to be output as well as the error."
msgstr ""
"在某些情况下，你可能希望在临时区域中记录日志消息，并且只在发生某种特定的情况下才输出它们。 "
"例如，你可能希望起始在函数中记录调试事件，如果函数执行完成且没有错误，你不希望输出收集的调试信息以避免造成日志混乱，但如果出现错误，那么你希望所有调试以及错误消息被输出。"

#: ../../howto/logging-cookbook.rst:3022
msgid ""
"Here is an example which shows how you could do this using a decorator for "
"your functions where you want logging to behave this way. It makes use of "
"the :class:`logging.handlers.MemoryHandler`, which allows buffering of "
"logged events until some condition occurs, at which point the buffered "
"events are ``flushed`` - passed to another handler (the ``target`` handler) "
"for processing. By default, the ``MemoryHandler`` flushed when its buffer "
"gets filled up or an event whose level is greater than or equal to a "
"specified threshold is seen. You can use this recipe with a more specialised"
" subclass of ``MemoryHandler`` if you want custom flushing behavior."
msgstr ""
"下面是一个示例，展示如何在你的日志记录函数上使用装饰器以实现这一功能。该示例使用 "
":class:`logging.handlers.MemoryHandler` "
"，它允许缓冲已记录的事件直到某些条件发生，缓冲的事件才会被刷新（``flushed``） - 传递给另一个处理程序（ ``target`` "
"handler）进行处理。 默认情况下， ``MemoryHandler`` 在其缓冲区被填满时被刷新，或者看到一个级别大于或等于指定阈值的事件。 "
"如果想要自定义刷新行为，你可以通过更专业的 ``MemoryHandler`` 子类来使用这个秘诀。"

#: ../../howto/logging-cookbook.rst:3032
msgid ""
"The example script has a simple function, ``foo``, which just cycles through"
" all the logging levels, writing to ``sys.stderr`` to say what level it's "
"about to log at, and then actually logging a message at that level. You can "
"pass a parameter to ``foo`` which, if true, will log at ERROR and CRITICAL "
"levels - otherwise, it only logs at DEBUG, INFO and WARNING levels."
msgstr ""
"这个示例脚本有一个简单的函数 ``foo`` ，它只是在所有的日志级别中循环运行，写到 ``sys.stderr`` "
"，说明它要记录在哪个级别上，然后在这个级别上实际记录一个消息。你可以给 ``foo`` 传递一个参数，如果为 true "
"，它将在ERROR和CRITICAL级别记录，否则，它只在DEBUG、INFO和WARNING级别记录。"

#: ../../howto/logging-cookbook.rst:3038
msgid ""
"The script just arranges to decorate ``foo`` with a decorator which will do "
"the conditional logging that's required. The decorator takes a logger as a "
"parameter and attaches a memory handler for the duration of the call to the "
"decorated function. The decorator can be additionally parameterised using a "
"target handler, a level at which flushing should occur, and a capacity for "
"the buffer (number of records buffered). These default to a "
":class:`~logging.StreamHandler` which writes to ``sys.stderr``, "
"``logging.ERROR`` and ``100`` respectively."
msgstr ""
"脚本只是使用了一个装饰器来装饰 "
"``foo``，这个装饰器将记录执行所需的条件。装饰器使用一个记录器作为参数，并在调用被装饰的函数期间附加一个内存处理程序。装饰器可以使用目标处理程序、记录级别和缓冲区的容量（缓冲记录的数量）来附加参数。这些参数分别默认为写入"
" ``sys.stderr`` 的 :class:`~logging.StreamHandler` ， ``logging.ERROR`` 和 "
"``100``。"

#: ../../howto/logging-cookbook.rst:3046
msgid "Here's the script::"
msgstr "以下是脚本："

#: ../../howto/logging-cookbook.rst:3048
msgid ""
"import logging\n"
"from logging.handlers import MemoryHandler\n"
"import sys\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"logger.addHandler(logging.NullHandler())\n"
"\n"
"def log_if_errors(logger, target_handler=None, flush_level=None, capacity=None):\n"
"    if target_handler is None:\n"
"        target_handler = logging.StreamHandler()\n"
"    if flush_level is None:\n"
"        flush_level = logging.ERROR\n"
"    if capacity is None:\n"
"        capacity = 100\n"
"    handler = MemoryHandler(capacity, flushLevel=flush_level, target=target_handler)\n"
"\n"
"    def decorator(fn):\n"
"        def wrapper(*args, **kwargs):\n"
"            logger.addHandler(handler)\n"
"            try:\n"
"                return fn(*args, **kwargs)\n"
"            except Exception:\n"
"                logger.exception('call failed')\n"
"                raise\n"
"            finally:\n"
"                super(MemoryHandler, handler).flush()\n"
"                logger.removeHandler(handler)\n"
"        return wrapper\n"
"\n"
"    return decorator\n"
"\n"
"def write_line(s):\n"
"    sys.stderr.write('%s\\n' % s)\n"
"\n"
"def foo(fail=False):\n"
"    write_line('about to log at DEBUG ...')\n"
"    logger.debug('Actually logged at DEBUG')\n"
"    write_line('about to log at INFO ...')\n"
"    logger.info('Actually logged at INFO')\n"
"    write_line('about to log at WARNING ...')\n"
"    logger.warning('Actually logged at WARNING')\n"
"    if fail:\n"
"        write_line('about to log at ERROR ...')\n"
"        logger.error('Actually logged at ERROR')\n"
"        write_line('about to log at CRITICAL ...')\n"
"        logger.critical('Actually logged at CRITICAL')\n"
"    return fail\n"
"\n"
"decorated_foo = log_if_errors(logger)(foo)\n"
"\n"
"if __name__ == '__main__':\n"
"    logger.setLevel(logging.DEBUG)\n"
"    write_line('Calling undecorated foo with False')\n"
"    assert not foo(False)\n"
"    write_line('Calling undecorated foo with True')\n"
"    assert foo(True)\n"
"    write_line('Calling decorated foo with False')\n"
"    assert not decorated_foo(False)\n"
"    write_line('Calling decorated foo with True')\n"
"    assert decorated_foo(True)"
msgstr ""
"import logging\n"
"from logging.handlers import MemoryHandler\n"
"import sys\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"logger.addHandler(logging.NullHandler())\n"
"\n"
"def log_if_errors(logger, target_handler=None, flush_level=None, capacity=None):\n"
"    if target_handler is None:\n"
"        target_handler = logging.StreamHandler()\n"
"    if flush_level is None:\n"
"        flush_level = logging.ERROR\n"
"    if capacity is None:\n"
"        capacity = 100\n"
"    handler = MemoryHandler(capacity, flushLevel=flush_level, target=target_handler)\n"
"\n"
"    def decorator(fn):\n"
"        def wrapper(*args, **kwargs):\n"
"            logger.addHandler(handler)\n"
"            try:\n"
"                return fn(*args, **kwargs)\n"
"            except Exception:\n"
"                logger.exception('call failed')\n"
"                raise\n"
"            finally:\n"
"                super(MemoryHandler, handler).flush()\n"
"                logger.removeHandler(handler)\n"
"        return wrapper\n"
"\n"
"    return decorator\n"
"\n"
"def write_line(s):\n"
"    sys.stderr.write('%s\\n' % s)\n"
"\n"
"def foo(fail=False):\n"
"    write_line('about to log at DEBUG ...')\n"
"    logger.debug('Actually logged at DEBUG')\n"
"    write_line('about to log at INFO ...')\n"
"    logger.info('Actually logged at INFO')\n"
"    write_line('about to log at WARNING ...')\n"
"    logger.warning('Actually logged at WARNING')\n"
"    if fail:\n"
"        write_line('about to log at ERROR ...')\n"
"        logger.error('Actually logged at ERROR')\n"
"        write_line('about to log at CRITICAL ...')\n"
"        logger.critical('Actually logged at CRITICAL')\n"
"    return fail\n"
"\n"
"decorated_foo = log_if_errors(logger)(foo)\n"
"\n"
"if __name__ == '__main__':\n"
"    logger.setLevel(logging.DEBUG)\n"
"    write_line('Calling undecorated foo with False')\n"
"    assert not foo(False)\n"
"    write_line('Calling undecorated foo with True')\n"
"    assert foo(True)\n"
"    write_line('Calling decorated foo with False')\n"
"    assert not decorated_foo(False)\n"
"    write_line('Calling decorated foo with True')\n"
"    assert decorated_foo(True)"

#: ../../howto/logging-cookbook.rst:3109
msgid "When this script is run, the following output should be observed:"
msgstr "运行此脚本时，应看到以下输出："

#: ../../howto/logging-cookbook.rst:3111
msgid ""
"Calling undecorated foo with False\n"
"about to log at DEBUG ...\n"
"about to log at INFO ...\n"
"about to log at WARNING ...\n"
"Calling undecorated foo with True\n"
"about to log at DEBUG ...\n"
"about to log at INFO ...\n"
"about to log at WARNING ...\n"
"about to log at ERROR ...\n"
"about to log at CRITICAL ...\n"
"Calling decorated foo with False\n"
"about to log at DEBUG ...\n"
"about to log at INFO ...\n"
"about to log at WARNING ...\n"
"Calling decorated foo with True\n"
"about to log at DEBUG ...\n"
"about to log at INFO ...\n"
"about to log at WARNING ...\n"
"about to log at ERROR ...\n"
"Actually logged at DEBUG\n"
"Actually logged at INFO\n"
"Actually logged at WARNING\n"
"Actually logged at ERROR\n"
"about to log at CRITICAL ...\n"
"Actually logged at CRITICAL"
msgstr ""
"Calling undecorated foo with False\n"
"about to log at DEBUG ...\n"
"about to log at INFO ...\n"
"about to log at WARNING ...\n"
"Calling undecorated foo with True\n"
"about to log at DEBUG ...\n"
"about to log at INFO ...\n"
"about to log at WARNING ...\n"
"about to log at ERROR ...\n"
"about to log at CRITICAL ...\n"
"Calling decorated foo with False\n"
"about to log at DEBUG ...\n"
"about to log at INFO ...\n"
"about to log at WARNING ...\n"
"Calling decorated foo with True\n"
"about to log at DEBUG ...\n"
"about to log at INFO ...\n"
"about to log at WARNING ...\n"
"about to log at ERROR ...\n"
"Actually logged at DEBUG\n"
"Actually logged at INFO\n"
"Actually logged at WARNING\n"
"Actually logged at ERROR\n"
"about to log at CRITICAL ...\n"
"Actually logged at CRITICAL"

#: ../../howto/logging-cookbook.rst:3139
msgid ""
"As you can see, actual logging output only occurs when an event is logged "
"whose severity is ERROR or greater, but in that case, any previous events at"
" lower severities are also logged."
msgstr "如你所见，实际日志记录输出仅在消息等级为ERROR或更高的事件时发生，但在这种情况下，任何之前较低消息等级的事件还会被记录。"

#: ../../howto/logging-cookbook.rst:3143
msgid "You can of course use the conventional means of decoration::"
msgstr "你当然可以使用传统的装饰方法::"

#: ../../howto/logging-cookbook.rst:3145
msgid ""
"@log_if_errors(logger)\n"
"def foo(fail=False):\n"
"    ..."
msgstr ""
"@log_if_errors(logger)\n"
"def foo(fail=False):\n"
"    ..."

#: ../../howto/logging-cookbook.rst:3153
msgid "Sending logging messages to email, with buffering"
msgstr "将日志消息发送至电子邮件，附带缓存支持"

#: ../../howto/logging-cookbook.rst:3155
msgid ""
"To illustrate how you can send log messages via email, so that a set number "
"of messages are sent per email, you can subclass "
":class:`~logging.handlers.BufferingHandler`. In the following  example, "
"which you can adapt to suit your specific needs, a simple test harness is "
"provided which allows you to run the script with command line arguments "
"specifying what you typically need to send things via SMTP. (Run the "
"downloaded script with the ``-h`` argument to see the required and optional "
"arguments.)"
msgstr ""
"为演示如何通过电子邮件发送日志消息，让每封电子邮件发送指定数量的日志消息，你可以子类化 "
":class:`~logging.handlers.BufferingHandler`。 "
"对于下面的例子，你可以继续调整以适合你自己的特定需求，它提供了简单的测试代码来允许你附带命令行参数运行该脚本来指定你需要通过 SMTP 发送的内容。 "
"（请附带 ``-h`` 参数运行已下载的脚本来查看必须的和可选的参数。）"

#: ../../howto/logging-cookbook.rst:3163
msgid ""
"import logging\n"
"import logging.handlers\n"
"import smtplib\n"
"\n"
"class BufferingSMTPHandler(logging.handlers.BufferingHandler):\n"
"    def __init__(self, mailhost, port, username, password, fromaddr, toaddrs,\n"
"                 subject, capacity):\n"
"        logging.handlers.BufferingHandler.__init__(self, capacity)\n"
"        self.mailhost = mailhost\n"
"        self.mailport = port\n"
"        self.username = username\n"
"        self.password = password\n"
"        self.fromaddr = fromaddr\n"
"        if isinstance(toaddrs, str):\n"
"            toaddrs = [toaddrs]\n"
"        self.toaddrs = toaddrs\n"
"        self.subject = subject\n"
"        self.setFormatter(logging.Formatter(\"%(asctime)s %(levelname)-5s %(message)s\"))\n"
"\n"
"    def flush(self):\n"
"        if len(self.buffer) > 0:\n"
"            try:\n"
"                smtp = smtplib.SMTP(self.mailhost, self.mailport)\n"
"                smtp.starttls()\n"
"                smtp.login(self.username, self.password)\n"
"                msg = \"From: %s\\r\\nTo: %s\\r\\nSubject: %s\\r\\n\\r\\n\" % (self.fromaddr, ','.join(self.toaddrs), self.subject)\n"
"                for record in self.buffer:\n"
"                    s = self.format(record)\n"
"                    msg = msg + s + \"\\r\\n\"\n"
"                smtp.sendmail(self.fromaddr, self.toaddrs, msg)\n"
"                smtp.quit()\n"
"            except Exception:\n"
"                if logging.raiseExceptions:\n"
"                    raise\n"
"            self.buffer = []\n"
"\n"
"if __name__ == '__main__':\n"
"    import argparse\n"
"\n"
"    ap = argparse.ArgumentParser()\n"
"    aa = ap.add_argument\n"
"    aa('host', metavar='HOST', help='SMTP server')\n"
"    aa('--port', '-p', type=int, default=587, help='SMTP port')\n"
"    aa('user', metavar='USER', help='SMTP username')\n"
"    aa('password', metavar='PASSWORD', help='SMTP password')\n"
"    aa('to', metavar='TO', help='Addressee for emails')\n"
"    aa('sender', metavar='SENDER', help='Sender email address')\n"
"    aa('--subject', '-s',\n"
"       default='Test Logging email from Python logging module (buffering)',\n"
"       help='Subject of email')\n"
"    options = ap.parse_args()\n"
"    logger = logging.getLogger()\n"
"    logger.setLevel(logging.DEBUG)\n"
"    h = BufferingSMTPHandler(options.host, options.port, options.user,\n"
"                             options.password, options.sender,\n"
"                             options.to, options.subject, 10)\n"
"    logger.addHandler(h)\n"
"    for i in range(102):\n"
"        logger.info(\"Info index = %d\", i)\n"
"    h.flush()\n"
"    h.close()"
msgstr ""
"import logging\n"
"import logging.handlers\n"
"import smtplib\n"
"\n"
"class BufferingSMTPHandler(logging.handlers.BufferingHandler):\n"
"    def __init__(self, mailhost, port, username, password, fromaddr, toaddrs,\n"
"                 subject, capacity):\n"
"        logging.handlers.BufferingHandler.__init__(self, capacity)\n"
"        self.mailhost = mailhost\n"
"        self.mailport = port\n"
"        self.username = username\n"
"        self.password = password\n"
"        self.fromaddr = fromaddr\n"
"        if isinstance(toaddrs, str):\n"
"            toaddrs = [toaddrs]\n"
"        self.toaddrs = toaddrs\n"
"        self.subject = subject\n"
"        self.setFormatter(logging.Formatter(\"%(asctime)s %(levelname)-5s %(message)s\"))\n"
"\n"
"    def flush(self):\n"
"        if len(self.buffer) > 0:\n"
"            try:\n"
"                smtp = smtplib.SMTP(self.mailhost, self.mailport)\n"
"                smtp.starttls()\n"
"                smtp.login(self.username, self.password)\n"
"                msg = \"From: %s\\r\\nTo: %s\\r\\nSubject: %s\\r\\n\\r\\n\" % (self.fromaddr, ','.join(self.toaddrs), self.subject)\n"
"                for record in self.buffer:\n"
"                    s = self.format(record)\n"
"                    msg = msg + s + \"\\r\\n\"\n"
"                smtp.sendmail(self.fromaddr, self.toaddrs, msg)\n"
"                smtp.quit()\n"
"            except Exception:\n"
"                if logging.raiseExceptions:\n"
"                    raise\n"
"            self.buffer = []\n"
"\n"
"if __name__ == '__main__':\n"
"    import argparse\n"
"\n"
"    ap = argparse.ArgumentParser()\n"
"    aa = ap.add_argument\n"
"    aa('host', metavar='HOST', help='SMTP server')\n"
"    aa('--port', '-p', type=int, default=587, help='SMTP port')\n"
"    aa('user', metavar='USER', help='SMTP username')\n"
"    aa('password', metavar='PASSWORD', help='SMTP password')\n"
"    aa('to', metavar='TO', help='Addressee for emails')\n"
"    aa('sender', metavar='SENDER', help='Sender email address')\n"
"    aa('--subject', '-s',\n"
"       default='Test Logging email from Python logging module (buffering)',\n"
"       help='Subject of email')\n"
"    options = ap.parse_args()\n"
"    logger = logging.getLogger()\n"
"    logger.setLevel(logging.DEBUG)\n"
"    h = BufferingSMTPHandler(options.host, options.port, options.user,\n"
"                             options.password, options.sender,\n"
"                             options.to, options.subject, 10)\n"
"    logger.addHandler(h)\n"
"    for i in range(102):\n"
"        logger.info(\"Info index = %d\", i)\n"
"    h.flush()\n"
"    h.close()"

#: ../../howto/logging-cookbook.rst:3227
msgid ""
"If you run this script and your SMTP server is correctly set up, you should "
"find that it sends eleven emails to the addressee you specify. The first ten"
" emails will each have ten log messages, and the eleventh will have two "
"messages. That makes up 102 messages as specified in the script."
msgstr ""
"如果你运行此脚本并且你的 SMTP 服务器已正确设置，你将发现它会向你指定的地址发出十一封电子邮件。 "
"前十封邮件每封各有十条日志消息，第十一封将有两条消息。 如脚本所指定的总计为 102 条消息。"

#: ../../howto/logging-cookbook.rst:3235
msgid "Formatting times using UTC (GMT) via configuration"
msgstr "通过配置使用UTC (GMT) 格式化时间"

#: ../../howto/logging-cookbook.rst:3237
msgid ""
"Sometimes you want to format times using UTC, which can be done using a "
"class such as ``UTCFormatter``, shown below::"
msgstr "有时你会想要使用 UTC 时间格式，这可以用 ``UTCFormatter`` 这样的类来实现，如下所示::"

#: ../../howto/logging-cookbook.rst:3240
msgid ""
"import logging\n"
"import time\n"
"\n"
"class UTCFormatter(logging.Formatter):\n"
"    converter = time.gmtime"
msgstr ""
"import logging\n"
"import time\n"
"\n"
"class UTCFormatter(logging.Formatter):\n"
"    converter = time.gmtime"

#: ../../howto/logging-cookbook.rst:3246
msgid ""
"and you can then use the ``UTCFormatter`` in your code instead of "
":class:`~logging.Formatter`. If you want to do that via configuration, you "
"can use the :func:`~logging.config.dictConfig` API with an approach "
"illustrated by the following complete example::"
msgstr ""
"然后你可以在你的代码中使用 ``UTCFormatter``，而不是 :class:`~logging.Formatter`。 "
"如果你想通过配置来实现这一功能，你可以使用 :func:`~logging.config.dictConfig` API "
"来完成，该方法在以下完整示例中展示::"

#: ../../howto/logging-cookbook.rst:3251
msgid ""
"import logging\n"
"import logging.config\n"
"import time\n"
"\n"
"class UTCFormatter(logging.Formatter):\n"
"    converter = time.gmtime\n"
"\n"
"LOGGING = {\n"
"    'version': 1,\n"
"    'disable_existing_loggers': False,\n"
"    'formatters': {\n"
"        'utc': {\n"
"            '()': UTCFormatter,\n"
"            'format': '%(asctime)s %(message)s',\n"
"        },\n"
"        'local': {\n"
"            'format': '%(asctime)s %(message)s',\n"
"        }\n"
"    },\n"
"    'handlers': {\n"
"        'console1': {\n"
"            'class': 'logging.StreamHandler',\n"
"            'formatter': 'utc',\n"
"        },\n"
"        'console2': {\n"
"            'class': 'logging.StreamHandler',\n"
"            'formatter': 'local',\n"
"        },\n"
"    },\n"
"    'root': {\n"
"        'handlers': ['console1', 'console2'],\n"
"   }\n"
"}\n"
"\n"
"if __name__ == '__main__':\n"
"    logging.config.dictConfig(LOGGING)\n"
"    logging.warning('The local time is %s', time.asctime())"
msgstr ""
"import logging\n"
"import logging.config\n"
"import time\n"
"\n"
"class UTCFormatter(logging.Formatter):\n"
"    converter = time.gmtime\n"
"\n"
"LOGGING = {\n"
"    'version': 1,\n"
"    'disable_existing_loggers': False,\n"
"    'formatters': {\n"
"        'utc': {\n"
"            '()': UTCFormatter,\n"
"            'format': '%(asctime)s %(message)s',\n"
"        },\n"
"        'local': {\n"
"            'format': '%(asctime)s %(message)s',\n"
"        }\n"
"    },\n"
"    'handlers': {\n"
"        'console1': {\n"
"            'class': 'logging.StreamHandler',\n"
"            'formatter': 'utc',\n"
"        },\n"
"        'console2': {\n"
"            'class': 'logging.StreamHandler',\n"
"            'formatter': 'local',\n"
"        },\n"
"    },\n"
"    'root': {\n"
"        'handlers': ['console1', 'console2'],\n"
"   }\n"
"}\n"
"\n"
"if __name__ == '__main__':\n"
"    logging.config.dictConfig(LOGGING)\n"
"    logging.warning('The local time is %s', time.asctime())"

#: ../../howto/logging-cookbook.rst:3289
msgid "When this script is run, it should print something like:"
msgstr "脚本会运行输出类似下面的内容:"

#: ../../howto/logging-cookbook.rst:3291
msgid ""
"2015-10-17 12:53:29,501 The local time is Sat Oct 17 13:53:29 2015\n"
"2015-10-17 13:53:29,501 The local time is Sat Oct 17 13:53:29 2015"
msgstr ""
"2015-10-17 12:53:29,501 The local time is Sat Oct 17 13:53:29 2015\n"
"2015-10-17 13:53:29,501 The local time is Sat Oct 17 13:53:29 2015"

#: ../../howto/logging-cookbook.rst:3296
msgid ""
"showing how the time is formatted both as local time and UTC, one for each "
"handler."
msgstr "展示了如何将时间格式化为本地时间和UTC两种形式，其中每种形式对应一个日志处理器 。"

#: ../../howto/logging-cookbook.rst:3303
msgid "Using a context manager for selective logging"
msgstr "使用上下文管理器的可选的日志记录"

#: ../../howto/logging-cookbook.rst:3305
msgid ""
"There are times when it would be useful to temporarily change the logging "
"configuration and revert it back after doing something. For this, a context "
"manager is the most obvious way of saving and restoring the logging context."
" Here is a simple example of such a context manager, which allows you to "
"optionally change the logging level and add a logging handler purely in the "
"scope of the context manager::"
msgstr ""
"有时候，我们需要暂时更改日志配置，并在执行某些操作后将其还原。为此，上下文管理器是实现保存和恢复日志上下文的最明显的方式。这是一个关于上下文管理器的简单例子，它允许你在上下文管理器的作用域内更改日志记录等级以及增加日志处理器："

#: ../../howto/logging-cookbook.rst:3312
msgid ""
"import logging\n"
"import sys\n"
"\n"
"class LoggingContext:\n"
"    def __init__(self, logger, level=None, handler=None, close=True):\n"
"        self.logger = logger\n"
"        self.level = level\n"
"        self.handler = handler\n"
"        self.close = close\n"
"\n"
"    def __enter__(self):\n"
"        if self.level is not None:\n"
"            self.old_level = self.logger.level\n"
"            self.logger.setLevel(self.level)\n"
"        if self.handler:\n"
"            self.logger.addHandler(self.handler)\n"
"\n"
"    def __exit__(self, et, ev, tb):\n"
"        if self.level is not None:\n"
"            self.logger.setLevel(self.old_level)\n"
"        if self.handler:\n"
"            self.logger.removeHandler(self.handler)\n"
"        if self.handler and self.close:\n"
"            self.handler.close()\n"
"        # implicit return of None => don't swallow exceptions"
msgstr ""
"import logging\n"
"import sys\n"
"\n"
"class LoggingContext:\n"
"    def __init__(self, logger, level=None, handler=None, close=True):\n"
"        self.logger = logger\n"
"        self.level = level\n"
"        self.handler = handler\n"
"        self.close = close\n"
"\n"
"    def __enter__(self):\n"
"        if self.level is not None:\n"
"            self.old_level = self.logger.level\n"
"            self.logger.setLevel(self.level)\n"
"        if self.handler:\n"
"            self.logger.addHandler(self.handler)\n"
"\n"
"    def __exit__(self, et, ev, tb):\n"
"        if self.level is not None:\n"
"            self.logger.setLevel(self.old_level)\n"
"        if self.handler:\n"
"            self.logger.removeHandler(self.handler)\n"
"        if self.handler and self.close:\n"
"            self.handler.close()\n"
"        # 隐式地返回 None => 不捕获异常"

#: ../../howto/logging-cookbook.rst:3338
msgid ""
"If you specify a level value, the logger's level is set to that value in the"
" scope of the with block covered by the context manager. If you specify a "
"handler, it is added to the logger on entry to the block and removed on exit"
" from the block. You can also ask the manager to close the handler for you "
"on block exit - you could do this if you don't need the handler any more."
msgstr ""
"如果指定上下文管理器的日志记录等级属性，则在上下文管理器的with语句所涵盖的代码中，日志记录器的记录等级将临时设置为上下文管理器所配置的日志记录等级。"
" 如果指定上下文管理的日志处理器属性，则该句柄在进入上下文管理器的上下文时添加到记录器中，并在退出时被删除。 "
"如果你再也不需要该日志处理器时，你可以让上下文管理器在退出上下文管理器的上下文时关闭它。"

#: ../../howto/logging-cookbook.rst:3344
msgid ""
"To illustrate how it works, we can add the following block of code to the "
"above::"
msgstr "为了说明它是如何工作的，我们可以在上面添加以下代码块::"

#: ../../howto/logging-cookbook.rst:3347
msgid ""
"if __name__ == '__main__':\n"
"    logger = logging.getLogger('foo')\n"
"    logger.addHandler(logging.StreamHandler())\n"
"    logger.setLevel(logging.INFO)\n"
"    logger.info('1. This should appear just once on stderr.')\n"
"    logger.debug('2. This should not appear.')\n"
"    with LoggingContext(logger, level=logging.DEBUG):\n"
"        logger.debug('3. This should appear once on stderr.')\n"
"    logger.debug('4. This should not appear.')\n"
"    h = logging.StreamHandler(sys.stdout)\n"
"    with LoggingContext(logger, level=logging.DEBUG, handler=h, close=True):\n"
"        logger.debug('5. This should appear twice - once on stderr and once on stdout.')\n"
"    logger.info('6. This should appear just once on stderr.')\n"
"    logger.debug('7. This should not appear.')"
msgstr ""
"if __name__ == '__main__':\n"
"    logger = logging.getLogger('foo')\n"
"    logger.addHandler(logging.StreamHandler())\n"
"    logger.setLevel(logging.INFO)\n"
"    logger.info('1. This should appear just once on stderr.')\n"
"    logger.debug('2. This should not appear.')\n"
"    with LoggingContext(logger, level=logging.DEBUG):\n"
"        logger.debug('3. This should appear once on stderr.')\n"
"    logger.debug('4. This should not appear.')\n"
"    h = logging.StreamHandler(sys.stdout)\n"
"    with LoggingContext(logger, level=logging.DEBUG, handler=h, close=True):\n"
"        logger.debug('5. This should appear twice - once on stderr and once on stdout.')\n"
"    logger.info('6. This should appear just once on stderr.')\n"
"    logger.debug('7. This should not appear.')"

#: ../../howto/logging-cookbook.rst:3362
msgid ""
"We initially set the logger's level to ``INFO``, so message #1 appears and "
"message #2 doesn't. We then change the level to ``DEBUG`` temporarily in the"
" following ``with`` block, and so message #3 appears. After the block exits,"
" the logger's level is restored to ``INFO`` and so message #4 doesn't "
"appear. In the next ``with`` block, we set the level to ``DEBUG`` again but "
"also add a handler writing to ``sys.stdout``. Thus, message #5 appears twice"
" on the console (once via ``stderr`` and once via ``stdout``). After the "
"``with`` statement's completion, the status is as it was before so message "
"#6 appears (like message #1) whereas message #7 doesn't (just like message "
"#2)."
msgstr ""
"我们最初设置日志记录器的消息等级为 ``INFO`` ，因此消息#1出现，消息#2没有出现。在接下来的 ``with`` "
"代码块中我们暂时将消息等级变更为 ``DEBUG`` ，从而消息 #3 出现。在这一代码块退出后，日志记录器的消息等级恢复为 ``INFO`` "
"，从而消息 #4 没有出现。在下一个 ``with`` 代码块中，我们再一次将设置消息等级设置为 ``DEBUG`` ，同时添加一个将消息写入 "
"``sys.stdout`` 的日志处理器。因此，消息#5在控制台出现两次 (分别通过 ``stderr`` 和 ``stdout`` )。在 "
"``with`` 语句完成后，状态与之前一样，因此消息 #6 出现（类似消息 #1），而消息 #7 没有出现（类似消息 #2）。"

#: ../../howto/logging-cookbook.rst:3372
msgid "If we run the resulting script, the result is as follows:"
msgstr "如果我们运行生成的脚本，结果如下："

#: ../../howto/logging-cookbook.rst:3374
msgid ""
"$ python logctx.py\n"
"1. This should appear just once on stderr.\n"
"3. This should appear once on stderr.\n"
"5. This should appear twice - once on stderr and once on stdout.\n"
"5. This should appear twice - once on stderr and once on stdout.\n"
"6. This should appear just once on stderr."
msgstr ""
"$ python logctx.py\n"
"1. This should appear just once on stderr.\n"
"3. This should appear once on stderr.\n"
"5. This should appear twice - once on stderr and once on stdout.\n"
"5. This should appear twice - once on stderr and once on stdout.\n"
"6. This should appear just once on stderr."

#: ../../howto/logging-cookbook.rst:3383
msgid ""
"If we run it again, but pipe ``stderr`` to ``/dev/null``, we see the "
"following, which is the only message written to ``stdout``:"
msgstr ""
"我们将 ``stderr`` 标准错误重定向到 ``/dev/null`` ，我再次运行生成的脚步，唯一被写入 ``stdout`` "
"标准输出的消息，即我们所能看见的消息，如下："

#: ../../howto/logging-cookbook.rst:3386
msgid ""
"$ python logctx.py 2>/dev/null\n"
"5. This should appear twice - once on stderr and once on stdout."
msgstr ""
"$ python logctx.py 2>/dev/null\n"
"5. This should appear twice - once on stderr and once on stdout."

#: ../../howto/logging-cookbook.rst:3391
msgid "Once again, but piping ``stdout`` to ``/dev/null``, we get:"
msgstr "再一次，将 ``stdout`` 标准输出重定向到 ``/dev/null``，我获得如下结果："

#: ../../howto/logging-cookbook.rst:3393
msgid ""
"$ python logctx.py >/dev/null\n"
"1. This should appear just once on stderr.\n"
"3. This should appear once on stderr.\n"
"5. This should appear twice - once on stderr and once on stdout.\n"
"6. This should appear just once on stderr."
msgstr ""

#: ../../howto/logging-cookbook.rst:3401
msgid ""
"In this case, the message #5 printed to ``stdout`` doesn't appear, as "
"expected."
msgstr "在这种情况下，与预期一致，打印到 ``stdout`` 标准输出的消息＃5不会出现。"

#: ../../howto/logging-cookbook.rst:3403
msgid ""
"Of course, the approach described here can be generalised, for example to "
"attach logging filters temporarily. Note that the above code works in Python"
" 2 as well as Python 3."
msgstr "当然，这里描述的方法可以被推广，例如临时附加日志记录过滤器。 请注意，上面的代码适用于Python 2以及Python 3。"

#: ../../howto/logging-cookbook.rst:3411
msgid "A CLI application starter template"
msgstr "命令行日志应用起步"

#: ../../howto/logging-cookbook.rst:3413
msgid "Here's an example which shows how you can:"
msgstr "下面的示例提供了如下功能："

#: ../../howto/logging-cookbook.rst:3415
msgid "Use a logging level based on command-line arguments"
msgstr "根据命令行参数确定日志级别"

#: ../../howto/logging-cookbook.rst:3416
msgid ""
"Dispatch to multiple subcommands in separate files, all logging at the same "
"level in a consistent way"
msgstr "在单独的文件中分发多条子命令，同一级别的子命令均以一致的方式记录。"

#: ../../howto/logging-cookbook.rst:3418
msgid "Make use of simple, minimal configuration"
msgstr "最简单的配置用法"

#: ../../howto/logging-cookbook.rst:3420
msgid ""
"Suppose we have a command-line application whose job is to stop, start or "
"restart some services. This could be organised for the purposes of "
"illustration as a file ``app.py`` that is the main script for the "
"application, with individual commands implemented in ``start.py``, "
"``stop.py`` and ``restart.py``. Suppose further that we want to control the "
"verbosity of the application via a command-line argument, defaulting to "
"``logging.INFO``. Here's one way that ``app.py`` could be written::"
msgstr ""
"假定有一个命令行应用程序，用于停止、启动或重新启动某些服务。为了便于演示，不妨将 ``app.py`` 作为应用程序的主代码文件，并在  "
"``start.py`` 、 ``stop.py`` 和 ``restart.py`` "
"中实现单独的命令。再假定要通过命令行参数控制应用程序的日志粒度，默认为 ``logging.INFO`` 。以下是 ``app.py`` 的一个示例："

#: ../../howto/logging-cookbook.rst:3428
msgid ""
"import argparse\n"
"import importlib\n"
"import logging\n"
"import os\n"
"import sys\n"
"\n"
"def main(args=None):\n"
"    scriptname = os.path.basename(__file__)\n"
"    parser = argparse.ArgumentParser(scriptname)\n"
"    levels = ('DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL')\n"
"    parser.add_argument('--log-level', default='INFO', choices=levels)\n"
"    subparsers = parser.add_subparsers(dest='command',\n"
"                                       help='Available commands:')\n"
"    start_cmd = subparsers.add_parser('start', help='Start a service')\n"
"    start_cmd.add_argument('name', metavar='NAME',\n"
"                           help='Name of service to start')\n"
"    stop_cmd = subparsers.add_parser('stop',\n"
"                                     help='Stop one or more services')\n"
"    stop_cmd.add_argument('names', metavar='NAME', nargs='+',\n"
"                          help='Name of service to stop')\n"
"    restart_cmd = subparsers.add_parser('restart',\n"
"                                        help='Restart one or more services')\n"
"    restart_cmd.add_argument('names', metavar='NAME', nargs='+',\n"
"                             help='Name of service to restart')\n"
"    options = parser.parse_args()\n"
"    # the code to dispatch commands could all be in this file. For the purposes\n"
"    # of illustration only, we implement each command in a separate module.\n"
"    try:\n"
"        mod = importlib.import_module(options.command)\n"
"        cmd = getattr(mod, 'command')\n"
"    except (ImportError, AttributeError):\n"
"        print('Unable to find the code for command \\'%s\\'' % options.command)\n"
"        return 1\n"
"    # Could get fancy here and load configuration from file or dictionary\n"
"    logging.basicConfig(level=options.log_level,\n"
"                        format='%(levelname)s %(name)s %(message)s')\n"
"    cmd(options)\n"
"\n"
"if __name__ == '__main__':\n"
"    sys.exit(main())"
msgstr ""

#: ../../howto/logging-cookbook.rst:3469
msgid ""
"And the ``start``, ``stop`` and ``restart`` commands can be implemented in "
"separate modules, like so for starting::"
msgstr "``start``、``stop`` 和 ``restart`` 命令可以在单独的模块中实现，启动命令的代码可如下："

#: ../../howto/logging-cookbook.rst:3472
msgid ""
"# start.py\n"
"import logging\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"def command(options):\n"
"    logger.debug('About to start %s', options.name)\n"
"    # actually do the command processing here ...\n"
"    logger.info('Started the \\'%s\\' service.', options.name)"
msgstr ""

#: ../../howto/logging-cookbook.rst:3482
msgid "and thus for stopping::"
msgstr "然后是停止命令的代码："

#: ../../howto/logging-cookbook.rst:3484
msgid ""
"# stop.py\n"
"import logging\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"def command(options):\n"
"    n = len(options.names)\n"
"    if n == 1:\n"
"        plural = ''\n"
"        services = '\\'%s\\'' % options.names[0]\n"
"    else:\n"
"        plural = 's'\n"
"        services = ', '.join('\\'%s\\'' % name for name in options.names)\n"
"        i = services.rfind(', ')\n"
"        services = services[:i] + ' and ' + services[i + 2:]\n"
"    logger.debug('About to stop %s', services)\n"
"    # actually do the command processing here ...\n"
"    logger.info('Stopped the %s service%s.', services, plural)"
msgstr ""

#: ../../howto/logging-cookbook.rst:3503
msgid "and similarly for restarting::"
msgstr "重启命令类似："

#: ../../howto/logging-cookbook.rst:3505
msgid ""
"# restart.py\n"
"import logging\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"def command(options):\n"
"    n = len(options.names)\n"
"    if n == 1:\n"
"        plural = ''\n"
"        services = '\\'%s\\'' % options.names[0]\n"
"    else:\n"
"        plural = 's'\n"
"        services = ', '.join('\\'%s\\'' % name for name in options.names)\n"
"        i = services.rfind(', ')\n"
"        services = services[:i] + ' and ' + services[i + 2:]\n"
"    logger.debug('About to restart %s', services)\n"
"    # actually do the command processing here ...\n"
"    logger.info('Restarted the %s service%s.', services, plural)"
msgstr ""

#: ../../howto/logging-cookbook.rst:3524
msgid ""
"If we run this application with the default log level, we get output like "
"this:"
msgstr "如果以默认日志级别运行该程序，会得到以下结果："

#: ../../howto/logging-cookbook.rst:3526
msgid ""
"$ python app.py start foo\n"
"INFO start Started the 'foo' service.\n"
"\n"
"$ python app.py stop foo bar\n"
"INFO stop Stopped the 'foo' and 'bar' services.\n"
"\n"
"$ python app.py restart foo bar baz\n"
"INFO restart Restarted the 'foo', 'bar' and 'baz' services."
msgstr ""

#: ../../howto/logging-cookbook.rst:3537
msgid ""
"The first word is the logging level, and the second word is the module or "
"package name of the place where the event was logged."
msgstr "第一个单词是日志级别，第二个单词是日志事件所在的模块或包的名称。"

#: ../../howto/logging-cookbook.rst:3540
msgid ""
"If we change the logging level, then we can change the information sent to "
"the log. For example, if we want more information:"
msgstr "如果修改了日志级别，发送给日志的信息就能得以改变。如要显示更多信息，则可："

#: ../../howto/logging-cookbook.rst:3543
msgid ""
"$ python app.py --log-level DEBUG start foo\n"
"DEBUG start About to start foo\n"
"INFO start Started the 'foo' service.\n"
"\n"
"$ python app.py --log-level DEBUG stop foo bar\n"
"DEBUG stop About to stop 'foo' and 'bar'\n"
"INFO stop Stopped the 'foo' and 'bar' services.\n"
"\n"
"$ python app.py --log-level DEBUG restart foo bar baz\n"
"DEBUG restart About to restart 'foo', 'bar' and 'baz'\n"
"INFO restart Restarted the 'foo', 'bar' and 'baz' services."
msgstr ""

#: ../../howto/logging-cookbook.rst:3557
msgid "And if we want less:"
msgstr "若要显示的信息少一些，则："

#: ../../howto/logging-cookbook.rst:3559
msgid ""
"$ python app.py --log-level WARNING start foo\n"
"$ python app.py --log-level WARNING stop foo bar\n"
"$ python app.py --log-level WARNING restart foo bar baz"
msgstr ""

#: ../../howto/logging-cookbook.rst:3565
msgid ""
"In this case, the commands don't print anything to the console, since "
"nothing at ``WARNING`` level or above is logged by them."
msgstr "这里的命令不会向控制台输出任何信息，因为没有记录 ``WARNING`` 以上级别的日志。"

#: ../../howto/logging-cookbook.rst:3571
msgid "A Qt GUI for logging"
msgstr "Qt GUI 日志示例"

#: ../../howto/logging-cookbook.rst:3573
msgid ""
"A question that comes up from time to time is about how to log to a GUI "
"application. The `Qt <https://www.qt.io/>`_ framework is a popular cross-"
"platform UI framework with Python bindings using :pypi:`PySide2` or "
":pypi:`PyQt5` libraries."
msgstr ""
"一个时常被提出的问题是 GUI 应用程序要如何记录日志。 `Qt <https://www.qt.io/>`_ 框架是一个流行的跨平台 UI "
"框架，它具有使用 :pypi:`PySide2` 或 :pypi:`PyQt5` 库的 Python 绑定。"

#: ../../howto/logging-cookbook.rst:3578
msgid ""
"The following example shows how to log to a Qt GUI. This introduces a simple"
" ``QtHandler`` class which takes a callable, which should be a slot in the "
"main thread that does GUI updates. A worker thread is also created to show "
"how you can log to the GUI from both the UI itself (via a button for manual "
"logging) as well as a worker thread doing work in the background (here, just"
" logging messages at random levels with random short delays in between)."
msgstr ""
"下面的例子演示了将日志写入 Qt GUI 程序的过程。这里引入了一个简单的 ``QtHandler`` "
"类，参数是一个可调用对象，其应为嵌入主线程某个“槽位”中运行的，因为GUI 的更新由主线程完成。这里还创建了一个工作线程，以便演示由 "
"UI（通过人工点击日志按钮）和后台工作线程（此处只是记录级别和时间间隔均随机生成的日志信息）将日志写入 GUI 的过程。"

#: ../../howto/logging-cookbook.rst:3585
msgid ""
"The worker thread is implemented using Qt's ``QThread`` class rather than "
"the :mod:`threading` module, as there are circumstances where one has to use"
" ``QThread``, which offers better integration with other ``Qt`` components."
msgstr ""
"该工作线程是用 Qt 的 ``QThread`` 类实现的，而不是 :mod:`threading` 模块，因为某些情况下只能采用 "
"```QThread``，它与其他 ``Qt`` 组件的集成性更好一些。"

#: ../../howto/logging-cookbook.rst:3589
msgid ""
"The code should work with recent releases of any of ``PySide6``, ``PyQt6``, "
"``PySide2`` or ``PyQt5``. You should be able to adapt the approach to "
"earlier versions of Qt. Please refer to the comments in the code snippet for"
" more detailed information."
msgstr ""
"此代码应当适用于最新的 ``PySide6``, ``PyQt6``, ``PySide2`` 或 ``PyQt5`` 发布版。 "
"你也可以将此做法适配到更早的 Qt 版本。 请参阅代码片段中的注释来获取更详细的信息。"

#: ../../howto/logging-cookbook.rst:3594
msgid ""
"import datetime\n"
"import logging\n"
"import random\n"
"import sys\n"
"import time\n"
"\n"
"# Deal with minor differences between different Qt packages\n"
"try:\n"
"    from PySide6 import QtCore, QtGui, QtWidgets\n"
"    Signal = QtCore.Signal\n"
"    Slot = QtCore.Slot\n"
"except ImportError:\n"
"    try:\n"
"        from PyQt6 import QtCore, QtGui, QtWidgets\n"
"        Signal = QtCore.pyqtSignal\n"
"        Slot = QtCore.pyqtSlot\n"
"    except ImportError:\n"
"        try:\n"
"            from PySide2 import QtCore, QtGui, QtWidgets\n"
"            Signal = QtCore.Signal\n"
"            Slot = QtCore.Slot\n"
"        except ImportError:\n"
"            from PyQt5 import QtCore, QtGui, QtWidgets\n"
"            Signal = QtCore.pyqtSignal\n"
"            Slot = QtCore.pyqtSlot\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"\n"
"#\n"
"# Signals need to be contained in a QObject or subclass in order to be correctly\n"
"# initialized.\n"
"#\n"
"class Signaller(QtCore.QObject):\n"
"    signal = Signal(str, logging.LogRecord)\n"
"\n"
"#\n"
"# Output to a Qt GUI is only supposed to happen on the main thread. So, this\n"
"# handler is designed to take a slot function which is set up to run in the main\n"
"# thread. In this example, the function takes a string argument which is a\n"
"# formatted log message, and the log record which generated it. The formatted\n"
"# string is just a convenience - you could format a string for output any way\n"
"# you like in the slot function itself.\n"
"#\n"
"# You specify the slot function to do whatever GUI updates you want. The handler\n"
"# doesn't know or care about specific UI elements.\n"
"#\n"
"class QtHandler(logging.Handler):\n"
"    def __init__(self, slotfunc, *args, **kwargs):\n"
"        super().__init__(*args, **kwargs)\n"
"        self.signaller = Signaller()\n"
"        self.signaller.signal.connect(slotfunc)\n"
"\n"
"    def emit(self, record):\n"
"        s = self.format(record)\n"
"        self.signaller.signal.emit(s, record)\n"
"\n"
"#\n"
"# This example uses QThreads, which means that the threads at the Python level\n"
"# are named something like \"Dummy-1\". The function below gets the Qt name of the\n"
"# current thread.\n"
"#\n"
"def ctname():\n"
"    return QtCore.QThread.currentThread().objectName()\n"
"\n"
"\n"
"#\n"
"# Used to generate random levels for logging.\n"
"#\n"
"LEVELS = (logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR,\n"
"          logging.CRITICAL)\n"
"\n"
"#\n"
"# This worker class represents work that is done in a thread separate to the\n"
"# main thread. The way the thread is kicked off to do work is via a button press\n"
"# that connects to a slot in the worker.\n"
"#\n"
"# Because the default threadName value in the LogRecord isn't much use, we add\n"
"# a qThreadName which contains the QThread name as computed above, and pass that\n"
"# value in an \"extra\" dictionary which is used to update the LogRecord with the\n"
"# QThread name.\n"
"#\n"
"# This example worker just outputs messages sequentially, interspersed with\n"
"# random delays of the order of a few seconds.\n"
"#\n"
"class Worker(QtCore.QObject):\n"
"    @Slot()\n"
"    def start(self):\n"
"        extra = {'qThreadName': ctname() }\n"
"        logger.debug('Started work', extra=extra)\n"
"        i = 1\n"
"        # Let the thread run until interrupted. This allows reasonably clean\n"
"        # thread termination.\n"
"        while not QtCore.QThread.currentThread().isInterruptionRequested():\n"
"            delay = 0.5 + random.random() * 2\n"
"            time.sleep(delay)\n"
"            try:\n"
"                if random.random() < 0.1:\n"
"                    raise ValueError('Exception raised: %d' % i)\n"
"                else:\n"
"                    level = random.choice(LEVELS)\n"
"                    logger.log(level, 'Message after delay of %3.1f: %d', delay, i, extra=extra)\n"
"            except ValueError as e:\n"
"                logger.exception('Failed: %s', e, extra=extra)\n"
"            i += 1\n"
"\n"
"#\n"
"# Implement a simple UI for this cookbook example. This contains:\n"
"#\n"
"# * A read-only text edit window which holds formatted log messages\n"
"# * A button to start work and log stuff in a separate thread\n"
"# * A button to log something from the main thread\n"
"# * A button to clear the log window\n"
"#\n"
"class Window(QtWidgets.QWidget):\n"
"\n"
"    COLORS = {\n"
"        logging.DEBUG: 'black',\n"
"        logging.INFO: 'blue',\n"
"        logging.WARNING: 'orange',\n"
"        logging.ERROR: 'red',\n"
"        logging.CRITICAL: 'purple',\n"
"    }\n"
"\n"
"    def __init__(self, app):\n"
"        super().__init__()\n"
"        self.app = app\n"
"        self.textedit = te = QtWidgets.QPlainTextEdit(self)\n"
"        # Set whatever the default monospace font is for the platform\n"
"        f = QtGui.QFont('nosuchfont')\n"
"        if hasattr(f, 'Monospace'):\n"
"            f.setStyleHint(f.Monospace)\n"
"        else:\n"
"            f.setStyleHint(f.StyleHint.Monospace)  # for Qt6\n"
"        te.setFont(f)\n"
"        te.setReadOnly(True)\n"
"        PB = QtWidgets.QPushButton\n"
"        self.work_button = PB('Start background work', self)\n"
"        self.log_button = PB('Log a message at a random level', self)\n"
"        self.clear_button = PB('Clear log window', self)\n"
"        self.handler = h = QtHandler(self.update_status)\n"
"        # Remember to use qThreadName rather than threadName in the format string.\n"
"        fs = '%(asctime)s %(qThreadName)-12s %(levelname)-8s %(message)s'\n"
"        formatter = logging.Formatter(fs)\n"
"        h.setFormatter(formatter)\n"
"        logger.addHandler(h)\n"
"        # Set up to terminate the QThread when we exit\n"
"        app.aboutToQuit.connect(self.force_quit)\n"
"\n"
"        # Lay out all the widgets\n"
"        layout = QtWidgets.QVBoxLayout(self)\n"
"        layout.addWidget(te)\n"
"        layout.addWidget(self.work_button)\n"
"        layout.addWidget(self.log_button)\n"
"        layout.addWidget(self.clear_button)\n"
"        self.setFixedSize(900, 400)\n"
"\n"
"        # Connect the non-worker slots and signals\n"
"        self.log_button.clicked.connect(self.manual_update)\n"
"        self.clear_button.clicked.connect(self.clear_display)\n"
"\n"
"        # Start a new worker thread and connect the slots for the worker\n"
"        self.start_thread()\n"
"        self.work_button.clicked.connect(self.worker.start)\n"
"        # Once started, the button should be disabled\n"
"        self.work_button.clicked.connect(lambda : self.work_button.setEnabled(False))\n"
"\n"
"    def start_thread(self):\n"
"        self.worker = Worker()\n"
"        self.worker_thread = QtCore.QThread()\n"
"        self.worker.setObjectName('Worker')\n"
"        self.worker_thread.setObjectName('WorkerThread')  # for qThreadName\n"
"        self.worker.moveToThread(self.worker_thread)\n"
"        # This will start an event loop in the worker thread\n"
"        self.worker_thread.start()\n"
"\n"
"    def kill_thread(self):\n"
"        # Just tell the worker to stop, then tell it to quit and wait for that\n"
"        # to happen\n"
"        self.worker_thread.requestInterruption()\n"
"        if self.worker_thread.isRunning():\n"
"            self.worker_thread.quit()\n"
"            self.worker_thread.wait()\n"
"        else:\n"
"            print('worker has already exited.')\n"
"\n"
"    def force_quit(self):\n"
"        # For use when the window is closed\n"
"        if self.worker_thread.isRunning():\n"
"            self.kill_thread()\n"
"\n"
"    # The functions below update the UI and run in the main thread because\n"
"    # that's where the slots are set up\n"
"\n"
"    @Slot(str, logging.LogRecord)\n"
"    def update_status(self, status, record):\n"
"        color = self.COLORS.get(record.levelno, 'black')\n"
"        s = '<pre><font color=\"%s\">%s</font></pre>' % (color, status)\n"
"        self.textedit.appendHtml(s)\n"
"\n"
"    @Slot()\n"
"    def manual_update(self):\n"
"        # This function uses the formatted message passed in, but also uses\n"
"        # information from the record to format the message in an appropriate\n"
"        # color according to its severity (level).\n"
"        level = random.choice(LEVELS)\n"
"        extra = {'qThreadName': ctname() }\n"
"        logger.log(level, 'Manually logged!', extra=extra)\n"
"\n"
"    @Slot()\n"
"    def clear_display(self):\n"
"        self.textedit.clear()\n"
"\n"
"\n"
"def main():\n"
"    QtCore.QThread.currentThread().setObjectName('MainThread')\n"
"    logging.getLogger().setLevel(logging.DEBUG)\n"
"    app = QtWidgets.QApplication(sys.argv)\n"
"    example = Window(app)\n"
"    example.show()\n"
"    if hasattr(app, 'exec'):\n"
"        rc = app.exec()\n"
"    else:\n"
"        rc = app.exec_()\n"
"    sys.exit(rc)\n"
"\n"
"if __name__=='__main__':\n"
"    main()"
msgstr ""

#: ../../howto/logging-cookbook.rst:3826
msgid "Logging to syslog with RFC5424 support"
msgstr "将日志记录到带有 RFC5424 支持的 syslog"

#: ../../howto/logging-cookbook.rst:3828
msgid ""
"Although :rfc:`5424` dates from 2009, most syslog servers are configured by "
"default to use the older :rfc:`3164`, which hails from 2001. When "
"``logging`` was added to Python in 2003, it supported the earlier (and only "
"existing) protocol at the time. Since RFC5424 came out, as there has not "
"been widespread deployment of it in syslog servers, the "
":class:`~logging.handlers.SysLogHandler` functionality has not been updated."
msgstr ""
"虽然 :rfc:`5424` 在 2009 年就已发布，但大多数 syslog 服务器都默认被配置为使用更旧的 :rfc:`3164`，它发布于 "
"2001 年。 当 ``logging`` 在 2003 年被加入 Python 时，它支持了当时（唯一存在的）较早版本的协议。 自从 RFC5424 "
"发布后，因为它还未被广泛部署到 syslog 服务器上，因此 :class:`~logging.handlers.SysLogHandler` "
"的功能也没有被更新。"

#: ../../howto/logging-cookbook.rst:3835
msgid ""
"RFC 5424 contains some useful features such as support for structured data, "
"and if you need to be able to log to a syslog server with support for it, "
"you can do so with a subclassed handler which looks something like this::"
msgstr ""
"RFC 5424 包括一些有用的特性例如对结构化数据的支持等，如果你想要能够将日志记录到带有该协议支持的 syslog "
"服务器上，你可以使用一个看起来像是这样的子类化处理器来实现::"

#: ../../howto/logging-cookbook.rst:3839
msgid ""
"import datetime\n"
"import logging.handlers\n"
"import re\n"
"import socket\n"
"import time\n"
"\n"
"class SysLogHandler5424(logging.handlers.SysLogHandler):\n"
"\n"
"    tz_offset = re.compile(r'([+-]\\d{2})(\\d{2})$')\n"
"    escaped = re.compile(r'([\\]\"\\\\])')\n"
"\n"
"    def __init__(self, *args, **kwargs):\n"
"        self.msgid = kwargs.pop('msgid', None)\n"
"        self.appname = kwargs.pop('appname', None)\n"
"        super().__init__(*args, **kwargs)\n"
"\n"
"    def format(self, record):\n"
"        version = 1\n"
"        asctime = datetime.datetime.fromtimestamp(record.created).isoformat()\n"
"        m = self.tz_offset.match(time.strftime('%z'))\n"
"        has_offset = False\n"
"        if m and time.timezone:\n"
"            hrs, mins = m.groups()\n"
"            if int(hrs) or int(mins):\n"
"                has_offset = True\n"
"        if not has_offset:\n"
"            asctime += 'Z'\n"
"        else:\n"
"            asctime += f'{hrs}:{mins}'\n"
"        try:\n"
"            hostname = socket.gethostname()\n"
"        except Exception:\n"
"            hostname = '-'\n"
"        appname = self.appname or '-'\n"
"        procid = record.process\n"
"        msgid = '-'\n"
"        msg = super().format(record)\n"
"        sdata = '-'\n"
"        if hasattr(record, 'structured_data'):\n"
"            sd = record.structured_data\n"
"            # This should be a dict where the keys are SD-ID and the value is a\n"
"            # dict mapping PARAM-NAME to PARAM-VALUE (refer to the RFC for what these\n"
"            # mean)\n"
"            # There's no error checking here - it's purely for illustration, and you\n"
"            # can adapt this code for use in production environments\n"
"            parts = []\n"
"\n"
"            def replacer(m):\n"
"                g = m.groups()\n"
"                return '\\\\' + g[0]\n"
"\n"
"            for sdid, dv in sd.items():\n"
"                part = f'[{sdid}'\n"
"                for k, v in dv.items():\n"
"                    s = str(v)\n"
"                    s = self.escaped.sub(replacer, s)\n"
"                    part += f' {k}=\"{s}\"'\n"
"                part += ']'\n"
"                parts.append(part)\n"
"            sdata = ''.join(parts)\n"
"        return f'{version} {asctime} {hostname} {appname} {procid} {msgid} {sdata} {msg}'"
msgstr ""

#: ../../howto/logging-cookbook.rst:3901
msgid ""
"You'll need to be familiar with RFC 5424 to fully understand the above code,"
" and it may be that you have slightly different needs (e.g. for how you pass"
" structural data to the log). Nevertheless, the above should be adaptable to"
" your speciric needs. With the above handler, you'd pass structured data "
"using something like this::"
msgstr ""
"你需要熟悉 RFC 5424 才能完全理解上面的代码，你还可能会有稍加变化的的需求（例如你要如何将结构化数据记入日志）。 "
"不管怎样，上面的代码应当根据你的特定需求来灵活调整。 通过上面的处理器，你可以使用类似这样的代码来传入结构化数据::"

#: ../../howto/logging-cookbook.rst:3906
msgid ""
"sd = {\n"
"    'foo@12345': {'bar': 'baz', 'baz': 'bozz', 'fizz': r'buzz'},\n"
"    'foo@54321': {'rab': 'baz', 'zab': 'bozz', 'zzif': r'buzz'}\n"
"}\n"
"extra = {'structured_data': sd}\n"
"i = 1\n"
"logger.debug('Message %d', i, extra=extra)"
msgstr ""

#: ../../howto/logging-cookbook.rst:3915
msgid "How to treat a logger like an output stream"
msgstr "如何将日志记录器作为输出流"

#: ../../howto/logging-cookbook.rst:3917
msgid ""
"Sometimes, you need to interface to a third-party API which expects a file-"
"like object to write to, but you want to direct the API's output to a "
"logger. You can do this using a class which wraps a logger with a file-like "
"API. Here's a short script illustrating such a class:"
msgstr ""
"有时，你需要通过接口访问某个预期要写入到文件型对象第三方 API，但你希望将 API 的输出重定向到一个日志记录器。 你可以使用一个以文件类 API "
"来包装日志记录器的类。 下面是一个演示这样的类的简短脚本:"

#: ../../howto/logging-cookbook.rst:3922
msgid ""
"import logging\n"
"\n"
"class LoggerWriter:\n"
"    def __init__(self, logger, level):\n"
"        self.logger = logger\n"
"        self.level = level\n"
"\n"
"    def write(self, message):\n"
"        if message != '\\n':  # avoid printing bare newlines, if you like\n"
"            self.logger.log(self.level, message)\n"
"\n"
"    def flush(self):\n"
"        # doesn't actually do anything, but might be expected of a file-like\n"
"        # object - so optional depending on your situation\n"
"        pass\n"
"\n"
"    def close(self):\n"
"        # doesn't actually do anything, but might be expected of a file-like\n"
"        # object - so optional depending on your situation. You might want\n"
"        # to set a flag so that later calls to write raise an exception\n"
"        pass\n"
"\n"
"def main():\n"
"    logging.basicConfig(level=logging.DEBUG)\n"
"    logger = logging.getLogger('demo')\n"
"    info_fp = LoggerWriter(logger, logging.INFO)\n"
"    debug_fp = LoggerWriter(logger, logging.DEBUG)\n"
"    print('An INFO message', file=info_fp)\n"
"    print('A DEBUG message', file=debug_fp)\n"
"\n"
"if __name__ == \"__main__\":\n"
"    main()"
msgstr ""

#: ../../howto/logging-cookbook.rst:3957
msgid "When this script is run, it prints"
msgstr "当此脚本运行时，它将打印"

#: ../../howto/logging-cookbook.rst:3959
msgid ""
"INFO:demo:An INFO message\n"
"DEBUG:demo:A DEBUG message"
msgstr ""

#: ../../howto/logging-cookbook.rst:3964
msgid ""
"You could also use ``LoggerWriter`` to redirect ``sys.stdout`` and "
"``sys.stderr`` by doing something like this:"
msgstr ""
"你还可以使用 ``LoggerWriter`` 通过下面这样的做法来重定向 ``sys.stdout`` 和 ``sys.stderr``:"

#: ../../howto/logging-cookbook.rst:3967
msgid ""
"import sys\n"
"\n"
"sys.stdout = LoggerWriter(logger, logging.INFO)\n"
"sys.stderr = LoggerWriter(logger, logging.WARNING)"
msgstr ""

#: ../../howto/logging-cookbook.rst:3974
msgid ""
"You should do this *after* configuring logging for your needs. In the above "
"example, the :func:`~logging.basicConfig` call does this (using the "
"``sys.stderr`` value *before* it is overwritten by a ``LoggerWriter`` "
"instance). Then, you'd get this kind of result:"
msgstr ""
"你应当在根据需要配置日志记录 *之后* 再这样做。 在上面的例子中，:func:`~logging.basicConfig` 调用执行了此操作（在 "
"``sys.stderr`` 被一个 ``LoggerWriter`` 实例覆盖 *之前* 使用它的值）。 然后，你将得到这样的结果:"

#: ../../howto/logging-cookbook.rst:3979
msgid ""
">>> print('Foo')\n"
"INFO:demo:Foo\n"
">>> print('Bar', file=sys.stderr)\n"
"WARNING:demo:Bar\n"
">>>"
msgstr ""

#: ../../howto/logging-cookbook.rst:3987
msgid ""
"Of course, the examples above show output according to the format used by "
":func:`~logging.basicConfig`, but you can use a different formatter when you"
" configure logging."
msgstr ""
"当然，上面的例子是按照 :func:`~logging.basicConfig` 所使用的格式来显示输出的，但你也可以在配置日志记录时使用其他的格式。"

#: ../../howto/logging-cookbook.rst:3991
msgid ""
"Note that with the above scheme, you are somewhat at the mercy of buffering "
"and the sequence of write calls which you are intercepting. For example, "
"with the definition of ``LoggerWriter`` above, if you have the snippet"
msgstr ""
"请注意当使用上面的预置方案时，你将在一定程度上受到你所拦截的写入调用的缓冲和顺序的控制。 例如，在使用上述 ``LoggerWriter`` "
"的定义的情况下，如果你使用代码段"

#: ../../howto/logging-cookbook.rst:3995
msgid ""
"sys.stderr = LoggerWriter(logger, logging.WARNING)\n"
"1 / 0"
msgstr ""
"sys.stderr = LoggerWriter(logger, logging.WARNING)\n"
"1 / 0"

#: ../../howto/logging-cookbook.rst:4000
msgid "then running the script results in"
msgstr "则运行该脚本的结果为"

#: ../../howto/logging-cookbook.rst:4002
msgid ""
"WARNING:demo:Traceback (most recent call last):\n"
"\n"
"WARNING:demo:  File \"/home/runner/cookbook-loggerwriter/test.py\", line 53, in <module>\n"
"\n"
"WARNING:demo:\n"
"WARNING:demo:main()\n"
"WARNING:demo:  File \"/home/runner/cookbook-loggerwriter/test.py\", line 49, in main\n"
"\n"
"WARNING:demo:\n"
"WARNING:demo:1 / 0\n"
"WARNING:demo:ZeroDivisionError\n"
"WARNING:demo::\n"
"WARNING:demo:division by zero"
msgstr ""

#: ../../howto/logging-cookbook.rst:4018
msgid ""
"As you can see, this output isn't ideal. That's because the underlying code "
"which writes to ``sys.stderr`` makes multiple writes, each of which results "
"in a separate logged line (for example, the last three lines above). To get "
"around this problem, you need to buffer things and only output log lines "
"when newlines are seen. Let's use a slightly better implementation of "
"``LoggerWriter``:"
msgstr ""
"如你所见，这个输出并不很理想。 那是因为下层的写入 ``sys.stderr`` "
"的代码会执行多次写入，每次都将产生一条单独的日志记录行（例如，上面的最后三行）。 要避免这个问题，你需要使用缓冲并且只在看到换行符时才输出日志记录行。 "
"让我们使用一个更好些的 ``LoggerWriter`` 实现："

#: ../../howto/logging-cookbook.rst:4024
msgid ""
"class BufferingLoggerWriter(LoggerWriter):\n"
"    def __init__(self, logger, level):\n"
"        super().__init__(logger, level)\n"
"        self.buffer = ''\n"
"\n"
"    def write(self, message):\n"
"        if '\\n' not in message:\n"
"            self.buffer += message\n"
"        else:\n"
"            parts = message.split('\\n')\n"
"            if self.buffer:\n"
"                s = self.buffer + parts.pop(0)\n"
"                self.logger.log(self.level, s)\n"
"            self.buffer = parts.pop()\n"
"            for part in parts:\n"
"                self.logger.log(self.level, part)"
msgstr ""

#: ../../howto/logging-cookbook.rst:4043
msgid ""
"This just buffers up stuff until a newline is seen, and then logs complete "
"lines. With this approach, you get better output:"
msgstr "这段代码对内容进行了缓冲直至遇到换行符，然后将完整的行写入日志记录。 通过这种方式，你将得到更好的输出:"

#: ../../howto/logging-cookbook.rst:4046
msgid ""
"WARNING:demo:Traceback (most recent call last):\n"
"WARNING:demo:  File \"/home/runner/cookbook-loggerwriter/main.py\", line 55, in <module>\n"
"WARNING:demo:    main()\n"
"WARNING:demo:  File \"/home/runner/cookbook-loggerwriter/main.py\", line 52, in main\n"
"WARNING:demo:    1/0\n"
"WARNING:demo:ZeroDivisionError: division by zero"
msgstr ""

#: ../../howto/logging-cookbook.rst:4059
msgid "Patterns to avoid"
msgstr "理应避免的用法"

#: ../../howto/logging-cookbook.rst:4061
msgid ""
"Although the preceding sections have described ways of doing things you "
"might need to do or deal with, it is worth mentioning some usage patterns "
"which are *unhelpful*, and which should therefore be avoided in most cases. "
"The following sections are in no particular order."
msgstr ""
"前几节虽介绍了几种方案，描述了可能需要处理的操作，但值得一提的是，有些用法是 *没有好处* 的，大多数情况下应该避免使用。下面几节的顺序不分先后。"

#: ../../howto/logging-cookbook.rst:4067
msgid "Opening the same log file multiple times"
msgstr "多次打开同一个日志文件"

#: ../../howto/logging-cookbook.rst:4069
msgid ""
"On Windows, you will generally not be able to open the same file multiple "
"times as this will lead to a \"file is in use by another process\" error. "
"However, on POSIX platforms you'll not get any errors if you open the same "
"file multiple times. This could be done accidentally, for example by:"
msgstr ""
"因会导致 \"文件被其他进程占用 \"错误，所以在 Windows 中一般无法多次打开同一个文件。但在 POSIX "
"平台中，多次打开同一个文件不会报任何错误。这种操作可能是意外发生的，比如："

#: ../../howto/logging-cookbook.rst:4074
msgid ""
"Adding a file handler more than once which references the same file (e.g. by"
" a copy/paste/forget-to-change error)."
msgstr "多次添加指向同一文件的 handler（比如通过复制/粘贴，或忘记修改）。"

#: ../../howto/logging-cookbook.rst:4077
msgid ""
"Opening two files that look different, as they have different names, but are"
" the same because one is a symbolic link to the other."
msgstr "打开两个貌似不同（文件名不一样）的文件，但一个是另一个的符号链接，所以其实是同一个文件。"

#: ../../howto/logging-cookbook.rst:4080
msgid ""
"Forking a process, following which both parent and child have a reference to"
" the same file. This might be through use of the :mod:`multiprocessing` "
"module, for example."
msgstr ""
"进程 fork，然后父进程和子进程都有对同一文件的引用。 例如，这可能是通过使用 :mod:`multiprocessing` 模块实现的。"

#: ../../howto/logging-cookbook.rst:4084
msgid ""
"Opening a file multiple times might *appear* to work most of the time, but "
"can lead to a number of problems in practice:"
msgstr "在大多数情况下，多次打开同一个文件 *貌似* 一切正常，但实际会导致很多问题。"

#: ../../howto/logging-cookbook.rst:4087
msgid ""
"Logging output can be garbled because multiple threads or processes try to "
"write to the same file. Although logging guards against concurrent use of "
"the same handler instance by multiple threads, there is no such protection "
"if concurrent writes are attempted by two different threads using two "
"different handler instances which happen to point to the same file."
msgstr ""
"由于多个线程或进程会尝试写入同一个文件，日志输出可能会出现乱码。尽管日志对象可以防止多个线程同时使用同一个 handler "
"实例，但如果两个不同的线程使用不同的 handler 实例同时写入文件，而这两个 handler 又恰好指向同一个文件，那么就失去了这种防护。"

#: ../../howto/logging-cookbook.rst:4093
msgid ""
"An attempt to delete a file (e.g. during file rotation) silently fails, "
"because there is another reference pointing to it. This can lead to "
"confusion and wasted debugging time - log entries end up in unexpected "
"places, or are lost altogether. Or a file that was supposed to be moved "
"remains in place, and grows in size unexpectedly despite size-based rotation"
" being supposedly in place."
msgstr ""
"尝试删除文件（例如在轮换日志文件时）会静默地失败，因为存在另一个指向它的引用。 这可能导致混乱并浪费调试时间 —— "
"日志条目会出现在意想不到的地方，或者完全丢失。 "
"或者会有应当移除的文件仍然保持存在，文件还会在已经设置了基于文件大小的轮换的情况下仍然增长到预料之外的大小。"

#: ../../howto/logging-cookbook.rst:4100
msgid ""
"Use the techniques outlined in :ref:`multiple-processes` to circumvent such "
"issues."
msgstr "请用 :ref:`multiple-processes` 中介绍的技术来避免上述问题。"

#: ../../howto/logging-cookbook.rst:4104
msgid "Using loggers as attributes in a class or passing them as parameters"
msgstr "将日志对象用作属性或传递参数"

#: ../../howto/logging-cookbook.rst:4106
msgid ""
"While there might be unusual cases where you'll need to do this, in general "
"there is no point because loggers are singletons. Code can always access a "
"given logger instance by name using ``logging.getLogger(name)``, so passing "
"instances around and holding them as instance attributes is pointless. Note "
"that in other languages such as Java and C#, loggers are often static class "
"attributes. However, this pattern doesn't make sense in Python, where the "
"module (and not the class) is the unit of software decomposition."
msgstr ""
"虽然特殊情况下可能有必要如此，但一般来说没有意义，因为日志是单实例对象。代码总是可以通过 ``logging.getLogger(name)`` "
"用名称访问一个已有的日志对象实例，因此将实例作为参数来传递，或作为属性留存，都是毫无意义的。请注意，在其他语言中，如 Java 和 "
"C#，日志对象通常是静态类属性。但在 Python 中是没有意义的，因为软件拆分的单位是模块（而不是类）。"

#: ../../howto/logging-cookbook.rst:4115
msgid ""
"Adding handlers other than :class:`~logging.NullHandler` to a logger in a "
"library"
msgstr "为库中的日志记录器添加 :class:`~logging.NullHandler` 以外的处理器"

#: ../../howto/logging-cookbook.rst:4117
msgid ""
"Configuring logging by adding handlers, formatters and filters is the "
"responsibility of the application developer, not the library developer. If "
"you are maintaining a library, ensure that you don't add handlers to any of "
"your loggers other than a :class:`~logging.NullHandler` instance."
msgstr ""
"通过添加 handler、formatter 和 filter "
"来配置日志，这是应用程序开发人员的责任，而不是库开发人员该做的。如果正在维护一个库，请确保不要向任何日志对象添加 "
":class:`~logging.NullHandler` 实例以外的 handler。"

#: ../../howto/logging-cookbook.rst:4123
msgid "Creating a lot of loggers"
msgstr "创建大量的日志对象"

#: ../../howto/logging-cookbook.rst:4125
msgid ""
"Loggers are singletons that are never freed during a script execution, and "
"so creating lots of loggers will use up memory which can't then be freed. "
"Rather than create a logger per e.g. file processed or network connection "
"made, use the :ref:`existing mechanisms <context-info>` for passing "
"contextual information into your logs and restrict the loggers created to "
"those describing areas within your application (generally modules, but "
"occasionally slightly more fine-grained than that)."
msgstr ""
"日志是单实例对象，在代码执行过程中不会被释放，因此创建大量的日志对象会占用很多内存，而这些内存又不能被释放。与其为每个文件或网络连接创建一个日志，还不如利用"
" :ref:`已有机制 <context-info>` "
"将上下文信息传给自定义日志对象，并将创建的日志对象限制在应用程序内的指定区域（通常是模块，但偶尔会再精细些）使用。"

#: ../../howto/logging-cookbook.rst:4136
msgid "Other resources"
msgstr "其他资源"

#: ../../howto/logging-cookbook.rst:4140
msgid "Module :mod:`logging`"
msgstr "模块 :mod:`logging`"

#: ../../howto/logging-cookbook.rst:4141
msgid "API reference for the logging module."
msgstr "日志记录模块的 API 参考。"

#: ../../howto/logging-cookbook.rst:4143
msgid "Module :mod:`logging.config`"
msgstr ":mod:`logging.config` 模块"

#: ../../howto/logging-cookbook.rst:4144
msgid "Configuration API for the logging module."
msgstr "日志记录模块的配置 API 。"

#: ../../howto/logging-cookbook.rst:4146
msgid "Module :mod:`logging.handlers`"
msgstr ":mod:`logging.handlers` 模块"

#: ../../howto/logging-cookbook.rst:4147
msgid "Useful handlers included with the logging module."
msgstr "日志记录模块附带的有用处理器。"

#: ../../howto/logging-cookbook.rst:4149
msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:`基础教程 <logging-basic-tutorial>`"

#: ../../howto/logging-cookbook.rst:4151
msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`进阶教程 <logging-advanced-tutorial>`"
