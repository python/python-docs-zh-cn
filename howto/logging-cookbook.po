# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Shengjing Zhu <zsj950618@gmail.com>, 2020
# ww song <sww4718168@gmail.com>, 2020
# 欢 王 <whthu168@163.com>, 2020
# Alpha Du <alphanow@gmail.com>, 2020
# MuSheng Chen <sheng.2179@gmail.com>, 2020
# WH-2099 <wh2099@outlook.com>, 2020
# 非法操作 <ultrahe@gmail.com>, 2020
# 浩听 王 <wht_andrew@163.com>, 2020
# Dai Xu <daixu61@hotmail.com>, 2021
# Freesand Leo <yuqinju@163.com>, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-01 16:06+0000\n"
"PO-Revision-Date: 2020-05-30 11:54+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2021\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/logging-cookbook.rst:5
msgid "Logging Cookbook"
msgstr "日志操作手册"

#: ../../howto/logging-cookbook.rst:0
msgid "Author"
msgstr "作者"

#: ../../howto/logging-cookbook.rst:7
msgid "Vinay Sajip <vinay_sajip at red-dove dot com>"
msgstr "Vinay Sajip <vinay_sajip at red-dove dot com>"

#: ../../howto/logging-cookbook.rst:9
msgid ""
"This page contains a number of recipes related to logging, which have been "
"found useful in the past."
msgstr "本页包含了许多日志记录相关的概念，这些概念在过去一直被认为很有用。"

#: ../../howto/logging-cookbook.rst:15
msgid "Using logging in multiple modules"
msgstr "在多个模块中记录日志"

#: ../../howto/logging-cookbook.rst:17
msgid ""
"Multiple calls to ``logging.getLogger('someLogger')`` return a reference to "
"the same logger object.  This is true not only within the same module, but "
"also across modules as long as it is in the same Python interpreter process."
"  It is true for references to the same object; additionally, application "
"code can define and configure a parent logger in one module and create (but "
"not configure) a child logger in a separate module, and all logger calls to "
"the child will pass up to the parent.  Here is a main module::"
msgstr ""
"多次调用 ``logging.getLogger('someLogger')`` 时会返回对同一个 logger 对象的引用。 "
"这不仅是在同一个模块中，在其他模块调用也是如此，只要是在同一个 Python 解释器进程中。 "
"是应该引用同一个对象，此外，应用程序也可以在一个模块中定义和配置父 logger，而在单独的模块中创建（但不配置）子 logger，对子 logger "
"的所有调用都将传给父 logger。 这里是主模块::"

#: ../../howto/logging-cookbook.rst:55
msgid "Here is the auxiliary module::"
msgstr "这里是辅助模块::"

#: ../../howto/logging-cookbook.rst:75
msgid "The output looks like this:"
msgstr "输出结果会像这样:"

#: ../../howto/logging-cookbook.rst:101
msgid "Logging from multiple threads"
msgstr "在多个线程中记录日志"

#: ../../howto/logging-cookbook.rst:103
msgid ""
"Logging from multiple threads requires no special effort. The following "
"example shows logging from the main (initial) thread and another thread::"
msgstr "在多个线程中记录日志并不需要特殊的处理，以下示例展示了如何在主（初始）线程和另一个线程中记录日志::"

#: ../../howto/logging-cookbook.rst:132
msgid "When run, the script should print something like the following:"
msgstr "脚本会运行输出类似下面的内容:"

#: ../../howto/logging-cookbook.rst:154
msgid ""
"This shows the logging output interspersed as one might expect. This "
"approach works for more threads than shown here, of course."
msgstr "这表明不同线程的日志像期望的那样穿插输出，当然更多的线程也会像这样输出。"

#: ../../howto/logging-cookbook.rst:158
msgid "Multiple handlers and formatters"
msgstr "多个日志处理器以及多种格式化器"

#: ../../howto/logging-cookbook.rst:160
msgid ""
"Loggers are plain Python objects.  The :meth:`~Logger.addHandler` method has"
" no minimum or maximum quota for the number of handlers you may add.  "
"Sometimes it will be beneficial for an application to log all messages of "
"all severities to a text file while simultaneously logging errors or above "
"to the console.  To set this up, simply configure the appropriate handlers."
"  The logging calls in the application code will remain unchanged.  Here is "
"a slight modification to the previous simple module-based configuration "
"example::"
msgstr ""
"日志记录器是普通的Python对象。:meth:`~Logger.addHandler` "
"方法对可以添加的日志处理器的数量没有限制。有时候，应用程序需要将所有严重性的所有消息记录到一个文本文件，而将错误或更高等级的消息输出到控制台。要进行这样的设定，只需配置适当的日志处理器即可。在应用程序代码中，记录日志的调用将保持不变。以下是对之前基于模块的简单配置示例的略微修改::"

#: ../../howto/logging-cookbook.rst:193
msgid ""
"Notice that the 'application' code does not care about multiple handlers.  "
"All that changed was the addition and configuration of a new handler named "
"*fh*."
msgstr "需要注意的是，'应用程序' 代码并不关心是否有多个日志处理器。示例中所做的改变只是添加和配置了一个新的名为 *fh* 的日志处理器。"

#: ../../howto/logging-cookbook.rst:196
msgid ""
"The ability to create new handlers with higher- or lower-severity filters "
"can be very helpful when writing and testing an application.  Instead of "
"using many ``print`` statements for debugging, use ``logger.debug``: Unlike "
"the print statements, which you will have to delete or comment out later, "
"the logger.debug statements can remain intact in the source code and remain "
"dormant until you need them again.  At that time, the only change that needs"
" to happen is to modify the severity level of the logger and/or handler to "
"debug."
msgstr ""
"在编写和测试应用程序时，能够创建带有更高或更低消息等级的过滤器的日志处理器是非常有用的。为了避免过多地使用 ``print`` 语句去调试，请使用 "
"``logger.debug`` ：它不像 ``print`` 语句需要你不得不在调试结束后注释或删除掉，logger.debug "
"语句可以在源代码中保持不变，在你再一次需要它之前保持无效。那时，唯一需要改变的是修改日志记录器和/或日志处理器的消息等级，以进行调试。"

#: ../../howto/logging-cookbook.rst:207
msgid "Logging to multiple destinations"
msgstr "在多个地方记录日志"

#: ../../howto/logging-cookbook.rst:209
msgid ""
"Let's say you want to log to console and file with different message formats"
" and in differing circumstances. Say you want to log messages with levels of"
" DEBUG and higher to file, and those messages at level INFO and higher to "
"the console. Let's also assume that the file should contain timestamps, but "
"the console messages should not. Here's how you can achieve this::"
msgstr ""
"假设有这样一种情况，你需要将日志按不同的格式和不同的情况存储在控制台和文件中。比如说想把日志等级为DEBUG或更高的消息记录于文件中，而把那些等级为INFO或更高的消息输出在控制台。而且记录在文件中的消息格式需要包含时间戳，打印在控制台的不需要。以下示例展示了如何做到::"

#: ../../howto/logging-cookbook.rst:247
msgid "When you run this, on the console you will see"
msgstr "当运行后，你会看到控制台如下所示"

#: ../../howto/logging-cookbook.rst:256
msgid "and in the file you will see something like"
msgstr "而在文件中会看到像这样"

#: ../../howto/logging-cookbook.rst:266
msgid ""
"As you can see, the DEBUG message only shows up in the file. The other "
"messages are sent to both destinations."
msgstr "正如你所看到的，DEBUG级别的消息只展示在文件中，而其他消息两个地方都会输出。"

#: ../../howto/logging-cookbook.rst:269
msgid ""
"This example uses console and file handlers, but you can use any number and "
"combination of handlers you choose."
msgstr "这个示例只演示了在控制台和文件中去记录日志，但你也可以自由组合任意数量的日志处理器。"

#: ../../howto/logging-cookbook.rst:274
msgid "Configuration server example"
msgstr "日志服务器配置示例"

#: ../../howto/logging-cookbook.rst:276
msgid ""
"Here is an example of a module using the logging configuration server::"
msgstr "以下是在一个模块中使用日志服务器配置的示例::"

#: ../../howto/logging-cookbook.rst:307
msgid ""
"And here is a script that takes a filename and sends that file to the "
"server, properly preceded with the binary-encoded length, as the new logging"
" configuration::"
msgstr "然后如下的脚本，它接收文件名做为命令行参数，并将该文件以二进制编码的方式传给服务器，做为新的日志服务器配置::"

#: ../../howto/logging-cookbook.rst:330
msgid "Dealing with handlers that block"
msgstr "处理日志处理器的阻塞"

#: ../../howto/logging-cookbook.rst:334
msgid ""
"Sometimes you have to get your logging handlers to do their work without "
"blocking the thread you're logging from. This is common in Web applications,"
" though of course it also occurs in other scenarios."
msgstr "有时候需要让日志处理程序在不阻塞当前正在记录线程的情况下完成工作。 这在Web应用程序中很常见，当然也会在其他场景中出现。"

#: ../../howto/logging-cookbook.rst:338
msgid ""
"A common culprit which demonstrates sluggish behaviour is the "
":class:`SMTPHandler`: sending emails can take a long time, for a number of "
"reasons outside the developer's control (for example, a poorly performing "
"mail or network infrastructure). But almost any network-based handler can "
"block: Even a :class:`SocketHandler` operation may do a DNS query under the "
"hood which is too slow (and this query can be deep in the socket library "
"code, below the Python layer, and outside your control)."
msgstr ""
"一个常见的缓慢行为是 :class:`SMTPHandler`: "
"由于开发者无法控制的多种原因（例如，性能不佳的邮件或网络基础架构），发送电子邮件可能需要很长时间。 其实几乎所有基于网络的处理程序都可能造成阻塞：即便是"
" :class:`SocketHandler` 也可能在底层进行 DNS 查询，这太慢了（这个查询会深入至套接字代码，位于 Python "
"层之下，这是不受开发者控制的）。"

#: ../../howto/logging-cookbook.rst:346
msgid ""
"One solution is to use a two-part approach. For the first part, attach only "
"a :class:`QueueHandler` to those loggers which are accessed from "
"performance-critical threads. They simply write to their queue, which can be"
" sized to a large enough capacity or initialized with no upper bound to "
"their size. The write to the queue will typically be accepted quickly, "
"though you will probably need to catch the :exc:`queue.Full` exception as a "
"precaution in your code. If you are a library developer who has performance-"
"critical threads in their code, be sure to document this (together with a "
"suggestion to attach only ``QueueHandlers`` to your loggers) for the benefit"
" of other developers who will use your code."
msgstr ""
"一种解决方案是分成两部分去处理。第一部分，针对那些对性能有要求的关键线程的日志记录附加一个 :class:`QueueHandler`。 "
"日志记录器只需简单写入队列，该队列可以设置一个足够大的容量甚至不设置容量上限。通常写入队列是一个快速的操作，即使可能需要在代码中去捕获例如 "
":exc:`queue.Full` 等异常。 如果你是一名处理关键线程的开发者，请务必记录这些信息 (包括建议只为日志处理器附加 "
"``QueueHandlers``) 以便于其他开发者使用你的代码。"

#: ../../howto/logging-cookbook.rst:357
msgid ""
"The second part of the solution is :class:`QueueListener`, which has been "
"designed as the counterpart to :class:`QueueHandler`.  A "
":class:`QueueListener` is very simple: it's passed a queue and some "
"handlers, and it fires up an internal thread which listens to its queue for "
"LogRecords sent from ``QueueHandlers`` (or any other source of "
"``LogRecords``, for that matter). The ``LogRecords`` are removed from the "
"queue and passed to the handlers for processing."
msgstr ""
"解决方案的另一部分是 :class:`QueueListener`，它被设计用来作为 :class:`QueueHandler` 的对应。 "
":class:`QueueListener` 非常简单：向其传入一个队列和一些处理句柄，它会启动一个内部线程来监听从 ``QueueHandlers``"
" (或任何其他可用的 ``LogRecords`` 源) 发送过来的 LogRecords 队列。 ``LogRecords`` "
"会从队列中被移除，并被传递给句柄进行处理。"

#: ../../howto/logging-cookbook.rst:365
msgid ""
"The advantage of having a separate :class:`QueueListener` class is that you "
"can use the same instance to service multiple ``QueueHandlers``. This is "
"more resource-friendly than, say, having threaded versions of the existing "
"handler classes, which would eat up one thread per handler for no particular"
" benefit."
msgstr ""
"使用一个单独的类 "
":class:`QueueListener` 优点是可以使用同一个实例去服务于多个``QueueHandlers``。这样会更节省资源，否则每个处理程序都占用一个线程没有任何益处。"

#: ../../howto/logging-cookbook.rst:370
msgid "An example of using these two classes follows (imports omitted)::"
msgstr "以下是使用了这样两个类的示例(省略了导入语句)::"

#: ../../howto/logging-cookbook.rst:388
msgid "which, when run, will produce:"
msgstr "在运行后会产生:"

#: ../../howto/logging-cookbook.rst:394
msgid ""
"Prior to Python 3.5, the :class:`QueueListener` always passed every message "
"received from the queue to every handler it was initialized with. (This was "
"because it was assumed that level filtering was all done on the other side, "
"where the queue is filled.) From 3.5 onwards, this behaviour can be changed "
"by passing a keyword argument ``respect_handler_level=True`` to the "
"listener's constructor. When this is done, the listener compares the level "
"of each message with the handler's level, and only passes a message to a "
"handler if it's appropriate to do so."
msgstr ""
"在 Python 3.5 之前，:class:`QueueListener` "
"总是把从队列中接收的每个消息都传给它初始化的日志处理程序。(这是因为它会假设过滤级别总是在队列的另一侧去设置的。) 从 Python 3.5 "
"开始，可以通过在监听器构造函数中添加一个参数 ``respect_handler_level=True`` "
"改变这种情况。当这样设置时，监听器会比较每条消息的等级和日志处理器中设置的等级，只把需要传递的消息传给对应的日志处理器。"

#: ../../howto/logging-cookbook.rst:407
msgid "Sending and receiving logging events across a network"
msgstr "通过网络发送和接收日志"

#: ../../howto/logging-cookbook.rst:409
msgid ""
"Let's say you want to send logging events across a network, and handle them "
"at the receiving end. A simple way of doing this is attaching a "
":class:`SocketHandler` instance to the root logger at the sending end::"
msgstr ""
"如果你想在网络上发送日志，并在接收端处理它们。一个简单的方式是通过附加一个 :class:`SocketHandler` "
"的实例在发送端的根日志处理器中::"

#: ../../howto/logging-cookbook.rst:437
msgid ""
"At the receiving end, you can set up a receiver using the "
":mod:`socketserver` module. Here is a basic working example::"
msgstr "在接收端，你可以使用 :mod:`socketserver` 模块设置一个接收器。这里是一个基础示例::"

#: ../../howto/logging-cookbook.rst:525
msgid ""
"First run the server, and then the client. On the client side, nothing is "
"printed on the console; on the server side, you should see something like:"
msgstr "首先运行服务端，然后是客户端。在客户端，没有什么内容会打印在控制台中；在服务端，你应该会看到如下内容："

#: ../../howto/logging-cookbook.rst:537
msgid ""
"Note that there are some security issues with pickle in some scenarios. If "
"these affect you, you can use an alternative serialization scheme by "
"overriding the :meth:`~handlers.SocketHandler.makePickle` method and "
"implementing your alternative there, as well as adapting the above script to"
" use your alternative serialization."
msgstr ""
"请注意，在某些情况下序列化会存在一些安全。如果这影响到你，那么你可以通过覆盖 "
":meth:`~handlers.SocketHandler.makePickle` "
"方法，使用自己的实现来解决，并调整上述脚本也使用覆盖后的序列化方法。"

#: ../../howto/logging-cookbook.rst:547
msgid "Adding contextual information to your logging output"
msgstr "在日志记录中添加上下文信息"

#: ../../howto/logging-cookbook.rst:549
msgid ""
"Sometimes you want logging output to contain contextual information in "
"addition to the parameters passed to the logging call. For example, in a "
"networked application, it may be desirable to log client-specific "
"information in the log (e.g. remote client's username, or IP address). "
"Although you could use the *extra* parameter to achieve this, it's not "
"always convenient to pass the information in this way. While it might be "
"tempting to create :class:`Logger` instances on a per-connection basis, this"
" is not a good idea because these instances are not garbage collected. While"
" this is not a problem in practice, when the number of :class:`Logger` "
"instances is dependent on the level of granularity you want to use in "
"logging an application, it could be hard to manage if the number of "
":class:`Logger` instances becomes effectively unbounded."
msgstr ""
"有时，除了传递给日志记录器调用的参数外，我们还希望日志记录中包含上下文信息。例如，有一个网络应用，可能需要记录一些特殊的客户端信息在日志中（比如客户端的用户名、IP地址等）。虽然你可以通过设置额外的参数去达到这个目的，但这种方式不一定方便。或者你可能想到在每个连接的基础上创建一个"
" :class:`Logger` 的实例，但这些实例是不会被垃圾回收的，这在练习中也许不是问题，但当 :class:`Logger` "
"的实例数量取决于你应用程序中想记录的细致程度时，如果 :class:`Logger` 的实例数量不受限制的话，将会变得难以管理。"

#: ../../howto/logging-cookbook.rst:564
msgid "Using LoggerAdapters to impart contextual information"
msgstr "使用日志适配器传递上下文信息"

#: ../../howto/logging-cookbook.rst:566
msgid ""
"An easy way in which you can pass contextual information to be output along "
"with logging event information is to use the :class:`LoggerAdapter` class. "
"This class is designed to look like a :class:`Logger`, so that you can call "
":meth:`debug`, :meth:`info`, :meth:`warning`, :meth:`error`, "
":meth:`exception`, :meth:`critical` and :meth:`log`. These methods have the "
"same signatures as their counterparts in :class:`Logger`, so you can use the"
" two types of instances interchangeably."
msgstr ""
"一个传递上下文信息和日志事件信息的简单办法是使用类 :class:`LoggerAdapter`。 这个类设计的像 "
":class:`Logger`，所以可以直接调用 :meth:`debug`、:meth:`info`、 :meth:`warning`、 "
":meth:`error`、:meth:`exception`、 :meth:`critical` 和 :meth:`log`。 这些方法在对应的 "
":class:`Logger` 中使用相同的签名，所以可以交替使用两种类型的实例。"

#: ../../howto/logging-cookbook.rst:574
msgid ""
"When you create an instance of :class:`LoggerAdapter`, you pass it a "
":class:`Logger` instance and a dict-like object which contains your "
"contextual information. When you call one of the logging methods on an "
"instance of :class:`LoggerAdapter`, it delegates the call to the underlying "
"instance of :class:`Logger` passed to its constructor, and arranges to pass "
"the contextual information in the delegated call. Here's a snippet from the "
"code of :class:`LoggerAdapter`::"
msgstr ""
"当你创建一个 :class:`LoggerAdapter` 的实例时，你会传入一个 :class:`Logger` "
"的实例和一个包含了上下文信息的字典对象。当你调用一个 :class:`LoggerAdapter` 实例的方法时，它会把调用委托给内部的 "
":class:`Logger` 的实例，并为其整理相关的上下文信息。这是 :class:`LoggerAdapter` 的一个代码片段::"

#: ../../howto/logging-cookbook.rst:590
msgid ""
"The :meth:`~LoggerAdapter.process` method of :class:`LoggerAdapter` is where"
" the contextual information is added to the logging output. It's passed the "
"message and keyword arguments of the logging call, and it passes back "
"(potentially) modified versions of these to use in the call to the "
"underlying logger. The default implementation of this method leaves the "
"message alone, but inserts an 'extra' key in the keyword argument whose "
"value is the dict-like object passed to the constructor. Of course, if you "
"had passed an 'extra' keyword argument in the call to the adapter, it will "
"be silently overwritten."
msgstr ""
":class:`LoggerAdapter` 的 :meth:`~LoggerAdapter.process` 方法是将上下文信息添加到日志的输出中。 "
"它传入日志消息和日志调用的关键字参数，并传回（隐式的）这些修改后的内容去调用底层的日志记录器。此方法的默认参数只是一个消息字段，但留有一个 "
"'extra' 的字段作为关键字参数传给构造器。当然，如果你在调用适配器时传入了一个 'extra' 字段的参数，它会被静默覆盖。"

#: ../../howto/logging-cookbook.rst:599
msgid ""
"The advantage of using 'extra' is that the values in the dict-like object "
"are merged into the :class:`LogRecord` instance's __dict__, allowing you to "
"use customized strings with your :class:`Formatter` instances which know "
"about the keys of the dict-like object. If you need a different method, e.g."
" if you want to prepend or append the contextual information to the message "
"string, you just need to subclass :class:`LoggerAdapter` and override "
":meth:`~LoggerAdapter.process` to do what you need. Here is a simple "
"example::"
msgstr ""
"使用 'extra' 的优点是这些键值对会被传入 :class:`LogRecord` 实例的 __dict__ 中，让你通过 "
":class:`Formatter` 的实例直接使用定制的字符串，实例能找到这个字典类对象的键。 "
"如果你需要一个其他的方法，比如说，想要在消息字符串前后增加上下文信息，你只需要创建一个 :class:`LoggerAdapter` 的子类，并覆盖它的"
" :meth:`~LoggerAdapter.process` 方法来做你想做的事情，以下是一个简单的示例::"

#: ../../howto/logging-cookbook.rst:615
msgid "which you can use like this::"
msgstr "你可以这样使用::"

#: ../../howto/logging-cookbook.rst:620
msgid ""
"Then any events that you log to the adapter will have the value of "
"``some_conn_id`` prepended to the log messages."
msgstr "然后，你记录在适配器中的任何事件消息前将添加``some_conn_id``的值。"

#: ../../howto/logging-cookbook.rst:624
msgid "Using objects other than dicts to pass contextual information"
msgstr "使用除字典之外的其它对象传递上下文信息"

#: ../../howto/logging-cookbook.rst:626
msgid ""
"You don't need to pass an actual dict to a :class:`LoggerAdapter` - you "
"could pass an instance of a class which implements ``__getitem__`` and "
"``__iter__`` so that it looks like a dict to logging. This would be useful "
"if you want to generate values dynamically (whereas the values in a dict "
"would be constant)."
msgstr ""
"你不需要将一个实际的字典传递给 :class:`LoggerAdapter`-你可以传入一个实现了``__getitem__`` "
"和``__iter__``的类的实例，这样它就像是一个字典。这对于你想动态生成值（而字典中的值往往是常量）将很有帮助。"

#: ../../howto/logging-cookbook.rst:635
msgid "Using Filters to impart contextual information"
msgstr "使用过滤器传递上下文信息"

#: ../../howto/logging-cookbook.rst:637
msgid ""
"You can also add contextual information to log output using a user-defined "
":class:`Filter`. ``Filter`` instances are allowed to modify the "
"``LogRecords`` passed to them, including adding additional attributes which "
"can then be output using a suitable format string, or if needed a custom "
":class:`Formatter`."
msgstr ""
"你也可以使用一个用户定义的类 :class:`Filter` 在日志输出中添加上下文信息。``Filter`` 的实例是被允许修改传入的 "
"``LogRecords``，包括添加其他的属性，然后可以使用合适的格式化字符串输出，或者可以使用一个自定义的类 :class:`Formatter`。"

#: ../../howto/logging-cookbook.rst:642
msgid ""
"For example in a web application, the request being processed (or at least, "
"the interesting parts of it) can be stored in a threadlocal "
"(:class:`threading.local`) variable, and then accessed from a ``Filter`` to "
"add, say, information from the request - say, the remote IP address and "
"remote user's username - to the ``LogRecord``, using the attribute names "
"'ip' and 'user' as in the ``LoggerAdapter`` example above. In that case, the"
" same format string can be used to get similar output to that shown above. "
"Here's an example script::"
msgstr ""
"例如，在一个web应用程序中，正在处理的请求（或者至少是请求的一部分），可以存储在一个线程本地 (:class:`threading.local`) "
"变量中，然后从``Filter`` 中去访问。请求中的信息，如IP地址和用户名将被存储在``LogRecord``中，使用上例 "
"``LoggerAdapter`` 中的 'ip' 和 'user' "
"属性名。在这种情况下，可以使用相同的格式化字符串来得到上例中类似的输出结果。这是一段示例代码::"

#: ../../howto/logging-cookbook.rst:688
msgid "which, when run, produces something like:"
msgstr "在运行时，产生如下内容:"

#: ../../howto/logging-cookbook.rst:709
msgid "Logging to a single file from multiple processes"
msgstr "从多个进程记录至单个文件"

#: ../../howto/logging-cookbook.rst:711
msgid ""
"Although logging is thread-safe, and logging to a single file from multiple "
"threads in a single process *is* supported, logging to a single file from "
"*multiple processes* is *not* supported, because there is no standard way to"
" serialize access to a single file across multiple processes in Python. If "
"you need to log to a single file from multiple processes, one way of doing "
"this is to have all the processes log to a :class:`~handlers.SocketHandler`,"
" and have a separate process which implements a socket server which reads "
"from the socket and logs to file. (If you prefer, you can dedicate one "
"thread in one of the existing processes to perform this function.) "
":ref:`This section <network-logging>` documents this approach in more detail"
" and includes a working socket receiver which can be used as a starting "
"point for you to adapt in your own applications."
msgstr ""
"尽管 logging 是线程安全的，将单个进程中的多个线程日志记录至单个文件也 *是* 受支持的，但将 *多个进程* 中的日志记录至单个文件则 *不是*"
" 受支持的，因为在 Python 中并没有在多个进程中实现对单个文件访问的序列化的标准方案。 "
"如果你需要将多个进程中的日志记录至单个文件，有一个方案是让所有进程都将日志记录至一个 "
":class:`~handlers.SocketHandler`，然后用一个实现了套接字服务器的单独进程一边从套接字中读取一边将日志记录至文件。 "
"（如果愿意的话，你可以在一个现有进程中专门开一个线程来执行此项功能。） :ref:`这一部分 <network-logging>` "
"文档对此方式有更详细的介绍，并包含一个可用的套接字接收器，你自己的应用可以在此基础上进行适配。"

#: ../../howto/logging-cookbook.rst:724
msgid ""
"You could also write your own handler which uses the "
":class:`~multiprocessing.Lock` class from the :mod:`multiprocessing` module "
"to serialize access to the file from your processes. The existing "
":class:`FileHandler` and subclasses do not make use of "
":mod:`multiprocessing` at present, though they may do so in the future. Note"
" that at present, the :mod:`multiprocessing` module does not provide working"
" lock functionality on all platforms (see "
"https://bugs.python.org/issue3770)."
msgstr ""
"你也可以编写你自己的处理程序，让其使用 :mod:`multiprocessing` 模块中的 "
":class:`~multiprocessing.Lock` 类来顺序访问你的多个进程中的文件。 现有的 :class:`FileHandler` "
"及其子类目前并不使用 :mod:`multiprocessing`，尽管它们将来可能会这样做。 "
"请注意在目前，:mod:`multiprocessing` 模块并未在所有平台上都提供可用的锁功能 (参见 "
"https://bugs.python.org/issue3770)。"

#: ../../howto/logging-cookbook.rst:734
msgid ""
"Alternatively, you can use a ``Queue`` and a :class:`QueueHandler` to send "
"all logging events to one of the processes in your multi-process "
"application. The following example script demonstrates how you can do this; "
"in the example a separate listener process listens for events sent by other "
"processes and logs them according to its own logging configuration. Although"
" the example only demonstrates one way of doing it (for example, you may "
"want to use a listener thread rather than a separate listener process -- the"
" implementation would be analogous) it does allow for completely different "
"logging configurations for the listener and the other processes in your "
"application, and can be used as the basis for code meeting your own specific"
" requirements::"
msgstr ""
"或者，你也可以使用 ``Queue`` 和 :class:`QueueHandler` 将所有的日志事件发送至你的多进程应用的一个进程中。 "
"以下示例脚本演示了如何执行此操作。 在示例中，一个单独的监听进程负责监听其他进程的日志事件，并根据自己的配置记录。 "
"尽管示例只演示了这种方法（例如你可能希望使用单独的监听线程而非监听进程 —— "
"它们的实现是类似的），但你也可以在应用程序的监听进程和其他进程使用不同的配置，它可以作为满足你特定需求的一个基础::"

#: ../../howto/logging-cookbook.rst:850
msgid ""
"A variant of the above script keeps the logging in the main process, in a "
"separate thread::"
msgstr "上面脚本的一个变种，仍然在主进程中记录日志，但使用一个单独的线程::"

#: ../../howto/logging-cookbook.rst:945
msgid ""
"This variant shows how you can e.g. apply configuration for particular "
"loggers - e.g. the ``foo`` logger has a special handler which stores all "
"events in the ``foo`` subsystem in a file ``mplog-foo.log``. This will be "
"used by the logging machinery in the main process (even though the logging "
"events are generated in the worker processes) to direct the messages to the "
"appropriate destinations."
msgstr ""
"这段变种的代码展示了如何使用特定的日志记录配置 - 例如``foo``记录器使用了特殊的处理程序，将 ``foo`` 子系统中所有的事件记录至一个文件 "
"``mplog-foo.log``。在主进程（即使是在工作进程中产生的日志事件）的日志记录机制中将直接使用恰当的配置。"

#: ../../howto/logging-cookbook.rst:952
msgid "Using concurrent.futures.ProcessPoolExecutor"
msgstr "concurrent.futures.ProcessPoolExecutor 的用法"

#: ../../howto/logging-cookbook.rst:954
msgid ""
"If you want to use :class:`concurrent.futures.ProcessPoolExecutor` to start "
"your worker processes, you need to create the queue slightly differently. "
"Instead of"
msgstr ""
"若要利用 :class:`concurrent.futures.ProcessPoolExecutor` "
"启动工作进程，创建队列的方式应稍有不同。不能是："

#: ../../howto/logging-cookbook.rst:962
msgid "you should use"
msgstr "而应是："

#: ../../howto/logging-cookbook.rst:968
msgid "and you can then replace the worker creation from this::"
msgstr "然后就可以将以下工作进程的创建过程："

#: ../../howto/logging-cookbook.rst:979
msgid "to this (remembering to first import :mod:`concurrent.futures`)::"
msgstr "改为 (记得要先导入 :mod:`concurrent.futures`)::"

#: ../../howto/logging-cookbook.rst:987
msgid "Using file rotation"
msgstr "轮换日志文件"

#: ../../howto/logging-cookbook.rst:992
msgid ""
"Sometimes you want to let a log file grow to a certain size, then open a new"
" file and log to that. You may want to keep a certain number of these files,"
" and when that many files have been created, rotate the files so that the "
"number of files and the size of the files both remain bounded. For this "
"usage pattern, the logging package provides a "
":class:`~handlers.RotatingFileHandler`::"
msgstr ""
"有时，你希望当日志文件不断记录增长至一定大小时，打开一个新的文件接着记录。 "
"你可能希望只保留一定数量的日志文件，当不断的创建文件到达该数量时，又覆盖掉最开始的文件形成循环。 对于这种使用场景，日志包提供了 "
":class:`~handlers.RotatingFileHandler`::"

#: ../../howto/logging-cookbook.rst:1024
msgid ""
"The result should be 6 separate files, each with part of the log history for"
" the application:"
msgstr "结果应该是6个单独的文件，每个文件都包含了应用程序的部分历史日志:"

#: ../../howto/logging-cookbook.rst:1036
msgid ""
"The most current file is always :file:`logging_rotatingfile_example.out`, "
"and each time it reaches the size limit it is renamed with the suffix "
"``.1``. Each of the existing backup files is renamed to increment the suffix"
" (``.1`` becomes ``.2``, etc.)  and the ``.6`` file is erased."
msgstr ""
"最新的文件始终是:file:`logging_rotatingfile_example.out`，每次到达大小限制时，都会使用后缀``.1``重命名。每个现有的备份文件都会被重命名并增加其后缀（例如``.1``"
" 变为``.2``），而``.6``文件会被删除掉。"

#: ../../howto/logging-cookbook.rst:1041
msgid ""
"Obviously this example sets the log length much too small as an extreme "
"example.  You would want to set *maxBytes* to an appropriate value."
msgstr "显然，这个例子将日志长度设置得太小，这是一个极端的例子。 你可能希望将 *maxBytes* 设置为一个合适的值。"

#: ../../howto/logging-cookbook.rst:1047
msgid "Use of alternative formatting styles"
msgstr "使用其他日志格式化方式"

#: ../../howto/logging-cookbook.rst:1049
msgid ""
"When logging was added to the Python standard library, the only way of "
"formatting messages with variable content was to use the %-formatting "
"method. Since then, Python has gained two new formatting approaches: "
":class:`string.Template` (added in Python 2.4) and :meth:`str.format` (added"
" in Python 2.6)."
msgstr ""
"当日志模块被添加至 Python 标准库时，只有一种格式化消息内容的方法即 %-formatting。 在那之后，Python 又增加了两种格式化方法:"
" :class:`string.Template` (在 Python 2.4 中新增) 和 :meth:`str.format` (在 Python "
"2.6 中新增)。"

#: ../../howto/logging-cookbook.rst:1055
msgid ""
"Logging (as of 3.2) provides improved support for these two additional "
"formatting styles. The :class:`Formatter` class been enhanced to take an "
"additional, optional keyword parameter named ``style``. This defaults to "
"``'%'``, but other possible values are ``'{'`` and ``'$'``, which correspond"
" to the other two formatting styles. Backwards compatibility is maintained "
"by default (as you would expect), but by explicitly specifying a style "
"parameter, you get the ability to specify format strings which work with "
":meth:`str.format` or :class:`string.Template`. Here's an example console "
"session to show the possibilities:"
msgstr ""
"日志（从 3.2 开始）为这两种格式化方式提供了更多支持。:class:`Formatter` 类可以添加一个额外的可选关键字参数 "
"``style``。它的默认值是 ``'%'``，其他的值 ``'{'`` 和 ``'$'`` "
"也支持，对应了其他两种格式化样式。其保持了向后兼容（如您所愿），但通过显示指定样式参数，你可以指定格式化字符串的方式是使用 "
":meth:`str.format` 或 :class:`string.Template`。 这里是一个控制台会话的示例，展示了这些方式："

#: ../../howto/logging-cookbook.rst:1089
msgid ""
"Note that the formatting of logging messages for final output to logs is "
"completely independent of how an individual logging message is constructed. "
"That can still use %-formatting, as shown here::"
msgstr "请注意最终输出到日志的消息格式完全独立于单条日志消息的构造方式。 它仍然可以使用 %-formatting，如下所示::"

#: ../../howto/logging-cookbook.rst:1097
msgid ""
"Logging calls (``logger.debug()``, ``logger.info()`` etc.) only take "
"positional parameters for the actual logging message itself, with keyword "
"parameters used only for determining options for how to handle the actual "
"logging call (e.g. the ``exc_info`` keyword parameter to indicate that "
"traceback information should be logged, or the ``extra`` keyword parameter "
"to indicate additional contextual information to be added to the log). So "
"you cannot directly make logging calls using :meth:`str.format` or "
":class:`string.Template` syntax, because internally the logging package uses"
" %-formatting to merge the format string and the variable arguments. There "
"would be no changing this while preserving backward compatibility, since all"
" logging calls which are out there in existing code will be using %-format "
"strings."
msgstr ""
"日志调用（``logger.debug()`` 、``logger.info()`` "
"等）接受的位置参数只会用于日志信息本身，而关键字参数仅用于日志调用的可选处理参数（如关键字参数 ``exc_info`` 表示应记录跟踪信息， "
"``extra`` 则标识了需要加入日志的额外上下文信息）。所以不能直接用 :meth:`str.format` 或 "
":class:`string.Template` 语法进行日志调用，因为日志包在内部使用 %-f "
"格式来合并格式串和参数变量。在保持向下兼容性时，这一点不会改变，因为已有代码中的所有日志调用都会使用%-f 格式串。"

#: ../../howto/logging-cookbook.rst:1110
msgid ""
"There is, however, a way that you can use {}- and $- formatting to construct"
" your individual log messages. Recall that for a message you can use an "
"arbitrary object as a message format string, and that the logging package "
"will call ``str()`` on that object to get the actual format string. Consider"
" the following two classes::"
msgstr ""
"还有一种方法可以构建自己的日志信息，就是利用 {}- 和 $- 格式。回想一下，任意对象都可用为日志信息的格式串，日志包将会调用该对象的 "
"``str()`` 方法，以获取最终的格式串。不妨看下一下两个类："

#: ../../howto/logging-cookbook.rst:1134
msgid ""
"Either of these can be used in place of a format string, to allow {}- or "
"$-formatting to be used to build the actual \"message\" part which appears "
"in the formatted log output in place of \"%(message)s\" or \"{message}\" or "
"\"$message\". It's a little unwieldy to use the class names whenever you "
"want to log something, but it's quite palatable if you use an alias such as "
"__ (double underscore --- not to be confused with _, the single underscore "
"used as a synonym/alias for :func:`gettext.gettext` or its brethren)."
msgstr ""
"上述两个类均可代替格式串，使得能用 {}- 或 $-formatting 构建最终的“日志信息”部分，这些信息将出现在格式化后的日志输出中，替换 "
"%(message)s 或“{message}”或“$message”。每次写入日志时都要使用类名，有点不大实用，但如果用上 __ "
"之类的别名就相当合适了（双下划线 --- 不要与 _ 混淆，单下划线用作 :func:`gettext.gettext` 或相关函数的同义词/别名 ）。"

#: ../../howto/logging-cookbook.rst:1142
msgid ""
"The above classes are not included in Python, though they're easy enough to "
"copy and paste into your own code. They can be used as follows (assuming "
"that they're declared in a module called ``wherever``):"
msgstr "Python 并没有上述两个类，当然复制粘贴到自己的代码中也很容易。用法可如下所示（假定在名为 ``wherever`` 的模块中声明）："

#: ../../howto/logging-cookbook.rst:1164
msgid ""
"While the above examples use ``print()`` to show how the formatting works, "
"you would of course use ``logger.debug()`` or similar to actually log using "
"this approach."
msgstr ""
"上述示例用了 ``print()`` 演示格式化输出的过程，实际记录日志时当然会用类似 ``logger.debug()`` 的方法来应用。 "

#: ../../howto/logging-cookbook.rst:1168
msgid ""
"One thing to note is that you pay no significant performance penalty with "
"this approach: the actual formatting happens not when you make the logging "
"call, but when (and if) the logged message is actually about to be output to"
" a log by a handler. So the only slightly unusual thing which might trip you"
" up is that the parentheses go around the format string and the arguments, "
"not just the format string. That's because the __ notation is just syntax "
"sugar for a constructor call to one of the XXXMessage classes."
msgstr ""
"值得注意的是，上述做法对性能并没什么影响：格式化过程其实不是在日志记录调用时发生的，而是在日志信息即将由 handler "
"输出到日志时发生。因此，唯一可能让人困惑的稍不寻常的地方，就是包裹在格式串和参数外面的括号，而不是格式串。因为 __ 符号只是对 XXXMessage "
"类的构造函数调用的语法糖。"

#: ../../howto/logging-cookbook.rst:1176
msgid ""
"If you prefer, you can use a :class:`LoggerAdapter` to achieve a similar "
"effect to the above, as in the following example::"
msgstr "只要愿意，上述类似的效果即可用 :class:`LoggerAdapter` 实现，如下例所示："

#: ../../howto/logging-cookbook.rst:1207
msgid ""
"The above script should log the message ``Hello, world!`` when run with "
"Python 3.2 or later."
msgstr "在用 Python 3.2 以上版本运行时，上述代码应该会把 ``Hello, world!`` 写入日志。"

#: ../../howto/logging-cookbook.rst:1216
msgid "Customizing ``LogRecord``"
msgstr "自定义 ``LogRecord``"

#: ../../howto/logging-cookbook.rst:1218
msgid ""
"Every logging event is represented by a :class:`LogRecord` instance. When an"
" event is logged and not filtered out by a logger's level, a "
":class:`LogRecord` is created, populated with information about the event "
"and then passed to the handlers for that logger (and its ancestors, up to "
"and including the logger where further propagation up the hierarchy is "
"disabled). Before Python 3.2, there were only two places where this creation"
" was done:"
msgstr ""
"每条日志事件都由一个  :class:`LogRecord` 实例表示。当某事件要记入日志并且没有被某级别过滤掉时，就会创建一个 "
":class:`LogRecord` 对象，并将有关事件的信息填入，传给该日志对象的 handler（及其祖先，直至对象禁止向上传播为止）。在 "
"Python 3.2 之前，只有两个地方会进行事件的创建："

#: ../../howto/logging-cookbook.rst:1225
msgid ""
":meth:`Logger.makeRecord`, which is called in the normal process of logging "
"an event. This invoked :class:`LogRecord` directly to create an instance."
msgstr ""
":meth:`Logger.makeRecord`，在事件正常记入日志的过程中调用。这会直接调用 :class:`LogRecord` 来创建一个实例。"

#: ../../howto/logging-cookbook.rst:1228
msgid ""
":func:`makeLogRecord`, which is called with a dictionary containing "
"attributes to be added to the LogRecord. This is typically invoked when a "
"suitable dictionary has been received over the network (e.g. in pickle form "
"via a :class:`~handlers.SocketHandler`, or in JSON form via an "
":class:`~handlers.HTTPHandler`)."
msgstr ""
":func:`makeLogRecord`，调用时会带上一个字典参数，其中存放着要加入 LogRecord "
"的属性。这通常在通过网络接收到合适的字典时调用（如通过 :class:`~handlers.SocketHandler` 以 pickle 形式，或通过"
" :class:`~handlers.HTTPHandler` 以 JSON 形式）。"

#: ../../howto/logging-cookbook.rst:1234
msgid ""
"This has usually meant that if you need to do anything special with a "
":class:`LogRecord`, you've had to do one of the following."
msgstr "于是这意味着若要对 :class:`LogRecord` 进行定制，必须进行下述某种操作。"

#: ../../howto/logging-cookbook.rst:1237
msgid ""
"Create your own :class:`Logger` subclass, which overrides "
":meth:`Logger.makeRecord`, and set it using :func:`~logging.setLoggerClass` "
"before any loggers that you care about are instantiated."
msgstr ""
"创建 :class:`Logger`  自定义子类，重写 :meth:`Logger.makeRecord`，并在实例化所需日志对象之前用 "
":func:`~logging.setLoggerClass` 进行设置。"

#: ../../howto/logging-cookbook.rst:1240
msgid ""
"Add a :class:`Filter` to a logger or handler, which does the necessary "
"special manipulation you need when its :meth:`~Filter.filter` method is "
"called."
msgstr ""
"为日志对象添加 :class:`Filter` 或 handler，当其 :meth:`~Filter.filter` "
"方法被调用时，会执行必要的定制操作。"

#: ../../howto/logging-cookbook.rst:1244
msgid ""
"The first approach would be a little unwieldy in the scenario where (say) "
"several different libraries wanted to do different things. Each would "
"attempt to set its own :class:`Logger` subclass, and the one which did this "
"last would win."
msgstr ""
"比如说在有多个不同库要完成不同操作的场景下，第一种方式会有点笨拙。 每次都要尝试设置自己的 :class:`Logger` "
"子类，而起作用的是最后一次尝试。"

#: ../../howto/logging-cookbook.rst:1249
msgid ""
"The second approach works reasonably well for many cases, but does not allow"
" you to e.g. use a specialized subclass of :class:`LogRecord`. Library "
"developers can set a suitable filter on their loggers, but they would have "
"to remember to do this every time they introduced a new logger (which they "
"would do simply by adding new packages or modules and doing ::"
msgstr ""
"第二种方式在多数情况下效果都比较良好，但不允许你使用特殊化的 :class:`LogRecord` 子类。 "
"库开发者可以为他们的日志记录器设置合适的过滤器，但他们应当要记得每次引入新的日志记录器时都需如此（他们只需通过添加新的包或模块并执行以下操作即可）::"

#: ../../howto/logging-cookbook.rst:1257
msgid ""
"at module level). It's probably one too many things to think about. "
"Developers could also add the filter to a :class:`~logging.NullHandler` "
"attached to their top-level logger, but this would not be invoked if an "
"application developer attached a handler to a lower-level library logger ---"
" so output from that handler would not reflect the intentions of the library"
" developer."
msgstr ""
"或许这样要顾及太多事情。开发人员还可以将过滤器附加到其顶级日志对象的 :class:`~logging.NullHandler` "
"中，但如果应用程序开发人员将 handler 附加到较底层库的日志对象，则不会调用该过滤器 --- 所以 handler "
"输出的内容不会符合库开发人员的预期。 "

#: ../../howto/logging-cookbook.rst:1263
msgid ""
"In Python 3.2 and later, :class:`~logging.LogRecord` creation is done "
"through a factory, which you can specify. The factory is just a callable you"
" can set with :func:`~logging.setLogRecordFactory`, and interrogate with "
":func:`~logging.getLogRecordFactory`. The factory is invoked with the same "
"signature as the :class:`~logging.LogRecord` constructor, as "
":class:`LogRecord` is the default setting for the factory."
msgstr ""
"在 Python 3.2 以上版本中，:class:`~logging.LogRecord` "
"的创建是通过工厂对象完成的，工厂对象可以指定。工厂对象只是一个可调用对象，可以用 "
":func:`~logging.setLogRecordFactory` 进行设置，并用 "
":func:`~logging.getLogRecordFactory` 进行查询。工厂对象的调用参数与 "
":class:`~logging.LogRecord` 的构造函数相同，因为 :class:`LogRecord` 是工厂对象的默认设置。"

#: ../../howto/logging-cookbook.rst:1270
msgid ""
"This approach allows a custom factory to control all aspects of LogRecord "
"creation. For example, you could return a subclass, or just add some "
"additional attributes to the record once created, using a pattern similar to"
" this::"
msgstr ""
"这种方式可以让自定义工厂对象完全控制 LogRecord 的创建过程。比如可以返回一个子类，或者在创建的日志对象中加入一些额外的属性，使用方式如下所示："

#: ../../howto/logging-cookbook.rst:1283
msgid ""
"This pattern allows different libraries to chain factories together, and as "
"long as they don't overwrite each other's attributes or unintentionally "
"overwrite the attributes provided as standard, there should be no surprises."
" However, it should be borne in mind that each link in the chain adds run-"
"time overhead to all logging operations, and the technique should only be "
"used when the use of a :class:`Filter` does not provide the desired result."
msgstr ""
"这种模式允许不同的库将多个工厂对象链在一起，只要不会覆盖彼此的属性或标准属性，就不会出现意外。但应记住，工厂链中的每个节点都会增加日志操作的运行开销，本技术仅在采用"
" :class:`Filter` 无法达到目标时才应使用。 "

#: ../../howto/logging-cookbook.rst:1294
msgid "Subclassing QueueHandler - a ZeroMQ example"
msgstr "子类化 QueueHandler - ZeroMQ 示例 "

#: ../../howto/logging-cookbook.rst:1296
msgid ""
"You can use a :class:`QueueHandler` subclass to send messages to other kinds"
" of queues, for example a ZeroMQ 'publish' socket. In the example below,the "
"socket is created separately and passed to the handler (as its 'queue')::"
msgstr ""
"你可以使用 :class:`QueueHandler` 子类将消息发送给其他类型的队列 ，比如 ZeroMQ 'publish' 套接字。 "
"在以下示例中，套接字将单独创建并传给处理句柄 (作为它的 'queue')::"

#: ../../howto/logging-cookbook.rst:1315
msgid ""
"Of course there are other ways of organizing this, for example passing in "
"the data needed by the handler to create the socket::"
msgstr "当然还有其他方案，比如通过 hander 传入所需数据，以创建 socket："

#: ../../howto/logging-cookbook.rst:1333
msgid "Subclassing QueueListener - a ZeroMQ example"
msgstr "子类化 QueueListener —— ZeroMQ 示例"

#: ../../howto/logging-cookbook.rst:1335
msgid ""
"You can also subclass :class:`QueueListener` to get messages from other "
"kinds of queues, for example a ZeroMQ 'subscribe' socket. Here's an "
"example::"
msgstr ""
"你还可以子类化 :class:`QueueListener` 来从其他类型的队列中获取消息，比如从 ZeroMQ 'subscribe' 套接字。 "
"下面是一个例子::"

#: ../../howto/logging-cookbook.rst:1354
msgid "Module :mod:`logging`"
msgstr "模块 :mod:`logging`"

#: ../../howto/logging-cookbook.rst:1354
msgid "API reference for the logging module."
msgstr "日志记录模块的 API 参考。"

#: ../../howto/logging-cookbook.rst:1357
msgid "Module :mod:`logging.config`"
msgstr ":mod:`logging.config` 模块"

#: ../../howto/logging-cookbook.rst:1357
msgid "Configuration API for the logging module."
msgstr "日志记录模块的配置 API 。"

#: ../../howto/logging-cookbook.rst:1360
msgid "Module :mod:`logging.handlers`"
msgstr ":mod:`logging.handlers` 模块"

#: ../../howto/logging-cookbook.rst:1360
msgid "Useful handlers included with the logging module."
msgstr "日志记录模块附带的有用处理器。"

#: ../../howto/logging-cookbook.rst:1362
msgid ":ref:`A basic logging tutorial <logging-basic-tutorial>`"
msgstr ":ref:`日志操作基础教程 <logging-basic-tutorial>`"

#: ../../howto/logging-cookbook.rst:1364
msgid ":ref:`A more advanced logging tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`日志操作的高级教程 <logging-advanced-tutorial>`"

#: ../../howto/logging-cookbook.rst:1368
msgid "An example dictionary-based configuration"
msgstr "基于字典进行日志配置的示例"

#: ../../howto/logging-cookbook.rst:1370
msgid ""
"Below is an example of a logging configuration dictionary - it's taken from "
"the `documentation on the Django project "
"<https://docs.djangoproject.com/en/stable/topics/logging/#configuring-"
"logging>`_. This dictionary is passed to :func:`~config.dictConfig` to put "
"the configuration into effect::"
msgstr ""
"以下是日志配置字典的一个示例——它取自 Django "
"项目的`文档<https://docs.djangoproject.com/en/stable/topics/logging/#configuring-"
"logging>`_。此字典将被传给 :func:`~config.dictConfig` 以使配置生效:: "

#: ../../howto/logging-cookbook.rst:1426
msgid ""
"For more information about this configuration, you can see the `relevant "
"section "
"<https://docs.djangoproject.com/en/stable/topics/logging/#configuring-"
"logging>`_ of the Django documentation."
msgstr ""
"有关本配置的更多信息，请参阅 Django 文档的  `有关章节 "
"<https://docs.djangoproject.com/en/stable/topics/logging/#configuring-"
"logging>`_ 。"

#: ../../howto/logging-cookbook.rst:1433
msgid "Using a rotator and namer to customize log rotation processing"
msgstr "利用 rotator 和 namer 自定义日志轮换操作"

#: ../../howto/logging-cookbook.rst:1435
msgid ""
"An example of how you can define a namer and rotator is given in the "
"following snippet, which shows zlib-based compression of the log file::"
msgstr "以下代码给出了定义 namer 和 rotator 的示例，其中演示了基于 zlib 的日志文件压缩过程："

#: ../../howto/logging-cookbook.rst:1453
msgid ""
"These are not \"true\" .gz files, as they are bare compressed data, with no "
"\"container\" such as you’d find in an actual gzip file. This snippet is "
"just for illustration purposes."
msgstr "这些不是“真正的” .gz 文件，因为他们只是纯压缩数据，缺少真正 gzip 文件中的“容器”。此段代码只是用于演示。 "

#: ../../howto/logging-cookbook.rst:1458
msgid "A more elaborate multiprocessing example"
msgstr "更加详细的多道处理示例"

#: ../../howto/logging-cookbook.rst:1460
msgid ""
"The following working example shows how logging can be used with "
"multiprocessing using configuration files. The configurations are fairly "
"simple, but serve to illustrate how more complex ones could be implemented "
"in a real multiprocessing scenario."
msgstr "以下可运行的示例显示了如何利用配置文件在多进程中应用日志。这些配置相当简单，但足以说明如何在真实的多进程场景中实现较为复杂的配置。 "

#: ../../howto/logging-cookbook.rst:1465
msgid ""
"In the example, the main process spawns a listener process and some worker "
"processes. Each of the main process, the listener and the workers have three"
" separate configurations (the workers all share the same configuration). We "
"can see logging in the main process, how the workers log to a QueueHandler "
"and how the listener implements a QueueListener and a more complex logging "
"configuration, and arranges to dispatch events received via the queue to the"
" handlers specified in the configuration. Note that these configurations are"
" purely illustrative, but you should be able to adapt this example to your "
"own scenario."
msgstr ""
"上述示例中，主进程产生一个侦听器进程和一些工作进程。每个主进程、侦听器进程和工作进程都有三种独立的日志配置（工作进程共享同一套配置）。大家可以看到主进程的日志记录过程、工作线程向"
" QueueHandler 写入日志的过程，以及侦听器实现 QueueListener 和较为复杂的日志配置，如何将由队列接收到的事件分发给配置指定的 "
"handler。请注意，这些配置纯粹用于演示，但应该能调整代码以适用于自己的场景。"

#: ../../howto/logging-cookbook.rst:1475
msgid ""
"Here's the script - the docstrings and the comments hopefully explain how it"
" works::"
msgstr "以下是代码——但愿文档字符串和注释能有助于理解其工作原理："

#: ../../howto/logging-cookbook.rst:1687
msgid "Inserting a BOM into messages sent to a SysLogHandler"
msgstr "在发送给 SysLogHandler 的信息中插入一个  BOM。"

#: ../../howto/logging-cookbook.rst:1689
msgid ""
":rfc:`5424` requires that a Unicode message be sent to a syslog daemon as a "
"set of bytes which have the following structure: an optional pure-ASCII "
"component, followed by a UTF-8 Byte Order Mark (BOM), followed by Unicode "
"encoded using UTF-8. (See the :rfc:`relevant section of the specification "
"<5424#section-6>`.)"
msgstr ""
":rfc:`5424` 要求，Unicode 信息应采用字节流形式发送到系统 syslog 守护程序，字节流结构如下所示：可选的纯 ASCII部分，后跟"
" UTF-8 字节序标记（BOM），然后是采用 UTF-8 编码的 Unicode。（参见 :rfc:`相关规范<5424#section-6>` 。）"
" "

#: ../../howto/logging-cookbook.rst:1695
msgid ""
"In Python 3.1, code was added to :class:`~logging.handlers.SysLogHandler` to"
" insert a BOM into the message, but unfortunately, it was implemented "
"incorrectly, with the BOM appearing at the beginning of the message and "
"hence not allowing any pure-ASCII component to appear before it."
msgstr ""
"在 Python 3.1 的 :class:`~logging.handlers.SysLogHandler` 中，已加入了在日志信息中插入 BOM "
"的代码，但不幸的是，代码并不正确，BOM 出现在了日志信息的开头，因此在它之前就不允许出现纯 ASCII 内容了。 "

#: ../../howto/logging-cookbook.rst:1701
msgid ""
"As this behaviour is broken, the incorrect BOM insertion code is being "
"removed from Python 3.2.4 and later. However, it is not being replaced, and "
"if you want to produce :rfc:`5424`-compliant messages which include a BOM, "
"an optional pure-ASCII sequence before it and arbitrary Unicode after it, "
"encoded using UTF-8, then you need to do the following:"
msgstr ""
"由于无法正常工作， Python 3.2.4 以上版本已删除了出错的插入 BOM 代码。但已有版本的代码不会被替换，若要生成与 :rfc:`5424` "
"兼容的日志信息，包括一个 BOM 符，前面有可选的纯 ASCII 字节流，后面为 UTF-8 编码的任意 Unicode，那么 需要执行以下操作： "

#: ../../howto/logging-cookbook.rst:1707
msgid ""
"Attach a :class:`~logging.Formatter` instance to your "
":class:`~logging.handlers.SysLogHandler` instance, with a format string such"
" as::"
msgstr ""
"为 :class:`~logging.handlers.SysLogHandler` 实例串上一个 "
":class:`~logging.Formatter` 实例，格式串可如下： "

#: ../../howto/logging-cookbook.rst:1713
msgid ""
"The Unicode code point U+FEFF, when encoded using UTF-8, will be encoded as "
"a UTF-8 BOM -- the byte-string ``b'\\xef\\xbb\\xbf'``."
msgstr "用 UTF-8 编码时，Unicode 码位 U+FEFF 将会编码为 UTF-8 BOM——字节串 ``b'\\xef\\xbb\\xbf'`` 。"

#: ../../howto/logging-cookbook.rst:1716
msgid ""
"Replace the ASCII section with whatever placeholders you like, but make sure"
" that the data that appears in there after substitution is always ASCII "
"(that way, it will remain unchanged after UTF-8 encoding)."
msgstr "用任意占位符替换 ASCII 部分，但要保证替换之后的数据一定是 ASCII 码（这样在 UTF-8 编码后就会维持不变）。"

#: ../../howto/logging-cookbook.rst:1720
msgid ""
"Replace the Unicode section with whatever placeholders you like; if the data"
" which appears there after substitution contains characters outside the "
"ASCII range, that's fine -- it will be encoded using UTF-8."
msgstr "用任意占位符替换 Unicode 部分；如果替换后的数据包含超出 ASCII 范围的字符，没问题——他们将用 UTF-8 进行编码。 "

#: ../../howto/logging-cookbook.rst:1724
msgid ""
"The formatted message *will* be encoded using UTF-8 encoding by "
"``SysLogHandler``. If you follow the above rules, you should be able to "
"produce :rfc:`5424`-compliant messages. If you don't, logging may not "
"complain, but your messages will not be RFC 5424-compliant, and your syslog "
"daemon may complain."
msgstr ""
"``SysLogHandler`` *将* 对格式化后的日志信息进行 UTF-8 编码。如果遵循上述规则，应能生成符合 :rfc:`5424` "
"的日志信息。否则，日志记录过程可能不会有什么反馈，但日志信息将不与 RFC 5424 兼容，syslog 守护程序可能会有出错反应。"

#: ../../howto/logging-cookbook.rst:1731
msgid "Implementing structured logging"
msgstr "结构化日志的实现代码"

#: ../../howto/logging-cookbook.rst:1733
msgid ""
"Although most logging messages are intended for reading by humans, and thus "
"not readily machine-parseable, there might be circumstances where you want "
"to output messages in a structured format which *is* capable of being parsed"
" by a program (without needing complex regular expressions to parse the log "
"message). This is straightforward to achieve using the logging package. "
"There are a number of ways in which this could be achieved, but the "
"following is a simple approach which uses JSON to serialise the event in a "
"machine-parseable manner::"
msgstr ""
"大多数日志信息是供人阅读的，所以机器解析起来并不容易，但某些时候可能希望以结构化的格式输出，以 *能够* "
"被程序解析（无需用到复杂的正则表达式）。这可以直接用 logging 包实现。实现方式有很多，以下是一种比较简单的方案，利用 JSON "
"以机器可解析的方式对事件信息进行序列化："

#: ../../howto/logging-cookbook.rst:1757
msgid "If the above script is run, it prints:"
msgstr "上述代码运行后的结果是："

#: ../../howto/logging-cookbook.rst:1763 ../../howto/logging-cookbook.rst:1812
msgid ""
"Note that the order of items might be different according to the version of "
"Python used."
msgstr "请注意，根据 Python 版本的不同，各项数据的输出顺序可能会不一样。"

#: ../../howto/logging-cookbook.rst:1766
msgid ""
"If you need more specialised processing, you can use a custom JSON encoder, "
"as in the following complete example::"
msgstr "若需进行更为定制化的处理，可以使用自定义 JSON 编码对象，下面给出完整示例： "

#: ../../howto/logging-cookbook.rst:1806
msgid "When the above script is run, it prints:"
msgstr "上述代码运行后的结果是："

#: ../../howto/logging-cookbook.rst:1821
msgid "Customizing handlers with :func:`dictConfig`"
msgstr "利用 :func:`dictConfig` 自定义 handler"

#: ../../howto/logging-cookbook.rst:1823
msgid ""
"There are times when you want to customize logging handlers in particular "
"ways, and if you use :func:`dictConfig` you may be able to do this without "
"subclassing. As an example, consider that you may want to set the ownership "
"of a log file. On POSIX, this is easily done using :func:`shutil.chown`, but"
" the file handlers in the stdlib don't offer built-in support. You can "
"customize handler creation using a plain function such as::"
msgstr ""
"有时需要以特定方式自定义日志 handler，如果采用 :func:`dictConfig`，可能无需生成子类就可以做到。比如要设置日志文件的所有权。在"
" POSIX 上，可以利用 :func:`shutil.chown` 轻松完成，但 stdlib 中的文件 handler "
"并不提供内置支持。于是可以用普通函数自定义 handler 的创建，例如："

#: ../../howto/logging-cookbook.rst:1837
msgid ""
"You can then specify, in a logging configuration passed to "
":func:`dictConfig`, that a logging handler be created by calling this "
"function::"
msgstr "然后，你可以在传给 :func:`dictConfig` 的日志配置中指定通过调用此函数来创建日志处理程序::"

#: ../../howto/logging-cookbook.rst:1870
msgid ""
"In this example I am setting the ownership using the ``pulse`` user and "
"group, just for the purposes of illustration. Putting it together into a "
"working script, ``chowntest.py``::"
msgstr "出于演示目的，以下示例设置用户和用户组为 ``pulse``。代码置于一个可运行的脚本文件 ``chowntest.py`` 中："

#: ../../howto/logging-cookbook.rst:1917
msgid "To run this, you will probably need to run as ``root``:"
msgstr "可能需要 ``root`` 权限才能运行："

#: ../../howto/logging-cookbook.rst:1927
msgid ""
"Note that this example uses Python 3.3 because that's where "
":func:`shutil.chown` makes an appearance. This approach should work with any"
" Python version that supports :func:`dictConfig` - namely, Python 2.7, 3.2 "
"or later. With pre-3.3 versions, you would need to implement the actual "
"ownership change using e.g. :func:`os.chown`."
msgstr ""
"请注意此示例用的是 Python 3.3，因为 :func:`shutil.chown` 是从此版本开始出现的。 此方式应当适用于任何支持 "
":func:`dictConfig` 的 Python 版本 —— 例如 Python 2.7, 3.2 或更新的版本。 对于 3.3 "
"之前的版本，你应当使用 :func:`os.chown` 之类的函数来实现实际的所有权修改。"

#: ../../howto/logging-cookbook.rst:1933
msgid ""
"In practice, the handler-creating function may be in a utility module "
"somewhere in your project. Instead of the line in the configuration::"
msgstr "实际应用中，handler 的创建函数可能位于项目的工具模块中。以下配置："

#: ../../howto/logging-cookbook.rst:1938
msgid "you could use e.g.::"
msgstr "应使用："

#: ../../howto/logging-cookbook.rst:1942
msgid ""
"where ``project.util`` can be replaced with the actual name of the package "
"where the function resides. In the above working script, using "
"``'ext://__main__.owned_file_handler'`` should work. Here, the actual "
"callable is resolved by :func:`dictConfig` from the ``ext://`` "
"specification."
msgstr ""
"这里的 ``project.util`` 可以换成函数所在包的实际名称。 在上述的可用脚本中，应该可以使用 "
"``'ext://__main__.owned_file_handler'``。 在这里，实际的可调用对象是由 :func:`dictConfig` 从"
" ``ext://`` 说明中解析出来的。"

#: ../../howto/logging-cookbook.rst:1947
msgid ""
"This example hopefully also points the way to how you could implement other "
"types of file change - e.g. setting specific POSIX permission bits - in the "
"same way, using :func:`os.chmod`."
msgstr "上述示例还指明了其他的文件修改类型的实现方案 —— 比如同样利用 :func:`os.chmod` 设置 POSIX 访问权限位。"

#: ../../howto/logging-cookbook.rst:1951
msgid ""
"Of course, the approach could also be extended to types of handler other "
"than a :class:`~logging.FileHandler` - for example, one of the rotating file"
" handlers, or a different type of handler altogether."
msgstr ""
"当然，以上做法也可以扩展到 :class:`~logging.FileHandler` 之外的其他类型的 handler ——比如某个轮换文件 "
"handler，或类型完全不同的其他 handler。"

#: ../../howto/logging-cookbook.rst:1961
msgid "Using particular formatting styles throughout your application"
msgstr "生效于整个应用程序的格式化样式"

#: ../../howto/logging-cookbook.rst:1963
msgid ""
"In Python 3.2, the :class:`~logging.Formatter` gained a ``style`` keyword "
"parameter which, while defaulting to ``%`` for backward compatibility, "
"allowed the specification of ``{`` or ``$`` to support the formatting "
"approaches supported by :meth:`str.format` and :class:`string.Template`. "
"Note that this governs the formatting of logging messages for final output "
"to logs, and is completely orthogonal to how an individual logging message "
"is constructed."
msgstr ""
"在 Python 3.2 中，:class:`~logging.Formatter` 增加了一个 ``style`` 关键字形参，它默认为 ``%`` "
"以便向下兼容，但是允许采用 ``{`` 或 ``{TX-PL-LABEL}#x60;`` 来支持 :meth:`str.format` 和 "
":class:`string.Template` 所支持的格式化方式。 "
"请注意此形参控制着用用于最终输出到日志的日志消息格式，并且与单独日志消息的构造方式完全无关。"

#: ../../howto/logging-cookbook.rst:1970
msgid ""
"Logging calls (:meth:`~Logger.debug`, :meth:`~Logger.info` etc.) only take "
"positional parameters for the actual logging message itself, with keyword "
"parameters used only for determining options for how to handle the logging "
"call (e.g. the ``exc_info`` keyword parameter to indicate that traceback "
"information should be logged, or the ``extra`` keyword parameter to indicate"
" additional contextual information to be added to the log). So you cannot "
"directly make logging calls using :meth:`str.format` or "
":class:`string.Template` syntax, because internally the logging package uses"
" %-formatting to merge the format string and the variable arguments. There "
"would no changing this while preserving backward compatibility, since all "
"logging calls which are out there in existing code will be using %-format "
"strings."
msgstr ""
"日志函数（:meth:`~Logger.debug`, :meth:`~Logger.info` "
"等）只会读取位置参数获取日志信息本身，而关键字参数仅用于确定日志函数的工作选项（比如关键字参数 ``exc_info`` "
"表示应将跟踪信息记入日志，关键字参数 ``extra`` 则给出了需加入日志的额外上下文信息）。所以不能直接使用 :meth:`str.format` "
"或 :class:`string.Template` 这种语法进行日志调用，因为日志包在内部使用 %-f "
"格式来合并格式串和可变参数。因为尚需保持向下兼容，这一点不会改变，已有代码中的所有日志调用都将采用 %-f 格式串。"

#: ../../howto/logging-cookbook.rst:1982
msgid ""
"There have been suggestions to associate format styles with specific "
"loggers, but that approach also runs into backward compatibility problems "
"because any existing code could be using a given logger name and using "
"%-formatting."
msgstr "有人建议将格式化样式与特定的日志对象进行关联，但其实也会遇到向下兼容的问题，因为已有代码可能用到了某日志对象并采用了 %-f 格式串。"

#: ../../howto/logging-cookbook.rst:1986
msgid ""
"For logging to work interoperably between any third-party libraries and your"
" code, decisions about formatting need to be made at the level of the "
"individual logging call. This opens up a couple of ways in which alternative"
" formatting styles can be accommodated."
msgstr "为了让第三方库和自编代码都能够交互使用日志功能，需要决定在单次日志记录调用级别采用什么格式。于是就出现了其他几种格式化样式方案。 "

#: ../../howto/logging-cookbook.rst:1993
msgid "Using LogRecord factories"
msgstr "LogRecord 工厂的用法"

#: ../../howto/logging-cookbook.rst:1995
msgid ""
"In Python 3.2, along with the :class:`~logging.Formatter` changes mentioned "
"above, the logging package gained the ability to allow users to set their "
"own :class:`LogRecord` subclasses, using the :func:`setLogRecordFactory` "
"function. You can use this to set your own subclass of :class:`LogRecord`, "
"which does the Right Thing by overriding the :meth:`~LogRecord.getMessage` "
"method. The base class implementation of this method is where the ``msg % "
"args`` formatting happens, and where you can substitute your alternate "
"formatting; however, you should be careful to support all formatting styles "
"and allow %-formatting as the default, to ensure interoperability with other"
" code. Care should also be taken to call ``str(self.msg)``, just as the base"
" implementation does."
msgstr ""
"在 Python 3.2 中，伴随着 :class:`~logging.Formatter` 的上述变化，logging 包增加了允许用户使用 "
":func:`setLogRecordFactory` 函数来。设置自己的 :class:`LogRecord` 子类的功能。 "
"你可以使用此功能来设置自己的 :class:`LogRecord` 子类，它会通过重载 :meth:`~LogRecord.getMessage` "
"方法来完成适当的操作。 ``msg % args`` "
"格式化是在此方法的基类实现中进行的，你可以在那里用你自己的格式化操作来替换；但是，你应当注意要支持全部的格式化样式并允许将 %-formatting "
"作为默认样式，以确保与其他代码进行配合。 还应当注意调用 ``str(self.msg)``，正如基类实现所做的一样。"

#: ../../howto/logging-cookbook.rst:2006
msgid ""
"Refer to the reference documentation on :func:`setLogRecordFactory` and "
":class:`LogRecord` for more information."
msgstr "更多信息请参阅 :func:`setLogRecordFactory` 和 :class:`LogRecord` 的参考文档。"

#: ../../howto/logging-cookbook.rst:2011
msgid "Using custom message objects"
msgstr "自定义信息对象的使用"

#: ../../howto/logging-cookbook.rst:2013
msgid ""
"There is another, perhaps simpler way that you can use {}- and $- formatting"
" to construct your individual log messages. You may recall (from "
":ref:`arbitrary-object-messages`) that when logging you can use an arbitrary"
" object as a message format string, and that the logging package will call "
":func:`str` on that object to get the actual format string. Consider the "
"following two classes::"
msgstr ""
"另一种方案可能更为简单，可以利用 {}- 和 $- 格式构建自己的日志消息。大家或许还记得（来自 :ref:`arbitrary-object-"
"messages`），可以用任意对象作为日志信息的格式串，日志包将调用该对象上 :func:`str` 获取实际的格式串。看下以下两个类："

#: ../../howto/logging-cookbook.rst:2038
msgid ""
"Either of these can be used in place of a format string, to allow {}- or "
"$-formatting to be used to build the actual \"message\" part which appears "
"in the formatted log output in place of “%(message)s” or “{message}” or "
"“$message”. If you find it a little unwieldy to use the class names whenever"
" you want to log something, you can make it more palatable if you use an "
"alias such as ``M`` or ``_`` for the message (or perhaps ``__``, if you are "
"using ``_`` for localization)."
msgstr ""
"以上两个类均都可用于替代格式串，以便用 {}- 或 $-formatting 构建实际的“日志信息”部分，此部分将出现在格式化后的日志输出中，替换 "
"%(message)s 、“{message}”或“$message”。每次要写入日志时都使用类名，如果觉得使用不便，可以采用 ``M`` 或 "
"``_`` 之类的别名（如果将 ``_`` 用于本地化操作，则可用 ``__``）。"

#: ../../howto/logging-cookbook.rst:2046
msgid ""
"Examples of this approach are given below. Firstly, formatting with "
":meth:`str.format`::"
msgstr "下面给出示例。 首先用 :meth:`str.format` 进行格式化："

#: ../../howto/logging-cookbook.rst:2060
msgid "Secondly, formatting with :class:`string.Template`::"
msgstr "然后，用 :class:`string.Template` 格式化："

#: ../../howto/logging-cookbook.rst:2067
msgid ""
"One thing to note is that you pay no significant performance penalty with "
"this approach: the actual formatting happens not when you make the logging "
"call, but when (and if) the logged message is actually about to be output to"
" a log by a handler. So the only slightly unusual thing which might trip you"
" up is that the parentheses go around the format string and the arguments, "
"not just the format string. That’s because the __ notation is just syntax "
"sugar for a constructor call to one of the ``XXXMessage`` classes shown "
"above."
msgstr ""
"值得注意的是，上述做法对性能并没什么影响：格式化过程其实不是在日志调用时发生的，而是在日志信息即将由 handler "
"输出到日志时发生。因此，唯一可能让人困惑的稍不寻常的地方，就是包裹在格式串和参数外面的括号，而不是格式串。因为 __ 符号只是对 "
"``XXXMessage`` 类的构造函数调用的语法糖。"

#: ../../howto/logging-cookbook.rst:2081
msgid "Configuring filters with :func:`dictConfig`"
msgstr "利用 :func:`dictConfig` 定义过滤器"

#: ../../howto/logging-cookbook.rst:2083
msgid ""
"You *can* configure filters using :func:`~logging.config.dictConfig`, though"
" it might not be obvious at first glance how to do it (hence this recipe). "
"Since :class:`~logging.Filter` is the only filter class included in the "
"standard library, and it is unlikely to cater to many requirements (it's "
"only there as a base class), you will typically need to define your own "
":class:`~logging.Filter` subclass with an overridden "
":meth:`~logging.Filter.filter` method. To do this, specify the ``()`` key in"
" the configuration dictionary for the filter, specifying a callable which "
"will be used to create the filter (a class is the most obvious, but you can "
"provide any callable which returns a :class:`~logging.Filter` instance). "
"Here is a complete example::"
msgstr ""
"用 :func:`~logging.config.dictConfig` *可以* 对日志过滤器进行设置，尽管乍一看做法并不明显（所以才需要本秘籍）。 "
"由于 :class:`~logging.Filter` 是标准库中唯一的日志过滤器类，不太可能满足众多的要求（它只是作为基类存在），通常需要定义自己的 "
":class:`~logging.Filter` 子类，并重写 :meth:`~logging.Filter.filter` "
"方法。为此，请在过滤器的配置字典中设置 ``()`` "
"键，指定要用于创建过滤器的可调用对象（最明显可用的就是给出一个类，但也可以提供任何一个可调用对象，只要能返回 "
":class:`~logging.Filter` 实例即可）。下面是一个完整的例子："

#: ../../howto/logging-cookbook.rst:2136
msgid ""
"This example shows how you can pass configuration data to the callable which"
" constructs the instance, in the form of keyword parameters. When run, the "
"above script will print:"
msgstr "以上示例展示了将配置数据传给构造实例的可调用对象，形式是关键字参数。运行后将会输出："

#: ../../howto/logging-cookbook.rst:2144
msgid "which shows that the filter is working as configured."
msgstr "这说明过滤器按照配置的参数生效了。"

#: ../../howto/logging-cookbook.rst:2146
msgid "A couple of extra points to note:"
msgstr "需要额外注意的地方："

#: ../../howto/logging-cookbook.rst:2148
msgid ""
"If you can't refer to the callable directly in the configuration (e.g. if it"
" lives in a different module, and you can't import it directly where the "
"configuration dictionary is), you can use the form ``ext://...`` as "
"described in :ref:`logging-config-dict-externalobj`. For example, you could "
"have used the text ``'ext://__main__.MyFilter'`` instead of ``MyFilter`` in "
"the above example."
msgstr ""
"如果在配置中无法直接引用可调用对象（比如位于不同的模块中，并且不能在配置字典所在的位置直接导入），则可以采用 ``ext://...`` 的形式，正如 "
":ref:`logging-config-dict-externalobj` 所述。例如，在上述示例中可以使用文本 "
"``'ext://__main__.MyFilter'`` 而不是 ``MyFilter`` 对象。 "

#: ../../howto/logging-cookbook.rst:2155
msgid ""
"As well as for filters, this technique can also be used to configure custom "
"handlers and formatters. See :ref:`logging-config-dict-userdef` for more "
"information on how logging supports using user-defined objects in its "
"configuration, and see the other cookbook recipe :ref:`custom-handlers` "
"above."
msgstr ""
"与过滤器一样，上述技术还可用于配置自定义 handler 和格式化对象。有关如何在日志配置中使用用户自定义对象的更多信息，请参阅 "
":ref:`logging-config-dict-userdef`，以及上述 :ref:`custom-handlers` 的其他指南。 "

#: ../../howto/logging-cookbook.rst:2164
msgid "Customized exception formatting"
msgstr "异常信息的自定义格式化"

#: ../../howto/logging-cookbook.rst:2166
msgid ""
"There might be times when you want to do customized exception formatting - "
"for argument's sake, let's say you want exactly one line per logged event, "
"even when exception information is present. You can do this with a custom "
"formatter class, as shown in the following example::"
msgstr ""
"有时可能需要设置自定义的异常信息格式——考虑到会用到参数，假定要让每条日志事件只占一行，即便存在异常信息也一样。这可以用自定义格式化类来实现，如下所示："

#: ../../howto/logging-cookbook.rst:2207
msgid "When run, this produces a file with exactly two lines:"
msgstr "运行后将会生成只有两行信息的文件："

#: ../../howto/logging-cookbook.rst:2214
msgid ""
"While the above treatment is simplistic, it points the way to how exception "
"information can be formatted to your liking. The :mod:`traceback` module may"
" be helpful for more specialized needs."
msgstr "虽然上述处理方式很简单，但也给出了根据喜好对异常信息进行格式化输出的方案。或许 :mod:`traceback` 模块能满足更专门的需求。"

#: ../../howto/logging-cookbook.rst:2221
msgid "Speaking logging messages"
msgstr "语音播报日志信息"

#: ../../howto/logging-cookbook.rst:2223
msgid ""
"There might be situations when it is desirable to have logging messages "
"rendered in an audible rather than a visible format. This is easy to do if "
"you have text-to-speech (TTS) functionality available in your system, even "
"if it doesn't have a Python binding. Most TTS systems have a command line "
"program you can run, and this can be invoked from a handler using "
":mod:`subprocess`. It's assumed here that TTS command line programs won't "
"expect to interact with users or take a long time to complete, and that the "
"frequency of logged messages will be not so high as to swamp the user with "
"messages, and that it's acceptable to have the messages spoken one at a time"
" rather than concurrently, The example implementation below waits for one "
"message to be spoken before the next is processed, and this might cause "
"other handlers to be kept waiting. Here is a short example showing the "
"approach, which assumes that the ``espeak`` TTS package is available::"
msgstr ""
"有时可能需要以声音的形式呈现日志消息。如果系统自带了文本转语音 （TTS）功能，即便没与 Python 关联也很容易做到。大多数 TTS "
"系统都有一个可运行的命令行程序，在 handler 中可以用 :mod:`subprocess` 进行调用。这里假定 TTS "
"命令行程序不会与用户交互，或需要很长时间才会执行完毕，写入日志的信息也不会多到影响用户查看，并且可以接受每次播报一条信息，以下示例实现了等一条信息播完再处理下一条，可能会导致其他"
" handler 的等待。这个简短示例仅供演示，假定 ``espeak`` TTS 包已就绪："

#: ../../howto/logging-cookbook.rst:2265
msgid ""
"When run, this script should say \"Hello\" and then \"Goodbye\" in a female "
"voice."
msgstr "运行后将会以女声播报“Hello”和“Goodbye”。"

#: ../../howto/logging-cookbook.rst:2267
msgid ""
"The above approach can, of course, be adapted to other TTS systems and even "
"other systems altogether which can process messages via external programs "
"run from a command line."
msgstr "当然，上述方案也适用于其他 TTS 系统，甚至可以通过利用命令行运行的外部程序来处理消息。"

#: ../../howto/logging-cookbook.rst:2275
msgid "Buffering logging messages and outputting them conditionally"
msgstr "缓冲日志消息并有条件地输出它们"

#: ../../howto/logging-cookbook.rst:2277
msgid ""
"There might be situations where you want to log messages in a temporary area"
" and only output them if a certain condition occurs. For example, you may "
"want to start logging debug events in a function, and if the function "
"completes without errors, you don't want to clutter the log with the "
"collected debug information, but if there is an error, you want all the "
"debug information to be output as well as the error."
msgstr ""
"在某些情况下，你可能希望在临时区域中记录日志消息，并且只在发生某种特定的情况下才输出它们。 "
"例如，你可能希望起始在函数中记录调试事件，如果函数执行完成且没有错误，你不希望输出收集的调试信息以避免造成日志混乱，但如果出现错误，那么你希望所有调试以及错误消息被输出。"
" "

#: ../../howto/logging-cookbook.rst:2284
msgid ""
"Here is an example which shows how you could do this using a decorator for "
"your functions where you want logging to behave this way. It makes use of "
"the :class:`logging.handlers.MemoryHandler`, which allows buffering of "
"logged events until some condition occurs, at which point the buffered "
"events are ``flushed`` - passed to another handler (the ``target`` handler) "
"for processing. By default, the ``MemoryHandler`` flushed when its buffer "
"gets filled up or an event whose level is greater than or equal to a "
"specified threshold is seen. You can use this recipe with a more specialised"
" subclass of ``MemoryHandler`` if you want custom flushing behavior."
msgstr ""
"下面是一个示例，展示如何在你的日志记录函数上使用装饰器以实现这一功能。该示例使用 "
":class:`logging.handlers.MemoryHandler` "
"，它允许缓冲已记录的事件直到某些条件发生，缓冲的事件才会被刷新（``flushed``） - 传递给另一个处理程序（ ``target`` "
"handler）进行处理。 默认情况下， ``MemoryHandler`` 在其缓冲区被填满时被刷新，或者看到一个级别大于或等于指定阈值的事件。 "
"如果想要自定义刷新行为，你可以通过更专业的 ``MemoryHandler`` 子类来使用这个秘诀。"

#: ../../howto/logging-cookbook.rst:2294
msgid ""
"The example script has a simple function, ``foo``, which just cycles through"
" all the logging levels, writing to ``sys.stderr`` to say what level it's "
"about to log at, and then actually logging a message at that level. You can "
"pass a parameter to ``foo`` which, if true, will log at ERROR and CRITICAL "
"levels - otherwise, it only logs at DEBUG, INFO and WARNING levels."
msgstr ""
"这个示例脚本有一个简单的函数 ``foo`` ，它只是在所有的日志级别中循环运行，写到 ``sys.stderr`` "
"，说明它要记录在哪个级别上，然后在这个级别上实际记录一个消息。你可以给 ``foo`` 传递一个参数，如果为 true "
"，它将在ERROR和CRITICAL级别记录，否则，它只在DEBUG、INFO和WARNING级别记录。"

#: ../../howto/logging-cookbook.rst:2300
msgid ""
"The script just arranges to decorate ``foo`` with a decorator which will do "
"the conditional logging that's required. The decorator takes a logger as a "
"parameter and attaches a memory handler for the duration of the call to the "
"decorated function. The decorator can be additionally parameterised using a "
"target handler, a level at which flushing should occur, and a capacity for "
"the buffer (number of records buffered). These default to a "
":class:`~logging.StreamHandler` which writes to ``sys.stderr``, "
"``logging.ERROR`` and ``100`` respectively."
msgstr ""
"脚本只是使用了一个装饰器来装饰 "
"``foo``，这个装饰器将记录执行所需的条件。装饰器使用一个记录器作为参数，并在调用被装饰的函数期间附加一个内存处理程序。装饰器可以使用目标处理程序、记录级别和缓冲区的容量（缓冲记录的数量）来附加参数。这些参数分别默认为写入``sys.stderr``"
" 的 :class:`~logging.StreamHandler` ， ``logging.ERROR`` 和 ``100``。"

#: ../../howto/logging-cookbook.rst:2308
msgid "Here's the script::"
msgstr "以下是脚本："

#: ../../howto/logging-cookbook.rst:2371
msgid "When this script is run, the following output should be observed:"
msgstr "运行此脚本时，应看到以下输出："

#: ../../howto/logging-cookbook.rst:2401
msgid ""
"As you can see, actual logging output only occurs when an event is logged "
"whose severity is ERROR or greater, but in that case, any previous events at"
" lower severities are also logged."
msgstr "如你所见，实际日志记录输出仅在消息等级为ERROR或更高的事件时发生，但在这种情况下，任何之前较低消息等级的事件还会被记录。"

#: ../../howto/logging-cookbook.rst:2405
msgid "You can of course use the conventional means of decoration::"
msgstr "你当然可以使用传统的装饰方法::"

#: ../../howto/logging-cookbook.rst:2415
msgid "Formatting times using UTC (GMT) via configuration"
msgstr "通过配置使用UTC (GMT) 格式化时间"

#: ../../howto/logging-cookbook.rst:2417
msgid ""
"Sometimes you want to format times using UTC, which can be done using a "
"class such as `UTCFormatter`, shown below::"
msgstr "有时候，你希望使用UTC来格式化时间，这可以通过使用一个类来实现，例如`UTCFormatter`，如下所示："

#: ../../howto/logging-cookbook.rst:2426
msgid ""
"and you can then use the ``UTCFormatter`` in your code instead of "
":class:`~logging.Formatter`. If you want to do that via configuration, you "
"can use the :func:`~logging.config.dictConfig` API with an approach "
"illustrated by the following complete example::"
msgstr ""
"然后你可以在你的代码中使用 ``UTCFormatter``，而不是 :class:`~logging.Formatter`。 "
"如果你想通过配置来实现这一功能，你可以使用 :func:`~logging.config.dictConfig` API "
"来完成，该方法在以下完整示例中展示::"

#: ../../howto/logging-cookbook.rst:2469
msgid "When this script is run, it should print something like:"
msgstr "脚本会运行输出类似下面的内容:"

#: ../../howto/logging-cookbook.rst:2476
msgid ""
"showing how the time is formatted both as local time and UTC, one for each "
"handler."
msgstr "展示了如何将时间格式化为本地时间和UTC两种形式，其中每种形式对应一个日志处理器 。"

#: ../../howto/logging-cookbook.rst:2483
msgid "Using a context manager for selective logging"
msgstr "使用上下文管理器的可选的日志记录"

#: ../../howto/logging-cookbook.rst:2485
msgid ""
"There are times when it would be useful to temporarily change the logging "
"configuration and revert it back after doing something. For this, a context "
"manager is the most obvious way of saving and restoring the logging context."
" Here is a simple example of such a context manager, which allows you to "
"optionally change the logging level and add a logging handler purely in the "
"scope of the context manager::"
msgstr ""
"有时候，我们需要暂时更改日志配置，并在执行某些操作后将其还原。为此，上下文管理器是实现保存和恢复日志上下文的最明显的方式。这是一个关于上下文管理器的简单例子，它允许你在上下文管理器的作用域内更改日志记录等级以及增加日志处理器："

#: ../../howto/logging-cookbook.rst:2518
msgid ""
"If you specify a level value, the logger's level is set to that value in the"
" scope of the with block covered by the context manager. If you specify a "
"handler, it is added to the logger on entry to the block and removed on exit"
" from the block. You can also ask the manager to close the handler for you "
"on block exit - you could do this if you don't need the handler any more."
msgstr ""
"如果指定上下文管理器的日志记录等级属性，则在上下文管理器的with语句所涵盖的代码中，日志记录器的记录等级将临时设置为上下文管理器所配置的日志记录等级。"
" 如果指定上下文管理的日志处理器属性，则该句柄在进入上下文管理器的上下文时添加到记录器中，并在退出时被删除。 "
"如果你再也不需要该日志处理器时，你可以让上下文管理器在退出上下文管理器的上下文时关闭它。"

#: ../../howto/logging-cookbook.rst:2524
msgid ""
"To illustrate how it works, we can add the following block of code to the "
"above::"
msgstr "为了说明它是如何工作的，我们可以在上面添加以下代码块::"

#: ../../howto/logging-cookbook.rst:2542
msgid ""
"We initially set the logger's level to ``INFO``, so message #1 appears and "
"message #2 doesn't. We then change the level to ``DEBUG`` temporarily in the"
" following ``with`` block, and so message #3 appears. After the block exits,"
" the logger's level is restored to ``INFO`` and so message #4 doesn't "
"appear. In the next ``with`` block, we set the level to ``DEBUG`` again but "
"also add a handler writing to ``sys.stdout``. Thus, message #5 appears twice"
" on the console (once via ``stderr`` and once via ``stdout``). After the "
"``with`` statement's completion, the status is as it was before so message "
"#6 appears (like message #1) whereas message #7 doesn't (just like message "
"#2)."
msgstr ""
"我们最初设置日志记录器的消息等级为 ``INFO``，因此消息#1出现，消息#2没有出现。在接下来的 ``with``代码块中我们暂时将消息等级变更为 "
"``DEBUG``，从而消息 #3 出现。在这一代码块退出后，日志记录器的消息等级恢复为 ``INFO``，从而消息 #4 没有出现。在下一个 "
"``with`` 代码块中，我们再一次将设置消息等级设置为 ``DEBUG``，同时添加一个将消息写入 ``sys.stdout`` "
"的日志处理器。因此，消息#5在控制台出现两次 (分别通过 ``stderr`` 和 ``stdout``)。在 ``with`` "
"语句完成后，状态与之前一样，因此消息 #6 出现（类似消息 #1），而消息 #7 没有出现（类似消息 #2）。"

#: ../../howto/logging-cookbook.rst:2552
msgid "If we run the resulting script, the result is as follows:"
msgstr "如果我们运行生成的脚本，结果如下："

#: ../../howto/logging-cookbook.rst:2563
msgid ""
"If we run it again, but pipe ``stderr`` to ``/dev/null``, we see the "
"following, which is the only message written to ``stdout``:"
msgstr ""
"我们将``stderr``标准错误重定向到``/dev/null``，我再次运行生成的脚步，唯一被写入``stdout``标准输出的消息，即我们所能看见的消息，如下："

#: ../../howto/logging-cookbook.rst:2571
msgid "Once again, but piping ``stdout`` to ``/dev/null``, we get:"
msgstr "再一次，将 ``stdout`` 标准输出重定向到 ``/dev/null``，我获得如下结果："

#: ../../howto/logging-cookbook.rst:2581
msgid ""
"In this case, the message #5 printed to ``stdout`` doesn't appear, as "
"expected."
msgstr "在这种情况下，与预期一致，打印到 ``stdout`` 标准输出的消息＃5不会出现。"

#: ../../howto/logging-cookbook.rst:2583
msgid ""
"Of course, the approach described here can be generalised, for example to "
"attach logging filters temporarily. Note that the above code works in Python"
" 2 as well as Python 3."
msgstr "当然，这里描述的方法可以被推广，例如临时附加日志记录过滤器。 请注意，上面的代码适用于Python 2以及Python 3。"

#: ../../howto/logging-cookbook.rst:2591
msgid "A CLI application starter template"
msgstr "命令行日志应用起步"

#: ../../howto/logging-cookbook.rst:2593
msgid "Here's an example which shows how you can:"
msgstr "下面的示例提供了如下功能："

#: ../../howto/logging-cookbook.rst:2595
msgid "Use a logging level based on command-line arguments"
msgstr "根据命令行参数确定日志级别"

#: ../../howto/logging-cookbook.rst:2596
msgid ""
"Dispatch to multiple subcommands in separate files, all logging at the same "
"level in a consistent way"
msgstr "在单独的文件中分发多条子命令，同一级别的子命令均以一致的方式记录。"

#: ../../howto/logging-cookbook.rst:2598
msgid "Make use of simple, minimal configuration"
msgstr "最简单的配置用法"

#: ../../howto/logging-cookbook.rst:2600
msgid ""
"Suppose we have a command-line application whose job is to stop, start or "
"restart some services. This could be organised for the purposes of "
"illustration as a file ``app.py`` that is the main script for the "
"application, with individual commands implemented in ``start.py``, "
"``stop.py`` and ``restart.py``. Suppose further that we want to control the "
"verbosity of the application via a command-line argument, defaulting to "
"``logging.INFO``. Here's one way that ``app.py`` could be written::"
msgstr ""
"假定有一个命令行应用程序，用于停止、启动或重新启动某些服务。为了便于演示，不妨将 ``app.py`` 作为应用程序的主代码文件，并在  "
"``start.py``、 ``stop.py``和 ``restart.py`` "
"中实现单独的命令。再假定要通过命令行参数控制应用程序的日志粒度，默认为 ``logging.INFO`` 。以下是 ``app.py`` 的一个示例："

#: ../../howto/logging-cookbook.rst:2649
msgid ""
"And the ``start``, ``stop`` and ``restart`` commands can be implemented in "
"separate modules, like so for starting::"
msgstr "``start``、``stop`` 和 ``restart`` 命令可以在单独的模块中实现，启动命令的代码可如下："

#: ../../howto/logging-cookbook.rst:2662
msgid "and thus for stopping::"
msgstr "然后是停止命令的代码："

#: ../../howto/logging-cookbook.rst:2683
msgid "and similarly for restarting::"
msgstr "重启命令类似："

#: ../../howto/logging-cookbook.rst:2704
msgid ""
"If we run this application with the default log level, we get output like "
"this:"
msgstr "如果以默认日志级别运行该程序，会得到以下结果："

#: ../../howto/logging-cookbook.rst:2717
msgid ""
"The first word is the logging level, and the second word is the module or "
"package name of the place where the event was logged."
msgstr "第一个单词是日志级别，第二个单词是日志事件所在的模块或包的名称。"

#: ../../howto/logging-cookbook.rst:2720
msgid ""
"If we change the logging level, then we can change the information sent to "
"the log. For example, if we want more information:"
msgstr "如果修改了日志级别，发送给日志的信息就能得以改变。如要显示更多信息，则可："

#: ../../howto/logging-cookbook.rst:2737
msgid "And if we want less:"
msgstr "若要显示的信息少一些，则："

#: ../../howto/logging-cookbook.rst:2745
msgid ""
"In this case, the commands don't print anything to the console, since "
"nothing at ``WARNING`` level or above is logged by them."
msgstr "这里的命令不会向控制台输出任何信息，因为没有记录 ``WARNING`` 以上级别的日志。"

#: ../../howto/logging-cookbook.rst:2751
msgid "A Qt GUI for logging"
msgstr "Qt GUI 日志示例"

#: ../../howto/logging-cookbook.rst:2753
msgid ""
"A question that comes up from time to time is about how to log to a GUI "
"application. The `Qt <https://www.qt.io/>`_ framework is a popular cross-"
"platform UI framework with Python bindings using `PySide2 "
"<https://pypi.org/project/PySide2/>`_ or `PyQt5 "
"<https://pypi.org/project/PyQt5/>`_ libraries."
msgstr ""
"GUI 应用程序如何记录日志，这是个常见的问题。 `Qt <https://www.qt.io/>`_ 框架是一个流行的跨平台 UI 框架，采用的是 "
"`PySide2 <https://pypi.org/project/PySide2/>`_ 或 `PyQt5 "
"<https://pypi.org/project/PyQt5/>`_ 库。"

#: ../../howto/logging-cookbook.rst:2759
msgid ""
"The following example shows how to log to a Qt GUI. This introduces a simple"
" ``QtHandler`` class which takes a callable, which should be a slot in the "
"main thread that does GUI updates. A worker thread is also created to show "
"how you can log to the GUI from both the UI itself (via a button for manual "
"logging) as well as a worker thread doing work in the background (here, just"
" logging messages at random levels with random short delays in between)."
msgstr ""
"下面的例子演示了将日志写入 Qt GUI 程序的过程。这里引入了一个简单的 ``QtHandler`` "
"类，参数是一个可调用对象，其应为嵌入主线程某个“槽位”中运行的，因为GUI 的更新由主线程完成。这里还创建了一个工作线程，以便演示由 "
"UI（通过人工点击日志按钮）和后台工作线程（此处只是记录级别和时间间隔均随机生成的日志信息）将日志写入 GUI 的过程。 "

#: ../../howto/logging-cookbook.rst:2766
msgid ""
"The worker thread is implemented using Qt's ``QThread`` class rather than "
"the :mod:`threading` module, as there are circumstances where one has to use"
" ``QThread``, which offers better integration with other ``Qt`` components."
msgstr ""
"该工作线程是用 Qt 的 ``QThread`` 类实现的，而不是 :mod:`threading` 模块，因为某些情况下只能采用 "
"```QThread``，它与其他 ``Qt`` 组件的集成性更好一些。"

#: ../../howto/logging-cookbook.rst:2770
msgid ""
"The code should work with recent releases of either ``PySide2`` or "
"``PyQt5``. You should be able to adapt the approach to earlier versions of "
"Qt. Please refer to the comments in the code snippet for more detailed "
"information."
msgstr "以下代码应能适用于最新版的 ``PySide2`` 或 ``PyQt5``。对于低版本的 Qt 应该也能适用。更多详情，请参阅代码注释。"
