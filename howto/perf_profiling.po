# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-09 14:19+0000\n"
"PO-Revision-Date: 2025-07-18 18:48+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/perf_profiling.rst:7
msgid "Python support for the Linux ``perf`` profiler"
msgstr "Python 对 Linux ``perf`` 性能分析器的支持"

#: ../../howto/perf_profiling.rst:0
msgid "author"
msgstr "作者"

#: ../../howto/perf_profiling.rst:9
msgid "Pablo Galindo"
msgstr "Pablo Galindo"

#: ../../howto/perf_profiling.rst:11
msgid ""
"`The Linux perf profiler <https://perf.wiki.kernel.org>`_ is a very powerful"
" tool that allows you to profile and obtain information about the "
"performance of your application. ``perf`` also has a very vibrant ecosystem "
"of tools that aid with the analysis of the data that it produces."
msgstr ""
"`Linux perf 性能分析器 <https://perf.wiki.kernel.org>`_ "
"是一个非常强大的工具，它允许你分析并获取有关你的应用程序运行性能的信息。 ``perf`` 还拥有一个非常活跃的工具生态系统可以帮助分析它所产生的数据。"

#: ../../howto/perf_profiling.rst:17
msgid ""
"The main problem with using the ``perf`` profiler with Python applications "
"is that ``perf`` only gets information about native symbols, that is, the "
"names of functions and procedures written in C. This means that the names "
"and file names of Python functions in your code will not appear in the "
"output of ``perf``."
msgstr ""
"将 ``perf`` 性能分析器与 Python 应用程序配合使用的主要问题在于 ``perf`` 只能获取原生符号的信息，即以 C "
"编写的函数和过程的名称。 这意味着在你的代码中的 Python 函数名称和文件名称将不会出现在 ``perf`` 输出中。"

#: ../../howto/perf_profiling.rst:22
msgid ""
"Since Python 3.12, the interpreter can run in a special mode that allows "
"Python functions to appear in the output of the ``perf`` profiler. When this"
" mode is enabled, the interpreter will interpose a small piece of code "
"compiled on the fly before the execution of every Python function and it "
"will teach ``perf`` the relationship between this piece of code and the "
"associated Python function using :doc:`perf map files <../c-api/perfmaps>`."
msgstr ""
"从 Python 3.12 开始，解释器可以运行于一个允许 ``perf`` 性能分析器的输出中显示 Python 函数的特殊模式下。 "
"当启用此模式时，解释器将在每个 Python 函数执行之前插入一小段即时编译的代码，它将使用 :doc:`perf 映射文件 "
"<../c-api/perfmaps>` 来告知 ``perf`` 这段代码与相关联的 Python 函数之间的关系。"

#: ../../howto/perf_profiling.rst:31
msgid ""
"Support for the ``perf`` profiler is currently only available for Linux on "
"select architectures. Check the output of the ``configure`` build step or "
"check the output of ``python -m sysconfig | grep HAVE_PERF_TRAMPOLINE`` to "
"see if your system is supported."
msgstr ""
"对 ``perf`` 性能分析器的支持目前仅在特定架构的 Linux 上可用。 请检查 ``configure`` 构建步骤的输出或检查 "
"``python -m sysconfig | grep HAVE_PERF_TRAMPOLINE`` 的输出来确定你的系统是否受到支持。"

#: ../../howto/perf_profiling.rst:36
msgid "For example, consider the following script:"
msgstr "例如，考虑以下脚本:"

#: ../../howto/perf_profiling.rst:38
msgid ""
"def foo(n):\n"
"    result = 0\n"
"    for _ in range(n):\n"
"        result += 1\n"
"    return result\n"
"\n"
"def bar(n):\n"
"    foo(n)\n"
"\n"
"def baz(n):\n"
"    bar(n)\n"
"\n"
"if __name__ == \"__main__\":\n"
"    baz(1000000)"
msgstr ""
"def foo(n):\n"
"    result = 0\n"
"    for _ in range(n):\n"
"        result += 1\n"
"    return result\n"
"\n"
"def bar(n):\n"
"    foo(n)\n"
"\n"
"def baz(n):\n"
"    bar(n)\n"
"\n"
"if __name__ == \"__main__\":\n"
"    baz(1000000)"

#: ../../howto/perf_profiling.rst:55
msgid "We can run ``perf`` to sample CPU stack traces at 9999 hertz::"
msgstr "我们可以运行 ``perf``  以 9999 赫兹的频率来对 CPU 栈追踪信息进行采样::"

#: ../../howto/perf_profiling.rst:57
msgid "$ perf record -F 9999 -g -o perf.data python my_script.py"
msgstr "$ perf record -F 9999 -g -o perf.data python my_script.py"

#: ../../howto/perf_profiling.rst:59
msgid "Then we can use ``perf report`` to analyze the data:"
msgstr "然后我们可以使用 ``perf report`` 来分析数据:"

#: ../../howto/perf_profiling.rst:61
msgid ""
"$ perf report --stdio -n -g\n"
"\n"
"# Children      Self       Samples  Command     Shared Object       Symbol\n"
"# ........  ........  ............  ..........  ..................  ..........................................\n"
"#\n"
"    91.08%     0.00%             0  python.exe  python.exe          [.] _start\n"
"            |\n"
"            ---_start\n"
"            |\n"
"                --90.71%--__libc_start_main\n"
"                        Py_BytesMain\n"
"                        |\n"
"                        |--56.88%--pymain_run_python.constprop.0\n"
"                        |          |\n"
"                        |          |--56.13%--_PyRun_AnyFileObject\n"
"                        |          |          _PyRun_SimpleFileObject\n"
"                        |          |          |\n"
"                        |          |          |--55.02%--run_mod\n"
"                        |          |          |          |\n"
"                        |          |          |           --54.65%--PyEval_EvalCode\n"
"                        |          |          |                     _PyEval_EvalFrameDefault\n"
"                        |          |          |                     PyObject_Vectorcall\n"
"                        |          |          |                     _PyEval_Vector\n"
"                        |          |          |                     _PyEval_EvalFrameDefault\n"
"                        |          |          |                     PyObject_Vectorcall\n"
"                        |          |          |                     _PyEval_Vector\n"
"                        |          |          |                     _PyEval_EvalFrameDefault\n"
"                        |          |          |                     PyObject_Vectorcall\n"
"                        |          |          |                     _PyEval_Vector\n"
"                        |          |          |                     |\n"
"                        |          |          |                     |--51.67%--_PyEval_EvalFrameDefault\n"
"                        |          |          |                     |          |\n"
"                        |          |          |                     |          |--11.52%--_PyLong_Add\n"
"                        |          |          |                     |          |          |\n"
"                        |          |          |                     |          |          |--2.97%--_PyObject_Malloc\n"
"..."
msgstr ""
"$ perf report --stdio -n -g\n"
"\n"
"# Children      Self       Samples  Command     Shared Object       Symbol\n"
"# ........  ........  ............  ..........  ..................  ..........................................\n"
"#\n"
"    91.08%     0.00%             0  python.exe  python.exe          [.] _start\n"
"            |\n"
"            ---_start\n"
"            |\n"
"                --90.71%--__libc_start_main\n"
"                        Py_BytesMain\n"
"                        |\n"
"                        |--56.88%--pymain_run_python.constprop.0\n"
"                        |          |\n"
"                        |          |--56.13%--_PyRun_AnyFileObject\n"
"                        |          |          _PyRun_SimpleFileObject\n"
"                        |          |          |\n"
"                        |          |          |--55.02%--run_mod\n"
"                        |          |          |          |\n"
"                        |          |          |           --54.65%--PyEval_EvalCode\n"
"                        |          |          |                     _PyEval_EvalFrameDefault\n"
"                        |          |          |                     PyObject_Vectorcall\n"
"                        |          |          |                     _PyEval_Vector\n"
"                        |          |          |                     _PyEval_EvalFrameDefault\n"
"                        |          |          |                     PyObject_Vectorcall\n"
"                        |          |          |                     _PyEval_Vector\n"
"                        |          |          |                     _PyEval_EvalFrameDefault\n"
"                        |          |          |                     PyObject_Vectorcall\n"
"                        |          |          |                     _PyEval_Vector\n"
"                        |          |          |                     |\n"
"                        |          |          |                     |--51.67%--_PyEval_EvalFrameDefault\n"
"                        |          |          |                     |          |\n"
"                        |          |          |                     |          |--11.52%--_PyLong_Add\n"
"                        |          |          |                     |          |          |\n"
"                        |          |          |                     |          |          |--2.97%--_PyObject_Malloc\n"
"..."

#: ../../howto/perf_profiling.rst:100
msgid ""
"As you can see, the Python functions are not shown in the output, only "
"``_PyEval_EvalFrameDefault`` (the function that evaluates the Python "
"bytecode) shows up. Unfortunately that's not very useful because all Python "
"functions use the same C function to evaluate bytecode so we cannot know "
"which Python function corresponds to which bytecode-evaluating function."
msgstr ""
"如你所见，Python 函数不会显示在输出中，只有 ``_PyEval_EvalFrameDefault`` (评估 Python 字节码的函数) "
"会显示出来。 不幸的是那没有什么用处因为所有 Python 函数都使用相同的 C 函数来评估字节码所以我们无法知道哪个 Python "
"函数与哪个字节码评估函数相对应。"

#: ../../howto/perf_profiling.rst:105
msgid ""
"Instead, if we run the same experiment with ``perf`` support enabled we get:"
msgstr "相反，如果我们在启用 ``perf`` 支持的情况下运行相同的实验代码我们将获得:"

#: ../../howto/perf_profiling.rst:107
msgid ""
"$ perf report --stdio -n -g\n"
"\n"
"# Children      Self       Samples  Command     Shared Object       Symbol\n"
"# ........  ........  ............  ..........  ..................  .....................................................................\n"
"#\n"
"    90.58%     0.36%             1  python.exe  python.exe          [.] _start\n"
"            |\n"
"            ---_start\n"
"            |\n"
"                --89.86%--__libc_start_main\n"
"                        Py_BytesMain\n"
"                        |\n"
"                        |--55.43%--pymain_run_python.constprop.0\n"
"                        |          |\n"
"                        |          |--54.71%--_PyRun_AnyFileObject\n"
"                        |          |          _PyRun_SimpleFileObject\n"
"                        |          |          |\n"
"                        |          |          |--53.62%--run_mod\n"
"                        |          |          |          |\n"
"                        |          |          |           --53.26%--PyEval_EvalCode\n"
"                        |          |          |                     py::<module>:/src/script.py\n"
"                        |          |          |                     _PyEval_EvalFrameDefault\n"
"                        |          |          |                     PyObject_Vectorcall\n"
"                        |          |          |                     _PyEval_Vector\n"
"                        |          |          |                     py::baz:/src/script.py\n"
"                        |          |          |                     _PyEval_EvalFrameDefault\n"
"                        |          |          |                     PyObject_Vectorcall\n"
"                        |          |          |                     _PyEval_Vector\n"
"                        |          |          |                     py::bar:/src/script.py\n"
"                        |          |          |                     _PyEval_EvalFrameDefault\n"
"                        |          |          |                     PyObject_Vectorcall\n"
"                        |          |          |                     _PyEval_Vector\n"
"                        |          |          |                     py::foo:/src/script.py\n"
"                        |          |          |                     |\n"
"                        |          |          |                     |--51.81%--_PyEval_EvalFrameDefault\n"
"                        |          |          |                     |          |\n"
"                        |          |          |                     |          |--13.77%--_PyLong_Add\n"
"                        |          |          |                     |          |          |\n"
"                        |          |          |                     |          |          |--3.26%--_PyObject_Malloc"
msgstr ""
"$ perf report --stdio -n -g\n"
"\n"
"# Children      Self       Samples  Command     Shared Object       Symbol\n"
"# ........  ........  ............  ..........  ..................  .....................................................................\n"
"#\n"
"    90.58%     0.36%             1  python.exe  python.exe          [.] _start\n"
"            |\n"
"            ---_start\n"
"            |\n"
"                --89.86%--__libc_start_main\n"
"                        Py_BytesMain\n"
"                        |\n"
"                        |--55.43%--pymain_run_python.constprop.0\n"
"                        |          |\n"
"                        |          |--54.71%--_PyRun_AnyFileObject\n"
"                        |          |          _PyRun_SimpleFileObject\n"
"                        |          |          |\n"
"                        |          |          |--53.62%--run_mod\n"
"                        |          |          |          |\n"
"                        |          |          |           --53.26%--PyEval_EvalCode\n"
"                        |          |          |                     py::<module>:/src/script.py\n"
"                        |          |          |                     _PyEval_EvalFrameDefault\n"
"                        |          |          |                     PyObject_Vectorcall\n"
"                        |          |          |                     _PyEval_Vector\n"
"                        |          |          |                     py::baz:/src/script.py\n"
"                        |          |          |                     _PyEval_EvalFrameDefault\n"
"                        |          |          |                     PyObject_Vectorcall\n"
"                        |          |          |                     _PyEval_Vector\n"
"                        |          |          |                     py::bar:/src/script.py\n"
"                        |          |          |                     _PyEval_EvalFrameDefault\n"
"                        |          |          |                     PyObject_Vectorcall\n"
"                        |          |          |                     _PyEval_Vector\n"
"                        |          |          |                     py::foo:/src/script.py\n"
"                        |          |          |                     |\n"
"                        |          |          |                     |--51.81%--_PyEval_EvalFrameDefault\n"
"                        |          |          |                     |          |\n"
"                        |          |          |                     |          |--13.77%--_PyLong_Add\n"
"                        |          |          |                     |          |          |\n"
"                        |          |          |                     |          |          |--3.26%--_PyObject_Malloc"

#: ../../howto/perf_profiling.rst:152
msgid "How to enable ``perf`` profiling support"
msgstr "如何启用 ``perf`` 性能分析支持"

#: ../../howto/perf_profiling.rst:154
msgid ""
"``perf`` profiling support can be enabled either from the start using the "
"environment variable :envvar:`PYTHONPERFSUPPORT` or the :option:`-X perf "
"<-X>` option, or dynamically using :func:`sys.activate_stack_trampoline` and"
" :func:`sys.deactivate_stack_trampoline`."
msgstr ""
"要启动 ``perf`` 性能分析支持可以通过使用环境变量 :envvar:`PYTHONPERFSUPPORT` 或 :option:`-X perf"
" <-X>` 选项，或者动态地使用 :func:`sys.activate_stack_trampoline` 和 "
":func:`sys.deactivate_stack_trampoline` 来运行。"

#: ../../howto/perf_profiling.rst:160
msgid ""
"The :mod:`!sys` functions take precedence over the :option:`!-X` option, the"
" :option:`!-X` option takes precedence over the environment variable."
msgstr ":mod:`!sys` 函数的优先级高于 :option:`!-X` 选项，:option:`!-X` 选项的优先级高于环境变量。"

#: ../../howto/perf_profiling.rst:163
msgid "Example, using the environment variable::"
msgstr "示例，使用环境变量::"

#: ../../howto/perf_profiling.rst:165
msgid ""
"$ PYTHONPERFSUPPORT=1 perf record -F 9999 -g -o perf.data python my_script.py\n"
"$ perf report -g -i perf.data"
msgstr ""
"$ PYTHONPERFSUPPORT=1 perf record -F 9999 -g -o perf.data python my_script.py\n"
"$ perf report -g -i perf.data"

#: ../../howto/perf_profiling.rst:168
msgid "Example, using the :option:`!-X` option::"
msgstr "示例，使用 :option:`!-X` 选项::"

#: ../../howto/perf_profiling.rst:170
msgid ""
"$ perf record -F 9999 -g -o perf.data python -X perf my_script.py\n"
"$ perf report -g -i perf.data"
msgstr ""
"$ perf record -F 9999 -g -o perf.data python -X perf my_script.py\n"
"$ perf report -g -i perf.data"

#: ../../howto/perf_profiling.rst:173
msgid "Example, using the :mod:`sys` APIs in file :file:`example.py`:"
msgstr "示例，在文件 :file:`example.py` 中使用 :mod:`sys` API:"

#: ../../howto/perf_profiling.rst:175
msgid ""
"import sys\n"
"\n"
"sys.activate_stack_trampoline(\"perf\")\n"
"do_profiled_stuff()\n"
"sys.deactivate_stack_trampoline()\n"
"\n"
"non_profiled_stuff()"
msgstr ""
"import sys\n"
"\n"
"sys.activate_stack_trampoline(\"perf\")\n"
"do_profiled_stuff()\n"
"sys.deactivate_stack_trampoline()\n"
"\n"
"non_profiled_stuff()"

#: ../../howto/perf_profiling.rst:185
msgid "...then::"
msgstr "...然后::"

#: ../../howto/perf_profiling.rst:187
msgid ""
"$ perf record -F 9999 -g -o perf.data python ./example.py\n"
"$ perf report -g -i perf.data"
msgstr ""
"$ perf record -F 9999 -g -o perf.data python ./example.py\n"
"$ perf report -g -i perf.data"

#: ../../howto/perf_profiling.rst:192
msgid "How to obtain the best results"
msgstr "如何获取最佳结果"

#: ../../howto/perf_profiling.rst:194
msgid ""
"For best results, Python should be compiled with ``CFLAGS=\"-fno-omit-frame-"
"pointer -mno-omit-leaf-frame-pointer\"`` as this allows profilers to unwind "
"using only the frame pointer and not on DWARF debug information. This is "
"because as the code that is interposed to allow ``perf`` support is "
"dynamically generated it doesn't have any DWARF debugging information "
"available."
msgstr ""
"要获取最佳结果，Python 应当使用 ``CFLAGS=\"-fno-omit-frame-pointer -mno-omit-leaf-frame-"
"pointer\"`` 来编译因为这将允许性能分析器仅使用帧指针而不是基于 DWARF 调试信息进行展开。 这是因为被插入以允许 ``perf`` "
"支持的代码是动态生成的所以它没有任何 DWARF 调试信息可用。"

#: ../../howto/perf_profiling.rst:201
msgid ""
"You can check if your system has been compiled with this flag by running::"
msgstr "你可以通过运行以下代码来检查你的系统是否为附带此旗标来编译的::"

#: ../../howto/perf_profiling.rst:203
msgid "$ python -m sysconfig | grep 'no-omit-frame-pointer'"
msgstr "$ python -m sysconfig | grep 'no-omit-frame-pointer'"

#: ../../howto/perf_profiling.rst:205
msgid ""
"If you don't see any output it means that your interpreter has not been "
"compiled with frame pointers and therefore it may not be able to show Python"
" functions in the output of ``perf``."
msgstr "如果你没有看到任何输出则意味着你的解释器没有附带帧指针来编译因而它将无法在 ``perf`` 的输出中显示 Python 函数。"

#: ../../howto/perf_profiling.rst:211
msgid "How to work without frame pointers"
msgstr "如何在不带帧指针的情况下使用"

#: ../../howto/perf_profiling.rst:213
msgid ""
"If you are working with a Python interpreter that has been compiled without "
"frame pointers, you can still use the ``perf`` profiler, but the overhead "
"will be a bit higher because Python needs to generate unwinding information "
"for every Python function call on the fly. Additionally, ``perf`` will take "
"more time to process the data because it will need to use the DWARF "
"debugging information to unwind the stack and this is a slow process."
msgstr ""
"如果你使用在不带帧指针的情况下编译的 Python 解释器，你仍然可以使用 ``perf`` 性能分析器，但会有较高的资源开销因为 Python "
"需要为每个 Python 函数即时生成回撤信息。 此外，``perf`` 将花费更多时间来处理数据因为它需要使用 DWARF "
"调试信息来回撤栈而这是一个缓慢的过程。"

#: ../../howto/perf_profiling.rst:220
msgid ""
"To enable this mode, you can use the environment variable "
":envvar:`PYTHON_PERF_JIT_SUPPORT` or the :option:`-X perf_jit <-X>` option, "
"which will enable the JIT mode for the ``perf`` profiler."
msgstr ""
"要启用此模式，你可以使用环境变量 :envvar:`PYTHON_PERF_JIT_SUPPORT` 或 :option:`-X perf_jit "
"<-X>` 选项，它将为 ``perf`` 性能分析器启用 JIT 模式。"

#: ../../howto/perf_profiling.rst:226
msgid ""
"Due to a bug in the ``perf`` tool, only ``perf`` versions higher than v6.8 "
"will work with the JIT mode.  The fix was also backported to the v6.7.2 "
"version of the tool."
msgstr ""
"由于 ``perf`` 工具的一个程序错误，只有 ``perf`` 版本号高于 v6.8 才能使用 JIT 模式。 修复也向下移植到了此工具的 "
"v6.7.2 版。"

#: ../../howto/perf_profiling.rst:230
msgid ""
"Note that when checking the version of the ``perf`` tool (which can be done "
"by running ``perf version``) you must take into account that some distros "
"add some custom version numbers including a ``-`` character.  This means "
"that ``perf 6.7-3`` is not necessarily ``perf 6.7.3``."
msgstr ""
"请注意在检测 ``perf`` 工具的版本时（这可通过运行 ``perf version`` 来完成）你必须将某些发行版添加包括了 ``-`` "
"字符的自定义版本号纳入考虑。 这意味着 ``perf 6.7-3`` 不一定等于 ``perf 6.7.3``。"

#: ../../howto/perf_profiling.rst:235
msgid ""
"When using the perf JIT mode, you need an extra step before you can run "
"``perf report``. You need to call the ``perf inject`` command to inject the "
"JIT information into the ``perf.data`` file.::"
msgstr ""
"当使用 perf JIT 模式时，在你运行 ``perf report`` 之前你还需要一个额外的步骤。 你需要调用 ``perf inject`` "
"命令来将 JIT 信息注入 ``perf.data`` 文件。::"

#: ../../howto/perf_profiling.rst:239
msgid ""
"$ perf record -F 9999 -g -k 1 --call-graph dwarf -o perf.data python -Xperf_jit my_script.py\n"
"$ perf inject -i perf.data --jit --output perf.jit.data\n"
"$ perf report -g -i perf.jit.data"
msgstr ""
"$ perf record -F 9999 -g -k 1 --call-graph dwarf -o perf.data python -Xperf_jit my_script.py\n"
"$ perf inject -i perf.data --jit --output perf.jit.data\n"
"$ perf report -g -i perf.jit.data"

#: ../../howto/perf_profiling.rst:243
msgid "or using the environment variable::"
msgstr "或者使用环境变量::"

#: ../../howto/perf_profiling.rst:245
msgid ""
"$ PYTHON_PERF_JIT_SUPPORT=1 perf record -F 9999 -g --call-graph dwarf -o perf.data python my_script.py\n"
"$ perf inject -i perf.data --jit --output perf.jit.data\n"
"$ perf report -g -i perf.jit.data"
msgstr ""
"$ PYTHON_PERF_JIT_SUPPORT=1 perf record -F 9999 -g --call-graph dwarf -o perf.data python my_script.py\n"
"$ perf inject -i perf.data --jit --output perf.jit.data\n"
"$ perf report -g -i perf.jit.data"

#: ../../howto/perf_profiling.rst:249
msgid ""
"``perf inject --jit`` command will read ``perf.data``, automatically pick up"
" the perf dump file that Python creates (in ``/tmp/perf-$PID.dump``), and "
"then create ``perf.jit.data`` which merges all the JIT information together."
" It should also create a lot of ``jitted-XXXX-N.so`` files in the current "
"directory which are ELF images for all the JIT trampolines that were created"
" by Python."
msgstr ""
"``perf inject --jit`` 命令将读取 ``perf.data``，自动获取 Python 创建的 perf 转储文件（在 "
"``/tmp/perf-$PID.dump`` 中），然后创建将所有 JIT 信息合并到一起的 ``perf.jit.data`` 文件。 "
"它还会在当前目录下创建大量 ``jitted-XXXX-N.so`` 文件，它们是 Python 所创建的所有 JIT 中间数据的 ELF 映像。"

#: ../../howto/perf_profiling.rst:257
msgid ""
"When using ``--call-graph dwarf``, the ``perf`` tool will take snapshots of "
"the stack of the process being profiled and save the information in the "
"``perf.data`` file. By default, the size of the stack dump is 8192 bytes, "
"but you can change the size by passing it after a comma like ``--call-graph "
"dwarf,16384``."
msgstr ""
"当使用 ``--call-graph dwarf`` 时，``perf`` 工具将对被分析进程的栈打快照并将信息保存在 ``perf.data`` "
"文件中。 在默认情况下，栈转储的大小为 8192 字节，但你可以通过额外传入一个逗号加数值如 ``--call-graph dwarf,16384`` "
"来改变这个大小。"

#: ../../howto/perf_profiling.rst:263
msgid ""
"The size of the stack dump is important because if the size is too small "
"``perf`` will not be able to unwind the stack and the output will be "
"incomplete. On the other hand, if the size is too big, then ``perf`` won't "
"be able to sample the process as frequently as it would like as the overhead"
" will be higher."
msgstr ""
"栈转储的大小很重要因为如果这个值太小 ``perf`` 将无法展开栈信息而输出将不完整。 另一方面，如果这个值太大，那么 ``perf`` "
"将无法按需以足够的频率对进程执行采样因为那样资源开销会过高。"

#: ../../howto/perf_profiling.rst:269
msgid ""
"The stack size is particularly important when profiling Python code compiled"
" with low optimization levels (like ``-O0``), as these builds tend to have "
"larger stack frames. If you are compiling Python with ``-O0`` and not seeing"
" Python functions in your profiling output, try increasing the stack dump "
"size to 65528 bytes (the maximum)::"
msgstr ""
"栈大小在对使用较低优化级别 (如 ``-O0``) 编译的 Python 代码进行性能分析时更为重要，因为这类构建版往往有更大的栈帧。 如果你是使用 "
"``-O0`` 来编译 Python 并且没有在你的性能分析输出中看到 Python 函数，请尝试将栈转储大小增加到 65528 字节 (最大值)::"

#: ../../howto/perf_profiling.rst:275
msgid ""
"$ perf record -F 9999 -g -k 1 --call-graph dwarf,65528 -o perf.data python "
"-Xperf_jit my_script.py"
msgstr ""
"$ perf record -F 9999 -g -k 1 --call-graph dwarf,65528 -o perf.data python "
"-Xperf_jit my_script.py"

#: ../../howto/perf_profiling.rst:277
msgid "Different compilation flags can significantly impact stack sizes:"
msgstr "不同的编译旗标可能显著地影响栈大小："

#: ../../howto/perf_profiling.rst:279
msgid ""
"Builds with ``-O0`` typically have much larger stack frames than those with "
"``-O1`` or higher"
msgstr "使用 ``-O0`` 构建通常会比使用 ``-O1`` 或更高的值具有大得多的栈帧数。"

#: ../../howto/perf_profiling.rst:280
msgid ""
"Adding optimizations (``-O1``, ``-O2``, etc.) typically reduces stack size"
msgstr "添加优化 (``-O1``, ``-O2`` 等) 通常会减小栈大小"

#: ../../howto/perf_profiling.rst:281
msgid ""
"Frame pointers (``-fno-omit-frame-pointer``) generally provide more reliable"
" stack unwinding"
msgstr "帧指针 (``-fno-omit-frame-pointer``) 通常会提供更可靠的栈展开"
