# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-06-06 14:20+0000\n"
"PO-Revision-Date: 2025-07-18 18:48+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/urllib2.rst:5
msgid "HOWTO Fetch Internet Resources Using The urllib Package"
msgstr "如何利用 urllib 包获取网络资源"

#: ../../howto/urllib2.rst:0
msgid "Author"
msgstr "作者"

#: ../../howto/urllib2.rst:7
msgid "`Michael Foord <https://agileabstractions.com/>`_"
msgstr "`Michael Foord <https://agileabstractions.com/>`_"

#: ../../howto/urllib2.rst:11
msgid "Introduction"
msgstr "概述"

#: ../../howto/urllib2.rst:15
msgid ""
"You may also find useful the following article on fetching web resources "
"with Python:"
msgstr "关于如何用 Python 获取 web 资源，以下文章或许也很有用："

#: ../../howto/urllib2.rst:18
msgid ""
"`Basic Authentication "
"<https://web.archive.org/web/20201215133350/http://www.voidspace.org.uk/python/articles/authentication.shtml>`_"
msgstr ""
"`基本身份认证 "
"<https://web.archive.org/web/20201215133350/http://www.voidspace.org.uk/python/articles/authentication.shtml>`_"

#: ../../howto/urllib2.rst:20
msgid "A tutorial on *Basic Authentication*, with examples in Python."
msgstr "*基本认证* 的教程，带有一些 Python 示例。"

#: ../../howto/urllib2.rst:22
msgid ""
"**urllib.request** is a Python module for fetching URLs (Uniform Resource "
"Locators). It offers a very simple interface, in the form of the *urlopen* "
"function. This is capable of fetching URLs using a variety of different "
"protocols. It also offers a slightly more complex interface for handling "
"common situations - like basic authentication, cookies, proxies and so on. "
"These are provided by objects called handlers and openers."
msgstr ""
"**urllib.request** 是用于获取 URL （统一资源定位符）的 Python 模块。它以 *urlopen* "
"函数的形式提供了一个非常简单的接口，能用不同的协议获取 "
"URL。同时它还为处理各种常见情形提供了一个稍微复杂一些的接口——比如：基础身份认证、cookies、代理等等。这些功能是由名为 handlers 和 "
"opener 的对象提供的。"

#: ../../howto/urllib2.rst:29
msgid ""
"urllib.request supports fetching URLs for many \"URL schemes\" (identified "
"by the string before the ``\":\"`` in URL - for example ``\"ftp\"`` is the "
"URL scheme of ``\"ftp://python.org/\"``) using their associated network "
"protocols (e.g. FTP, HTTP). This tutorial focuses on the most common case, "
"HTTP."
msgstr ""
"urllib.request 支持多种  \"URL 方案\" （通过 URL中 ``\":\"`` 之前的字符串加以区分——如 "
"``\"ftp://python.org/\"`` 中的 ``\"ftp\"``）即为采用其关联网络协议（FTP、HTTP 之类）的 URL 方案 "
"。本教程重点关注最常用的 HTTP 场景。"

#: ../../howto/urllib2.rst:34
msgid ""
"For straightforward situations *urlopen* is very easy to use. But as soon as"
" you encounter errors or non-trivial cases when opening HTTP URLs, you will "
"need some understanding of the HyperText Transfer Protocol. The most "
"comprehensive and authoritative reference to HTTP is :rfc:`2616`. This is a "
"technical document and not intended to be easy to read. This HOWTO aims to "
"illustrate using *urllib*, with enough detail about HTTP to help you "
"through. It is not intended to replace the :mod:`urllib.request` docs, but "
"is supplementary to them."
msgstr ""
"对于简单场景而言， *urlopen* 用起来十分容易。但只要在打开 HTTP URL "
"时遇到错误或非常情况，就需要对超文本传输协议有所了解才行。最全面、最权威的 HTTP 参考是 :rfc:`2616` "
"。那是一份技术文档，并没有追求可读性。本 文旨在说明 *urllib* 的用法，为了便于阅读也附带了足够详细的 HTTP 信息。本文并不是为了替代 "
":mod:`urllib.request` 文档，只是其补充说明而已。"

#: ../../howto/urllib2.rst:44
msgid "Fetching URLs"
msgstr "获取 URL 资源"

#: ../../howto/urllib2.rst:46
msgid "The simplest way to use urllib.request is as follows::"
msgstr "urllib.request 最简单的使用方式如下所示："

#: ../../howto/urllib2.rst:48
msgid ""
"import urllib.request\n"
"with urllib.request.urlopen('http://python.org/') as response:\n"
"   html = response.read()"
msgstr ""
"import urllib.request\n"
"with urllib.request.urlopen('http://python.org/') as response:\n"
"   html = response.read()"

#: ../../howto/urllib2.rst:52
msgid ""
"If you wish to retrieve a resource via URL and store it in a temporary "
"location, you can do so via the :func:`shutil.copyfileobj` and "
":func:`tempfile.NamedTemporaryFile` functions::"
msgstr ""
"如果想通过 URL 获取资源并临时存储一下，可以采用 :func:`shutil.copyfileobj` 和 "
":func:`tempfile.NamedTemporaryFile` 函数："

#: ../../howto/urllib2.rst:56
msgid ""
"import shutil\n"
"import tempfile\n"
"import urllib.request\n"
"\n"
"with urllib.request.urlopen('http://python.org/') as response:\n"
"    with tempfile.NamedTemporaryFile(delete=False) as tmp_file:\n"
"        shutil.copyfileobj(response, tmp_file)\n"
"\n"
"with open(tmp_file.name) as html:\n"
"    pass"
msgstr ""
"import shutil\n"
"import tempfile\n"
"import urllib.request\n"
"\n"
"with urllib.request.urlopen('http://python.org/') as response:\n"
"    with tempfile.NamedTemporaryFile(delete=False) as tmp_file:\n"
"        shutil.copyfileobj(response, tmp_file)\n"
"\n"
"with open(tmp_file.name) as html:\n"
"    pass"

#: ../../howto/urllib2.rst:67
msgid ""
"Many uses of urllib will be that simple (note that instead of an 'http:' URL"
" we could have used a URL starting with 'ftp:', 'file:', etc.).  However, "
"it's the purpose of this tutorial to explain the more complicated cases, "
"concentrating on HTTP."
msgstr ""
"urllib 的很多用法就是这么简单（注意 URL 不仅可以 http: 开头，还可以是 ftp: 、file: "
"等）。不过本教程的目的是介绍更加复杂的应用场景，重点还是关注 HTTP。"

#: ../../howto/urllib2.rst:72
msgid ""
"HTTP is based on requests and responses - the client makes requests and "
"servers send responses. urllib.request mirrors this with a ``Request`` "
"object which represents the HTTP request you are making. In its simplest "
"form you create a Request object that specifies the URL you want to fetch. "
"Calling ``urlopen`` with this Request object returns a response object for "
"the URL requested. This response is a file-like object, which means you can "
"for example call ``.read()`` on the response::"
msgstr ""
"HTTP 以请求和响应为基础——客户端生成请求，服务器发送响应。urllib.request 用 ``Request`` 对象来表示要生成的 HTTP "
"请求。最简单的形式就是创建一个 Request 对象，指定了想要获取的 URL。用这个 Request 对象作为参数调用 ``urlopen`` "
"，将会返回该 URL 的响应对象。响应对象类似于文件对象，就是说可以对其调用 ``.read()`` 之类的命令："

#: ../../howto/urllib2.rst:80
msgid ""
"import urllib.request\n"
"\n"
"req = urllib.request.Request('http://python.org/')\n"
"with urllib.request.urlopen(req) as response:\n"
"   the_page = response.read()"
msgstr ""
"import urllib.request\n"
"\n"
"req = urllib.request.Request('http://python.org/')\n"
"with urllib.request.urlopen(req) as response:\n"
"   the_page = response.read()"

#: ../../howto/urllib2.rst:86
msgid ""
"Note that urllib.request makes use of the same Request interface to handle "
"all URL schemes.  For example, you can make an FTP request like so::"
msgstr "请注意，urllib.request 用同一个 Request 接口处理所有 URL 方案。比如可生成 FTP 请求如下："

#: ../../howto/urllib2.rst:89
msgid "req = urllib.request.Request('ftp://example.com/')"
msgstr "req = urllib.request.Request('ftp://example.com/')"

#: ../../howto/urllib2.rst:91
msgid ""
"In the case of HTTP, there are two extra things that Request objects allow "
"you to do: First, you can pass data to be sent to the server.  Second, you "
"can pass extra information (\"metadata\") *about* the data or about the "
"request itself, to the server - this information is sent as HTTP "
"\"headers\".  Let's look at each of these in turn."
msgstr ""
"就 HTTP 而言，Request 对象能够做两件额外的事情：首先可以把数据传给服务器。其次，可以将 *有关* "
"数据或请求本身的额外信息（metadata）传给服务器——这些信息将会作为 HTTP “头部”数据发送。下面依次看下。"

#: ../../howto/urllib2.rst:98
msgid "Data"
msgstr "数据"

#: ../../howto/urllib2.rst:100
msgid ""
"Sometimes you want to send data to a URL (often the URL will refer to a CGI "
"(Common Gateway Interface) script or other web application). With HTTP, this"
" is often done using what's known as a **POST** request. This is often what "
"your browser does when you submit a HTML form that you filled in on the web."
" Not all POSTs have to come from forms: you can use a POST to transmit "
"arbitrary data to your own application. In the common case of HTML forms, "
"the data needs to be encoded in a standard way, and then passed to the "
"Request object as the ``data`` argument. The encoding is done using a "
"function from the :mod:`urllib.parse` library. ::"
msgstr ""
"有时需要向某个 URL 发送数据，通常此 URL 会指向某个CGI（通用网关接口）脚本或其他 web 应用。对于 HTTP 而言，这通常会用所谓的 "
"**POST** 请求来完成。当要把 Web 页填写的 HTML 表单提交时，浏览器通常会执行此操作。但并不是所有的 POST 都来自表单：可以用 "
"POST 方式传输任何数据到自己的应用上。对于通常的 HTML 表单，数据需要以标准的方式编码，然后作为 ``data`` 参数传给 Request "
"对象。编码过程是用 :mod:`urllib.parse` 库的函数完成的："

#: ../../howto/urllib2.rst:110
msgid ""
"import urllib.parse\n"
"import urllib.request\n"
"\n"
"url = 'http://www.someserver.com/cgi-bin/register.cgi'\n"
"values = {'name' : 'Michael Foord',\n"
"          'location' : 'Northampton',\n"
"          'language' : 'Python' }\n"
"\n"
"data = urllib.parse.urlencode(values)\n"
"data = data.encode('ascii') # data should be bytes\n"
"req = urllib.request.Request(url, data)\n"
"with urllib.request.urlopen(req) as response:\n"
"   the_page = response.read()"
msgstr ""
"import urllib.parse\n"
"import urllib.request\n"
"\n"
"url = 'http://www.someserver.com/cgi-bin/register.cgi'\n"
"values = {'name' : 'Michael Foord',\n"
"          'location' : 'Northampton',\n"
"          'language' : 'Python' }\n"
"\n"
"data = urllib.parse.urlencode(values)\n"
"data = data.encode('ascii') # 数据应为字节串\n"
"req = urllib.request.Request(url, data)\n"
"with urllib.request.urlopen(req) as response:\n"
"   the_page = response.read()"

#: ../../howto/urllib2.rst:124
msgid ""
"Note that other encodings are sometimes required (e.g. for file upload from "
"HTML forms - see `HTML Specification, Form Submission "
"<https://www.w3.org/TR/REC-html40/interact/forms.html#h-17.13>`_ for more "
"details)."
msgstr ""
"请注意，有时还需要采用其他编码，比如由 HTML 表单上传文件——更多细节请参见 `HTML 规范，提交表单 "
"<https://www.w3.org/TR/REC-html40/interact/forms.html#h-17.13>`_ 。"

#: ../../howto/urllib2.rst:129
msgid ""
"If you do not pass the ``data`` argument, urllib uses a **GET** request. One"
" way in which GET and POST requests differ is that POST requests often have "
"\"side-effects\": they change the state of the system in some way (for "
"example by placing an order with the website for a hundredweight of tinned "
"spam to be delivered to your door).  Though the HTTP standard makes it clear"
" that POSTs are intended to *always* cause side-effects, and GET requests "
"*never* to cause side-effects, nothing prevents a GET request from having "
"side-effects, nor a POST requests from having no side-effects. Data can also"
" be passed in an HTTP GET request by encoding it in the URL itself."
msgstr ""
"如果不传递 ``data`` 参数，urllib 将采用 **GET** 请求。GET 和 POST 请求有一点不同，POST "
"请求往往具有“副作用”，他们会以某种方式改变系统的状态。例如，从网站下一个订单，购买一大堆罐装垃圾并运送到家。 尽管 HTTP 标准明确指出 POST "
"*总是* 要导致副作用，而 GET 请求 *从来不会* 导致副作用。但没有什么办法能阻止 GET 和 POST 请求的副作用。数据也可以在 HTTP "
"GET 请求中传递，只要把数据编码到 URL 中即可。"

#: ../../howto/urllib2.rst:139
msgid "This is done as follows::"
msgstr "做法如下所示："

#: ../../howto/urllib2.rst:141
msgid ""
">>> import urllib.request\n"
">>> import urllib.parse\n"
">>> data = {}\n"
">>> data['name'] = 'Somebody Here'\n"
">>> data['location'] = 'Northampton'\n"
">>> data['language'] = 'Python'\n"
">>> url_values = urllib.parse.urlencode(data)\n"
">>> print(url_values)  # The order may differ from below.\n"
"name=Somebody+Here&language=Python&location=Northampton\n"
">>> url = 'http://www.example.com/example.cgi'\n"
">>> full_url = url + '?' + url_values\n"
">>> data = urllib.request.urlopen(full_url)"
msgstr ""
">>> import urllib.request\n"
">>> import urllib.parse\n"
">>> data = {}\n"
">>> data['name'] = 'Somebody Here'\n"
">>> data['location'] = 'Northampton'\n"
">>> data['language'] = 'Python'\n"
">>> url_values = urllib.parse.urlencode(data)\n"
">>> print(url_values)  # The order may differ from below.\n"
"name=Somebody+Here&language=Python&location=Northampton\n"
">>> url = 'http://www.example.com/example.cgi'\n"
">>> full_url = url + '?' + url_values\n"
">>> data = urllib.request.urlopen(full_url)"

#: ../../howto/urllib2.rst:154
msgid ""
"Notice that the full URL is created by adding a ``?`` to the URL, followed "
"by the encoded values."
msgstr "请注意，完整的 URL 是通过在其中添加 ``?`` 创建的，后面跟着经过编码的数据。"

#: ../../howto/urllib2.rst:158
msgid "Headers"
msgstr "HTTP 头部信息"

#: ../../howto/urllib2.rst:160
msgid ""
"We'll discuss here one particular HTTP header, to illustrate how to add "
"headers to your HTTP request."
msgstr "下面介绍一个具体的 HTTP 头部信息，以此说明如何在 HTTP 请求加入头部信息。"

#: ../../howto/urllib2.rst:163
msgid ""
"Some websites [#]_ dislike being browsed by programs, or send different "
"versions to different browsers [#]_. By default urllib identifies itself as "
"``Python-urllib/x.y`` (where ``x`` and ``y`` are the major and minor version"
" numbers of the Python release, e.g. ``Python-urllib/2.5``), which may "
"confuse the site, or just plain not work. The way a browser identifies "
"itself is through the ``User-Agent`` header [#]_. When you create a Request "
"object you can pass a dictionary of headers in. The following example makes "
"the same request as above, but identifies itself as a version of Internet "
"Explorer [#]_. ::"
msgstr ""
"有些网站 [#]_ 不愿被程序浏览到，或者要向不同的浏览器发送不同版本 [#]_ 的网页。默认情况下，urllib 将自身标识为“Python-"
"urllib/xy”（其中 ``x`` 、 ``y`` 是 Python 版本的主、次版本号，例如  ``Python-"
"urllib/2.5``），这可能会让网站不知所措，或者干脆就使其无法正常工作。浏览器是通过头部信息 ``User-Agent`` [#]_ "
"来标识自己的。在创建 Request 对象时，可以传入字典形式的头部信息。以下示例将生成与之前相同的请求，只是将自身标识为某个版本的 Internet "
"Explorer [#]_ ："

#: ../../howto/urllib2.rst:174
msgid ""
"import urllib.parse\n"
"import urllib.request\n"
"\n"
"url = 'http://www.someserver.com/cgi-bin/register.cgi'\n"
"user_agent = 'Mozilla/5.0 (Windows NT 6.1; Win64; x64)'\n"
"values = {'name': 'Michael Foord',\n"
"          'location': 'Northampton',\n"
"          'language': 'Python' }\n"
"headers = {'User-Agent': user_agent}\n"
"\n"
"data = urllib.parse.urlencode(values)\n"
"data = data.encode('ascii')\n"
"req = urllib.request.Request(url, data, headers)\n"
"with urllib.request.urlopen(req) as response:\n"
"   the_page = response.read()"
msgstr ""
"import urllib.parse\n"
"import urllib.request\n"
"\n"
"url = 'http://www.someserver.com/cgi-bin/register.cgi'\n"
"user_agent = 'Mozilla/5.0 (Windows NT 6.1; Win64; x64)'\n"
"values = {'name': 'Michael Foord',\n"
"          'location': 'Northampton',\n"
"          'language': 'Python' }\n"
"headers = {'User-Agent': user_agent}\n"
"\n"
"data = urllib.parse.urlencode(values)\n"
"data = data.encode('ascii')\n"
"req = urllib.request.Request(url, data, headers)\n"
"with urllib.request.urlopen(req) as response:\n"
"   the_page = response.read()"

#: ../../howto/urllib2.rst:190
msgid ""
"The response also has two useful methods. See the section on `info and "
"geturl`_ which comes after we have a look at what happens when things go "
"wrong."
msgstr "响应对象也有两个很有用的方法。请参阅有关 `info 和 geturl`_ 部分，了解出现问题时会发生什么。"

#: ../../howto/urllib2.rst:195
msgid "Handling Exceptions"
msgstr "异常的处理"

#: ../../howto/urllib2.rst:197
msgid ""
"*urlopen* raises :exc:`~urllib.error.URLError` when it cannot handle a "
"response (though as usual with Python APIs, built-in exceptions such as "
":exc:`ValueError`, :exc:`TypeError` etc. may also be raised)."
msgstr ""
"当 *urlopen* 无法处理响应信息时将会引发 :exc:`~urllib.error.URLError` (当然与 Python API "
"通常的情况一样，也可能会引发如 :exc:`ValueError`, :exc:`TypeError` 之类的内置异常)。"

#: ../../howto/urllib2.rst:201
msgid ""
":exc:`~urllib.error.HTTPError` is the subclass of "
":exc:`~urllib.error.URLError` raised in the specific case of HTTP URLs."
msgstr ""
":exc:`~urllib.error.HTTPError` 是在 HTTP URL 的特定情况下引发的 "
":exc:`~urllib.error.URLError` 的子类。"

#: ../../howto/urllib2.rst:204
msgid ""
"The exception classes are exported from the :mod:`urllib.error` module."
msgstr "上述异常类是从 :mod:`urllib.error` 模块中导出的。"

#: ../../howto/urllib2.rst:207
msgid "URLError"
msgstr "URLError"

#: ../../howto/urllib2.rst:209
msgid ""
"Often, URLError is raised because there is no network connection (no route "
"to the specified server), or the specified server doesn't exist.  In this "
"case, the exception raised will have a 'reason' attribute, which is a tuple "
"containing an error code and a text error message."
msgstr ""
"触发 URLError 的原因，通常是网络不通（或者没有到指定服务器的路由），或者指定的服务器不存在。这时触发的异常会带有一个 reason "
"属性，是一个包含错误代码和文本错误信息的元组。"

#: ../../howto/urllib2.rst:214
msgid "e.g. ::"
msgstr "例如："

#: ../../howto/urllib2.rst:216
msgid ""
">>> req = urllib.request.Request('http://www.pretend_server.org')\n"
">>> try: urllib.request.urlopen(req)\n"
"... except urllib.error.URLError as e:\n"
"...     print(e.reason)\n"
"...\n"
"(4, 'getaddrinfo failed')"
msgstr ""
">>> req = urllib.request.Request('http://www.pretend_server.org')\n"
">>> try: urllib.request.urlopen(req)\n"
"... except urllib.error.URLError as e:\n"
"...     print(e.reason)\n"
"...\n"
"(4, 'getaddrinfo failed')"

#: ../../howto/urllib2.rst:225
msgid "HTTPError"
msgstr "HTTPError"

#: ../../howto/urllib2.rst:227
msgid ""
"Every HTTP response from the server contains a numeric \"status code\". "
"Sometimes the status code indicates that the server is unable to fulfil the "
"request. The default handlers will handle some of these responses for you "
"(for example, if the response is a \"redirection\" that requests the client "
"fetch the document from a different URL, urllib will handle that for you). "
"For those it can't handle, urlopen will raise an "
":exc:`~urllib.error.HTTPError`. Typical errors include '404' (page not "
"found), '403' (request forbidden), and '401' (authentication required)."
msgstr ""
"来自服务器的每个 HTTP 响应都包含一个数字形式的“状态码”。 "
"有时该状态码表明服务器无法完成请求。默认的处理器将会为你处理其中的部分响应（例如，当响应为要求客户端从另一 URL "
"获取文档的“重定向”响应时，urllib 将为你处理该响应）。 对于无法处理的响应，urlopen 将会引发 "
":exc:`~urllib.error.HTTPError`。 典型的错误包括 \"404\"（页面未找到）、\"403\"（请求遭拒）和 "
"\"401\"（需要身份认证）等。"

#: ../../howto/urllib2.rst:235
msgid ""
"See section 10 of :rfc:`2616` for a reference on all the HTTP error codes."
msgstr "全部的 HTTP 错误码请参阅 :rfc:`2616` 。"

#: ../../howto/urllib2.rst:237
msgid ""
"The :exc:`~urllib.error.HTTPError` instance raised will have an integer "
"'code' attribute, which corresponds to the error sent by the server."
msgstr ""
"被引发的 :exc:`~urllib.error.HTTPError` 实例将有一个整数形式的 'code' 属性，对应于服务器发送的错误信息。"

#: ../../howto/urllib2.rst:241
msgid "Error Codes"
msgstr "错误代码"

#: ../../howto/urllib2.rst:243
msgid ""
"Because the default handlers handle redirects (codes in the 300 range), and "
"codes in the 100--299 range indicate success, you will usually only see "
"error codes in the 400--599 range."
msgstr ""
"由于默认处理函数会自行处理重定向（300 以内的错误码），而且 100--299 的状态码表示成功，因此通常只会出现 400--599 的错误码。"

#: ../../howto/urllib2.rst:247
msgid ""
":attr:`http.server.BaseHTTPRequestHandler.responses` is a useful dictionary "
"of response codes that shows all the response codes used by :rfc:`2616`. An "
"excerpt from the dictionary is shown below ::"
msgstr ""
":attr:`http.server.BaseHTTPRequestHandler.responses` 是一个很有用的响应码字典，它提供了 "
":rfc:`2616` 用到的所有码。 下面显示了来自该字典的一段摘录 ::"

#: ../../howto/urllib2.rst:251
msgid ""
"responses = {\n"
"    ...\n"
"    <HTTPStatus.OK: 200>: ('OK', 'Request fulfilled, document follows'),\n"
"    ...\n"
"    <HTTPStatus.FORBIDDEN: 403>: ('Forbidden',\n"
"                                  'Request forbidden -- authorization will '\n"
"                                  'not help'),\n"
"    <HTTPStatus.NOT_FOUND: 404>: ('Not Found',\n"
"                                  'Nothing matches the given URI'),\n"
"    ...\n"
"    <HTTPStatus.IM_A_TEAPOT: 418>: (\"I'm a Teapot\",\n"
"                                    'Server refuses to brew coffee because '\n"
"                                    'it is a teapot'),\n"
"    ...\n"
"    <HTTPStatus.SERVICE_UNAVAILABLE: 503>: ('Service Unavailable',\n"
"                                            'The server cannot process the '\n"
"                                            'request due to a high load'),\n"
"    ...\n"
"    }"
msgstr ""
"responses = {\n"
"    ...\n"
"    <HTTPStatus.OK: 200>: ('OK', 'Request fulfilled, document follows'),\n"
"    ...\n"
"    <HTTPStatus.FORBIDDEN: 403>: ('Forbidden',\n"
"                                  'Request forbidden -- authorization will '\n"
"                                  'not help'),\n"
"    <HTTPStatus.NOT_FOUND: 404>: ('Not Found',\n"
"                                  'Nothing matches the given URI'),\n"
"    ...\n"
"    <HTTPStatus.IM_A_TEAPOT: 418>: (\"I'm a Teapot\",\n"
"                                    'Server refuses to brew coffee because '\n"
"                                    'it is a teapot'),\n"
"    ...\n"
"    <HTTPStatus.SERVICE_UNAVAILABLE: 503>: ('Service Unavailable',\n"
"                                            'The server cannot process the '\n"
"                                            'request due to a high load'),\n"
"    ...\n"
"    }"

#: ../../howto/urllib2.rst:271
msgid ""
"When an error is raised the server responds by returning an HTTP error code "
"*and* an error page. You can use the :exc:`~urllib.error.HTTPError` instance"
" as a response on the page returned. This means that as well as the code "
"attribute, it also has read, geturl, and info, methods as returned by the "
"``urllib.response`` module::"
msgstr ""
"当错误被引发时服务器会通过返回 HTTP 错误码 *和* 错误页面进行响应。 你可以在返回的页面上使用 "
":exc:`~urllib.error.HTTPError` 实例作为响应。 这意味着除了 code 属性之外，它还像 "
"``urllib.response`` 模块: 所返回对象那样具有 read, geturl 和 info 等方法::"

#: ../../howto/urllib2.rst:276
msgid ""
">>> req = urllib.request.Request('http://www.python.org/fish.html')\n"
">>> try:\n"
"...     urllib.request.urlopen(req)\n"
"... except urllib.error.HTTPError as e:\n"
"...     print(e.code)\n"
"...     print(e.read())\n"
"...\n"
"404\n"
"b'<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n"
"  \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\\n\\n\\n<html\n"
"  ...\n"
"  <title>Page Not Found</title>\\n\n"
"  ..."
msgstr ""
">>> req = urllib.request.Request('http://www.python.org/fish.html')\n"
">>> try:\n"
"...     urllib.request.urlopen(req)\n"
"... except urllib.error.HTTPError as e:\n"
"...     print(e.code)\n"
"...     print(e.read())\n"
"...\n"
"404\n"
"b'<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n"
"  \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\\n\\n\\n<html\n"
"  ...\n"
"  <title>Page Not Found</title>\\n\n"
"  ..."

#: ../../howto/urllib2.rst:291
msgid "Wrapping it Up"
msgstr "总之"

#: ../../howto/urllib2.rst:293
msgid ""
"So if you want to be prepared for :exc:`~urllib.error.HTTPError` *or* "
":exc:`~urllib.error.URLError` there are two basic approaches. I prefer the "
"second approach."
msgstr ""
"因此当你想为 :exc:`~urllib.error.HTTPError` *或* :exc:`~urllib.error.URLError` "
"做好准备时有两种基本的方案。 我更倾向使用第二种方案。"

#: ../../howto/urllib2.rst:297
msgid "Number 1"
msgstr "第一种方案"

#: ../../howto/urllib2.rst:302
msgid ""
"from urllib.request import Request, urlopen\n"
"from urllib.error import URLError, HTTPError\n"
"req = Request(someurl)\n"
"try:\n"
"    response = urlopen(req)\n"
"except HTTPError as e:\n"
"    print('The server couldn\\'t fulfill the request.')\n"
"    print('Error code: ', e.code)\n"
"except URLError as e:\n"
"    print('We failed to reach a server.')\n"
"    print('Reason: ', e.reason)\n"
"else:\n"
"    # everything is fine"
msgstr ""
"from urllib.request import Request, urlopen\n"
"from urllib.error import URLError, HTTPError\n"
"req = Request(someurl)\n"
"try:\n"
"    response = urlopen(req)\n"
"except HTTPError as e:\n"
"    print('The server couldn\\'t fulfill the request.')\n"
"    print('Error code: ', e.code)\n"
"except URLError as e:\n"
"    print('We failed to reach a server.')\n"
"    print('Reason: ', e.reason)\n"
"else:\n"
"    # 一切正常"

#: ../../howto/urllib2.rst:319
msgid ""
"The ``except HTTPError`` *must* come first, otherwise ``except URLError`` "
"will *also* catch an :exc:`~urllib.error.HTTPError`."
msgstr ""
"``except HTTPError`` *必须* 首先被处理，否则 ``except URLError`` 将会 *同时* 捕获 "
":exc:`~urllib.error.HTTPError`。"

#: ../../howto/urllib2.rst:323
msgid "Number 2"
msgstr "第二种方案"

#: ../../howto/urllib2.rst:327
msgid ""
"from urllib.request import Request, urlopen\n"
"from urllib.error import URLError\n"
"req = Request(someurl)\n"
"try:\n"
"    response = urlopen(req)\n"
"except URLError as e:\n"
"    if hasattr(e, 'reason'):\n"
"        print('We failed to reach a server.')\n"
"        print('Reason: ', e.reason)\n"
"    elif hasattr(e, 'code'):\n"
"        print('The server couldn\\'t fulfill the request.')\n"
"        print('Error code: ', e.code)\n"
"else:\n"
"    # everything is fine"
msgstr ""
"from urllib.request import Request, urlopen\n"
"from urllib.error import URLError\n"
"req = Request(someurl)\n"
"try:\n"
"    response = urlopen(req)\n"
"except URLError as e:\n"
"    if hasattr(e, 'reason'):\n"
"        print('We failed to reach a server.')\n"
"        print('Reason: ', e.reason)\n"
"    elif hasattr(e, 'code'):\n"
"        print('The server couldn\\'t fulfill the request.')\n"
"        print('Error code: ', e.code)\n"
"else:\n"
"    # 一切正常"

#: ../../howto/urllib2.rst:344
msgid "info and geturl"
msgstr "info 和 geturl 方法"

#: ../../howto/urllib2.rst:346
msgid ""
"The response returned by urlopen (or the :exc:`~urllib.error.HTTPError` "
"instance) has two useful methods :meth:`!info` and :meth:`!geturl` and is "
"defined in the module :mod:`urllib.response`."
msgstr ""
"urlopen 返回的响应（或 :exc:`~urllib.error.HTTPError` 实例）包含两个有用的方法 :meth:`!info` 和 "
":meth:`!geturl` 并且是在 :mod:`urllib.response` 模块中定义的。"

#: ../../howto/urllib2.rst:350
msgid ""
"**geturl** - this returns the real URL of the page fetched. This is useful "
"because ``urlopen`` (or the opener object used) may have followed a "
"redirect. The URL of the page fetched may not be the same as the URL "
"requested."
msgstr ""
"**geturl** ——返回所获取页面的真实 URL。该方法很有用，因为 ``urlopen`` （或 opener "
"对象）可能已经经过了一次重定向。已获取页面的 URL 未必就是所请求的 URL 。"

#: ../../howto/urllib2.rst:354
msgid ""
"**info** - this returns a dictionary-like object that describes the page "
"fetched, particularly the headers sent by the server. It is currently an "
":class:`http.client.HTTPMessage` instance."
msgstr ""
"**info** - 该方法返回一个类似字典的对象，描述了所获取的页面，特别是由服务器送出的头部信息（headers） 。目前它是一个 "
":class:`http.client.HTTPMessage` 实例。"

#: ../../howto/urllib2.rst:358
msgid ""
"Typical headers include 'Content-length', 'Content-type', and so on. See the"
" `Quick Reference to HTTP Headers <https://jkorpela.fi/http.html>`_ for a "
"useful listing of HTTP headers with brief explanations of their meaning and "
"use."
msgstr ""
"典型的标头包括 'Content-length', 'Content-type' 等等。 请参阅 `HTTP 标头快速参考 "
"<https://jkorpela.fi/http.html>`_ 获取 HTTP 标头的完整列表及其含义和用法的简要说明。"

#: ../../howto/urllib2.rst:365
msgid "Openers and Handlers"
msgstr "Opener 和 Handler"

#: ../../howto/urllib2.rst:367
msgid ""
"When you fetch a URL you use an opener (an instance of the perhaps "
"confusingly named :class:`urllib.request.OpenerDirector`). Normally we have "
"been using the default opener - via ``urlopen`` - but you can create custom "
"openers. Openers use handlers. All the \"heavy lifting\" is done by the "
"handlers. Each handler knows how to open URLs for a particular URL scheme "
"(http, ftp, etc.), or how to handle an aspect of URL opening, for example "
"HTTP redirections or HTTP cookies."
msgstr ""
"当你获取 URL 时会使用一个 opener (名称可能有些令人困惑的 :class:`urllib.request.OpenerDirector` "
"的实例)。 通常我们会使用默认的 opener —— 通过 ``urlopen`` —— 但你也可以创建自定义的 opener。 opener 还会用到"
" handler。 所有 \"繁重工作\" 都是由 handler 来完成的。 每种 handler 都知道要以何种 URL 方案 (http, ftp"
" 等等) 来打开特定的 URL，或是如何处理 URL 打开时的特定操作，例如 HTTP 重定向或 HTTP cookie 等。"

#: ../../howto/urllib2.rst:375
msgid ""
"You will want to create openers if you want to fetch URLs with specific "
"handlers installed, for example to get an opener that handles cookies, or to"
" get an opener that does not handle redirections."
msgstr ""
"若要用已安装的某个 handler 获取 URL，需要创建一个 opener 对象，例如处理 cookie 的 opener，或对重定向不做处理的 "
"opener。"

#: ../../howto/urllib2.rst:379
msgid ""
"To create an opener, instantiate an ``OpenerDirector``, and then call "
"``.add_handler(some_handler_instance)`` repeatedly."
msgstr ""
"若要创建 opener，请实例化一个 ``OpenerDirector`` ，然后重复调用 "
"``.add_handler(some_handler_instance)`` 。"

#: ../../howto/urllib2.rst:382
msgid ""
"Alternatively, you can use ``build_opener``, which is a convenience function"
" for creating opener objects with a single function call.  ``build_opener`` "
"adds several handlers by default, but provides a quick way to add more "
"and/or override the default handlers."
msgstr ""
"或者也可以用 ``build_opener`` ，这是个用单次调用创建 opener 对象的便捷函数。``build_opener`` 默认会添加几个"
"  handler，不过还提供了一种快速添加和/或覆盖默认 handler 的方法。"

#: ../../howto/urllib2.rst:387
msgid ""
"Other sorts of handlers you might want to can handle proxies, "
"authentication, and other common but slightly specialised situations."
msgstr "可能还需要其他类型的 handler，以便处理代理、身份认证和其他常见但稍微特殊的情况。"

#: ../../howto/urllib2.rst:390
msgid ""
"``install_opener`` can be used to make an ``opener`` object the (global) "
"default opener. This means that calls to ``urlopen`` will use the opener you"
" have installed."
msgstr ""
"``install_opener`` 可用于让 ``opener`` 对象成为（全局）默认 opener。这意味着调用 ``urlopen`` "
"时会采用已安装的 opener。"

#: ../../howto/urllib2.rst:394
msgid ""
"Opener objects have an ``open`` method, which can be called directly to "
"fetch urls in the same way as the ``urlopen`` function: there's no need to "
"call ``install_opener``, except as a convenience."
msgstr ""
"opener 对象带有一个 ```open`` 方法，可供直接调用以获取 url，方式与 ``urlopen`` "
"函数相同。除非是为了调用方便，否则没必要去调用 ``install_opener`` 。"

#: ../../howto/urllib2.rst:400
msgid "Basic Authentication"
msgstr "基本认证"

#: ../../howto/urllib2.rst:402
msgid ""
"To illustrate creating and installing a handler we will use the "
"``HTTPBasicAuthHandler``. For a more detailed discussion of this subject -- "
"including an explanation of how Basic Authentication works - see the `Basic "
"Authentication Tutorial "
"<https://web.archive.org/web/20201215133350/http://www.voidspace.org.uk/python/articles/authentication.shtml>`__."
msgstr ""
"为了说明 handler 的创建和安装过程我们将使用 ``HTTPBasicAuthHandler``。 有关该主题的更详细讨论 -- "
"包括对基本身份认证的原理的阐述 -- 请参阅 `Basic Authentication Tutorial "
"<https://web.archive.org/web/20201215133350/http://www.voidspace.org.uk/python/articles/authentication.shtml>`__。"

#: ../../howto/urllib2.rst:408
msgid ""
"When authentication is required, the server sends a header (as well as the "
"401 error code) requesting authentication.  This specifies the "
"authentication scheme and a 'realm'. The header looks like: ``WWW-"
"Authenticate: SCHEME realm=\"REALM\"``."
msgstr ""
"如果需要身份认证，服务器会发送一条请求身份认证的头部信息（以及 401 "
"错误代码）。这条信息中指明了身份认证方式和“安全区域（realm）”。格式如下所示：``WWW-Authenticate: SCHEME "
"realm=\"REALM\"`` 。"

#: ../../howto/urllib2.rst:413
msgid "e.g."
msgstr "例如"

#: ../../howto/urllib2.rst:415
msgid "WWW-Authenticate: Basic realm=\"cPanel Users\""
msgstr "WWW-Authenticate: Basic realm=\"cPanel Users\""

#: ../../howto/urllib2.rst:420
msgid ""
"The client should then retry the request with the appropriate name and "
"password for the realm included as a header in the request. This is 'basic "
"authentication'. In order to simplify this process we can create an instance"
" of ``HTTPBasicAuthHandler`` and an opener to use this handler."
msgstr ""
"然后，客户端应重试发起请求，请求数据中的头部信息应包含安全区域对应的用户名和密码。这就是“基本身份认证”。为了简化此过程，可以创建 "
"``HTTPBasicAuthHandler`` 的一个实例及使用它的 opener。"

#: ../../howto/urllib2.rst:425
msgid ""
"The ``HTTPBasicAuthHandler`` uses an object called a password manager to "
"handle the mapping of URLs and realms to passwords and usernames. If you "
"know what the realm is (from the authentication header sent by the server), "
"then you can use a ``HTTPPasswordMgr``. Frequently one doesn't care what the"
" realm is. In that case, it is convenient to use "
"``HTTPPasswordMgrWithDefaultRealm``. This allows you to specify a default "
"username and password for a URL. This will be supplied in the absence of you"
" providing an alternative combination for a specific realm. We indicate this"
" by providing ``None`` as the realm argument to the ``add_password`` method."
msgstr ""
"``HTTPBasicAuthHandler`` 用一个名为密码管理器的对象来管理 "
"URL、安全区域与密码、用户名之间的映射关系。如果知道确切的安全区域（来自服务器发送的身份认证头部信息），那就可以用到 "
"``HTTPPasswordMgr`` 。通常人们并不关心安全区域是什么，这时用 ``HTTPPasswordMgrWithDefaultRealm``"
" 就很方便，允许为 URL 指定默认的用户名和密码。当没有为某个安全区域提供用户名和密码时，就会用到默认值。下面用 ``None`` 作为 "
"``add_password`` 方法的安全区域参数，表明采用默认用户名和密码。"

#: ../../howto/urllib2.rst:435
msgid ""
"The top-level URL is the first URL that requires authentication. URLs "
"\"deeper\" than the URL you pass to .add_password() will also match. ::"
msgstr "首先需要身份认证的是顶级 URL。比传给 .add_password() 的 URL 级别“更深”的 URL 也会得以匹配："

#: ../../howto/urllib2.rst:438
msgid ""
"# create a password manager\n"
"password_mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm()\n"
"\n"
"# Add the username and password.\n"
"# If we knew the realm, we could use it instead of None.\n"
"top_level_url = \"http://example.com/foo/\"\n"
"password_mgr.add_password(None, top_level_url, username, password)\n"
"\n"
"handler = urllib.request.HTTPBasicAuthHandler(password_mgr)\n"
"\n"
"# create \"opener\" (OpenerDirector instance)\n"
"opener = urllib.request.build_opener(handler)\n"
"\n"
"# use the opener to fetch a URL\n"
"opener.open(a_url)\n"
"\n"
"# Install the opener.\n"
"# Now all calls to urllib.request.urlopen use our opener.\n"
"urllib.request.install_opener(opener)"
msgstr ""
"# 创建一个密码管理器\n"
"password_mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm()\n"
"\n"
"# 添加用户名和密码。\n"
"# 如果我们知道域，可以用它代替 None。\n"
"top_level_url = \"http://example.com/foo/\"\n"
"password_mgr.add_password(None, top_level_url, username, password)\n"
"\n"
"handler = urllib.request.HTTPBasicAuthHandler(password_mgr)\n"
"\n"
"# 创建 \"opener\" (OpenerDirector 实例)\n"
"opener = urllib.request.build_opener(handler)\n"
"\n"
"# 使用 opener 获取一个 URL\n"
"opener.open(a_url)\n"
"\n"
"# 安装 opener。\n"
"# 现在所有对 urllib.request.urlopen 的调用都将使用此 opener。\n"
"urllib.request.install_opener(opener)"

#: ../../howto/urllib2.rst:460
msgid ""
"In the above example we only supplied our ``HTTPBasicAuthHandler`` to "
"``build_opener``. By default openers have the handlers for normal situations"
" -- ``ProxyHandler`` (if a proxy setting such as an :envvar:`!http_proxy` "
"environment variable is set), ``UnknownHandler``, ``HTTPHandler``, "
"``HTTPDefaultErrorHandler``, ``HTTPRedirectHandler``, ``FTPHandler``, "
"``FileHandler``, ``DataHandler``, ``HTTPErrorProcessor``."
msgstr ""
"在上面的救命中我们只向 ``build_opener`` 提供了 ``HTTPBasicAuthHandler``。 在默认情况下 opener "
"会包含针对常见状况的处理器 -- ``ProxyHandler`` (如果设置了代理如设置了 :envvar:`!http_proxy` "
"环境变量)，``UnknownHandler``, ``HTTPHandler``, ``HTTPDefaultErrorHandler``, "
"``HTTPRedirectHandler``, ``FTPHandler``, ``FileHandler``, ``DataHandler``, "
"``HTTPErrorProcessor``。"

#: ../../howto/urllib2.rst:467
msgid ""
"``top_level_url`` is in fact *either* a full URL (including the 'http:' "
"scheme component and the hostname and optionally the port number) e.g. "
"``\"http://example.com/\"`` *or* an \"authority\" (i.e. the hostname, "
"optionally including the port number) e.g. ``\"example.com\"`` or "
"``\"example.com:8080\"`` (the latter example includes a port number).  The "
"authority, if present, must NOT contain the \"userinfo\" component - for "
"example ``\"joe:password@example.com\"`` is not correct."
msgstr ""
"``top_level_url`` 其实 *要么* 是一条完整的 URL（包括 “http:” 部分和主机名及可选的端口号），比如 "
"``\"http://example.com/\"`` ， *要么* 是一条“访问权限”（即主机名，及可选的端口号），比如 "
"``\"example.com\"`` 或 ``\"example.com:8080\"`` （后一个示例包含了端口号）。访问权限 **不得** "
"包含“用户信息”部分——比如 ``\"joe:password@example.com\"`` 就不正确。"

#: ../../howto/urllib2.rst:477
msgid "Proxies"
msgstr "代理"

#: ../../howto/urllib2.rst:479
msgid ""
"**urllib** will auto-detect your proxy settings and use those. This is "
"through the ``ProxyHandler``, which is part of the normal handler chain when"
" a proxy setting is detected.  Normally that's a good thing, but there are "
"occasions when it may not be helpful [#]_. One way to do this is to setup "
"our own ``ProxyHandler``, with no proxies defined. This is done using "
"similar steps to setting up a `Basic Authentication`_ handler: ::"
msgstr ""
"**urllib** 将自动检测并使用代理设置。 这是通过 ``ProxyHandler`` 实现的，当检测到代理设置时，是正常 handler "
"链中的一部分。通常这是一件好事，但有时也可能会无效 [#]_。 一种方案是配置自己的 ``ProxyHandler`` ，不要定义代理。 设置的步骤与 "
"`Basic Authentication`_ handler 类似: ::"

#: ../../howto/urllib2.rst:486
msgid ""
">>> proxy_support = urllib.request.ProxyHandler({})\n"
">>> opener = urllib.request.build_opener(proxy_support)\n"
">>> urllib.request.install_opener(opener)"
msgstr ""
">>> proxy_support = urllib.request.ProxyHandler({})\n"
">>> opener = urllib.request.build_opener(proxy_support)\n"
">>> urllib.request.install_opener(opener)"

#: ../../howto/urllib2.rst:492
msgid ""
"Currently ``urllib.request`` *does not* support fetching of ``https`` "
"locations through a proxy.  However, this can be enabled by extending "
"urllib.request as shown in the recipe [#]_."
msgstr ""
"目前 ``urllib.request`` *尚不* 支持通过代理抓取 ``https`` 链接地址。 但此功能可以通过扩展 "
"urllib.request 来启用，如以下例程所示 [#]_。"

#: ../../howto/urllib2.rst:498
msgid ""
"``HTTP_PROXY`` will be ignored if a variable ``REQUEST_METHOD`` is set; see "
"the documentation on :func:`~urllib.request.getproxies`."
msgstr ""
"如果设置了 ``REQUEST_METHOD`` 变量，则会忽略 ``HTTP_PROXY`` ；参阅 "
":func:`~urllib.request.getproxies` 文档。"

#: ../../howto/urllib2.rst:503
msgid "Sockets and Layers"
msgstr "套接字与分层"

#: ../../howto/urllib2.rst:505
msgid ""
"The Python support for fetching resources from the web is layered.  urllib "
"uses the :mod:`http.client` library, which in turn uses the socket library."
msgstr "Python 获取 Web 资源的能力是分层的。urllib 用到的是 :mod:`http.client` 库，而后者又用到了套接字库。"

#: ../../howto/urllib2.rst:508
msgid ""
"As of Python 2.3 you can specify how long a socket should wait for a "
"response before timing out. This can be useful in applications which have to"
" fetch web pages. By default the socket module has *no timeout* and can "
"hang. Currently, the socket timeout is not exposed at the http.client or "
"urllib.request levels. However, you can set the default timeout globally for"
" all sockets using ::"
msgstr ""
"从 Python 2.3 开始，可以指定套接字等待响应的超时时间。这对必须要读到网页数据的应用程序会很有用。默认情况下，套接字模块 *不会超时* "
"并且可以挂起。目前，套接字超时机制未暴露给 http.client 或 urllib.request "
"层使用。不过可以为所有套接字应用设置默认的全局超时。"

#: ../../howto/urllib2.rst:514
msgid ""
"import socket\n"
"import urllib.request\n"
"\n"
"# timeout in seconds\n"
"timeout = 10\n"
"socket.setdefaulttimeout(timeout)\n"
"\n"
"# this call to urllib.request.urlopen now uses the default timeout\n"
"# we have set in the socket module\n"
"req = urllib.request.Request('http://www.voidspace.org.uk')\n"
"response = urllib.request.urlopen(req)"
msgstr ""
"import socket\n"
"import urllib.request\n"
"\n"
"# 超时秒数\n"
"timeout = 10\n"
"socket.setdefaulttimeout(timeout)\n"
"\n"
"# 这个对 urllib.request.urlopen 的调用现在将使用\n"
"# 我们在 socket 模块中设置的默认超时值\n"
"req = urllib.request.Request('http://www.voidspace.org.uk')\n"
"response = urllib.request.urlopen(req)"

#: ../../howto/urllib2.rst:531
msgid "Footnotes"
msgstr "备注"

#: ../../howto/urllib2.rst:533
msgid "This document was reviewed and revised by John Lee."
msgstr "这篇文档由 John Lee 审订。"

#: ../../howto/urllib2.rst:535
msgid "Google for example."
msgstr "例如 Google。"

#: ../../howto/urllib2.rst:536
msgid ""
"Browser sniffing is a very bad practice for website design - building sites "
"using web standards is much more sensible. Unfortunately a lot of sites "
"still send different versions to different browsers."
msgstr ""
"对于网站设计而言，探测不同的浏览器是非常糟糕的做法——更为明智的做法是采用 web "
"标准构建网站。不幸的是，很多网站依然向不同的浏览器发送不同版本的网页。"

#: ../../howto/urllib2.rst:539
msgid ""
"The user agent for MSIE 6 is *'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT"
" 5.1; SV1; .NET CLR 1.1.4322)'*"
msgstr ""
"MSIE 6 的 user-agent 信息是 *“Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;"
" SV1; .NET CLR 1.1.4322)”*"

#: ../../howto/urllib2.rst:541
msgid ""
"For details of more HTTP request headers, see `Quick Reference to HTTP "
"Headers`_."
msgstr "有关 HTTP 请求的头部信息，详情请参阅 `Quick Reference to HTTP Headers`_。"

#: ../../howto/urllib2.rst:543
msgid ""
"In my case I have to use a proxy to access the internet at work. If you "
"attempt to fetch *localhost* URLs through this proxy it blocks them. IE is "
"set to use the proxy, which urllib picks up on. In order to test scripts "
"with a localhost server, I have to prevent urllib from using the proxy."
msgstr ""
"本人必须使用代理才能在工作中访问互联网。如果尝试通过代理获取 *localhost* URL，将会遭到阻止。IE 设置为代理模式，urllib "
"就会获取到配置信息。为了用 localhost 服务器测试脚本，我必须阻止 urllib 使用代理。"

#: ../../howto/urllib2.rst:548
msgid ""
"urllib opener for SSL proxy (CONNECT method): `ASPN Cookbook Recipe "
"<https://code.activestate.com/recipes/456195-urrlib2-opener-for-ssl-proxy-"
"connect-method/>`_."
msgstr ""
"urllib 的 SSL 代理 opener (CONNECT 方法): `ASPN Cookbook Recipe "
"<https://code.activestate.com/recipes/456195-urrlib2-opener-for-ssl-proxy-"
"connect-method/>`_。"
