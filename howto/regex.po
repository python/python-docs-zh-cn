# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-06-20 14:58+0000\n"
"PO-Revision-Date: 2025-05-08 05:09+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/regex.rst:5
msgid "Regular Expression HOWTO"
msgstr "正则表达式指南"

#: ../../howto/regex.rst:0
msgid "Author"
msgstr "作者"

#: ../../howto/regex.rst:7
msgid "A.M. Kuchling <amk@amk.ca>"
msgstr "A.M. Kuchling <amk@amk.ca>"

#: ../../howto/regex.rst-1
msgid "Abstract"
msgstr "摘要"

#: ../../howto/regex.rst:18
msgid ""
"This document is an introductory tutorial to using regular expressions in "
"Python with the :mod:`re` module.  It provides a gentler introduction than "
"the corresponding section in the Library Reference."
msgstr "本文是关于在 Python 中通过 :mod:`re` 模块使用正则表达式的入门教程。它提供了比“标准库参考”的相关章节更平易的介绍。"

#: ../../howto/regex.rst:24
msgid "Introduction"
msgstr "引言"

#: ../../howto/regex.rst:26
msgid ""
"Regular expressions (called REs, or regexes, or regex patterns) are "
"essentially a tiny, highly specialized programming language embedded inside "
"Python and made available through the :mod:`re` module. Using this little "
"language, you specify the rules for the set of possible strings that you "
"want to match; this set might contain English sentences, or e-mail "
"addresses, or TeX commands, or anything you like.  You can then ask "
"questions such as \"Does this string match the pattern?\", or \"Is there a "
"match for the pattern anywhere in this string?\".  You can also use REs to "
"modify a string or to split it apart in various ways."
msgstr ""
"正则表达式（Regular expressions，也叫 REs、 regexs 或 regex patterns），本质上是嵌入 Python "
"内部并通过 :mod:`re` "
"模块提供的一种微小的、高度专业化的编程语言。使用这种小语言，你可以为想要匹配的可能字符串编写规则；这些字符串可能是英文句子、邮箱地址、TeX "
"命令或任何你喜欢的内容。然后，你可以提出诸如“此字符串是否与表达式匹配？”、“字符串中是否存在表达式的匹配项？”之类的问题。你还可以用正则来修改字符串，或以各种方式将其拆分。"

#: ../../howto/regex.rst:35
msgid ""
"Regular expression patterns are compiled into a series of bytecodes which "
"are then executed by a matching engine written in C.  For advanced use, it "
"may be necessary to pay careful attention to how the engine will execute a "
"given RE, and write the RE in a certain way in order to produce bytecode "
"that runs faster. Optimization isn't covered in this document, because it "
"requires that you have a good understanding of the matching engine's "
"internals."
msgstr ""
"正则表达式会被编译成一系列字节码，然后由 C "
"语言编写的匹配引擎执行。对于高级用途，可能有必要特别注意引擎将如何执行一个给定的正则，并以某种方式写入正则，以生成运行更快的字节码。本文不涉及优化问题，因为这要求你对正则引擎的匹配过程有很好的了解。"

#: ../../howto/regex.rst:42
msgid ""
"The regular expression language is relatively small and restricted, so not "
"all possible string processing tasks can be done using regular expressions."
"  There are also tasks that *can* be done with regular expressions, but the "
"expressions turn out to be very complicated.  In these cases, you may be "
"better off writing Python code to do the processing; while Python code will "
"be slower than an elaborate regular expression, it will also probably be "
"more understandable."
msgstr ""
"正则表达式语言相对较小且受限，因此并非所有可能的字符串处理任务都可以使用正则表达式完成。有些任务尽管 *可以* "
"用正则表达式来完成，但表达式会变得非常复杂。 这些情况下，最好通过编写 Python 代码来进行处理。 也许 Python "
"代码会比精心设计的正则表达式慢，但它可能更容易理解。"

#: ../../howto/regex.rst:51
msgid "Simple Patterns"
msgstr "简单正则"

#: ../../howto/regex.rst:53
msgid ""
"We'll start by learning about the simplest possible regular expressions.  "
"Since regular expressions are used to operate on strings, we'll begin with "
"the most common task: matching characters."
msgstr "让我们从最简单的正则表达式开始吧。由于正则表达式是用来操作字符串的，我们将从最常见的任务开始：匹配字符。"

#: ../../howto/regex.rst:57
msgid ""
"For a detailed explanation of the computer science underlying regular "
"expressions (deterministic and non-deterministic finite automata), you can "
"refer to almost any textbook on writing compilers."
msgstr "关于正则表达式背后的计算机科学的详细解释（确定性和非确定性有限自动机），你可以参考几乎所有关于编写编译器的教科书。"

#: ../../howto/regex.rst:63
msgid "Matching Characters"
msgstr "匹配字符"

#: ../../howto/regex.rst:65
msgid ""
"Most letters and characters will simply match themselves.  For example, the "
"regular expression ``test`` will match the string ``test`` exactly.  (You "
"can enable a case-insensitive mode that would let this RE match ``Test`` or "
"``TEST`` as well; more about this later.)"
msgstr ""
"大多数字母和符号都会简单地匹配自身。例如，正则表达式 ``test`` 将会精确地匹配到 ``test`` "
"。（你可以启用不区分大小写模式，让这个正则也匹配 ``Test`` 或 ``TEST`` ，稍后会详细介绍。）"

#: ../../howto/regex.rst:70
msgid ""
"There are exceptions to this rule; some characters are special "
":dfn:`metacharacters`, and don't match themselves.  Instead, they signal "
"that some out-of-the-ordinary thing should be matched, or they affect other "
"portions of the RE by repeating them or changing their meaning.  Much of "
"this document is devoted to discussing various metacharacters and what they "
"do."
msgstr ""
"但该规则有例外。有些字符是特殊的 "
":dfn:`元字符（metacharacters）`，并不匹配自身。事实上，它们表示匹配一些非常规的内容，或者通过重复它们或改变它们的含义来影响正则的其他部分。本文的大部分内容都致力于讨论各种元字符及其作用。"

#: ../../howto/regex.rst:76
msgid ""
"Here's a complete list of the metacharacters; their meanings will be "
"discussed in the rest of this HOWTO."
msgstr "这是元字符的完整列表。它们的含义将在本 HOWTO 的其余部分进行讨论。"

#: ../../howto/regex.rst:79
msgid ". ^ $ * + ? { } [ ] \\ | ( )"
msgstr ". ^ $ * + ? { } [ ] \\ | ( )"

#: ../../howto/regex.rst:83
msgid ""
"The first metacharacters we'll look at are ``[`` and ``]``. They're used for"
" specifying a character class, which is a set of characters that you wish to"
" match.  Characters can be listed individually, or a range of characters can"
" be indicated by giving two characters and separating them by a ``'-'``.  "
"For example, ``[abc]`` will match any of the characters ``a``, ``b``, or "
"``c``; this is the same as ``[a-c]``, which uses a range to express the same"
" set of characters.  If you wanted to match only lowercase letters, your RE "
"would be ``[a-z]``."
msgstr ""
"首先介绍的元字符是 ``[`` 和 ``]`` "
"。这两个元字符用于指定一个字符类，也就是你希望匹配的字符的一个集合。这些字符可以单独地列出，也可以用字符范围来表示（给出两个字符并用 ``'-'`` "
"分隔）。例如，``[abc]`` 将匹配 ``a``、``b``、``c`` 之中的任意一个字符；这与 ``[a-c]`` "
"相同，后者使用一个范围来表达相同的字符集合。如果只想匹配小写字母，则正则表达式将是 ``[a-z]`` 。"

#: ../../howto/regex.rst:92
msgid ""
"Metacharacters (except ``\\``) are not active inside classes.  For example, "
"``[akm$]`` will match any of the characters ``'a'``, ``'k'``, ``'m'``, or "
"``'$'``; ``'$'`` is usually a metacharacter, but inside a character class "
"it's stripped of its special nature."
msgstr ""
"元字符 (除了 ``\\``) 在字符类中是不起作用的。 例如，``[akm$]`` 将会匹配以下任一字符 ``'a'``, ``'k'``, "
"``'m'`` 或 ``'$'``；``'$'`` 通常是一个元字符，但在一个字符类中它的特殊性被消除了。"

#: ../../howto/regex.rst:97
msgid ""
"You can match the characters not listed within the class by "
":dfn:`complementing` the set.  This is indicated by including a ``'^'`` as "
"the first character of the class. For example, ``[^5]`` will match any "
"character except ``'5'``.  If the caret appears elsewhere in a character "
"class, it does not have special meaning. For example: ``[5^]`` will match "
"either a ``'5'`` or a ``'^'``."
msgstr ""
"你可以通过对集合 :dfn:`取反` 来匹配字符类中未列出的字符。方法是把 ``'^'`` 放在字符类的最开头。 例如，``[^5]`` 将匹配除 "
"``'5'`` 之外的任何字符。 如果插入符出现在字符类的其他位置，则它没有特殊含义。 例如：``[5^]`` 将匹配 ``'5'`` 或 "
"``'^'``。"

#: ../../howto/regex.rst:103
msgid ""
"Perhaps the most important metacharacter is the backslash, ``\\``.   As in "
"Python string literals, the backslash can be followed by various characters "
"to signal various special sequences.  It's also used to escape all the "
"metacharacters so you can still match them in patterns; for example, if you "
"need to match a ``[`` or  ``\\``, you can precede them with a backslash to "
"remove their special meaning: ``\\[`` or ``\\\\``."
msgstr ""
"也许最重要的元字符是反斜杠，``\\`` 。 与 Python "
"字符串字面量一样，反斜杠后面可以跟各种字符来表示各种特殊序列。它还用于转义元字符，以便可以在表达式中匹配元字符本身。例如，如果需要匹配一个 ``[`` "
"或 ``\\`` ，可以在其前面加上一个反斜杠来消除它们的特殊含义：``\\[`` 或 ``\\\\`` 。"

#: ../../howto/regex.rst:110
msgid ""
"Some of the special sequences beginning with ``'\\'`` represent predefined "
"sets of characters that are often useful, such as the set of digits, the set"
" of letters, or the set of anything that isn't whitespace."
msgstr "一些以 ``'\\'`` 开头的特殊序列表示预定义的字符集合，这些字符集通常很有用，例如数字集合、字母集合或非空白字符集合。"

#: ../../howto/regex.rst:115
msgid ""
"Let's take an example: ``\\w`` matches any alphanumeric character.  If the "
"regex pattern is expressed in bytes, this is equivalent to the class "
"``[a-zA-Z0-9_]``.  If the regex pattern is a string, ``\\w`` will match all "
"the characters marked as letters in the Unicode database provided by the "
":mod:`unicodedata` module.  You can use the more restricted definition of "
"``\\w`` in a string pattern by supplying the :const:`re.ASCII` flag when "
"compiling the regular expression."
msgstr ""
"让我们举一个例子：``\\w`` 匹配任何字母数字字符。 如果正则表达式以 bytes 类型表示，``\\w`` 相当于字符类 "
"``[a-zA-Z0-9_]`` 。如果正则表达式是 str 类型，``\\w`` 将匹配由 :mod:`unicodedata` 模块提供的 "
"Unicode 数据库中标记为字母的所有字符。 通过在编译正则表达式时提供 :const:`re.ASCII` 标志，可以在 str "
"表达式中使用较为狭窄的 ``\\w`` 定义。"

#: ../../howto/regex.rst:123
msgid ""
"The following list of special sequences isn't complete. For a complete list "
"of sequences and expanded class definitions for Unicode string patterns, see"
" the last part of :ref:`Regular Expression Syntax <re-syntax>` in the "
"Standard Library reference.  In general, the Unicode versions match any "
"character that's in the appropriate category in the Unicode database."
msgstr ""
"以下为特殊序列的不完全列表。 有关 Unicode 字符串正则表达式的序列和扩展类定义的完整列表，参见标准库参考中 :ref:`正则表达式语法 <re-"
"syntax>`  的最后一部分 。通常，Unicode 版本的字符类会匹配 Unicode 数据库的相应类别中的任何字符。"

#: ../../howto/regex.rst:130
msgid "``\\d``"
msgstr "``\\d``"

#: ../../howto/regex.rst:131
msgid "Matches any decimal digit; this is equivalent to the class ``[0-9]``."
msgstr "匹配任何十进制数字，等价于字符类 ``[0-9]`` 。"

#: ../../howto/regex.rst:133
msgid "``\\D``"
msgstr "``\\D``"

#: ../../howto/regex.rst:134
msgid ""
"Matches any non-digit character; this is equivalent to the class ``[^0-9]``."
msgstr "匹配任何非数字字符，等价于字符类 ``[^0-9]`` 。"

#: ../../howto/regex.rst:136
msgid "``\\s``"
msgstr "``\\s``"

#: ../../howto/regex.rst:137
msgid ""
"Matches any whitespace character; this is equivalent to the class ``[ "
"\\t\\n\\r\\f\\v]``."
msgstr "匹配任何空白字符，等价于字符类 ``[ \\t\\n\\r\\f\\v]`` 。"

#: ../../howto/regex.rst:140
msgid "``\\S``"
msgstr "``\\S``"

#: ../../howto/regex.rst:141
msgid ""
"Matches any non-whitespace character; this is equivalent to the class ``[^ "
"\\t\\n\\r\\f\\v]``."
msgstr "匹配任何非空白字符，等价于字符类 ``[^ \\t\\n\\r\\f\\v]`` 。"

#: ../../howto/regex.rst:144
msgid "``\\w``"
msgstr "``\\w``"

#: ../../howto/regex.rst:145
msgid ""
"Matches any alphanumeric character; this is equivalent to the class "
"``[a-zA-Z0-9_]``."
msgstr "匹配任何字母与数字字符，等价于字符类 ``[a-zA-Z0-9_]`` 。"

#: ../../howto/regex.rst:148
msgid "``\\W``"
msgstr "``\\W``"

#: ../../howto/regex.rst:149
msgid ""
"Matches any non-alphanumeric character; this is equivalent to the class "
"``[^a-zA-Z0-9_]``."
msgstr "匹配任何非字母与数字字符，等价于字符类 ``[^a-zA-Z0-9_]`` 。"

#: ../../howto/regex.rst:152
msgid ""
"These sequences can be included inside a character class.  For example, "
"``[\\s,.]`` is a character class that will match any whitespace character, "
"or ``','`` or ``'.'``."
msgstr "这些序列可以包含在字符类中。 例如，``[\\s,.]`` 是一个匹配任何空白字符、``','`` 或 ``'.'`` 的字符类。"

#: ../../howto/regex.rst:156
msgid ""
"The final metacharacter in this section is ``.``.  It matches anything "
"except a newline character, and there's an alternate mode "
"(:const:`re.DOTALL`) where it will match even a newline.  ``.`` is often "
"used where you want to match \"any character\"."
msgstr ""
"本节的最后一个元字符是 ``.`` 。 它匹配除换行符之外的任何字符，并且有一个可选模式（ :const:`re.DOTALL` "
"），在该模式下它甚至可以匹配换行符。 ``.`` 通常用于你想匹配“任何字符”的场景。"

#: ../../howto/regex.rst:163
msgid "Repeating Things"
msgstr "重复"

#: ../../howto/regex.rst:165
msgid ""
"Being able to match varying sets of characters is the first thing regular "
"expressions can do that isn't already possible with the methods available on"
" strings.  However, if that was the only additional capability of regexes, "
"they wouldn't be much of an advance. Another capability is that you can "
"specify that portions of the RE must be repeated a certain number of times."
msgstr ""
"能够匹配各种各样的字符集合是正则表达式可以做到的第一件事，而这是字符串方法所不能做到的。但是，如果正则表达式就只有这么一个附加功能，它很难说的上有多大优势。另一个功能是，你可以指定正则的某部分必须重复一定的次数。"

#: ../../howto/regex.rst:171
msgid ""
"The first metacharacter for repeating things that we'll look at is ``*``.  "
"``*`` doesn't match the literal character ``'*'``; instead, it specifies "
"that the previous character can be matched zero or more times, instead of "
"exactly once."
msgstr ""
"我们先来说说重复元字符 ``*`` 。 ``*`` 并不是匹配一个字面字符  ``'*'`` "
"。实际上，它指定前一个字符可以匹配零次或更多次，而不是只匹配一次。"

#: ../../howto/regex.rst:175
msgid ""
"For example, ``ca*t`` will match ``'ct'`` (0 ``'a'`` characters), ``'cat'`` "
"(1 ``'a'``), ``'caaat'`` (3 ``'a'`` characters), and so forth."
msgstr ""
"例如，``ca*t`` 将匹配 ``'ct'`` （ 0 个 ``'a'`` ）、``'cat'`` （ 1 个 ``'a'`` ）、 "
"``'caaat'`` （ 3 个 ``'a'`` ）等等。"

#: ../../howto/regex.rst:178
msgid ""
"Repetitions such as ``*`` are :dfn:`greedy`; when repeating a RE, the "
"matching engine will try to repeat it as many times as possible. If later "
"portions of the pattern don't match, the matching engine will then back up "
"and try again with fewer repetitions."
msgstr ""
"类似 ``*`` 这样的重复是 :dfn:`贪婪的` 。当重复正则时，匹配引擎将尝试重复尽可能多的次数。 "
"如果表达式的后续部分不匹配，则匹配引擎将回退并以较少的重复次数再次尝试。"

#: ../../howto/regex.rst:183
msgid ""
"A step-by-step example will make this more obvious.  Let's consider the "
"expression ``a[bcd]*b``.  This matches the letter ``'a'``, zero or more "
"letters from the class ``[bcd]``, and finally ends with a ``'b'``.  Now "
"imagine matching this RE against the string ``'abcbd'``."
msgstr ""
"通过一个逐步示例更容易理解这一点。让我们分析一下表达式 ``a[bcd]*b`` 。 该表达式首先匹配一个字母 ``'a'`` ，接着匹配字符类 "
"``[bcd]`` 中的零个或更多个字母，最后以一个 ``'b'`` 结尾。 现在想象一下用这个正则来匹配字符串 ``'abcbd'`` 。"

#: ../../howto/regex.rst:189
msgid "Step"
msgstr "步骤"

#: ../../howto/regex.rst:189
msgid "Matched"
msgstr "匹配"

#: ../../howto/regex.rst:189
msgid "Explanation"
msgstr "说明"

#: ../../howto/regex.rst:191
msgid "1"
msgstr "1"

#: ../../howto/regex.rst:191
msgid "``a``"
msgstr "``a``"

#: ../../howto/regex.rst:191
msgid "The ``a`` in the RE matches."
msgstr "正则中的 ``a`` 匹配成功。"

#: ../../howto/regex.rst:193
msgid "2"
msgstr "2"

#: ../../howto/regex.rst:193
msgid "``abcbd``"
msgstr "``abcbd``"

#: ../../howto/regex.rst:193
msgid ""
"The engine matches ``[bcd]*``, going as far as it can, which is to the end "
"of the string."
msgstr "引擎尽可能多地匹配 ``[bcd]*`` ，直至字符串末尾。"

#: ../../howto/regex.rst:197
msgid "3"
msgstr "3"

#: ../../howto/regex.rst:197 ../../howto/regex.rst:205
msgid "*Failure*"
msgstr "*失败*"

#: ../../howto/regex.rst:197
msgid ""
"The engine tries to match ``b``, but the current position is at the end of "
"the string, so it fails."
msgstr "引擎尝试匹配 ``b`` ，但是当前位置位于字符串末尾，所以匹配失败。"

#: ../../howto/regex.rst:202
msgid "4"
msgstr "4"

#: ../../howto/regex.rst:202 ../../howto/regex.rst:213
msgid "``abcb``"
msgstr "``abcb``"

#: ../../howto/regex.rst:202
msgid "Back up, so that  ``[bcd]*`` matches one less character."
msgstr "回退，让 ``[bcd]*`` 少匹配一个字符。"

#: ../../howto/regex.rst:205
msgid "5"
msgstr "5"

#: ../../howto/regex.rst:205
msgid ""
"Try ``b`` again, but the current position is at the last character, which is"
" a ``'d'``."
msgstr "再次尝试匹配 ``b`` ， 但是当前位置上的字符是最后一个字符 ``'d'`` 。"

#: ../../howto/regex.rst:209 ../../howto/regex.rst:213
msgid "6"
msgstr "6"

#: ../../howto/regex.rst:209
msgid "``abc``"
msgstr "``abc``"

#: ../../howto/regex.rst:209
msgid "Back up again, so that ``[bcd]*`` is only matching ``bc``."
msgstr "再次回退，让 ``[bcd]*`` 只匹配 ``bc`` 。"

#: ../../howto/regex.rst:213
msgid ""
"Try ``b`` again.  This time the character at the current position is "
"``'b'``, so it succeeds."
msgstr "再次尝试匹配 ``b`` 。 这一次当前位置的字符是 ``'b'`` ，所以它成功了。"

#: ../../howto/regex.rst:219
msgid ""
"The end of the RE has now been reached, and it has matched ``'abcb'``.  This"
" demonstrates how the matching engine goes as far as it can at first, and if"
" no match is found it will then progressively back up and retry the rest of "
"the RE again and again.  It will back up until it has tried zero matches for"
" ``[bcd]*``, and if that subsequently fails, the engine will conclude that "
"the string doesn't match the RE at all."
msgstr ""
"此时正则表达式已经到达了尽头，并且匹配到了 ``'abcb'`` 。 "
"这个例子演示了匹配引擎一开始会尽其所能地进行匹配，如果没有找到匹配，它将逐步回退并重试正则的剩余部分，如此往复，直至 ``[bcd]*`` "
"只匹配零次。如果随后的匹配还是失败了，那么引擎会宣告整个正则表达式与字符串匹配失败。"

#: ../../howto/regex.rst:226
msgid ""
"Another repeating metacharacter is ``+``, which matches one or more times.  "
"Pay careful attention to the difference between ``*`` and ``+``; ``*`` "
"matches *zero* or more times, so whatever's being repeated may not be "
"present at all, while ``+`` requires at least *one* occurrence.  To use a "
"similar example, ``ca+t`` will match ``'cat'`` (1 ``'a'``), ``'caaat'`` (3 "
"``'a'``\\ s), but won't match ``'ct'``."
msgstr ""
"另一个重复元字符是 ``+`` ，表示匹配一次或更多次。请注意 ``*`` 与 ``+`` 之间的差别。 ``*`` 表示匹配 *零次* "
"或更多次，也就是说它所重复的内容是可以完全不出现的。而 ``+`` 则要求至少出现一次。举一个类似的例子， ``ca+t`` 可以匹配 "
"``'cat'`` （ 1 个 ``'a'`` ）或 ``'caaat'`` （ 3 个 ``'a'``），但不能匹配 ``'ct'`` 。"

#: ../../howto/regex.rst:233
msgid ""
"There are two more repeating operators or quantifiers.  The question mark "
"character, ``?``, matches either once or zero times; you can think of it as "
"marking something as being optional.  For example, ``home-?brew`` matches "
"either ``'homebrew'`` or ``'home-brew'``."
msgstr ""
"此外还有两个重复操作符或限定符。 问号 ``?`` 表示匹配一次或零次；你可以认为它把某项内容变成了可选的。 例如，``home-?brew`` "
"可以匹配 ``'homebrew'`` 或 ``'home-brew'``。"

#: ../../howto/regex.rst:238
msgid ""
"The most complicated quantifier is ``{m,n}``, where *m* and *n* are decimal "
"integers.  This quantifier means there must be at least *m* repetitions, and"
" at most *n*.  For example, ``a/{1,3}b`` will match ``'a/b'``, ``'a//b'``, "
"and ``'a///b'``.  It won't match ``'ab'``, which has no slashes, or "
"``'a////b'``, which has four."
msgstr ""
"最复杂的限定符是 ``{m,n}``，其中 *m* 和 *n* 都是十进制整数。 该限定符表示必须至少重复 *m* 次，至多重复 *n* 次。 "
"例如，``a/{1,3}b`` 将匹配 ``'a/b'``, ``'a//b'`` 和 ``'a///b'``。 它不能匹配 "
"``'ab'``，因为其中没有斜杠，也不能匹配 ``'a////b'``，因为其中有四个斜杠。"

#: ../../howto/regex.rst:244
msgid ""
"You can omit either *m* or *n*; in that case, a reasonable value is assumed "
"for the missing value.  Omitting *m* is interpreted as a lower limit of 0, "
"while omitting *n* results in an upper bound of infinity."
msgstr ""
"*m* 和 *n* 不是必填的，缺失的情况下会设定为默认值。缺失 *m* 会解释为最少重复 0 次 ，缺失 *n* 则解释为最多重复无限次。"

#: ../../howto/regex.rst:248
msgid ""
"The simplest case ``{m}`` matches the preceding item exactly *m* times. For "
"example, ``a/{2}b`` will only match ``'a//b'``."
msgstr "最简单情况 ``{m}`` 将与前一项完全匹配 *m* 次。 例如，``a/{2}b`` 将只匹配 ``'a//b'``。"

#: ../../howto/regex.rst:251
msgid ""
"Readers of a reductionist bent may notice that the three other quantifiers "
"can all be expressed using this notation.  ``{0,}`` is the same as ``*``, "
"``{1,}`` is equivalent to ``+``, and ``{0,1}`` is the same as ``?``.  It's "
"better to use ``*``, ``+``, or ``?`` when you can, simply because they're "
"shorter and easier to read."
msgstr ""
"细心的读者可能会注意到另外三个限定符都可以使用此标记法来表示。 ``{0,}`` 等同于 ``*``, ``{1,}`` 等同于 ``+``, 而 "
"``{0,1}`` 等同于 ``?``。 在可能的情况下使用 ``*``, ``+`` 或 ``?`` 会更好，因为它们更为简短易读。"

#: ../../howto/regex.rst:259
msgid "Using Regular Expressions"
msgstr "使用正则表达式"

#: ../../howto/regex.rst:261
msgid ""
"Now that we've looked at some simple regular expressions, how do we actually"
" use them in Python?  The :mod:`re` module provides an interface to the "
"regular expression engine, allowing you to compile REs into objects and then"
" perform matches with them."
msgstr ""
"现在我们已经了解了一些简单的正则表达式，那么我们如何在 Python 中实际使用它们呢？  :mod:`re` "
"模块提供了正则表达式引擎的接口，可以让你将正则编译为对象，然后用它们来进行匹配。"

#: ../../howto/regex.rst:268
msgid "Compiling Regular Expressions"
msgstr "编译正则表达式"

#: ../../howto/regex.rst:270
msgid ""
"Regular expressions are compiled into pattern objects, which have methods "
"for various operations such as searching for pattern matches or performing "
"string substitutions. ::"
msgstr "正则表达式被编译成模式对象，模式对象具有各种操作的方法，例如搜索模式匹配或执行字符串替换。::"

#: ../../howto/regex.rst:274
msgid ""
">>> import re\n"
">>> p = re.compile('ab*')\n"
">>> p\n"
"re.compile('ab*')"
msgstr ""
">>> import re\n"
">>> p = re.compile('ab*')\n"
">>> p\n"
"re.compile('ab*')"

#: ../../howto/regex.rst:279
msgid ""
":func:`re.compile` also accepts an optional *flags* argument, used to enable"
" various special features and syntax variations.  We'll go over the "
"available settings later, but for now a single example will do::"
msgstr ""
":func:`re.compile` 也接受一个可选的 *flags* 参数，用于启用各种特殊功能和语法变体。 "
"我们稍后将介绍可用的设置，但现在只需一个例子 ::"

#: ../../howto/regex.rst:283
msgid ">>> p = re.compile('ab*', re.IGNORECASE)"
msgstr ">>> p = re.compile('ab*', re.IGNORECASE)"

#: ../../howto/regex.rst:285
msgid ""
"The RE is passed to :func:`re.compile` as a string.  REs are handled as "
"strings because regular expressions aren't part of the core Python language,"
" and no special syntax was created for expressing them.  (There are "
"applications that don't need REs at all, so there's no need to bloat the "
"language specification by including them.) Instead, the :mod:`re` module is "
"simply a C extension module included with Python, just like the "
":mod:`socket` or :mod:`zlib` modules."
msgstr ""
"正则作为字符串传递给 :func:`re.compile` 。 "
"正则被处理为字符串，因为正则表达式不是核心Python语言的一部分，并且没有创建用于表达它们的特殊语法。 "
"（有些应用程序根本不需要正则，因此不需要通过包含它们来扩展语言规范。）相反，:mod:`re` 模块只是Python附带的C扩展模块，就类似于 "
":mod:`socket` 或 :mod:`zlib` 模块。"

#: ../../howto/regex.rst:292
msgid ""
"Putting REs in strings keeps the Python language simpler, but has one "
"disadvantage which is the topic of the next section."
msgstr "将正则放在字符串中可以使 Python 语言更简单，但有一个缺点是下一节的主题。"

#: ../../howto/regex.rst:299
msgid "The Backslash Plague"
msgstr "反斜杠灾难"

#: ../../howto/regex.rst:301
msgid ""
"As stated earlier, regular expressions use the backslash character "
"(``'\\'``) to indicate special forms or to allow special characters to be "
"used without invoking their special meaning. This conflicts with Python's "
"usage of the same character for the same purpose in string literals."
msgstr ""
"如前所述，正则表达式使用反斜杠字符 (``'\\'``) 来表示特殊形式或允许使用特殊字符而不调用它们的特殊含义。 这与 Python "
"在字符串文字中用于相同目的的相同字符的使用相冲突。"

#: ../../howto/regex.rst:306
msgid ""
"Let's say you want to write a RE that matches the string ``\\section``, "
"which might be found in a LaTeX file.  To figure out what to write in the "
"program code, start with the desired string to be matched.  Next, you must "
"escape any backslashes and other metacharacters by preceding them with a "
"backslash, resulting in the string ``\\\\section``.  The resulting string "
"that must be passed to :func:`re.compile` must be ``\\\\section``.  However,"
" to express this as a Python string literal, both backslashes must be "
"escaped *again*."
msgstr ""
"假设你想要编写一个与字符串 ``\\section`` 相匹配的正则，它可以在 LaTeX 文件中找到。 "
"要找出在程序代码中写入的内容，请从要匹配的字符串开始。 接下来，您必须通过在反斜杠前面添加反斜杠和其他元字符，从而产生字符串 "
"``\\\\section``。 必须传递给 :func:`re.compile` 的结果字符串必须是 ``\\\\section``。 "
"但是，要将其表示为 Python 字符串文字，必须 *再次* 转义两个反斜杠。"

#: ../../howto/regex.rst:315
msgid "Characters"
msgstr "字符"

#: ../../howto/regex.rst:315
msgid "Stage"
msgstr "阶段"

#: ../../howto/regex.rst:317
msgid "``\\section``"
msgstr "``\\section``"

#: ../../howto/regex.rst:317
msgid "Text string to be matched"
msgstr "被匹配的字符串"

#: ../../howto/regex.rst:319
msgid "``\\\\section``"
msgstr "``\\\\section``"

#: ../../howto/regex.rst:319
msgid "Escaped backslash for :func:`re.compile`"
msgstr "为 :func:`re.compile` 转义的反斜杠"

#: ../../howto/regex.rst:321 ../../howto/regex.rst:348
msgid "``\"\\\\\\\\section\"``"
msgstr "``\"\\\\\\\\section\"``"

#: ../../howto/regex.rst:321
msgid "Escaped backslashes for a string literal"
msgstr "为字符串字面转义的反斜杠"

#: ../../howto/regex.rst:324
msgid ""
"In short, to match a literal backslash, one has to write ``'\\\\\\\\'`` as "
"the RE string, because the regular expression must be ``\\\\``, and each "
"backslash must be expressed as ``\\\\`` inside a regular Python string "
"literal.  In REs that feature backslashes repeatedly, this leads to lots of "
"repeated backslashes and makes the resulting strings difficult to "
"understand."
msgstr ""
"简而言之，要匹配文字反斜杠，必须将 ``'\\\\\\\\'`` 写为正则字符串，因为正则表达式必须是 ``\\\\``，并且每个反斜杠必须表示为 "
"``\\\\`` 在常规Python字符串字面中。 在反复使用反斜杠的正则中，这会导致大量重复的反斜杠，并使得生成的字符串难以理解。"

#: ../../howto/regex.rst:330
msgid ""
"The solution is to use Python's raw string notation for regular expressions;"
" backslashes are not handled in any special way in a string literal prefixed"
" with ``'r'``, so ``r\"\\n\"`` is a two-character string containing ``'\\'``"
" and ``'n'``, while ``\"\\n\"`` is a one-character string containing a "
"newline. Regular expressions will often be written in Python code using this"
" raw string notation."
msgstr ""
"解决方案是使用 Python 的原始字符串表示法来表示正则表达式；反斜杠不以任何特殊的方式处理前缀为 ``'r'`` 的字符串字面，因此 "
"``r\"\\n\"`` 是一个包含 ``'\\'`` 和 ``'n'`` 的双字符字符串，而 ``\"\\n\"`` 是一个包含换行符的单字符字符串。"
" 正则表达式通常使用这种原始字符串表示法用 Python 代码编写。"

#: ../../howto/regex.rst:336
msgid ""
"In addition, special escape sequences that are valid in regular expressions,"
" but not valid as Python string literals, now result in a "
":exc:`DeprecationWarning` and will eventually become a :exc:`SyntaxError`, "
"which means the sequences will be invalid if raw string notation or escaping"
" the backslashes isn't used."
msgstr ""
"此外，在正则表达式中有效但在 Python 字符串文字中无效的特殊转义序列现在导致 :exc:`DeprecationWarning` 并最终变为 "
":exc:`SyntaxError`。 这意味着如果未使用原始字符串表示法或转义反斜杠，序列将无效。"

#: ../../howto/regex.rst:344
msgid "Regular String"
msgstr "常规字符串"

#: ../../howto/regex.rst:344
msgid "Raw string"
msgstr "原始字符串"

#: ../../howto/regex.rst:346
msgid "``\"ab*\"``"
msgstr "``\"ab*\"``"

#: ../../howto/regex.rst:346
msgid "``r\"ab*\"``"
msgstr "``r\"ab*\"``"

#: ../../howto/regex.rst:348
msgid "``r\"\\\\section\"``"
msgstr "``r\"\\\\section\"``"

#: ../../howto/regex.rst:350
msgid "``\"\\\\w+\\\\s+\\\\1\"``"
msgstr "``\"\\\\w+\\\\s+\\\\1\"``"

#: ../../howto/regex.rst:350
msgid "``r\"\\w+\\s+\\1\"``"
msgstr "``r\"\\w+\\s+\\1\"``"

#: ../../howto/regex.rst:355
msgid "Performing Matches"
msgstr "应用匹配"

#: ../../howto/regex.rst:357
msgid ""
"Once you have an object representing a compiled regular expression, what do "
"you do with it?  Pattern objects have several methods and attributes. Only "
"the most significant ones will be covered here; consult the :mod:`re` docs "
"for a complete listing."
msgstr ""
"一旦你有一个表示编译正则表达式的对象，你用它做什么？ 模式对象有几种方法和属性。 这里只介绍最重要的内容；请参阅 :mod:`re` 文档获取完整列表。"

#: ../../howto/regex.rst:363 ../../howto/regex.rst:417
#: ../../howto/regex.rst:1069
msgid "Method/Attribute"
msgstr "方法 / 属性"

#: ../../howto/regex.rst:363 ../../howto/regex.rst:417
#: ../../howto/regex.rst:1069
msgid "Purpose"
msgstr "目的"

#: ../../howto/regex.rst:365
msgid "``match()``"
msgstr "``match()``"

#: ../../howto/regex.rst:365
msgid "Determine if the RE matches at the beginning of the string."
msgstr "确定正则是否从字符串的开头匹配。"

#: ../../howto/regex.rst:368
msgid "``search()``"
msgstr "``search()``"

#: ../../howto/regex.rst:368
msgid "Scan through a string, looking for any location where this RE matches."
msgstr "扫描字符串，查找此正则匹配的任何位置。"

#: ../../howto/regex.rst:371
msgid "``findall()``"
msgstr "``findall()``"

#: ../../howto/regex.rst:371
msgid "Find all substrings where the RE matches, and returns them as a list."
msgstr "找到正则匹配的所有子字符串，并将它们作为列表返回。"

#: ../../howto/regex.rst:374
msgid "``finditer()``"
msgstr "``finditer()``"

#: ../../howto/regex.rst:374
msgid ""
"Find all substrings where the RE matches, and returns them as an "
":term:`iterator`."
msgstr "找到正则匹配的所有子字符串，并将它们返回为一个 :term:`iterator`。"

#: ../../howto/regex.rst:378
msgid ""
":meth:`~re.Pattern.match` and :meth:`~re.Pattern.search` return ``None`` if "
"no match can be found.  If they're successful, a :ref:`match object <match-"
"objects>` instance is returned, containing information about the match: "
"where it starts and ends, the substring it matched, and more."
msgstr ""
"如果没有找到匹配， :meth:`~re.Pattern.match` 和 :meth:`~re.Pattern.search` 返回 ``None``"
" 。如果它们成功， 一个 :ref:`匹配对象 <match-objects>` 实例将被返回，包含匹配相关的信息：起始和终结位置、匹配的子串以及其它。"

#: ../../howto/regex.rst:383
msgid ""
"You can learn about this by interactively experimenting with the :mod:`re` "
"module."
msgstr "你可以通过交互式地试验 :mod:`re` 模块来学习这一点。"

#: ../../howto/regex.rst:386
msgid ""
"This HOWTO uses the standard Python interpreter for its examples. First, run"
" the Python interpreter, import the :mod:`re` module, and compile a RE::"
msgstr ""
"本 HOWTO 使用标准 Python 解释器作为示例。 首先，运行 Python 解释器，导入 :mod:`re` 模块，然后编译一个正则 ::"

#: ../../howto/regex.rst:389
msgid ""
">>> import re\n"
">>> p = re.compile('[a-z]+')\n"
">>> p\n"
"re.compile('[a-z]+')"
msgstr ""
">>> import re\n"
">>> p = re.compile('[a-z]+')\n"
">>> p\n"
"re.compile('[a-z]+')"

#: ../../howto/regex.rst:394
msgid ""
"Now, you can try matching various strings against the RE ``[a-z]+``.  An "
"empty string shouldn't match at all, since ``+`` means 'one or more "
"repetitions'. :meth:`~re.Pattern.match` should return ``None`` in this case,"
" which will cause the interpreter to print no output.  You can explicitly "
"print the result of :meth:`!match` to make this clear. ::"
msgstr ""
"现在，你可以尝试匹配正则 ``[a-z]+`` 的各种字符串。 空字符串根本不匹配，因为 ``+`` 表示“一次或多次重复”。 "
":meth:`~re.Pattern.match` 在这种情况下应返回 ``None``，这将导致解释器不打印输出。 你可以显式打印 "
":meth:`!match` 的结果，使其清晰。::"

#: ../../howto/regex.rst:400
msgid ""
">>> p.match(\"\")\n"
">>> print(p.match(\"\"))\n"
"None"
msgstr ""
">>> p.match(\"\")\n"
">>> print(p.match(\"\"))\n"
"None"

#: ../../howto/regex.rst:404
msgid ""
"Now, let's try it on a string that it should match, such as ``tempo``.  In "
"this case, :meth:`~re.Pattern.match` will return a :ref:`match object "
"<match-objects>`, so you should store the result in a variable for later "
"use. ::"
msgstr ""
"现在，让我们尝试一下它应该匹配的字符串，例如 ``tempo``。在这个例子中 :meth:`~re.Pattern.match` 将返回一个 "
":ref:`匹配对象 <match-objects>`，因此你应该将结果储存到一个变量中以供稍后使用。 ::"

#: ../../howto/regex.rst:408
msgid ""
">>> m = p.match('tempo')\n"
">>> m\n"
"<re.Match object; span=(0, 5), match='tempo'>"
msgstr ""
">>> m = p.match('tempo')\n"
">>> m\n"
"<re.Match object; span=(0, 5), match='tempo'>"

#: ../../howto/regex.rst:412
msgid ""
"Now you can query the :ref:`match object <match-objects>` for information "
"about the matching string.  Match object instances also have several methods"
" and attributes; the most important ones are:"
msgstr ""
"现在你可以检查 :ref:`匹配对象 <match-objects>` 以获取有关匹配字符串的信息。 匹配对象实例也有几个方法和属性；最重要的是："

#: ../../howto/regex.rst:419
msgid "``group()``"
msgstr "``group()``"

#: ../../howto/regex.rst:419
msgid "Return the string matched by the RE"
msgstr "返回正则匹配的字符串"

#: ../../howto/regex.rst:421
msgid "``start()``"
msgstr "``start()``"

#: ../../howto/regex.rst:421
msgid "Return the starting position of the match"
msgstr "返回匹配的开始位置"

#: ../../howto/regex.rst:423
msgid "``end()``"
msgstr "``end()``"

#: ../../howto/regex.rst:423
msgid "Return the ending position of the match"
msgstr "返回匹配的结束位置"

#: ../../howto/regex.rst:425
msgid "``span()``"
msgstr "``span()``"

#: ../../howto/regex.rst:425
msgid "Return a tuple containing the (start, end) positions  of the match"
msgstr "返回包含匹配 (start, end) 位置的元组"

#: ../../howto/regex.rst:429
msgid "Trying these methods will soon clarify their meaning::"
msgstr "尝试这些方法很快就会清楚它们的含义::"

#: ../../howto/regex.rst:431
msgid ""
">>> m.group()\n"
"'tempo'\n"
">>> m.start(), m.end()\n"
"(0, 5)\n"
">>> m.span()\n"
"(0, 5)"
msgstr ""
">>> m.group()\n"
"'tempo'\n"
">>> m.start(), m.end()\n"
"(0, 5)\n"
">>> m.span()\n"
"(0, 5)"

#: ../../howto/regex.rst:438
msgid ""
":meth:`~re.Match.group` returns the substring that was matched by the RE.  "
":meth:`~re.Match.start` and :meth:`~re.Match.end` return the starting and "
"ending index of the match. :meth:`~re.Match.span` returns both start and end"
" indexes in a single tuple.  Since the :meth:`~re.Pattern.match` method only"
" checks if the RE matches at the start of a string, :meth:`!start` will "
"always be zero.  However, the :meth:`~re.Pattern.search` method of patterns "
"scans through the string, so  the match may not start at zero in that case. "
"::"
msgstr ""
":meth:`~re.Match.group` 返回正则匹配的子字符串。 :meth:`~re.Match.start` 和 "
":meth:`~re.Match.end` 返回匹配的起始和结束索引。 :meth:`~re.Match.span` 在单个元组中返回开始和结束索引。 "
"由于 :meth:`~re.Pattern.match` 方法只检查正则是否在字符串的开头匹配，所以 :meth:`!start` 将始终为零。 "
"但是，模式的 :meth:`~re.Pattern.search` 方法会扫描字符串，因此在这种情况下匹配可能不会从零开始。::"

#: ../../howto/regex.rst:446
msgid ""
">>> print(p.match('::: message'))\n"
"None\n"
">>> m = p.search('::: message'); print(m)\n"
"<re.Match object; span=(4, 11), match='message'>\n"
">>> m.group()\n"
"'message'\n"
">>> m.span()\n"
"(4, 11)"
msgstr ""
">>> print(p.match('::: message'))\n"
"None\n"
">>> m = p.search('::: message'); print(m)\n"
"<re.Match object; span=(4, 11), match='message'>\n"
">>> m.group()\n"
"'message'\n"
">>> m.span()\n"
"(4, 11)"

#: ../../howto/regex.rst:455
msgid ""
"In actual programs, the most common style is to store the :ref:`match object"
" <match-objects>` in a variable, and then check if it was ``None``.  This "
"usually looks like::"
msgstr ""
"在实际程序中，最常见的样式是在变量中存储 :ref:`匹配对象 <match-objects>`，然后检查它是否为 ``None``。 "
"这通常看起来像::"

#: ../../howto/regex.rst:459
msgid ""
"p = re.compile( ... )\n"
"m = p.match( 'string goes here' )\n"
"if m:\n"
"    print('Match found: ', m.group())\n"
"else:\n"
"    print('No match')"
msgstr ""
"p = re.compile( ... )\n"
"m = p.match( 'string goes here' )\n"
"if m:\n"
"    print('Match found: ', m.group())\n"
"else:\n"
"    print('No match')"

#: ../../howto/regex.rst:466
msgid ""
"Two pattern methods return all of the matches for a pattern. "
":meth:`~re.Pattern.findall` returns a list of matching strings::"
msgstr "两种模式方法返回模式的所有匹配项。 :meth:`~re.Pattern.findall` 返回匹配字符串的列表::"

#: ../../howto/regex.rst:469
msgid ""
">>> p = re.compile(r'\\d+')\n"
">>> p.findall('12 drummers drumming, 11 pipers piping, 10 lords a-leaping')\n"
"['12', '11', '10']"
msgstr ""
">>> p = re.compile(r'\\d+')\n"
">>> p.findall('12 drummers drumming, 11 pipers piping, 10 lords a-leaping')\n"
"['12', '11', '10']"

#: ../../howto/regex.rst:473
msgid ""
"The ``r`` prefix, making the literal a raw string literal, is needed in this"
" example because escape sequences in a normal \"cooked\" string literal that"
" are not recognized by Python, as opposed to regular expressions, now result"
" in a :exc:`DeprecationWarning` and will eventually become a "
":exc:`SyntaxError`.  See :ref:`the-backslash-plague`."
msgstr ""
"在这个例子中需要 ``r`` 前缀，使字面为原始字符串字面，因为普通的“加工”字符串字面中的转义序列不能被 Python 识别为正则表达式，导致 "
":exc:`DeprecationWarning` 并最终产生 :exc:`SyntaxError`。 请参阅 :ref:`the-backslash-"
"plague`。"

#: ../../howto/regex.rst:479
msgid ""
":meth:`~re.Pattern.findall` has to create the entire list before it can be "
"returned as the result.  The :meth:`~re.Pattern.finditer` method returns a "
"sequence of :ref:`match object <match-objects>` instances as an "
":term:`iterator`::"
msgstr ""
":meth:`~re.Pattern.findall` 必须先创建整个列表才能返回结果。 :meth:`~re.Pattern.finditer` "
"方法将一个 :ref:`匹配对象 <match-objects>` 的序列返回为一个 :term:`iterator` ::"

#: ../../howto/regex.rst:483
msgid ""
">>> iterator = p.finditer('12 drummers drumming, 11 ... 10 ...')\n"
">>> iterator\n"
"<callable_iterator object at 0x...>\n"
">>> for match in iterator:\n"
"...     print(match.span())\n"
"...\n"
"(0, 2)\n"
"(22, 24)\n"
"(29, 31)"
msgstr ""
">>> iterator = p.finditer('12 drummers drumming, 11 ... 10 ...')\n"
">>> iterator\n"
"<callable_iterator object at 0x...>\n"
">>> for match in iterator:\n"
"...     print(match.span())\n"
"...\n"
"(0, 2)\n"
"(22, 24)\n"
"(29, 31)"

#: ../../howto/regex.rst:495
msgid "Module-Level Functions"
msgstr "模块级函数"

#: ../../howto/regex.rst:497
msgid ""
"You don't have to create a pattern object and call its methods; the "
":mod:`re` module also provides top-level functions called :func:`~re.match`,"
" :func:`~re.search`, :func:`~re.findall`, :func:`~re.sub`, and so forth.  "
"These functions take the same arguments as the corresponding pattern method "
"with the RE string added as the first argument, and still return either "
"``None`` or a :ref:`match object <match-objects>` instance. ::"
msgstr ""
"你不必创建模式对象并调用其方法；:mod:`re` 模块还提供了顶级函数 "
":func:`~re.match`，:func:`~re.search`，:func:`~re.findall`，:func:`~re.sub` 等等。"
" 这些函数采用与相应模式方法相同的参数，并将正则字符串作为第一个参数添加，并仍然返回 ``None`` 或  :ref:`匹配对象 <match-"
"objects>` 实例。::"

#: ../../howto/regex.rst:504
msgid ""
">>> print(re.match(r'From\\s+', 'Fromage amk'))\n"
"None\n"
">>> re.match(r'From\\s+', 'From amk Thu May 14 19:12:10 1998')\n"
"<re.Match object; span=(0, 5), match='From '>"
msgstr ""
">>> print(re.match(r'From\\s+', 'Fromage amk'))\n"
"None\n"
">>> re.match(r'From\\s+', 'From amk Thu May 14 19:12:10 1998')\n"
"<re.Match object; span=(0, 5), match='From '>"

#: ../../howto/regex.rst:509
msgid ""
"Under the hood, these functions simply create a pattern object for you and "
"call the appropriate method on it.  They also store the compiled object in a"
" cache, so future calls using the same RE won't need to parse the pattern "
"again and again."
msgstr ""
"本质上，这些函数只是为你创建一个模式对象，并在其上调用适当的方法。 它们还将编译对象存储在缓存中，因此使用相同的未来调用将不需要一次又一次地解析该模式。"

#: ../../howto/regex.rst:514
msgid ""
"Should you use these module-level functions, or should you get the pattern "
"and call its methods yourself?  If you're accessing a regex within a loop, "
"pre-compiling it will save a few function calls. Outside of loops, there's "
"not much difference thanks to the internal cache."
msgstr ""
"你是否应该使用这些模块级函数，还是应该自己获取模式并调用其方法？ 如果你正在循环中访问正则表达式，预编译它将节省一些函数调用。 "
"在循环之外，由于有内部缓存，没有太大区别。"

#: ../../howto/regex.rst:522
msgid "Compilation Flags"
msgstr "编译标志"

#: ../../howto/regex.rst:526
msgid ""
"Compilation flags let you modify some aspects of how regular expressions "
"work. Flags are available in the :mod:`re` module under two names, a long "
"name such as :const:`IGNORECASE` and a short, one-letter form such as "
":const:`I`.  (If you're familiar with Perl's pattern modifiers, the one-"
"letter forms use the same letters; the short form of :const:`re.VERBOSE` is "
":const:`re.X`, for example.) Multiple flags can be specified by bitwise OR-"
"ing them; ``re.I | re.M`` sets both the :const:`I` and :const:`M` flags, for"
" example."
msgstr ""
"编译标志允许你修改正则表达式的工作方式。 标志在 :mod:`re` 模块中有两个名称，长名称如 :const:`IGNORECASE` "
"和一个简短的单字母形式，例如 :const:`I`。 （如果你熟悉 Perl 的模式修饰符，则单字母形式使用和其相同的字母；例如， "
":const:`re.VERBOSE` 的缩写形式为 :const:`re.X`。）多个标志可以 通过按位或运算来指定它们；例如，``re.I | "
"re.M`` 设置 :const:`I` 和 :const:`M` 标志。"

#: ../../howto/regex.rst:534
msgid ""
"Here's a table of the available flags, followed by a more detailed "
"explanation of each one."
msgstr "这是一个可用标志表，以及每个标志的更详细说明。"

#: ../../howto/regex.rst:538
msgid "Flag"
msgstr "旗标"

#: ../../howto/regex.rst:538
msgid "Meaning"
msgstr "含意"

#: ../../howto/regex.rst:540
msgid ":const:`ASCII`, :const:`A`"
msgstr ":const:`ASCII`, :const:`A`"

#: ../../howto/regex.rst:540
msgid ""
"Makes several escapes like ``\\w``, ``\\b``, ``\\s`` and ``\\d`` match only "
"on ASCII characters with the respective property."
msgstr "使几个转义如 ``\\w``、``\\b``、``\\s`` 和 ``\\d`` 匹配仅与具有相应特征属性的 ASCII 字符匹配。"

#: ../../howto/regex.rst:544
msgid ":const:`DOTALL`, :const:`S`"
msgstr ":const:`DOTALL`, :const:`S`"

#: ../../howto/regex.rst:544
msgid "Make ``.`` match any character, including newlines."
msgstr "使 ``.`` 匹配任何字符，包括换行符。"

#: ../../howto/regex.rst:547
msgid ":const:`IGNORECASE`, :const:`I`"
msgstr ":const:`IGNORECASE`, :const:`I`"

#: ../../howto/regex.rst:547
msgid "Do case-insensitive matches."
msgstr "进行大小写不敏感匹配。"

#: ../../howto/regex.rst:549
msgid ":const:`LOCALE`, :const:`L`"
msgstr ":const:`LOCALE`, :const:`L`"

#: ../../howto/regex.rst:549
msgid "Do a locale-aware match."
msgstr "进行区域设置感知匹配。"

#: ../../howto/regex.rst:551
msgid ":const:`MULTILINE`, :const:`M`"
msgstr ":const:`MULTILINE`, :const:`M`"

#: ../../howto/regex.rst:551
msgid "Multi-line matching, affecting ``^`` and ``$``."
msgstr "多行匹配，影响 ``^`` 和 ``$``。"

#: ../../howto/regex.rst:554
msgid ":const:`VERBOSE`, :const:`X` (for 'extended')"
msgstr ":const:`VERBOSE`, :const:`X` （为 '扩展'）"

#: ../../howto/regex.rst:554
msgid ""
"Enable verbose REs, which can be organized more cleanly and understandably."
msgstr "启用详细的正则，可以更清晰，更容易理解。"

#: ../../howto/regex.rst:563
msgid ""
"Perform case-insensitive matching; character class and literal strings will "
"match letters by ignoring case.  For example, ``[A-Z]`` will match lowercase"
" letters, too. Full Unicode matching also works unless the :const:`ASCII` "
"flag is used to disable non-ASCII matches.  When the Unicode patterns "
"``[a-z]`` or ``[A-Z]`` are used in combination with the :const:`IGNORECASE` "
"flag, they will match the 52 ASCII letters and 4 additional non-ASCII "
"letters: 'İ' (U+0130, Latin capital letter I with dot above), 'ı' (U+0131, "
"Latin small letter dotless i), 'ſ' (U+017F, Latin small letter long s) and "
"'K' (U+212A, Kelvin sign).  ``Spam`` will match ``'Spam'``, ``'spam'``, "
"``'spAM'``, or ``'ſpam'`` (the latter is matched only in Unicode mode). This"
" lowercasing doesn't take the current locale into account; it will if you "
"also set the :const:`LOCALE` flag."
msgstr ""
"执行不区分大小写的匹配；字符类和字面字符串将通过忽略大小写来匹配字母。 例如，``[A-Z]`` 也匹配小写字母。 除非使用 "
":const:`ASCII` 标志来禁用非ASCII匹配，否则完全 Unicode 匹配也有效。 当 Unicode 模式 ``[a-z]`` 或 "
"``[A-Z]`` 与 :const:`IGNORECASE` 标志结合使用时，它们将匹配 52 个 ASCII 字母和 4 个额外的非 ASCII "
"字母：'İ' (U+0130，拉丁大写字母 I，带上面的点)，'ı' (U+0131，拉丁文小写字母无点 i)，'s' (U+017F，拉丁文小写字母长"
" s) 和'K' (U+212A，开尔文符号)。 ``Spam`` 将匹配 ``'Spam'``，``'spam'``，``'spAM'`` 或 "
"``'ſpam'`` (后者仅在 Unicode 模式下匹配)。 此小写不考虑当前区域设置；如果你还设置了 :const:`LOCALE` "
"标志，则将考虑。"

#: ../../howto/regex.rst:581
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B`` and case-insensitive matching "
"dependent on the current locale instead of the Unicode database."
msgstr "使 ``\\w``、``\\W``、``\\b``、``\\B`` 和大小写敏感匹配依赖于当前区域而不是 Unicode 数据库。"

#: ../../howto/regex.rst:584
msgid ""
"Locales are a feature of the C library intended to help in writing programs "
"that take account of language differences.  For example, if you're "
"processing encoded French text, you'd want to be able to write ``\\w+`` to "
"match words, but ``\\w`` only matches the character class ``[A-Za-z]`` in "
"bytes patterns; it won't match bytes corresponding to ``é`` or ``ç``. If "
"your system is configured properly and a French locale is selected, certain "
"C functions will tell the program that the byte corresponding to ``é`` "
"should also be considered a letter. Setting the :const:`LOCALE` flag when "
"compiling a regular expression will cause the resulting compiled object to "
"use these C functions for ``\\w``; this is slower, but also enables ``\\w+``"
" to match French words as you'd expect. The use of this flag is discouraged "
"in Python 3 as the locale mechanism is very unreliable, it only handles one "
"\"culture\" at a time, and it only works with 8-bit locales.  Unicode "
"matching is already enabled by default in Python 3 for Unicode (str) "
"patterns, and it is able to handle different locales/languages."
msgstr ""
"区域设置是 C 库的一个功能，旨在帮助编写考虑到语言差异的程序。例如，如果你正在处理编码的法语文本，那么你希望能够编写 ``\\w+`` 来匹配单词，但"
" ``\\w`` 只匹配字符类 ``[A-Za-z]`` 字节模式；它不会匹配对应于 ``é`` 或 ``ç`` "
"的字节。如果你的系统配置正确并且选择了法语区域设置，某些C函数将告诉程序对应于 ``é`` 的字节也应该被视为字母。在编译正则表达式时设置 "
":const:`LOCALE` 标志将导致生成的编译对象将这些C函数用于 ``\\w``；这比较慢，但也可以使 ``\\w+`` "
"匹配你所期望的法语单词。在 Python 3 中不鼓励使用此标志，因为语言环境机制非常不可靠，它一次只处理一个“文化”，它只适用于 8 "
"位语言环境。默认情况下，Python 3 中已经为 Unicode（str）模式启用了 Unicode 匹配，并且它能够处理不同的区域/语言。"

#: ../../howto/regex.rst:606
msgid ""
"(``^`` and ``$`` haven't been explained yet;  they'll be introduced in "
"section :ref:`more-metacharacters`.)"
msgstr "(``^`` 和 ``$`` 还没有解释；它们将在以下部分介绍 :ref:`more-metacharacters`。)"

#: ../../howto/regex.rst:609
msgid ""
"Usually ``^`` matches only at the beginning of the string, and ``$`` matches"
" only at the end of the string and immediately before the newline (if any) "
"at the end of the string. When this flag is specified, ``^`` matches at the "
"beginning of the string and at the beginning of each line within the string,"
" immediately following each newline.  Similarly, the ``$`` metacharacter "
"matches either at the end of the string and at the end of each line "
"(immediately preceding each newline)."
msgstr ""
"通常 ``^`` 只匹配字符串的开头，而 ``$`` 只匹配字符串的结尾，紧接在字符串末尾的换行符（如果有的话）之前。 当指定了这个标志时，``^`` "
"匹配字符串的开头和字符串中每一行的开头，紧跟在每个换行符之后。 类似地，``$`` 元字符匹配字符串的结尾和每行的结尾（紧接在每个换行符之前）。"

#: ../../howto/regex.rst:622
msgid ""
"Makes the ``'.'`` special character match any character at all, including a "
"newline; without this flag, ``'.'`` will match anything *except* a newline."
msgstr "使 ``'.'`` 特殊字符匹配任何字符，包括换行符；没有这个标志，``'.'`` 将匹配任何字符 *除了* 换行符。"

#: ../../howto/regex.rst:630
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\s`` and ``\\S`` perform ASCII-"
"only matching instead of full Unicode matching. This is only meaningful for "
"Unicode patterns, and is ignored for byte patterns."
msgstr ""
"使 ``\\w``、``\\W``、``\\b``、``\\B``、``\\s`` 和 ``\\S`` 执行仅 ASCII 匹配而不是完整匹配 "
"Unicode 匹配。 这仅对 Unicode 模式有意义，并且对于字节模式将被忽略。"

#: ../../howto/regex.rst:639
msgid ""
"This flag allows you to write regular expressions that are more readable by "
"granting you more flexibility in how you can format them.  When this flag "
"has been specified, whitespace within the RE string is ignored, except when "
"the whitespace is in a character class or preceded by an unescaped "
"backslash; this lets you organize and indent the RE more clearly.  This flag"
" also lets you put comments within a RE that will be ignored by the engine; "
"comments are marked by a ``'#'`` that's neither in a character class or "
"preceded by an unescaped backslash."
msgstr ""
"此标志允许你编写更易读的正则表达式，方法是为您提供更灵活的格式化方式。 "
"指定此标志后，将忽略正则字符串中的空格，除非空格位于字符类中或前面带有未转义的反斜杠；这使你可以更清楚地组织和缩进正则。 "
"此标志还允许你将注释放在正则中，引擎将忽略该注释；注释标记为 ``'#'`` 既不是在字符类中，也不是在未转义的反斜杠之前。"

#: ../../howto/regex.rst:648
msgid ""
"For example, here's a RE that uses :const:`re.VERBOSE`; see how much easier "
"it is to read? ::"
msgstr "例如，这里的正则使用 :const:`re.VERBOSE`；看看阅读有多容易？::"

#: ../../howto/regex.rst:651
msgid ""
"charref = re.compile(r\"\"\"\n"
" &[#]                # Start of a numeric entity reference\n"
" (\n"
"     0[0-7]+         # Octal form\n"
"   | [0-9]+          # Decimal form\n"
"   | x[0-9a-fA-F]+   # Hexadecimal form\n"
" )\n"
" ;                   # Trailing semicolon\n"
"\"\"\", re.VERBOSE)"
msgstr ""
"charref = re.compile(r\"\"\"\n"
" &[#]                # 数字实体引用的开始\n"
" (\n"
"     0[0-7]+         # 八进制形式\n"
"   | [0-9]+          # 十进制形式\n"
"   | x[0-9a-fA-F]+   # 十六进制形式\n"
" )\n"
" ;                   # 末尾分号\n"
"\"\"\", re.VERBOSE)"

#: ../../howto/regex.rst:661
msgid "Without the verbose setting, the RE would look like this::"
msgstr "如果没有详细设置，正则将如下所示::"

#: ../../howto/regex.rst:663
msgid ""
"charref = re.compile(\"&#(0[0-7]+\"\n"
"                     \"|[0-9]+\"\n"
"                     \"|x[0-9a-fA-F]+);\")"
msgstr ""
"charref = re.compile(\"&#(0[0-7]+\"\n"
"                     \"|[0-9]+\"\n"
"                     \"|x[0-9a-fA-F]+);\")"

#: ../../howto/regex.rst:667
msgid ""
"In the above example, Python's automatic concatenation of string literals "
"has been used to break up the RE into smaller pieces, but it's still more "
"difficult to understand than the version using :const:`re.VERBOSE`."
msgstr ""
"在上面的例子中，Python的字符串文字的自动连接已被用于将正则分解为更小的部分，但它仍然比以下使用 :const:`re.VERBOSE` "
"版本更难理解。"

#: ../../howto/regex.rst:673
msgid "More Pattern Power"
msgstr "更多模式能力"

#: ../../howto/regex.rst:675
msgid ""
"So far we've only covered a part of the features of regular expressions.  In"
" this section, we'll cover some new metacharacters, and how to use groups to"
" retrieve portions of the text that was matched."
msgstr "到目前为止，我们只介绍了正则表达式的一部分功能。 在本节中，我们将介绍一些新的元字符，以及如何使用组来检索匹配的文本部分。"

#: ../../howto/regex.rst:683
msgid "More Metacharacters"
msgstr "更多元字符"

#: ../../howto/regex.rst:685
msgid ""
"There are some metacharacters that we haven't covered yet.  Most of them "
"will be covered in this section."
msgstr "我们还没有涉及到一些元字符。 其中大部分内容将在本节中介绍。"

#: ../../howto/regex.rst:688
msgid ""
"Some of the remaining metacharacters to be discussed are :dfn:`zero-width "
"assertions`.  They don't cause the engine to advance through the string; "
"instead, they consume no characters at all, and simply succeed or fail.  For"
" example, ``\\b`` is an assertion that the current position is located at a "
"word boundary; the position isn't changed by the ``\\b`` at all.  This means"
" that zero-width assertions should never be repeated, because if they match "
"once at a given location, they can obviously be matched an infinite number "
"of times."
msgstr ""
"要讨论的其余一些元字符是 :dfn:`零宽度断言` 。 "
"它们不会使解析引擎在字符串中前进一个字符；相反，它们根本不占用任何字符，只是成功或失败。例如，``\\b`` "
"是一个断言，指明当前位置位于字边界；这个位置根本不会被 ``\\b`` "
"改变。这意味着永远不应重复零宽度断言，因为如果它们在给定位置匹配一次，它们显然可以无限次匹配。"

#: ../../howto/regex.rst:696
msgid "``|``"
msgstr "``|``"

#: ../../howto/regex.rst:697
msgid ""
"Alternation, or the \"or\" operator.   If *A* and *B* are regular "
"expressions, ``A|B`` will match any string that matches either *A* or *B*. "
"``|`` has very low precedence in order to make it work reasonably when "
"you're alternating multi-character strings. ``Crow|Servo`` will match either"
" ``'Crow'`` or ``'Servo'``, not ``'Cro'``, a ``'w'`` or an ``'S'``, and "
"``'ervo'``."
msgstr ""
"或者“or”运算符。 如果 *A* 和 *B* 是正则表达式，``A|B`` 将匹配任何与 *A* 或 *B* 匹配的字符串。 ``|`` "
"具有非常低的优先级，以便在交替使用多字符字符串时使其合理地工作。 ``Crow|Servo`` 将匹配 ``'Crow'`` 或 "
"``'Servo'``，而不是 ``'Cro'``、``'w'`` 或 ``'S'`` 和 ``'ervo'``。"

#: ../../howto/regex.rst:703
msgid ""
"To match a literal ``'|'``, use ``\\|``, or enclose it inside a character "
"class, as in ``[|]``."
msgstr "要匹配字面 ``'|'``，请使用 ``\\|``，或将其括在字符类中，如 ``[|]``。"

#: ../../howto/regex.rst:706
msgid "``^``"
msgstr "``^``"

#: ../../howto/regex.rst:707
msgid ""
"Matches at the beginning of lines.  Unless the :const:`MULTILINE` flag has "
"been set, this will only match at the beginning of the string.  In "
":const:`MULTILINE` mode, this also matches immediately after each newline "
"within the string."
msgstr ""
"在行的开头匹配。 除非设置了 :const:`MULTILINE` 标志，否则只会在字符串的开头匹配。 在 :const:`MULTILINE` "
"模式下，这也在字符串中的每个换行符后立即匹配。"

#: ../../howto/regex.rst:711
msgid ""
"For example, if you wish to match the word ``From`` only at the beginning of"
" a line, the RE to use is ``^From``. ::"
msgstr "例如，如果你希望仅在行的开头匹配单词 ``From``，则要使用的正则 ``^From``。::"

#: ../../howto/regex.rst:714
msgid ""
">>> print(re.search('^From', 'From Here to Eternity'))\n"
"<re.Match object; span=(0, 4), match='From'>\n"
">>> print(re.search('^From', 'Reciting From Memory'))\n"
"None"
msgstr ""
">>> print(re.search('^From', 'From Here to Eternity'))\n"
"<re.Match object; span=(0, 4), match='From'>\n"
">>> print(re.search('^From', 'Reciting From Memory'))\n"
"None"

#: ../../howto/regex.rst:719
msgid "To match a literal ``'^'``, use ``\\^``."
msgstr "要匹配字面 ``'^'``，使用 ``\\^``。"

#: ../../howto/regex.rst:721
msgid "``$``"
msgstr "``$``"

#: ../../howto/regex.rst:722
msgid ""
"Matches at the end of a line, which is defined as either the end of the "
"string, or any location followed by a newline character.     ::"
msgstr "匹配行的末尾，定义为字符串的结尾，或者后跟换行符的任何位置。::"

#: ../../howto/regex.rst:725
msgid ""
">>> print(re.search('}$', '{block}'))\n"
"<re.Match object; span=(6, 7), match='}'>\n"
">>> print(re.search('}$', '{block} '))\n"
"None\n"
">>> print(re.search('}$', '{block}\\n'))\n"
"<re.Match object; span=(6, 7), match='}'>"
msgstr ""
">>> print(re.search('}$', '{block}'))\n"
"<re.Match object; span=(6, 7), match='}'>\n"
">>> print(re.search('}$', '{block} '))\n"
"None\n"
">>> print(re.search('}$', '{block}\\n'))\n"
"<re.Match object; span=(6, 7), match='}'>"

#: ../../howto/regex.rst:732
msgid ""
"To match a literal ``'$'``, use ``\\$`` or enclose it inside a character "
"class, as in  ``[$]``."
msgstr "以匹配字面 ``'$'``，使用 ``\\$`` 或者将其包裹在一个字符类中，例如 ``[$]``。"

#: ../../howto/regex.rst:735
msgid "``\\A``"
msgstr "``\\A``"

#: ../../howto/regex.rst:736
msgid ""
"Matches only at the start of the string.  When not in :const:`MULTILINE` "
"mode, ``\\A`` and ``^`` are effectively the same.  In :const:`MULTILINE` "
"mode, they're different: ``\\A`` still matches only at the beginning of the "
"string, but ``^`` may match at any location inside the string that follows a"
" newline character."
msgstr ""
"仅匹配字符串的开头。 当不在 :const:`MULTILINE` 模式时，``\\A`` 和 ``^`` 实际上是相同的。 在 "
":const:`MULTILINE` 模式中，它们是不同的: ``\\A`` 仍然只在字符串的开头匹配，但 ``^`` "
"可以匹配在换行符之后的字符串内的任何位置。"

#: ../../howto/regex.rst:741
msgid "``\\Z``"
msgstr "``\\Z``"

#: ../../howto/regex.rst:742
msgid "Matches only at the end of the string."
msgstr "只匹配字符串尾。"

#: ../../howto/regex.rst:744
msgid "``\\b``"
msgstr "``\\b``"

#: ../../howto/regex.rst:745
msgid ""
"Word boundary.  This is a zero-width assertion that matches only at the "
"beginning or end of a word.  A word is defined as a sequence of alphanumeric"
" characters, so the end of a word is indicated by whitespace or a non-"
"alphanumeric character."
msgstr "字边界。 这是一个零宽度断言，仅在单词的开头或结尾处匹配。 单词被定义为一个字母数字字符序列，因此单词的结尾由空格或非字母数字字符表示。"

#: ../../howto/regex.rst:750
msgid ""
"The following example matches ``class`` only when it's a complete word; it "
"won't match when it's contained inside another word. ::"
msgstr "以下示例仅当它是一个完整的单词时匹配 ``class``；当它包含在另一个单词中时将不会匹配。 ::"

#: ../../howto/regex.rst:753
msgid ""
">>> p = re.compile(r'\\bclass\\b')\n"
">>> print(p.search('no class at all'))\n"
"<re.Match object; span=(3, 8), match='class'>\n"
">>> print(p.search('the declassified algorithm'))\n"
"None\n"
">>> print(p.search('one subclass is'))\n"
"None"
msgstr ""
">>> p = re.compile(r'\\bclass\\b')\n"
">>> print(p.search('no class at all'))\n"
"<re.Match object; span=(3, 8), match='class'>\n"
">>> print(p.search('the declassified algorithm'))\n"
"None\n"
">>> print(p.search('one subclass is'))\n"
"None"

#: ../../howto/regex.rst:761
msgid ""
"There are two subtleties you should remember when using this special "
"sequence. First, this is the worst collision between Python's string "
"literals and regular expression sequences.  In Python's string literals, "
"``\\b`` is the backspace character, ASCII value 8.  If you're not using raw "
"strings, then Python will convert the ``\\b`` to a backspace, and your RE "
"won't match as you expect it to. The following example looks the same as our"
" previous RE, but omits the ``'r'`` in front of the RE string. ::"
msgstr ""
"使用这个特殊序列时，你应该记住两个细微之处。 首先，这是 Python 的字符串文字和正则表达式序列之间最严重的冲突。 在 Python "
"的字符串文字中，``\\b`` 是退格字符，ASCII 值为8。 如果你没有使用原始字符串，那么 Python 会将 ``\\b`` "
"转换为退格，你的正则不会按照你的预期匹配。 以下示例与我们之前的正则看起来相同，但省略了正则字符串前面的 ``'r'``。::"

#: ../../howto/regex.rst:769
msgid ""
">>> p = re.compile('\\bclass\\b')\n"
">>> print(p.search('no class at all'))\n"
"None\n"
">>> print(p.search('\\b' + 'class' + '\\b'))\n"
"<re.Match object; span=(0, 7), match='\\x08class\\x08'>"
msgstr ""
">>> p = re.compile('\\bclass\\b')\n"
">>> print(p.search('no class at all'))\n"
"None\n"
">>> print(p.search('\\b' + 'class' + '\\b'))\n"
"<re.Match object; span=(0, 7), match='\\x08class\\x08'>"

#: ../../howto/regex.rst:775
msgid ""
"Second, inside a character class, where there's no use for this assertion, "
"``\\b`` represents the backspace character, for compatibility with Python's "
"string literals."
msgstr "其次，在一个字符类中，这个断言没有用处，``\\b`` 表示退格字符，以便与 Python 的字符串文字兼容。"

#: ../../howto/regex.rst:779
msgid "``\\B``"
msgstr "``\\B``"

#: ../../howto/regex.rst:780
msgid ""
"Another zero-width assertion, this is the opposite of ``\\b``, only matching"
" when the current position is not at a word boundary."
msgstr "另一个零宽度断言，这与 ``\\b`` 相反，仅在当前位置不在字边界时才匹配。"

#: ../../howto/regex.rst:785
msgid "Grouping"
msgstr "分组"

#: ../../howto/regex.rst:787
msgid ""
"Frequently you need to obtain more information than just whether the RE "
"matched or not.  Regular expressions are often used to dissect strings by "
"writing a RE divided into several subgroups which match different components"
" of interest. For example, an RFC-822 header line is divided into a header "
"name and a value, separated by a ``':'``, like this:"
msgstr ""
"通常，你需要获取更多信息，而不仅仅是正则是否匹配。 正则表达式通常用于通过将正则分成几个子组来解析字符串，这些子组匹配不同的感兴趣组件。 "
"例如，RFC-822 标题行分为标题名称和值，用 ``':'`` 分隔，如下所示："

#: ../../howto/regex.rst:793
msgid ""
"From: author@example.com\n"
"User-Agent: Thunderbird 1.5.0.9 (X11/20061227)\n"
"MIME-Version: 1.0\n"
"To: editor@example.com"
msgstr ""
"From: author@example.com\n"
"User-Agent: Thunderbird 1.5.0.9 (X11/20061227)\n"
"MIME-Version: 1.0\n"
"To: editor@example.com"

#: ../../howto/regex.rst:800
msgid ""
"This can be handled by writing a regular expression which matches an entire "
"header line, and has one group which matches the header name, and another "
"group which matches the header's value."
msgstr "这可以通过编写与整个标题行匹配的正则表达式来处理，并且具有与标题名称匹配的一个组，以及与标题的值匹配的另一个组。"

#: ../../howto/regex.rst:804
msgid ""
"Groups are marked by the ``'('``, ``')'`` metacharacters. ``'('`` and "
"``')'`` have much the same meaning as they do in mathematical expressions; "
"they group together the expressions contained inside them, and you can "
"repeat the contents of a group with a quantifier, such as ``*``, ``+``, "
"``?``, or ``{m,n}``.  For example, ``(ab)*`` will match zero or more "
"repetitions of ``ab``. ::"
msgstr ""
"分组是用 ``'('``, ``')'`` 元字符来标记的。 ``'('`` 和 ``')'`` "
"与它们在数学表达式中的含义基本一致；它们会将所包含的表达式合为一组，并且你可以使用限定符例如 ``*``, ``+``, ``?``, 或 "
"``{m,n}`` 来重复一个分组的内容。 举例来说，``(ab)*`` 将匹配 ``ab`` 的零次或多次重复。 ::"

#: ../../howto/regex.rst:811
msgid ""
">>> p = re.compile('(ab)*')\n"
">>> print(p.match('ababababab').span())\n"
"(0, 10)"
msgstr ""
">>> p = re.compile('(ab)*')\n"
">>> print(p.match('ababababab').span())\n"
"(0, 10)"

#: ../../howto/regex.rst:815
msgid ""
"Groups indicated with ``'('``, ``')'`` also capture the starting and ending "
"index of the text that they match; this can be retrieved by passing an "
"argument to :meth:`~re.Match.group`, :meth:`~re.Match.start`, "
":meth:`~re.Match.end`, and :meth:`~re.Match.span`.  Groups are numbered "
"starting with 0.  Group 0 is always present; it's the whole RE, so "
":ref:`match object <match-objects>` methods all have group 0 as their "
"default argument.  Later we'll see how to express groups that don't capture "
"the span of text that they match. ::"
msgstr ""
"用 ``'('``，``')'`` 表示的组也捕获它们匹配的文本的起始和结束索引；这可以通过将参数传递给 "
":meth:`~re.Match.group`、:meth:`~re.Match.start`、:meth:`~re.Match.end` 以及 "
":meth:`~re.Match.span`。 组从 0 开始编号。组 0 始终存在；它表示整个正则，所以 :ref:`匹配对象 <match-"
"objects>` 方法都将组 0 作为默认参数。 稍后我们将看到如何表达不捕获它们匹配的文本范围的组。::"

#: ../../howto/regex.rst:824
msgid ""
">>> p = re.compile('(a)b')\n"
">>> m = p.match('ab')\n"
">>> m.group()\n"
"'ab'\n"
">>> m.group(0)\n"
"'ab'"
msgstr ""
">>> p = re.compile('(a)b')\n"
">>> m = p.match('ab')\n"
">>> m.group()\n"
"'ab'\n"
">>> m.group(0)\n"
"'ab'"

#: ../../howto/regex.rst:831
msgid ""
"Subgroups are numbered from left to right, from 1 upward.  Groups can be "
"nested; to determine the number, just count the opening parenthesis "
"characters, going from left to right. ::"
msgstr "子组从左到右编号，从 1 向上编号。 组可以嵌套；要确定编号，只需计算从左到右的左括号字符。::"

#: ../../howto/regex.rst:835
msgid ""
">>> p = re.compile('(a(b)c)d')\n"
">>> m = p.match('abcd')\n"
">>> m.group(0)\n"
"'abcd'\n"
">>> m.group(1)\n"
"'abc'\n"
">>> m.group(2)\n"
"'b'"
msgstr ""
">>> p = re.compile('(a(b)c)d')\n"
">>> m = p.match('abcd')\n"
">>> m.group(0)\n"
"'abcd'\n"
">>> m.group(1)\n"
"'abc'\n"
">>> m.group(2)\n"
"'b'"

#: ../../howto/regex.rst:844
msgid ""
":meth:`~re.Match.group` can be passed multiple group numbers at a time, in "
"which case it will return a tuple containing the corresponding values for "
"those groups. ::"
msgstr ":meth:`~re.Match.group` 可以一次传递多个组号，在这种情况下，它将返回一个包含这些组的相应值的元组。::"

#: ../../howto/regex.rst:847
msgid ""
">>> m.group(2,1,2)\n"
"('b', 'abc', 'b')"
msgstr ""
">>> m.group(2,1,2)\n"
"('b', 'abc', 'b')"

#: ../../howto/regex.rst:850
msgid ""
"The :meth:`~re.Match.groups` method returns a tuple containing the strings "
"for all the subgroups, from 1 up to however many there are. ::"
msgstr ":meth:`~re.Match.groups` 方法返回一个元组，其中包含所有子组的字符串，从1到最后一个子组。::"

#: ../../howto/regex.rst:853
msgid ""
">>> m.groups()\n"
"('abc', 'b')"
msgstr ""
">>> m.groups()\n"
"('abc', 'b')"

#: ../../howto/regex.rst:856
msgid ""
"Backreferences in a pattern allow you to specify that the contents of an "
"earlier capturing group must also be found at the current location in the "
"string.  For example, ``\\1`` will succeed if the exact contents of group 1 "
"can be found at the current position, and fails otherwise.  Remember that "
"Python's string literals also use a backslash followed by numbers to allow "
"including arbitrary characters in a string, so be sure to use a raw string "
"when incorporating backreferences in a RE."
msgstr ""
"模式中的后向引用允许你指定还必须在字符串中的当前位置找到先前捕获组的内容。 例如，如果可以在当前位置找到组 1 的确切内容，则 ``\\1`` "
"将成功，否则将失败。 请记住，Python 的字符串文字也使用反斜杠后跟数字以允许在字符串中包含任意字符，因此正则中引入反向引用时务必使用原始字符串。"

#: ../../howto/regex.rst:864
msgid "For example, the following RE detects doubled words in a string. ::"
msgstr "例如，以下正则检测字符串中重复的单词。::"

#: ../../howto/regex.rst:866
msgid ""
">>> p = re.compile(r'\\b(\\w+)\\s+\\1\\b')\n"
">>> p.search('Paris in the the spring').group()\n"
"'the the'"
msgstr ""
">>> p = re.compile(r'\\b(\\w+)\\s+\\1\\b')\n"
">>> p.search('Paris in the the spring').group()\n"
"'the the'"

#: ../../howto/regex.rst:870
msgid ""
"Backreferences like this aren't often useful for just searching through a "
"string --- there are few text formats which repeat data in this way --- but "
"you'll soon find out that they're *very* useful when performing string "
"substitutions."
msgstr ""
"像这样的后向引用通常不仅仅用于搜索字符串 —— 很少有文本格式以这种方式重复数据 —— 但是你很快就会发现它们在执行字符串替换时 *非常* 有用。"

#: ../../howto/regex.rst:876
msgid "Non-capturing and Named Groups"
msgstr "非捕获和命名组"

#: ../../howto/regex.rst:878
msgid ""
"Elaborate REs may use many groups, both to capture substrings of interest, "
"and to group and structure the RE itself.  In complex REs, it becomes "
"difficult to keep track of the group numbers.  There are two features which "
"help with this problem.  Both of them use a common syntax for regular "
"expression extensions, so we'll look at that first."
msgstr ""
"精心设计的正则可以使用许多组，既可以捕获感兴趣的子串，也可以对正则本身进行分组和构建。 在复杂的正则中，很难跟踪组号。 有两个功能可以帮助解决这个问题。"
" 它们都使用常用语法进行正则表达式扩展，因此我们首先看一下。"

#: ../../howto/regex.rst:884
msgid ""
"Perl 5 is well known for its powerful additions to standard regular "
"expressions. For these new features the Perl developers couldn't choose new "
"single-keystroke metacharacters or new special sequences beginning with "
"``\\`` without making Perl's regular expressions confusingly different from "
"standard REs.  If they chose ``&`` as a new metacharacter, for example, old "
"expressions would be assuming that ``&`` was a regular character and "
"wouldn't have escaped it by writing ``\\&`` or ``[&]``."
msgstr ""
"Perl 5 以其对标准正则表达式的强大补充而闻名。 对于这些新功能，Perl 开发人员无法选择新的单键击元字符或以 ``\\`` "
"开头的新特殊序列，否则 Perl 的正则表达式与标准正则容易混淆。 例如，如果他们选择 ``&`` 作为一个新的元字符，旧的表达式将假设 ``&`` "
"是一个普通字符，并且不会编写 ``\\&`` 或 ``[&]``。"

#: ../../howto/regex.rst:891
msgid ""
"The solution chosen by the Perl developers was to use ``(?...)`` as the "
"extension syntax.  ``?`` immediately after a parenthesis was a syntax error "
"because the ``?`` would have nothing to repeat, so this didn't introduce any"
" compatibility problems.  The characters immediately after the ``?``  "
"indicate what extension is being used, so ``(?=foo)`` is one thing (a "
"positive lookahead assertion) and ``(?:foo)`` is something else (a non-"
"capturing group containing the subexpression ``foo``)."
msgstr ""
"Perl 开发人员选择的解决方案是使用 ``(?...)`` 作为扩展语法。 括号后面紧跟 ``?`` 是一个语法错误，因为 ``?`` "
"没有什么可重复的，所以这样并不会带来任何兼容性问题。 紧跟在 ``?`` 之后的字符表示正在使用的扩展语法，所以 ``(?=foo)`` "
"是一种语法（一个前视断言）和 ``(?:foo)`` 是另一种语法（ 包含子表达式 ``foo`` 的非捕获组）。"

#: ../../howto/regex.rst:899
msgid ""
"Python supports several of Perl's extensions and adds an extension syntax to"
" Perl's extension syntax.  If the first character after the question mark is"
" a ``P``, you know that it's an extension that's specific to Python."
msgstr ""
"Python 支持一些 Perl 的扩展，并增加了新的扩展语法用于 Perl 的扩展语法。 如果在问号之后的第一个字符为 ``P``，即表明其为 "
"Python 专属的扩展。"

#: ../../howto/regex.rst:904
msgid ""
"Now that we've looked at the general extension syntax, we can return to the "
"features that simplify working with groups in complex REs."
msgstr "现在我们已经了解了一般的扩展语法，我们可以回到简化复杂正则中组处理的功能。"

#: ../../howto/regex.rst:907
msgid ""
"Sometimes you'll want to use a group to denote a part of a regular "
"expression, but aren't interested in retrieving the group's contents. You "
"can make this fact explicit by using a non-capturing group: ``(?:...)``, "
"where you can replace the ``...`` with any other regular expression. ::"
msgstr ""
"有时你会想要使用组来表示正则表达式的一部分，但是对检索组的内容不感兴趣。 你可以通过使用非捕获组来显式表达这个事实: "
"``(?:...)``，你可以用任何其他正则表达式替换 ``...``。::"

#: ../../howto/regex.rst:912
msgid ""
">>> m = re.match(\"([abc])+\", \"abc\")\n"
">>> m.groups()\n"
"('c',)\n"
">>> m = re.match(\"(?:[abc])+\", \"abc\")\n"
">>> m.groups()\n"
"()"
msgstr ""
">>> m = re.match(\"([abc])+\", \"abc\")\n"
">>> m.groups()\n"
"('c',)\n"
">>> m = re.match(\"(?:[abc])+\", \"abc\")\n"
">>> m.groups()\n"
"()"

#: ../../howto/regex.rst:919
msgid ""
"Except for the fact that you can't retrieve the contents of what the group "
"matched, a non-capturing group behaves exactly the same as a capturing "
"group; you can put anything inside it, repeat it with a repetition "
"metacharacter such as ``*``, and nest it within other groups (capturing or "
"non-capturing). ``(?:...)`` is particularly useful when modifying an "
"existing pattern, since you can add new groups without changing how all the "
"other groups are numbered.  It should be mentioned that there's no "
"performance difference in searching between capturing and non-capturing "
"groups; neither form is any faster than the other."
msgstr ""
"除了你无法检索组匹配内容的事实外，非捕获组的行为与捕获组完全相同；你可以在里面放任何东西，用重复元字符重复它，比如 "
"``*``，然后把它嵌入其他组（捕获或不捕获）。 ``(?:...)`` 在修改现有模式时特别有用，因为你可以添加新组而不更改所有其他组的编号方式。 "
"值得一提的是，捕获和非捕获组之间的搜索没有性能差异；两种形式没有一种更快。"

#: ../../howto/regex.rst:928
msgid ""
"A more significant feature is named groups: instead of referring to them by "
"numbers, groups can be referenced by a name."
msgstr "更重要的功能是命名组：不是通过数字引用它们，而是可以通过名称引用组。"

#: ../../howto/regex.rst:931
msgid ""
"The syntax for a named group is one of the Python-specific extensions: "
"``(?P<name>...)``.  *name* is, obviously, the name of the group.  Named "
"groups behave exactly like capturing groups, and additionally associate a "
"name with a group.  The :ref:`match object <match-objects>` methods that "
"deal with capturing groups all accept either integers that refer to the "
"group by number or strings that contain the desired group's name.  Named "
"groups are still given numbers, so you can retrieve information about a "
"group in two ways::"
msgstr ""
"命名组的语法是Python特定的扩展之一: ``(?P<name>...)``。 *name* 显然是该组的名称。 "
"命名组的行为与捕获组完全相同，并且还将名称与组关联。 处理捕获组的 :ref:`匹配对象 <match-objects>` "
"方法都接受按编号引用组的整数或包含所需组名的字符串。 命名组仍然是给定的数字，因此你可以通过两种方式检索有关组的信息::"

#: ../../howto/regex.rst:939
msgid ""
">>> p = re.compile(r'(?P<word>\\b\\w+\\b)')\n"
">>> m = p.search( '(((( Lots of punctuation )))' )\n"
">>> m.group('word')\n"
"'Lots'\n"
">>> m.group(1)\n"
"'Lots'"
msgstr ""
">>> p = re.compile(r'(?P<word>\\b\\w+\\b)')\n"
">>> m = p.search( '(((( Lots of punctuation )))' )\n"
">>> m.group('word')\n"
"'Lots'\n"
">>> m.group(1)\n"
"'Lots'"

#: ../../howto/regex.rst:946
msgid ""
"Additionally, you can retrieve named groups as a dictionary with "
":meth:`~re.Match.groupdict`::"
msgstr "此外，你可以通过 :meth:`~re.Match.groupdict` 将命名分组提取为一个字典::"

#: ../../howto/regex.rst:949
msgid ""
">>> m = re.match(r'(?P<first>\\w+) (?P<last>\\w+)', 'Jane Doe')\n"
">>> m.groupdict()\n"
"{'first': 'Jane', 'last': 'Doe'}"
msgstr ""
">>> m = re.match(r'(?P<first>\\w+) (?P<last>\\w+)', 'Jane Doe')\n"
">>> m.groupdict()\n"
"{'first': 'Jane', 'last': 'Doe'}"

#: ../../howto/regex.rst:953
msgid ""
"Named groups are handy because they let you use easily remembered names, "
"instead of having to remember numbers.  Here's an example RE from the "
":mod:`imaplib` module::"
msgstr "命名分组很方便因为它们让你可以使用容易记忆的名称，而不必记忆数字。 下面是一个来自 :mod:`imaplib` 模块的正则表达式示例::"

#: ../../howto/regex.rst:957
msgid ""
"InternalDate = re.compile(r'INTERNALDATE \"'\n"
"        r'(?P<day>[ 123][0-9])-(?P<mon>[A-Z][a-z][a-z])-'\n"
"        r'(?P<year>[0-9][0-9][0-9][0-9])'\n"
"        r' (?P<hour>[0-9][0-9]):(?P<min>[0-9][0-9]):(?P<sec>[0-9][0-9])'\n"
"        r' (?P<zonen>[-+])(?P<zoneh>[0-9][0-9])(?P<zonem>[0-9][0-9])'\n"
"        r'\"')"
msgstr ""
"InternalDate = re.compile(r'INTERNALDATE \"'\n"
"        r'(?P<day>[ 123][0-9])-(?P<mon>[A-Z][a-z][a-z])-'\n"
"        r'(?P<year>[0-9][0-9][0-9][0-9])'\n"
"        r' (?P<hour>[0-9][0-9]):(?P<min>[0-9][0-9]):(?P<sec>[0-9][0-9])'\n"
"        r' (?P<zonen>[-+])(?P<zoneh>[0-9][0-9])(?P<zonem>[0-9][0-9])'\n"
"        r'\"')"

#: ../../howto/regex.rst:964
msgid ""
"It's obviously much easier to retrieve ``m.group('zonem')``, instead of "
"having to remember to retrieve group 9."
msgstr "检索 ``m.group('zonem')`` 显然要容易得多，而不必记住检索第 9 组。"

#: ../../howto/regex.rst:967
msgid ""
"The syntax for backreferences in an expression such as ``(...)\\1`` refers "
"to the number of the group.  There's naturally a variant that uses the group"
" name instead of the number. This is another Python extension: ``(?P=name)``"
" indicates that the contents of the group called *name* should again be "
"matched at the current point.  The regular expression for finding doubled "
"words, ``\\b(\\w+)\\s+\\1\\b`` can also be written as "
"``\\b(?P<word>\\w+)\\s+(?P=word)\\b``::"
msgstr ""
"表达式中的后向引用语法，例如 ``(...)\\1``，指的是组的编号。 当然有一种变体使用组名而不是数字。 这是另一个 Python 扩展: "
"``(?P=name)`` 表示在当前点再次匹配名为 *name* 的组的内容。 "
"用于查找重复单词的正则表达式，``\\b(\\w+)\\s+\\1\\b`` 也可以写为 "
"``\\b(?P<word>\\w+)\\s+(?P=word)\\b``::"

#: ../../howto/regex.rst:974
msgid ""
">>> p = re.compile(r'\\b(?P<word>\\w+)\\s+(?P=word)\\b')\n"
">>> p.search('Paris in the the spring').group()\n"
"'the the'"
msgstr ""
">>> p = re.compile(r'\\b(?P<word>\\w+)\\s+(?P=word)\\b')\n"
">>> p.search('Paris in the the spring').group()\n"
"'the the'"

#: ../../howto/regex.rst:980
msgid "Lookahead Assertions"
msgstr "前视断言"

#: ../../howto/regex.rst:982
msgid ""
"Another zero-width assertion is the lookahead assertion.  Lookahead "
"assertions are available in both positive and negative form, and  look like "
"this:"
msgstr "另一个零宽断言是前视断言。 前视断言有肯定型和否定型两种形式，如下所示："

#: ../../howto/regex.rst:985
msgid "``(?=...)``"
msgstr "``(?=…)``"

#: ../../howto/regex.rst:986
msgid ""
"Positive lookahead assertion.  This succeeds if the contained regular "
"expression, represented here by ``...``, successfully matches at the current"
" location, and fails otherwise. But, once the contained expression has been "
"tried, the matching engine doesn't advance at all; the rest of the pattern "
"is tried right where the assertion started."
msgstr ""
"肯定型前视断言。如果内部的表达式（这里用 ``...`` 来表示）在当前位置可以匹配，则匹配成功，否则匹配失败。 "
"但是，内部表达式尝试匹配之后，正则引擎并不会向前推进；正则表达式的其余部分依然会在断言开始的地方尝试匹配。"

#: ../../howto/regex.rst:992
msgid "``(?!...)``"
msgstr "``(?!…)``"

#: ../../howto/regex.rst:993
msgid ""
"Negative lookahead assertion.  This is the opposite of the positive "
"assertion; it succeeds if the contained expression *doesn't* match at the "
"current position in the string."
msgstr "否定型前视断言。 与肯定型断言正好相反，如果内部表达式在字符串中的当前位置 **不** 匹配，则成功。"

#: ../../howto/regex.rst:997
msgid ""
"To make this concrete, let's look at a case where a lookahead is useful. "
"Consider a simple pattern to match a filename and split it apart into a base"
" name and an extension, separated by a ``.``.  For example, in ``news.rc``, "
"``news`` is the base name, and ``rc`` is the filename's extension."
msgstr ""
"更具体一些，来看一个前视的实用案例。 考虑用一个简单的表达式来匹配文件名并将其拆分为基本名称和扩展名，以 ``.`` 分隔。 例如，在 "
"``news.rc`` 中，``news`` 是基本名称，``rc`` 是文件名的扩展名。"

#: ../../howto/regex.rst:1002
msgid "The pattern to match this is quite simple:"
msgstr "与此匹配的模式非常简单："

#: ../../howto/regex.rst:1004
msgid "``.*[.].*$``"
msgstr "``.*[.].*$``"

#: ../../howto/regex.rst:1006
msgid ""
"Notice that the ``.`` needs to be treated specially because it's a "
"metacharacter, so it's inside a character class to only match that specific "
"character.  Also notice the trailing ``$``; this is added to ensure that all"
" the rest of the string must be included in the extension.  This regular "
"expression matches ``foo.bar`` and ``autoexec.bat`` and ``sendmail.cf`` and "
"``printers.conf``."
msgstr ""
"请注意，``.`` 需要特别处理，因为它是元字符，所以它在字符类中只能匹配特定字符。 还要注意尾随的 "
"``$``；添加此项以确保扩展名中的所有其余字符串都必须包含在扩展名中。 这个正则表达式匹配 "
"``foo.bar``、``autoexec.bat``、``sendmail.cf`` 和 ``printers.conf``。"

#: ../../howto/regex.rst:1013
msgid ""
"Now, consider complicating the problem a bit; what if you want to match "
"filenames where the extension is not ``bat``? Some incorrect attempts:"
msgstr "现在，考虑使更复杂一点的问题；如果你想匹配扩展名不是 ``bat`` 的文件名怎么办？ 一些错误的尝试："

#: ../../howto/regex.rst:1016
msgid "``.*[.][^b].*$``"
msgstr "``.*[.][^b].*$``"

#: ../../howto/regex.rst:1018
msgid ""
"The first attempt above tries to exclude ``bat`` by requiring that the first"
" character of the extension is not a ``b``.  This is wrong, because the "
"pattern also doesn't match ``foo.bar``."
msgstr ""
"上面的第一次尝试将通过要求扩展的第一个字符不为 ``b`` 来排除 ``bat``。 这是错误的，因为该模式同样不能匹配 ``foo.bar``。"

#: ../../howto/regex.rst:1022
msgid "``.*[.]([^b]..|.[^a].|..[^t])$``"
msgstr "``.*[.]([^b]..|.[^a].|..[^t])$``"

#: ../../howto/regex.rst:1024
msgid ""
"The expression gets messier when you try to patch up the first solution by "
"requiring one of the following cases to match: the first character of the "
"extension isn't ``b``; the second character isn't ``a``; or the third "
"character isn't ``t``.  This accepts ``foo.bar`` and rejects "
"``autoexec.bat``, but it requires a three-letter extension and won't accept "
"a filename with a two-letter extension such as ``sendmail.cf``.  We'll "
"complicate the pattern again in an effort to fix it."
msgstr ""
"当你尝试通过要求以下一种情况匹配来修补第一个解决方案时，表达式变得更加混乱：扩展的第一个字符不是 ``b``。 第二个字符不 "
"``a``；或者第三个字符不是 ``t``。 这接受 ``foo.bar`` 并拒绝 "
"``autoexec.bat``，但它需要三个字母的扩展名，并且不接受带有两个字母扩展名的文件名，例如 ``sendmail.cf``。 "
"为了解决这个问题，我们会再次使模式复杂化。"

#: ../../howto/regex.rst:1032
msgid "``.*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$``"
msgstr "``.*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$``"

#: ../../howto/regex.rst:1034
msgid ""
"In the third attempt, the second and third letters are all made optional in "
"order to allow matching extensions shorter than three characters, such as "
"``sendmail.cf``."
msgstr "在第三次尝试中，第二个和第三个字母都是可选的，以便允许匹配的扩展名短于三个字符，例如 ``sendmail.cf``。"

#: ../../howto/regex.rst:1038
msgid ""
"The pattern's getting really complicated now, which makes it hard to read "
"and understand.  Worse, if the problem changes and you want to exclude both "
"``bat`` and ``exe`` as extensions, the pattern would get even more "
"complicated and confusing."
msgstr ""
"模式现在变得非常复杂，这使得它难以阅读和理解。 更糟糕的是，如果问题发生变化并且你想要将 ``bat`` 和 ``exe`` "
"排除为扩展，那么该模式将变得更加复杂和混乱。"

#: ../../howto/regex.rst:1043
msgid "A negative lookahead cuts through all this confusion:"
msgstr "否定型前视可以解决所有这些困扰："

#: ../../howto/regex.rst:1045
msgid "``.*[.](?!bat$)[^.]*$``"
msgstr "``.*[.](?!bat$)[^.]*$``"

#: ../../howto/regex.rst:1047
msgid ""
"The negative lookahead means: if the expression ``bat`` doesn't match at "
"this point, try the rest of the pattern; if ``bat$`` does match, the whole "
"pattern will fail.  The trailing ``$`` is required to ensure that something "
"like ``sample.batch``, where the extension only starts with ``bat``, will be"
" allowed.  The ``[^.]*`` makes sure that the pattern works when there are "
"multiple dots in the filename."
msgstr ""
"否定前视意味着：如果表达式 ``bat`` 在这个点位不匹配，则尝试模式的其余部分；如果 ``bat$`` 不匹配，整个模式匹配将失败。 需要有末尾的 "
"``$`` 来确保 ``sample.batch`` 这样的内容，其中扩展名只能以 ``bat`` 开头，将被允许。 ``[^.]*`` "
"将确保当文件名中有多个点号时该模式仍能正常工作。"

#: ../../howto/regex.rst:1054
msgid ""
"Excluding another filename extension is now easy; simply add it as an "
"alternative inside the assertion.  The following pattern excludes filenames "
"that end in either ``bat`` or ``exe``:"
msgstr "现在很容易排除另一个文件扩展名；只需在断言中添加它作为替代。  以下模块排除以 ``bat`` 或 ``exe``:"

#: ../../howto/regex.rst:1058
msgid "``.*[.](?!bat$|exe$)[^.]*$``"
msgstr "``.*[.](?!bat$|exe$)[^.]*$``"

#: ../../howto/regex.rst:1062
msgid "Modifying Strings"
msgstr "修改字符串"

#: ../../howto/regex.rst:1064
msgid ""
"Up to this point, we've simply performed searches against a static string. "
"Regular expressions are also commonly used to modify strings in various "
"ways, using the following pattern methods:"
msgstr "到目前为止，我们只是针对静态字符串执行搜索。 正则表达式通常也用于以各种方式修改字符串，使用以下模式方法："

#: ../../howto/regex.rst:1071
msgid "``split()``"
msgstr "``split()``"

#: ../../howto/regex.rst:1071
msgid "Split the string into a list, splitting it wherever the RE matches"
msgstr "将字符串拆分为一个列表，在正则匹配的任何地方将其拆分"

#: ../../howto/regex.rst:1074
msgid "``sub()``"
msgstr "``sub()``"

#: ../../howto/regex.rst:1074
msgid ""
"Find all substrings where the RE matches, and replace them with a different "
"string"
msgstr "找到正则匹配的所有子字符串，并用不同的字符串替换它们"

#: ../../howto/regex.rst:1077
msgid "``subn()``"
msgstr "``subn()``"

#: ../../howto/regex.rst:1077
msgid ""
"Does the same thing as :meth:`!sub`,  but returns the new string and the "
"number of replacements"
msgstr "与 :meth:`!sub` 相同，但返回新字符串和替换次数"

#: ../../howto/regex.rst:1084
msgid "Splitting Strings"
msgstr "分割字符串"

#: ../../howto/regex.rst:1086
msgid ""
"The :meth:`~re.Pattern.split` method of a pattern splits a string apart "
"wherever the RE matches, returning a list of the pieces. It's similar to the"
" :meth:`~str.split` method of strings but provides much more generality in "
"the delimiters that you can split by; string :meth:`!split` only supports "
"splitting by whitespace or by a fixed string.  As you'd expect, there's a "
"module-level :func:`re.split` function, too."
msgstr ""
"模式的 :meth:`~re.Pattern.split` 方法在正则匹配的任何地方拆分字符串，返回一个片段列表。 它类似于 "
":meth:`~str.split` 字符串方法，但在分隔符的分隔符中提供了更多的通用性；字符串的 :meth:`!split` "
"仅支持按空格或固定字符串进行拆分。 正如你所期望的那样，还有一个模块级 :func:`re.split` 函数。"

#: ../../howto/regex.rst:1097
msgid ""
"Split *string* by the matches of the regular expression.  If capturing "
"parentheses are used in the RE, then their contents will also be returned as"
" part of the resulting list.  If *maxsplit* is nonzero, at most *maxsplit* "
"splits are performed."
msgstr ""
"通过正则表达式的匹配拆分 *字符串*。 如果在正则中使用捕获括号，则它们的内容也将作为结果列表的一部分返回。 如果 *maxsplit* "
"非零，则最多执行 *maxsplit* 次拆分。"

#: ../../howto/regex.rst:1102
msgid ""
"You can limit the number of splits made, by passing a value for *maxsplit*. "
"When *maxsplit* is nonzero, at most *maxsplit* splits will be made, and the "
"remainder of the string is returned as the final element of the list.  In "
"the following example, the delimiter is any sequence of non-alphanumeric "
"characters. ::"
msgstr ""
"你可以通过传递 *maxsplit* 的值来限制分割的数量。 当 *maxsplit* 非零时，将最多进行 *maxsplit* "
"次拆分，并且字符串的其余部分将作为列表的最后一个元素返回。 在以下示例中，分隔符是任何非字母数字字符序列。::"

#: ../../howto/regex.rst:1108
msgid ""
">>> p = re.compile(r'\\W+')\n"
">>> p.split('This is a test, short and sweet, of split().')\n"
"['This', 'is', 'a', 'test', 'short', 'and', 'sweet', 'of', 'split', '']\n"
">>> p.split('This is a test, short and sweet, of split().', 3)\n"
"['This', 'is', 'a', 'test, short and sweet, of split().']"
msgstr ""
">>> p = re.compile(r'\\W+')\n"
">>> p.split('This is a test, short and sweet, of split().')\n"
"['This', 'is', 'a', 'test', 'short', 'and', 'sweet', 'of', 'split', '']\n"
">>> p.split('This is a test, short and sweet, of split().', 3)\n"
"['This', 'is', 'a', 'test, short and sweet, of split().']"

#: ../../howto/regex.rst:1114
msgid ""
"Sometimes you're not only interested in what the text between delimiters is,"
" but also need to know what the delimiter was.  If capturing parentheses are"
" used in the RE, then their values are also returned as part of the list.  "
"Compare the following calls::"
msgstr ""
"有时你不仅对分隔符之间的文本感兴趣，而且还需要知道分隔符是什么。 如果在正则中使用捕获括号，则它们的值也将作为列表的一部分返回。 比较以下调用::"

#: ../../howto/regex.rst:1119
msgid ""
">>> p = re.compile(r'\\W+')\n"
">>> p2 = re.compile(r'(\\W+)')\n"
">>> p.split('This... is a test.')\n"
"['This', 'is', 'a', 'test', '']\n"
">>> p2.split('This... is a test.')\n"
"['This', '... ', 'is', ' ', 'a', ' ', 'test', '.', '']"
msgstr ""
">>> p = re.compile(r'\\W+')\n"
">>> p2 = re.compile(r'(\\W+)')\n"
">>> p.split('This... is a test.')\n"
"['This', 'is', 'a', 'test', '']\n"
">>> p2.split('This... is a test.')\n"
"['This', '... ', 'is', ' ', 'a', ' ', 'test', '.', '']"

#: ../../howto/regex.rst:1126
msgid ""
"The module-level function :func:`re.split` adds the RE to be used as the "
"first argument, but is otherwise the same.   ::"
msgstr "模块级函数 :func:`re.split` 添加要正则作为第一个参数，但在其他方面是相同的。::"

#: ../../howto/regex.rst:1129
msgid ""
">>> re.split(r'[\\W]+', 'Words, words, words.')\n"
"['Words', 'words', 'words', '']\n"
">>> re.split(r'([\\W]+)', 'Words, words, words.')\n"
"['Words', ', ', 'words', ', ', 'words', '.', '']\n"
">>> re.split(r'[\\W]+', 'Words, words, words.', 1)\n"
"['Words', 'words, words.']"
msgstr ""
">>> re.split(r'[\\W]+', 'Words, words, words.')\n"
"['Words', 'words', 'words', '']\n"
">>> re.split(r'([\\W]+)', 'Words, words, words.')\n"
"['Words', ', ', 'words', ', ', 'words', '.', '']\n"
">>> re.split(r'[\\W]+', 'Words, words, words.', 1)\n"
"['Words', 'words, words.']"

#: ../../howto/regex.rst:1138
msgid "Search and Replace"
msgstr "搜索和替换"

#: ../../howto/regex.rst:1140
msgid ""
"Another common task is to find all the matches for a pattern, and replace "
"them with a different string.  The :meth:`~re.Pattern.sub` method takes a "
"replacement value, which can be either a string or a function, and the "
"string to be processed."
msgstr ""
"另一个常见任务是找到模式的所有匹配项，并用不同的字符串替换它们。 :meth:`~re.Pattern.sub` "
"方法接受一个替换值，可以是字符串或函数，也可以是要处理的字符串。"

#: ../../howto/regex.rst:1147
msgid ""
"Returns the string obtained by replacing the leftmost non-overlapping "
"occurrences of the RE in *string* by the replacement *replacement*.  If the "
"pattern isn't found, *string* is returned unchanged."
msgstr ""
"返回通过替换 *replacement* 替换 *string* 中正则的最左边非重叠出现而获得的字符串。 如果未找到模式，则 *string* "
"将保持不变。"

#: ../../howto/regex.rst:1151
msgid ""
"The optional argument *count* is the maximum number of pattern occurrences "
"to be replaced; *count* must be a non-negative integer.  The default value "
"of 0 means to replace all occurrences."
msgstr "可选参数 *count* 是要替换的模式最大的出现次数；*count* 必须是非负整数。 默认值 0 表示替换所有。"

#: ../../howto/regex.rst:1155
msgid ""
"Here's a simple example of using the :meth:`~re.Pattern.sub` method.  It "
"replaces colour names with the word ``colour``::"
msgstr "这是一个使用 :meth:`~re.Pattern.sub` 方法的简单示例。 它用 ``colour`` 这个词取代颜色名称::"

#: ../../howto/regex.rst:1158
msgid ""
">>> p = re.compile('(blue|white|red)')\n"
">>> p.sub('colour', 'blue socks and red shoes')\n"
"'colour socks and colour shoes'\n"
">>> p.sub('colour', 'blue socks and red shoes', count=1)\n"
"'colour socks and red shoes'"
msgstr ""
">>> p = re.compile('(blue|white|red)')\n"
">>> p.sub('colour', 'blue socks and red shoes')\n"
"'colour socks and colour shoes'\n"
">>> p.sub('colour', 'blue socks and red shoes', count=1)\n"
"'colour socks and red shoes'"

#: ../../howto/regex.rst:1164
msgid ""
"The :meth:`~re.Pattern.subn` method does the same work, but returns a "
"2-tuple containing the new string value and the number of replacements  that"
" were performed::"
msgstr ":meth:`~re.Pattern.subn` 方法完成相同的工作，但返回一个包含新字符串值和已执行的替换次数的 2 元组::"

#: ../../howto/regex.rst:1167
msgid ""
">>> p = re.compile('(blue|white|red)')\n"
">>> p.subn('colour', 'blue socks and red shoes')\n"
"('colour socks and colour shoes', 2)\n"
">>> p.subn('colour', 'no colours at all')\n"
"('no colours at all', 0)"
msgstr ""
">>> p = re.compile('(blue|white|red)')\n"
">>> p.subn('colour', 'blue socks and red shoes')\n"
"('colour socks and colour shoes', 2)\n"
">>> p.subn('colour', 'no colours at all')\n"
"('no colours at all', 0)"

#: ../../howto/regex.rst:1173
msgid ""
"Empty matches are replaced only when they're not adjacent to a previous "
"empty match. ::"
msgstr "仅当空匹配与前一个空匹配不相邻时，才会替换空匹配。::"

#: ../../howto/regex.rst:1176
msgid ""
">>> p = re.compile('x*')\n"
">>> p.sub('-', 'abxd')\n"
"'-a-b--d-'"
msgstr ""
">>> p = re.compile('x*')\n"
">>> p.sub('-', 'abxd')\n"
"'-a-b--d-'"

#: ../../howto/regex.rst:1180
msgid ""
"If *replacement* is a string, any backslash escapes in it are processed.  "
"That is, ``\\n`` is converted to a single newline character, ``\\r`` is "
"converted to a carriage return, and so forth. Unknown escapes such as "
"``\\&`` are left alone. Backreferences, such as ``\\6``, are replaced with "
"the substring matched by the corresponding group in the RE.  This lets you "
"incorporate portions of the original text in the resulting replacement "
"string."
msgstr ""
"如果 *replacement* 是一个字符串，则处理其中的任何反斜杠转义。 也就是说，``\\n`` 被转换为单个换行符，``\\r`` "
"被转换为回车符，依此类推。 诸如 ``\\&`` 之类的未知转义是孤立的。 后向引用，例如 ``\\6``，被替换为正则中相应组匹配的子字符串。 "
"这使你可以在生成的替换字符串中合并原始文本的部分内容。"

#: ../../howto/regex.rst:1187
msgid ""
"This example matches the word ``section`` followed by a string enclosed in "
"``{``, ``}``, and changes ``section`` to ``subsection``::"
msgstr ""
"这个例子匹配单词 ``section`` 后跟一个用 ``{``，``}`` 括起来的字符串，并将 ``section`` 改为 "
"``subsection`` ::"

#: ../../howto/regex.rst:1190
msgid ""
">>> p = re.compile('section{ ( [^}]* ) }', re.VERBOSE)\n"
">>> p.sub(r'subsection{\\1}','section{First} section{second}')\n"
"'subsection{First} subsection{second}'"
msgstr ""
">>> p = re.compile('section{ ( [^}]* ) }', re.VERBOSE)\n"
">>> p.sub(r'subsection{\\1}','section{First} section{second}')\n"
"'subsection{First} subsection{second}'"

#: ../../howto/regex.rst:1194
msgid ""
"There's also a syntax for referring to named groups as defined by the "
"``(?P<name>...)`` syntax.  ``\\g<name>`` will use the substring matched by "
"the group named ``name``, and  ``\\g<number>``  uses the corresponding group"
" number. ``\\g<2>`` is therefore equivalent to ``\\2``,  but isn't ambiguous"
" in a replacement string such as ``\\g<2>0``.  (``\\20`` would be "
"interpreted as a reference to group 20, not a reference to group 2 followed "
"by the literal character ``'0'``.)  The following substitutions are all "
"equivalent, but use all three variations of the replacement string. ::"
msgstr ""
"还有一种语法用于引用由 ``(?P<name>...)`` 语法定义的命名组。 ``\\g<name>`` 将使用名为 ``name`` "
"的组匹配的子字符串，``\\g<number>`` 使用相应的组号。 因此 ``\\g<2>`` 等同于 ``\\2``，但在诸如 "
"``\\g<2>0`` 之类的替换字符串中并不模糊。 (``\\20`` 将被解释为对组 20 的引用，而不是对组 2 的引用，后跟字面字符 "
"``'0'``。) 以下替换都是等效的，但使用所有三种变体替换字符串。::"

#: ../../howto/regex.rst:1203
msgid ""
">>> p = re.compile('section{ (?P<name> [^}]* ) }', re.VERBOSE)\n"
">>> p.sub(r'subsection{\\1}','section{First}')\n"
"'subsection{First}'\n"
">>> p.sub(r'subsection{\\g<1>}','section{First}')\n"
"'subsection{First}'\n"
">>> p.sub(r'subsection{\\g<name>}','section{First}')\n"
"'subsection{First}'"
msgstr ""
">>> p = re.compile('section{ (?P<name> [^}]* ) }', re.VERBOSE)\n"
">>> p.sub(r'subsection{\\1}','section{First}')\n"
"'subsection{First}'\n"
">>> p.sub(r'subsection{\\g<1>}','section{First}')\n"
"'subsection{First}'\n"
">>> p.sub(r'subsection{\\g<name>}','section{First}')\n"
"'subsection{First}'"

#: ../../howto/regex.rst:1211
msgid ""
"*replacement* can also be a function, which gives you even more control.  If"
" *replacement* is a function, the function is called for every non-"
"overlapping occurrence of *pattern*.  On each call, the function is passed a"
" :ref:`match object <match-objects>` argument for the match and can use this"
" information to compute the desired replacement string and return it."
msgstr ""
"*replacement* 也可以是一个函数，它可以为你提供更多控制。 如果 *replacement* 是一个函数，则为 *pattern* "
"的每次非重叠出现将调用该函数。 在每次调用时，函数都会传递一个匹配的 :ref:`匹配对象 <match-objects>` "
"参数，并可以使用此信息计算所需的替换字符串并将其返回。"

#: ../../howto/regex.rst:1217
msgid ""
"In the following example, the replacement function translates decimals into "
"hexadecimal::"
msgstr "在以下示例中，替换函数将小数转换为十六进制::"

#: ../../howto/regex.rst:1220
msgid ""
">>> def hexrepl(match):\n"
"...     \"Return the hex string for a decimal number\"\n"
"...     value = int(match.group())\n"
"...     return hex(value)\n"
"...\n"
">>> p = re.compile(r'\\d+')\n"
">>> p.sub(hexrepl, 'Call 65490 for printing, 49152 for user code.')\n"
"'Call 0xffd2 for printing, 0xc000 for user code.'"
msgstr ""
">>> def hexrepl(match):\n"
"...     \"返回十进制数字的十六进制字符串\"\n"
"...     value = int(match.group())\n"
"...     return hex(value)\n"
"...\n"
">>> p = re.compile(r'\\d+')\n"
">>> p.sub(hexrepl, 'Call 65490 for printing, 49152 for user code.')\n"
"'Call 0xffd2 for printing, 0xc000 for user code.'"

#: ../../howto/regex.rst:1229
msgid ""
"When using the module-level :func:`re.sub` function, the pattern is passed "
"as the first argument.  The pattern may be provided as an object or as a "
"string; if you need to specify regular expression flags, you must either use"
" a pattern object as the first parameter, or use embedded modifiers in the "
"pattern string, e.g. ``sub(\"(?i)b+\", \"x\", \"bbbb BBBB\")`` returns ``'x "
"x'``."
msgstr ""
"使用模块级别 :func:`re.sub` 函数时，模式作为第一个参数传递。 "
"模式可以是对象或字符串；如果需要指定正则表达式标志，则必须使用模式对象作为第一个参数，或者在模式字符串中使用嵌入式修饰符，例如: "
"``sub(\"(?i)b+\", \"x\", \"bbbb BBBB\")`` 返回 ``'x x'``。"

#: ../../howto/regex.rst:1237
msgid "Common Problems"
msgstr "常见问题"

#: ../../howto/regex.rst:1239
msgid ""
"Regular expressions are a powerful tool for some applications, but in some "
"ways their behaviour isn't intuitive and at times they don't behave the way "
"you may expect them to.  This section will point out some of the most common"
" pitfalls."
msgstr ""
"正则表达式对于某些应用程序来说是一个强大的工具，但在某些方面，它们的行为并不直观，有时它们的行为方式与你的预期不同。 本节将指出一些最常见的陷阱。"

#: ../../howto/regex.rst:1245
msgid "Use String Methods"
msgstr "使用字符串方法"

#: ../../howto/regex.rst:1247
msgid ""
"Sometimes using the :mod:`re` module is a mistake.  If you're matching a "
"fixed string, or a single character class, and you're not using any "
":mod:`re` features such as the :const:`~re.IGNORECASE` flag, then the full "
"power of regular expressions may not be required. Strings have several "
"methods for performing operations with fixed strings and they're usually "
"much faster, because the implementation is a single small C loop that's been"
" optimized for the purpose, instead of the large, more generalized regular "
"expression engine."
msgstr ""
"有时使用 :mod:`re` 模块是一个错误。 如果你匹配固定字符串或单个字符类，并且你没有使用任何 :mod:`re` 功能，例如 "
":const:`~re.IGNORECASE` 标志，那么正则表达式的全部功能可能不是必需的。 "
"字符串有几种方法可以使用固定字符串执行操作，它们通常要快得多，因为实现是一个针对此目的而优化的单个小 C 循环，而不是大型、更通用的正则表达式引擎。"

#: ../../howto/regex.rst:1255
msgid ""
"One example might be replacing a single fixed string with another one; for "
"example, you might replace ``word`` with ``deed``.  :func:`re.sub` seems "
"like the function to use for this, but consider the :meth:`~str.replace` "
"method.  Note that :meth:`!replace` will also replace ``word`` inside words,"
" turning ``swordfish`` into ``sdeedfish``, but the  naive RE ``word`` would "
"have done that, too.  (To avoid performing the substitution on parts of "
"words, the pattern would have to be ``\\bword\\b``, in order to require that"
" ``word`` have a word boundary on either side.  This takes the job beyond  "
":meth:`!replace`'s abilities.)"
msgstr ""
"一个例子可能是用另一个固定字符串替换一个固定字符串；例如，你可以用 ``deed`` 替换 ``word`` 。 :func:`re.sub` "
"看起来像是用于此的函数，但请考虑 :meth:`~str.replace` 方法。 注意 :meth:`!replace` 也会替换单词里面的 "
"``word`` ，把 ``swordfish`` 变成 ``sdeedfish`` ，但简单的正则 ``word`` 也会这样做。 "
"（为了避免对单词的部分进行替换，模式必须是 ``\\bword\\b``，以便要求 ``word`` 在任何一方都有一个单词边界。这使得工作超出了 "
":meth:`!replace` 的能力。）"

#: ../../howto/regex.rst:1264
msgid ""
"Another common task is deleting every occurrence of a single character from "
"a string or replacing it with another single character.  You might do this "
"with something like ``re.sub('\\n', ' ', S)``, but :meth:`~str.translate` is"
" capable of doing both tasks and will be faster than any regular expression "
"operation can be."
msgstr ""
"另一个常见任务是从字符串中删除单个字符的每个匹配项或将其替换为另一个字符。 你可以用 ``re.sub('\\n', ' ', S)`` "
"之类的东西来做这件事，但是 :meth:`~str.translate` 能够完成这两项任务，并且比任何正则表达式都快。"

#: ../../howto/regex.rst:1270
msgid ""
"In short, before turning to the :mod:`re` module, consider whether your "
"problem can be solved with a faster and simpler string method."
msgstr "简而言之，在转向 :mod:`re` 模块之前，请考虑是否可以使用更快更简单的字符串方法解决问题。"

#: ../../howto/regex.rst:1275
msgid "match() versus search()"
msgstr "match() 和 search()"

#: ../../howto/regex.rst:1277
msgid ""
"The :func:`~re.match` function only checks if the RE matches at the "
"beginning of the string while :func:`~re.search` will scan forward through "
"the string for a match. It's important to keep this distinction in mind.  "
"Remember,  :func:`!match` will only report a successful match which will "
"start at 0; if the match wouldn't start at zero,  :func:`!match` will *not* "
"report it. ::"
msgstr ""
" :func:`~re.match` 函数只检查正则能否在字符串起始位置上找到匹配项，而 :func:`~re.search` "
"将向前扫描整个字符串的所有位置查找匹配项。 记住这一区别非常重要。 记住， :func:`!match` "
"仅会返回起始于位置0的匹配项；如果匹配不是起始于位置0，则 :func:`!match`  *不会* 返回。::"

#: ../../howto/regex.rst:1283
msgid ""
">>> print(re.match('super', 'superstition').span())\n"
"(0, 5)\n"
">>> print(re.match('super', 'insuperable'))\n"
"None"
msgstr ""
">>> print(re.match('super', 'superstition').span())\n"
"(0, 5)\n"
">>> print(re.match('super', 'insuperable'))\n"
"None"

#: ../../howto/regex.rst:1288
msgid ""
"On the other hand, :func:`~re.search` will scan forward through the string, "
"reporting the first match it finds. ::"
msgstr "另一方面， :func:`~re.search` 将向前扫描字符串，报告它找到的第一个匹配项。::"

#: ../../howto/regex.rst:1291
msgid ""
">>> print(re.search('super', 'superstition').span())\n"
"(0, 5)\n"
">>> print(re.search('super', 'insuperable').span())\n"
"(2, 7)"
msgstr ""
">>> print(re.search('super', 'superstition').span())\n"
"(0, 5)\n"
">>> print(re.search('super', 'insuperable').span())\n"
"(2, 7)"

#: ../../howto/regex.rst:1296
msgid ""
"Sometimes you'll be tempted to keep using :func:`re.match`, and just add "
"``.*`` to the front of your RE.  Resist this temptation and use "
":func:`re.search` instead.  The regular expression compiler does some "
"analysis of REs in order to speed up the process of looking for a match.  "
"One such analysis figures out what the first character of a match must be; "
"for example, a pattern starting with ``Crow`` must match starting with a "
"``'C'``.  The analysis lets the engine quickly scan through the string "
"looking for the starting character, only trying the full match if a ``'C'`` "
"is found."
msgstr ""
"有时你会被诱惑继续使用 :func:`re.match` ，只需在你的正则前面添加 ``.*`` 。抵制这种诱惑并使用 "
":func:`re.search` 代替。 正则表达式编译器对正则进行一些分析，以加快寻找匹配的过程。 "
"其中一个分析可以确定匹配的第一个特征必须是什么；例如，以 ``Crow`` 开头的模式必须与 ``'C'`` 匹配。 "
"分析让引擎快速扫描字符串，寻找起始字符，只在找到 ``'C'`` 时尝试完全匹配。"

#: ../../howto/regex.rst:1305
msgid ""
"Adding ``.*`` defeats this optimization, requiring scanning to the end of "
"the string and then backtracking to find a match for the rest of the RE.  "
"Use :func:`re.search` instead."
msgstr ""
"添加 ``.*`` 会使这个优化失效，需要扫描到字符串的末尾，然后回溯以找到正则的其余部分的匹配。 使用 :func:`re.search` 代替。"

#: ../../howto/regex.rst:1311
msgid "Greedy versus Non-Greedy"
msgstr "贪婪与非贪婪"

#: ../../howto/regex.rst:1313
msgid ""
"When repeating a regular expression, as in ``a*``, the resulting action is "
"to consume as much of the pattern as possible.  This fact often bites you "
"when you're trying to match a pair of balanced delimiters, such as the angle"
" brackets surrounding an HTML tag.  The naive pattern for matching a single "
"HTML tag doesn't work because of the greedy nature of ``.*``. ::"
msgstr ""
"当重复一个正则表达式时，就像在 ``a*`` 中一样，最终的动作就是消耗尽可能多的模式。 当你尝试匹配一对对称分隔符，例如 HTML "
"标记周围的尖括号时，这个事实经常会让你感到困惑。因为 ``.*`` 的贪婪性质， 用于匹配单个 HTML 标记的简单模式不起作用。 ::"

#: ../../howto/regex.rst:1319
msgid ""
">>> s = '<html><head><title>Title</title>'\n"
">>> len(s)\n"
"32\n"
">>> print(re.match('<.*>', s).span())\n"
"(0, 32)\n"
">>> print(re.match('<.*>', s).group())\n"
"<html><head><title>Title</title>"
msgstr ""
">>> s = '<html><head><title>Title</title>'\n"
">>> len(s)\n"
"32\n"
">>> print(re.match('<.*>', s).span())\n"
"(0, 32)\n"
">>> print(re.match('<.*>', s).group())\n"
"<html><head><title>Title</title>"

#: ../../howto/regex.rst:1327
msgid ""
"The RE matches the ``'<'`` in ``'<html>'``, and the ``.*`` consumes the rest"
" of the string.  There's still more left in the RE, though, and the ``>`` "
"can't match at the end of the string, so the regular expression engine has "
"to backtrack character by character until it finds a match for the ``>``.   "
"The final match extends from the ``'<'`` in ``'<html>'`` to the ``'>'`` in "
"``'</title>'``, which isn't what you want."
msgstr ""
"正则匹配 ``'<'`` 中的 ``'<html>'`` 和 ``.*`` 消耗字符串的其余部分。 正则中还有更多的剩余东西，并且 ``>`` "
"在字符串的末尾不能匹配，所以正则表达式引擎必须逐个字符地回溯，直到它找到匹配 ``>`` 。最终匹配从 ``'<html>'`` 中的 ``'<'`` "
"扩展到 ``'</title>'`` 中的 ``'>'`` ，而这并不是你想要的结果。"

#: ../../howto/regex.rst:1334
msgid ""
"In this case, the solution is to use the non-greedy quantifiers ``*?``, "
"``+?``, ``??``, or ``{m,n}?``, which match as *little* text as possible.  In"
" the above example, the ``'>'`` is tried immediately after the first ``'<'``"
" matches, and when it fails, the engine advances a character at a time, "
"retrying the ``'>'`` at every step.  This produces just the right result::"
msgstr ""
"在这种情况下，解决方案是使用非贪婪限定符 ``*?``, ``+?``, ``??`` 或 ``{m,n}?``，它们会匹配尽可能 *少的* 文本。 "
"在上面的例子中，``'>'`` 会在第一个 ``'<'`` 匹配后被立即尝试，而当匹配失败时，引擎将每次前进一个字符，并在每一步重试 ``'>'``。 "
"这将产生正确的结果::"

#: ../../howto/regex.rst:1340
msgid ""
">>> print(re.match('<.*?>', s).group())\n"
"<html>"
msgstr ""
">>> print(re.match('<.*?>', s).group())\n"
"<html>"

#: ../../howto/regex.rst:1343
msgid ""
"(Note that parsing HTML or XML with regular expressions is painful. Quick-"
"and-dirty patterns will handle common cases, but HTML and XML have special "
"cases that will break the obvious regular expression; by the time you've "
"written a regular expression that handles all of the possible cases, the "
"patterns will be *very* complicated.  Use an HTML or XML parser module for "
"such tasks.)"
msgstr ""
"（请注意，使用正则表达式解析 HTML 或 XML 很痛苦。快而脏的模式将处理常见情况，但 HTML 和 XML "
"有特殊情况会破坏明显的正则表达式；当你编写正则表达式处理所有可能的情况时，模式将非常复杂。使用 HTML 或 XML 解析器模块来执行此类任务。）"

#: ../../howto/regex.rst:1351
msgid "Using re.VERBOSE"
msgstr "使用 re.VERBOSE"

#: ../../howto/regex.rst:1353
msgid ""
"By now you've probably noticed that regular expressions are a very compact "
"notation, but they're not terribly readable.  REs of moderate complexity can"
" become lengthy collections of backslashes, parentheses, and metacharacters,"
" making them difficult to read and understand."
msgstr ""
"到目前为止，你可能已经注意到正则表达式是一种非常紧凑的表示法，但它们并不是非常易读。 "
"具有中等复杂度的正则可能会成为反斜杠、括号和元字符的冗长集合，使其难以阅读和理解。"

#: ../../howto/regex.rst:1358
msgid ""
"For such REs, specifying the :const:`re.VERBOSE` flag when compiling the "
"regular expression can be helpful, because it allows you to format the "
"regular expression more clearly."
msgstr "对于这样的正则，在编译正则表达式时指定 :const:`re.VERBOSE` 标志可能会有所帮助，因为它允许你更清楚地格式化正则表达式。"

#: ../../howto/regex.rst:1362
msgid ""
"The ``re.VERBOSE`` flag has several effects.  Whitespace in the regular "
"expression that *isn't* inside a character class is ignored.  This means "
"that an expression such as ``dog | cat`` is equivalent to the less readable "
"``dog|cat``, but ``[a b]`` will still match the characters ``'a'``, ``'b'``,"
" or a space.  In addition, you can also put comments inside a RE; comments "
"extend from a ``#`` character to the next newline.  When used with triple-"
"quoted strings, this enables REs to be formatted more neatly::"
msgstr ""
"``re.VERBOSE`` 标志有几种效果。 正则表达式中的 *不是* 在字符类中的空格将被忽略。 这意味着表达式如 ``dog | cat`` "
"等同于不太可读的 ``dog|cat`` ，但 ``[a b]`` 仍将匹配字符 ``'a'`` 、 ``'b'`` 或空格。 "
"此外，你还可以在正则中放置注释；注释从 ``#`` 字符扩展到下一个换行符。 当与三引号字符串一起使用时，这使正则的格式更加整齐::"

#: ../../howto/regex.rst:1370
msgid ""
"pat = re.compile(r\"\"\"\n"
" \\s*                 # Skip leading whitespace\n"
" (?P<header>[^:]+)   # Header name\n"
" \\s* :               # Whitespace, and a colon\n"
" (?P<value>.*?)      # The header's value -- *? used to\n"
"                     # lose the following trailing whitespace\n"
" \\s*$                # Trailing whitespace to end-of-line\n"
"\"\"\", re.VERBOSE)"
msgstr ""
"pat = re.compile(r\"\"\"\n"
" \\s*                 # Skip leading whitespace\n"
" (?P<header>[^:]+)   # Header name\n"
" \\s* :               # Whitespace, and a colon\n"
" (?P<value>.*?)      # The header's value -- *? used to\n"
"                     # lose the following trailing whitespace\n"
" \\s*$                # Trailing whitespace to end-of-line\n"
"\"\"\", re.VERBOSE)"

#: ../../howto/regex.rst:1379
msgid "This is far more readable than::"
msgstr "这更具有可读性::"

#: ../../howto/regex.rst:1381
msgid "pat = re.compile(r\"\\s*(?P<header>[^:]+)\\s*:(?P<value>.*?)\\s*$\")"
msgstr "pat = re.compile(r\"\\s*(?P<header>[^:]+)\\s*:(?P<value>.*?)\\s*$\")"

#: ../../howto/regex.rst:1385
msgid "Feedback"
msgstr "反馈"

#: ../../howto/regex.rst:1387
msgid ""
"Regular expressions are a complicated topic.  Did this document help you "
"understand them?  Were there parts that were unclear, or Problems you "
"encountered that weren't covered here?  If so, please send suggestions for "
"improvements to the author."
msgstr ""
"正则表达式是一个复杂的主题。 这份文档是否有助于你理解它们？ 是否存在不清楚的部分，或者你遇到的问题未在此处涉及？ 如果是，请向作者发送改进建议。"

#: ../../howto/regex.rst:1392
msgid ""
"The most complete book on regular expressions is almost certainly Jeffrey "
"Friedl's Mastering Regular Expressions, published by O'Reilly.  "
"Unfortunately, it exclusively concentrates on Perl and Java's flavours of "
"regular expressions, and doesn't contain any Python material at all, so it "
"won't be useful as a reference for programming in Python.  (The first "
"edition covered Python's now-removed :mod:`!regex` module, which won't help "
"you much.)  Consider checking it out from your library."
msgstr ""
"关于正则表达式的最完整的书几乎肯定是由 O'Reilly 出版的 Jeffrey Friedl 的 Mastering Regular "
"Expressions 。 不幸的是，它专注于 Perl 和 Java 的正则表达式，并且根本不包含任何 Python 材料，因此它不能用作 "
"Python 编程的参考。 （第一版涵盖了 Python 现在删除的 :mod:`!regex` 模块，这对你没有多大帮助。）考虑从你的图书馆中查找它。"
