# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 汇民 王 <whuim@qq.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 14:21+0000\n"
"PO-Revision-Date: 2025-07-18 18:48+0000\n"
"Last-Translator: 汇民 王 <whuim@qq.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/free-threading-extensions.rst:7
msgid "C API Extension Support for Free Threading"
msgstr "自由线程的 C API 扩展支持"

#: ../../howto/free-threading-extensions.rst:9
msgid ""
"Starting with the 3.13 release, CPython has support for running with the "
":term:`global interpreter lock` (GIL) disabled in a configuration called "
":term:`free threading`.  This document describes how to adapt C API "
"extensions to support free threading."
msgstr ""
"从 3.13 发布版开始，CPython 通过名为 :term:`free threading` 的配置引入了对于运行时禁用 :term:`global"
" interpreter lock` (GIL) 的支持。 这份文档描述了如何调整 C API 扩展以支持自由线程。"

#: ../../howto/free-threading-extensions.rst:16
msgid "Identifying the Free-Threaded Build in C"
msgstr "在 C 中识别自由线程构建"

#: ../../howto/free-threading-extensions.rst:18
msgid ""
"The CPython C API exposes the ``Py_GIL_DISABLED`` macro: in the free-"
"threaded build it's defined to ``1``, and in the regular build it's not "
"defined. You can use it to enable code that only runs under the free-"
"threaded build::"
msgstr ""
"CPython C API 提供了 ``Py_GIL_DISABLED`` 宏，它在自由线程构建中被定义为 "
"``1``，而在常规构建中未被定义。你可以使用它让代码仅在自由线程构建中运行："

#: ../../howto/free-threading-extensions.rst:22
msgid ""
"#ifdef Py_GIL_DISABLED\n"
"/* code that only runs in the free-threaded build */\n"
"#endif"
msgstr ""
"#ifdef Py_GIL_DISABLED\n"
"/* 仅在自由线程构建版中运行的代码 */\n"
"#endif"

#: ../../howto/free-threading-extensions.rst:28
msgid ""
"On Windows, this macro is not defined automatically, but must be specified "
"to the compiler when building. The :func:`sysconfig.get_config_var` function"
" can be used to determine whether the current running interpreter had the "
"macro defined."
msgstr ""
"在 Windows 上，该宏不会被自动定义，而必须在构建时向编译器指明。 :func:`sysconfig.get_config_var` "
"函数可被用来确定当前运行的解释器是否定义了该宏。"

#: ../../howto/free-threading-extensions.rst:35
msgid "Module Initialization"
msgstr "模块初始化"

#: ../../howto/free-threading-extensions.rst:37
msgid ""
"Extension modules need to explicitly indicate that they support running with"
" the GIL disabled; otherwise importing the extension will raise a warning "
"and enable the GIL at runtime."
msgstr "扩展模块需要明确指明它们支持在禁用 GIL 的情况下运行；否则导入扩展模块时会引发警告，并在运行时启用 GIL。"

#: ../../howto/free-threading-extensions.rst:41
msgid ""
"There are two ways to indicate that an extension module supports running "
"with the GIL disabled depending on whether the extension uses multi-phase or"
" single-phase initialization."
msgstr "取决于扩展使用多阶段还是单阶段初始化，有两种方式指明扩展模块支持在 GIL 禁用的情况下运行。"

#: ../../howto/free-threading-extensions.rst:46
msgid "Multi-Phase Initialization"
msgstr "多阶段初始化"

#: ../../howto/free-threading-extensions.rst:48
msgid ""
"Extensions that use multi-phase initialization (i.e., "
":c:func:`PyModuleDef_Init`) should add a :c:data:`Py_mod_gil` slot in the "
"module definition.  If your extension supports older versions of CPython, "
"you should guard the slot with a :c:data:`PY_VERSION_HEX` check."
msgstr ""
"使用多阶段初始化（例如 :c:func:`PyModuleDef_Init`）的扩展应该在模块定义中添加 :c:data:`Py_mod_gil` "
"槽位。如果你的扩展需要支持更老版本的 CPython，请检查 :c:data:`PY_VERSION_HEX` 以保护槽位。"

#: ../../howto/free-threading-extensions.rst:55
msgid ""
"static struct PyModuleDef_Slot module_slots[] = {\n"
"    ...\n"
"#if PY_VERSION_HEX >= 0x030D0000\n"
"    {Py_mod_gil, Py_MOD_GIL_NOT_USED},\n"
"#endif\n"
"    {0, NULL}\n"
"};\n"
"\n"
"static struct PyModuleDef moduledef = {\n"
"    PyModuleDef_HEAD_INIT,\n"
"    .m_slots = module_slots,\n"
"    ...\n"
"};"
msgstr ""
"static struct PyModuleDef_Slot module_slots[] = {\n"
"    ...\n"
"#if PY_VERSION_HEX >= 0x030D0000\n"
"    {Py_mod_gil, Py_MOD_GIL_NOT_USED},\n"
"#endif\n"
"    {0, NULL}\n"
"};\n"
"\n"
"static struct PyModuleDef moduledef = {\n"
"    PyModuleDef_HEAD_INIT,\n"
"    .m_slots = module_slots,\n"
"    ...\n"
"};"

#: ../../howto/free-threading-extensions.rst:71
msgid "Single-Phase Initialization"
msgstr "单阶段初始化"

#: ../../howto/free-threading-extensions.rst:73
msgid ""
"Extensions that use single-phase initialization (i.e., "
":c:func:`PyModule_Create`) should call :c:func:`PyUnstable_Module_SetGIL` to"
" indicate that they support running with the GIL disabled.  The function is "
"only defined in the free-threaded build, so you should guard the call with "
"``#ifdef Py_GIL_DISABLED`` to avoid compilation errors in the regular build."
msgstr ""
"使用单阶段初始化（即 :c:func:`PyModule_Create`）的扩展应该调用 "
":c:func:`PyUnstable_Module_SetGIL` 来表明它们支持在禁用 GIL "
"的情况下运行。该函数只在自由线程构建中被定义，因此应使用 ``#ifdef Py_GIL_DISABLED`` "
"来保护调用，以避免在常规构建中出现编译错误。"

#: ../../howto/free-threading-extensions.rst:81
msgid ""
"static struct PyModuleDef moduledef = {\n"
"    PyModuleDef_HEAD_INIT,\n"
"    ...\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_mymodule(void)\n"
"{\n"
"    PyObject *m = PyModule_Create(&moduledef);\n"
"    if (m == NULL) {\n"
"        return NULL;\n"
"    }\n"
"#ifdef Py_GIL_DISABLED\n"
"    PyUnstable_Module_SetGIL(m, Py_MOD_GIL_NOT_USED);\n"
"#endif\n"
"    return m;\n"
"}"
msgstr ""
"static struct PyModuleDef moduledef = {\n"
"    PyModuleDef_HEAD_INIT,\n"
"    ...\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_mymodule(void)\n"
"{\n"
"    PyObject *m = PyModule_Create(&moduledef);\n"
"    if (m == NULL) {\n"
"        return NULL;\n"
"    }\n"
"#ifdef Py_GIL_DISABLED\n"
"    PyUnstable_Module_SetGIL(m, Py_MOD_GIL_NOT_USED);\n"
"#endif\n"
"    return m;\n"
"}"

#: ../../howto/free-threading-extensions.rst:101
msgid "General API Guidelines"
msgstr "通用 API 指南"

#: ../../howto/free-threading-extensions.rst:103
msgid "Most of the C API is thread-safe, but there are some exceptions."
msgstr "大多数 C API 是线程安全的，但是也存在例外。"

#: ../../howto/free-threading-extensions.rst:105
msgid ""
"**Struct Fields**: Accessing fields in Python C API objects or structs "
"directly is not thread-safe if the field may be concurrently modified."
msgstr "**结构字段**：如果 Python C API 对象或结构的字段可能被并行修改，那么直接访问这些字段不是线程安全的。"

#: ../../howto/free-threading-extensions.rst:107
msgid ""
"**Macros**: Accessor macros like :c:macro:`PyList_GET_ITEM`, "
":c:macro:`PyList_SET_ITEM`, and macros like "
":c:macro:`PySequence_Fast_GET_SIZE` that use the object returned by "
":c:func:`PySequence_Fast` do not perform any error checking or locking. "
"These macros are not thread-safe if the container object may be modified "
"concurrently."
msgstr ""
"**宏**: 访问器宏如 :c:macro:`PyList_GET_ITEM`, :c:macro:`PyList_SET_ITEM`，以及 "
":c:macro:`PySequence_Fast_GET_SIZE` 这样使用由 :c:func:`PySequence_Fast` "
"返回的对象的宏不会进行任何错误检查或加锁。 当容器对象可能被并行修改时这些宏不是线程安全的。"

#: ../../howto/free-threading-extensions.rst:113
msgid ""
"**Borrowed References**: C API functions that return :term:`borrowed "
"references <borrowed reference>` may not be thread-safe if the containing "
"object is modified concurrently.  See the section on :ref:`borrowed "
"references <borrowed-references>` for more information."
msgstr ""
"**借入引用**：返回 :term:`借入引用 <borrowed reference>` 的  C API "
"函数如果引用内容可能被并行修改，那么它不是线程安全的。详见 :ref:`借入引用 <borrowed-references>`。"

#: ../../howto/free-threading-extensions.rst:120
msgid "Container Thread Safety"
msgstr "容器相关的线程安全"

#: ../../howto/free-threading-extensions.rst:122
msgid ""
"Containers like :c:struct:`PyListObject`, :c:struct:`PyDictObject`, and "
":c:struct:`PySetObject` perform internal locking in the free-threaded build."
"  For example, the :c:func:`PyList_Append` will lock the list before "
"appending an item."
msgstr ""
":c:struct:`PyListObject`, :c:struct:`PyDictObject` 及 :c:struct:`PySetObject`"
" 等容器在自由线程构建中执行内部上锁机制，例如 :c:func:`PyList_Append` 在追加对象前会对列表上锁。"

#: ../../howto/free-threading-extensions.rst:130
msgid "``PyDict_Next``"
msgstr "``PyDict_Next``"

#: ../../howto/free-threading-extensions.rst:132
msgid ""
"A notable exception is :c:func:`PyDict_Next`, which does not lock the "
"dictionary.  You should use :c:macro:`Py_BEGIN_CRITICAL_SECTION` to protect "
"the dictionary while iterating over it if the dictionary may be concurrently"
" modified::"
msgstr ""
"一个值得注意的例外是 :c:func:`PyDict_Next`，它不会锁定目录。 在迭代目录时如果该目录可能被并发地修改那么你应当使用 "
":c:macro:`Py_BEGIN_CRITICAL_SECTION` 来保护它::"

#: ../../howto/free-threading-extensions.rst:137
msgid ""
"Py_BEGIN_CRITICAL_SECTION(dict);\n"
"PyObject *key, *value;\n"
"Py_ssize_t pos = 0;\n"
"while (PyDict_Next(dict, &pos, &key, &value)) {\n"
"    ...\n"
"}\n"
"Py_END_CRITICAL_SECTION();"
msgstr ""
"Py_BEGIN_CRITICAL_SECTION(dict);\n"
"PyObject *key, *value;\n"
"Py_ssize_t pos = 0;\n"
"while (PyDict_Next(dict, &pos, &key, &value)) {\n"
"    ...\n"
"}\n"
"Py_END_CRITICAL_SECTION();"

#: ../../howto/free-threading-extensions.rst:147
msgid "Borrowed References"
msgstr "借入引用"

#: ../../howto/free-threading-extensions.rst:151
msgid ""
"Some C API functions return :term:`borrowed references <borrowed "
"reference>`. These APIs are not thread-safe if the containing object is "
"modified concurrently.  For example, it's not safe to use "
":c:func:`PyList_GetItem` if the list may be modified concurrently."
msgstr ""
"有些 C API 函数返回 :term:`borrowed references <borrowed "
"reference>`。如果引用内容可能被并行修改，那么这些 API 不是线程安全的。例如，如果列表可能被并行修改，那么使用 "
":c:func:`PyList_GetItem` 是不安全的。"

#: ../../howto/free-threading-extensions.rst:156
msgid ""
"The following table lists some borrowed reference APIs and their "
"replacements that return :term:`strong references <strong reference>`."
msgstr "下表列出了一些返回借入引用的 API 及它们返回 :term:`强引用 <strong reference>` 的替代版本。"

#: ../../howto/free-threading-extensions.rst:160
msgid "Borrowed reference API"
msgstr "借入引用 API"

#: ../../howto/free-threading-extensions.rst:160
msgid "Strong reference API"
msgstr "强引用 API"

#: ../../howto/free-threading-extensions.rst:162
msgid ":c:func:`PyList_GetItem`"
msgstr ":c:func:`PyList_GetItem`"

#: ../../howto/free-threading-extensions.rst:162
#: ../../howto/free-threading-extensions.rst:164
msgid ":c:func:`PyList_GetItemRef`"
msgstr ":c:func:`PyList_GetItemRef`"

#: ../../howto/free-threading-extensions.rst:164
msgid ":c:func:`PyList_GET_ITEM`"
msgstr ":c:func:`PyList_GET_ITEM`"

#: ../../howto/free-threading-extensions.rst:166
msgid ":c:func:`PyDict_GetItem`"
msgstr ":c:func:`PyDict_GetItem`"

#: ../../howto/free-threading-extensions.rst:166
#: ../../howto/free-threading-extensions.rst:168
msgid ":c:func:`PyDict_GetItemRef`"
msgstr ":c:func:`PyDict_GetItemRef`"

#: ../../howto/free-threading-extensions.rst:168
msgid ":c:func:`PyDict_GetItemWithError`"
msgstr ":c:func:`PyDict_GetItemWithError`"

#: ../../howto/free-threading-extensions.rst:170
msgid ":c:func:`PyDict_GetItemString`"
msgstr ":c:func:`PyDict_GetItemString`"

#: ../../howto/free-threading-extensions.rst:170
msgid ":c:func:`PyDict_GetItemStringRef`"
msgstr ":c:func:`PyDict_GetItemStringRef`"

#: ../../howto/free-threading-extensions.rst:172
msgid ":c:func:`PyDict_SetDefault`"
msgstr ":c:func:`PyDict_SetDefault`"

#: ../../howto/free-threading-extensions.rst:172
msgid ":c:func:`PyDict_SetDefaultRef`"
msgstr ":c:func:`PyDict_SetDefaultRef`"

#: ../../howto/free-threading-extensions.rst:174
msgid ":c:func:`PyDict_Next`"
msgstr ":c:func:`PyDict_Next`"

#: ../../howto/free-threading-extensions.rst:174
msgid "none (see :ref:`PyDict_Next`)"
msgstr "无 (参见 :ref:`PyDict_Next`)"

#: ../../howto/free-threading-extensions.rst:176
msgid ":c:func:`PyWeakref_GetObject`"
msgstr ":c:func:`PyWeakref_GetObject`"

#: ../../howto/free-threading-extensions.rst:176
#: ../../howto/free-threading-extensions.rst:178
msgid ":c:func:`PyWeakref_GetRef`"
msgstr ":c:func:`PyWeakref_GetRef`"

#: ../../howto/free-threading-extensions.rst:178
msgid ":c:func:`PyWeakref_GET_OBJECT`"
msgstr ":c:func:`PyWeakref_GET_OBJECT`"

#: ../../howto/free-threading-extensions.rst:180
msgid ":c:func:`PyImport_AddModule`"
msgstr ":c:func:`PyImport_AddModule`"

#: ../../howto/free-threading-extensions.rst:180
msgid ":c:func:`PyImport_AddModuleRef`"
msgstr ":c:func:`PyImport_AddModuleRef`"

#: ../../howto/free-threading-extensions.rst:182
msgid ":c:func:`PyCell_GET`"
msgstr ":c:func:`PyCell_GET`"

#: ../../howto/free-threading-extensions.rst:182
msgid ":c:func:`PyCell_Get`"
msgstr ":c:func:`PyCell_Get`"

#: ../../howto/free-threading-extensions.rst:185
msgid ""
"Not all APIs that return borrowed references are problematic.  For example, "
":c:func:`PyTuple_GetItem` is safe because tuples are immutable. Similarly, "
"not all uses of the above APIs are problematic.  For example, "
":c:func:`PyDict_GetItem` is often used for parsing keyword argument "
"dictionaries in function calls; those keyword argument dictionaries are "
"effectively private (not accessible by other threads), so using borrowed "
"references in that context is safe."
msgstr ""
"返回借用引用的 API 不一定都有问题。例如，:c:func:`PyTuple_GetItem` 是安全的，因为元组是不可变的。同样，上述 API "
"的使用不一定都有问题。 例如，:c:func:`PyDict_GetItem` "
"通常用于解析函数调用中的关键字参数字典；这些关键字参数字典实际上是私有（其他线程无法访问）的，因此在这种情况下使用借入引用是安全的。"

#: ../../howto/free-threading-extensions.rst:193
msgid ""
"Some of these functions were added in Python 3.13.  You can use the "
"`pythoncapi-compat <https://github.com/python/pythoncapi-compat>`_ package "
"to provide implementations of these functions for older Python versions."
msgstr ""
"上述函数中有的是在 Python 3.13 中添加的。在旧 Python 版本上您可以使用提供这些函数实现的 `pythoncapi-compat "
"<https://github.com/python/pythoncapi-compat>`_ 包。"

#: ../../howto/free-threading-extensions.rst:201
msgid "Memory Allocation APIs"
msgstr "内存分配 API"

#: ../../howto/free-threading-extensions.rst:203
msgid ""
"Python's memory management C API provides functions in three different "
":ref:`allocation domains <allocator-domains>`: \"raw\", \"mem\", and "
"\"object\". For thread-safety, the free-threaded build requires that only "
"Python objects are allocated using the object domain, and that all Python "
"object are allocated using that domain.  This differs from the prior Python "
"versions, where this was only a best practice and not a hard requirement."
msgstr ""
"Python 的内存管理 C API 提供了三个不同 :ref:`分配域 <allocator-domains>` 的函数: \"raw\", "
"\"mem\" 和 \"object\"。 为了保证线程安全，自由线程构建版要求只有 Python 对象使用 object 域来分配，并且所有 "
"Python 对象都应使用该域来分配。 这不同于之前的 Python 版本，因为在此之前这只是一个最佳实践而不是硬性要求。"

#: ../../howto/free-threading-extensions.rst:212
msgid ""
"Search for uses of :c:func:`PyObject_Malloc` in your extension and check "
"that the allocated memory is used for Python objects. Use "
":c:func:`PyMem_Malloc` to allocate buffers instead of "
":c:func:`PyObject_Malloc`."
msgstr ""
"搜索 :c:func:`PyObject_Malloc` 在您的扩展中的使用，并检查分配的内存是否用于 Python 对象。使用 "
":c:func:`PyMem_Malloc` 来分配缓冲区，而不是 :c:func:`PyObject_Malloc`。"

#: ../../howto/free-threading-extensions.rst:219
msgid "Thread State and GIL APIs"
msgstr "线程状态与 GIL API"

#: ../../howto/free-threading-extensions.rst:221
msgid ""
"Python provides a set of functions and macros to manage thread state and the"
" GIL, such as:"
msgstr "Python 提供了一系列函数和宏来管理线程状态和 GIL，例如："

#: ../../howto/free-threading-extensions.rst:224
msgid ":c:func:`PyGILState_Ensure` and :c:func:`PyGILState_Release`"
msgstr ":c:func:`PyGILState_Ensure` 与 :c:func:`PyGILState_Release`"

#: ../../howto/free-threading-extensions.rst:225
msgid ":c:func:`PyEval_SaveThread` and :c:func:`PyEval_RestoreThread`"
msgstr ":c:func:`PyEval_SaveThread` 与 :c:func:`PyEval_RestoreThread`"

#: ../../howto/free-threading-extensions.rst:226
msgid ":c:macro:`Py_BEGIN_ALLOW_THREADS` and :c:macro:`Py_END_ALLOW_THREADS`"
msgstr ":c:macro:`Py_BEGIN_ALLOW_THREADS` 与 :c:macro:`Py_END_ALLOW_THREADS`"

#: ../../howto/free-threading-extensions.rst:228
msgid ""
"These functions should still be used in the free-threaded build to manage "
"thread state even when the :term:`GIL` is disabled.  For example, if you "
"create a thread outside of Python, you must call :c:func:`PyGILState_Ensure`"
" before calling into the Python API to ensure that the thread has a valid "
"Python thread state."
msgstr ""
"即使 :term:`GIL` 被禁用，仍应在自由线程构建中使用这些函数管理线程状态。例如，如果在 Python 之外创建线程，则必须在调用 Python"
" API 前调用 :c:func:`PyGILState_Ensure`，以确保线程具有有效的 Python 线程状态。"

#: ../../howto/free-threading-extensions.rst:234
msgid ""
"You should continue to call :c:func:`PyEval_SaveThread` or "
":c:macro:`Py_BEGIN_ALLOW_THREADS` around blocking operations, such as I/O or"
" lock acquisitions, to allow other threads to run the :term:`cyclic garbage "
"collector <garbage collection>`."
msgstr ""
"你应该继续在阻塞操作（如输入/输出或获取锁）前调用 :c:func:`PyEval_SaveThread` 或 "
":c:macro:`Py_BEGIN_ALLOW_THREADS`，以允许其他线程运行 :term:`循环垃圾回收器 <garbage "
"collection>`。"

#: ../../howto/free-threading-extensions.rst:241
msgid "Protecting Internal Extension State"
msgstr "保护内部扩展状态"

#: ../../howto/free-threading-extensions.rst:243
msgid ""
"Your extension may have internal state that was previously protected by the "
"GIL.  You may need to add locking to protect this state.  The approach will "
"depend on your extension, but some common patterns include:"
msgstr "您的扩展可能有以前受 GIL 保护的内部状态。您可能需要上锁来保护内部状态。具体方法取决于您的扩展，但一些常见的模式包括："

#: ../../howto/free-threading-extensions.rst:247
msgid ""
"**Caches**: global caches are a common source of shared state.  Consider "
"using a lock to protect the cache or disabling it in the free-threaded build"
" if the cache is not critical for performance."
msgstr "**缓存**：全局缓存是共享状态的常见来源。如果缓存对性能并不重要，可考虑使用锁来保护缓存，或在自由线程构建中禁用缓存。"

#: ../../howto/free-threading-extensions.rst:250
msgid ""
"**Global State**: global state may need to be protected by a lock or moved "
"to thread local storage. C11 and C++11 provide the ``thread_local`` or "
"``_Thread_local`` for `thread-local storage "
"<https://en.cppreference.com/w/c/language/storage_duration>`_."
msgstr ""
"**全局状态**：全局状态可能需要用锁保护或移至线程本地存储。C11 和 C++11 提供了 ``thread_local`` 或 "
"``_Thread_local`` 用于 `线程本地存储 "
"<https://en.cppreference.com/w/c/language/storage_duration>`_。"

#: ../../howto/free-threading-extensions.rst:257
msgid "Critical Sections"
msgstr "关键节"

#: ../../howto/free-threading-extensions.rst:261
msgid ""
"In the free-threaded build, CPython provides a mechanism called \"critical "
"sections\" to protect data that would otherwise be protected by the GIL. "
"While extension authors may not interact with the internal critical section "
"implementation directly, understanding their behavior is crucial when using "
"certain C API functions or managing shared state in the free-threaded build."
msgstr ""
"在自由线程构建中，CPython提供了一种称为“临界区”的机制来保护原本由GIL保护的数据。虽然扩展作者可能不会直接与内部临界区实现交互，但在使用某些C"
" API函数或在自由线程构建中管理共享状态时，理解它们的行为是至关重要的。"

#: ../../howto/free-threading-extensions.rst:268
msgid "What Are Critical Sections?"
msgstr "什么是临界区？"

#: ../../howto/free-threading-extensions.rst:270
msgid ""
"Conceptually, critical sections act as a deadlock avoidance layer built on "
"top of simple mutexes. Each thread maintains a stack of active critical "
"sections. When a thread needs to acquire a lock associated with a critical "
"section (e.g., implicitly when calling a thread-safe C API function like "
":c:func:`PyDict_SetItem`, or explicitly using macros), it attempts to "
"acquire the underlying mutex."
msgstr ""
"从概念上讲，临界区充当建立在简单互斥锁之上的死锁避免层。 每个线程维护一个活动临界区堆栈。 当线程需要获取与临界区相关的锁时（例如，隐式调用线程安全的 "
"C API 函数时，如 :c:func:`PyDict_SetItem`，或显式使用宏），它会尝试获取底层互斥锁。"

#: ../../howto/free-threading-extensions.rst:278
msgid "Using Critical Sections"
msgstr "使用临界区"

#: ../../howto/free-threading-extensions.rst:280
msgid "The primary APIs for using critical sections are:"
msgstr "使用临界区的主要API有："

#: ../../howto/free-threading-extensions.rst:282
msgid ""
":c:macro:`Py_BEGIN_CRITICAL_SECTION` and :c:macro:`Py_END_CRITICAL_SECTION` "
"- For locking a single object"
msgstr ""
":c:macro:`Py_BEGIN_CRITICAL_SECTION` 和 :c:macro:`Py_END_CRITICAL_SECTION` - "
"用于锁定单个对象"

#: ../../howto/free-threading-extensions.rst:285
msgid ""
":c:macro:`Py_BEGIN_CRITICAL_SECTION2` and "
":c:macro:`Py_END_CRITICAL_SECTION2` - For locking two objects simultaneously"
msgstr ""
":c:macro:`Py_BEGIN_CRITICAL_SECTION2` 和 :c:macro:`Py_END_CRITICAL_SECTION2` "
"- 用于同时锁定两个对象"

#: ../../howto/free-threading-extensions.rst:288
msgid ""
"These macros must be used in matching pairs and must appear in the same C "
"scope, since they establish a new local scope.  These macros are no-ops in "
"non-free-threaded builds, so they can be safely added to code that needs to "
"support both build types."
msgstr ""
"这些宏必须成对使用，并且必须出现在同一个C作用域中，因为它们建立了一个新的局部作用域。这些宏在非自由线程构建中是无操作的，因此可以安全地将它们添加到需要支持两种构建类型的代码中。"

#: ../../howto/free-threading-extensions.rst:293
msgid ""
"A common use of a critical section would be to lock an object while "
"accessing an internal attribute of it.  For example, if an extension type "
"has an internal count field, you could use a critical section while reading "
"or writing that field::"
msgstr "临界区的一个常见用途是在访问对象的内部属性时锁定对象。例如，如果扩展类型有一个内部计数字段，你可以在读取或写入该字段时使用临界区::"

#: ../../howto/free-threading-extensions.rst:298
msgid ""
"// read the count, returns new reference to internal count value\n"
"PyObject *result;\n"
"Py_BEGIN_CRITICAL_SECTION(obj);\n"
"result = Py_NewRef(obj->count);\n"
"Py_END_CRITICAL_SECTION();\n"
"return result;\n"
"\n"
"// write the count, consumes reference from new_count\n"
"Py_BEGIN_CRITICAL_SECTION(obj);\n"
"obj->count = new_count;\n"
"Py_END_CRITICAL_SECTION();"
msgstr ""
"// 读取计数，返回对内部计数值的新引用\n"
"PyObject *result;\n"
"Py_BEGIN_CRITICAL_SECTION(obj);\n"
"result = Py_NewRef(obj->count);\n"
"Py_END_CRITICAL_SECTION();\n"
"return result;\n"
"\n"
"// 写入计数，从new_count中获取引用\n"
"Py_BEGIN_CRITICAL_SECTION(obj);\n"
"obj->count = new_count;\n"
"Py_END_CRITICAL_SECTION();"

#: ../../howto/free-threading-extensions.rst:312
msgid "How Critical Sections Work"
msgstr "临界区如何运作"

#: ../../howto/free-threading-extensions.rst:314
msgid ""
"Unlike traditional locks, critical sections do not guarantee exclusive "
"access throughout their entire duration. If a thread would block while "
"holding a critical section (e.g., by acquiring another lock or performing "
"I/O), the critical section is temporarily suspended—all locks are "
"released—and then resumed when the blocking operation completes."
msgstr ""
"与传统锁不同，临界区不能保证在其整个持续时间内的独占访问。如果线程在持有临界区时阻塞（例如，通过获取另一个锁或执行I/O），则临界区被暂时挂起——所有锁被释放——然后在阻塞操作完成时恢复。"

#: ../../howto/free-threading-extensions.rst:320
msgid ""
"This behavior is similar to what happens with the GIL when a thread makes a "
"blocking call. The key differences are:"
msgstr "此行为类似于当线程执行阻塞型调用时 GIL 的行为。 主要的区别在于："

#: ../../howto/free-threading-extensions.rst:323
msgid "Critical sections operate on a per-object basis rather than globally"
msgstr "关键节的运作是基于每个对象的而不是全局的"

#: ../../howto/free-threading-extensions.rst:325
msgid ""
"Critical sections follow a stack discipline within each thread (the "
"\"begin\" and \"end\" macros enforce this since they must be paired and "
"within the same scope)"
msgstr "关键节遵循设置于每个线程内部的纪律栈（\"begin\" 和 \"end\" 宏将应用该纪律栈，因为它们必须成对出现并位于相同作用域中）"

#: ../../howto/free-threading-extensions.rst:328
msgid ""
"Critical sections automatically release and reacquire locks around potential"
" blocking operations"
msgstr "关键节会针对潜在的阻塞型操作自动释放和重新获取锁"

#: ../../howto/free-threading-extensions.rst:332
msgid "Deadlock Avoidance"
msgstr "避免死锁"

#: ../../howto/free-threading-extensions.rst:334
msgid "Critical sections help avoid deadlocks in two ways:"
msgstr "关键节通过两种方式帮助避免死锁："

#: ../../howto/free-threading-extensions.rst:336
msgid ""
"If a thread tries to acquire a lock that's already held by another thread, "
"it first suspends all of its active critical sections, temporarily releasing"
" their locks"
msgstr "如果一个线程试图获取某个已被其他线程持有的锁，它会先挂起该线程的所有关键节，临时释放它们的锁。"

#: ../../howto/free-threading-extensions.rst:340
msgid ""
"When the blocking operation completes, only the top-most critical section is"
" reacquired first"
msgstr "当阻塞型操作完成时，只有最顶端的关键节会被首先重新获取"

#: ../../howto/free-threading-extensions.rst:343
msgid ""
"This means you cannot rely on nested critical sections to lock multiple "
"objects at once, as the inner critical section may suspend the outer ones. "
"Instead, use :c:macro:`Py_BEGIN_CRITICAL_SECTION2` to lock two objects "
"simultaneously."
msgstr ""
"这意味着你不能依赖嵌套的关键节来同时锁定多个对象，因为内层的关键节可能挂起外层的关键节。 作为替代，请使用 "
":c:macro:`Py_BEGIN_CRITICAL_SECTION2` 来同时锁定两个对象。"

#: ../../howto/free-threading-extensions.rst:347
msgid ""
"Note that the locks described above are only :c:type:`!PyMutex` based locks."
" The critical section implementation does not know about or affect other "
"locking mechanisms that might be in use, like POSIX mutexes.  Also note that"
" while blocking on any :c:type:`!PyMutex` causes the critical sections to be"
" suspended, only the mutexes that are part of the critical sections are "
"released.  If :c:type:`!PyMutex` is used without a critical section, it will"
" not be released and therefore does not get the same deadlock avoidance."
msgstr ""
"注意，上面描述的锁只是基于 :c:type:`!PyMutex` 的锁。 临界区实现并不知道或影响其他可能正在使用的锁定机制，比如 POSIX 互斥锁。"
" 还要注意，当任何 :c:type:`!PyMutex` 阻塞时会导致临界区被挂起，只有属于临界区的互斥锁才会被释放。 如果 "
":c:type:`!PyMutex` 在没有临界区的情况下使用，它不会被释放，因此不会得到同样的死锁避免。"

#: ../../howto/free-threading-extensions.rst:356
msgid "Important Considerations"
msgstr "重要考量"

#: ../../howto/free-threading-extensions.rst:358
msgid ""
"Critical sections may temporarily release their locks, allowing other "
"threads to modify the protected data. Be careful about making assumptions "
"about the state of the data after operations that might block."
msgstr "临界区可以暂时释放它们的锁，允许其他线程修改受保护的数据。在进行可能阻塞的操作之后，要谨慎地假设数据的状态。"

#: ../../howto/free-threading-extensions.rst:362
msgid ""
"Because locks can be temporarily released (suspended), entering a critical "
"section does not guarantee exclusive access to the protected resource "
"throughout the section's duration. If code within a critical section calls "
"another function that blocks (e.g., acquires another lock, performs blocking"
" I/O), all locks held by the thread via critical sections will be released. "
"This is similar to how the GIL can be released during blocking calls."
msgstr ""
"因为锁可以临时释放（挂起），所以进入临界区并不能保证在整个临界区期间对受保护资源的独占访问。如果临界区内的代码调用另一个阻塞函数（例如，获取另一个锁、执行阻塞I/O），则该线程通过临界区持有的所有锁将被释放。这类似于在阻塞调用期间释放GIL的方式。"

#: ../../howto/free-threading-extensions.rst:369
msgid ""
"Only the lock(s) associated with the most recently entered (top-most) "
"critical section are guaranteed to be held at any given time. Locks for "
"outer, nested critical sections might have been suspended."
msgstr "在任何给定时间，只有与最近进入（最顶部）的临界区相关的锁才能保证被持有。外部嵌套临界区的锁可能已经挂起。"

#: ../../howto/free-threading-extensions.rst:373
msgid ""
"You can lock at most two objects simultaneously with these APIs. If you need"
" to lock more objects, you'll need to restructure your code."
msgstr "使用这些API最多可以同时锁定两个对象。如果你需要锁定更多的对象，你需要调整你的代码。"

#: ../../howto/free-threading-extensions.rst:376
msgid ""
"While critical sections will not deadlock if you attempt to lock the same "
"object twice, they are less efficient than purpose-built reentrant locks for"
" this use case."
msgstr "虽然如果你尝试锁定同一个对象两次，临界区不会死锁，但是对于这种用例，它们的效率不如专门构建的可重入锁。"

#: ../../howto/free-threading-extensions.rst:380
msgid ""
"When using :c:macro:`Py_BEGIN_CRITICAL_SECTION2`, the order of the objects "
"doesn't affect correctness (the implementation handles deadlock avoidance), "
"but it's good practice to always lock objects in a consistent order."
msgstr ""
"当使用 :c:macro:`Py_BEGIN_CRITICAL_SECTION2` "
"时，对象的顺序不影响正确性（实现处理死锁避免），但始终以一致的顺序锁定对象是良好的实践。"

#: ../../howto/free-threading-extensions.rst:384
msgid ""
"Remember that the critical section macros are primarily for protecting "
"access to *Python objects* that might be involved in internal CPython "
"operations susceptible to the deadlock scenarios described above. For "
"protecting purely internal extension state, standard mutexes or other "
"synchronization primitives might be more appropriate."
msgstr ""
"请记住，临界区宏主要用于保护对 *Python对象* "
"的访问，这些对象可能涉及易受上述死锁场景影响的内部CPython操作。为了保护纯粹的内部扩展状态，标准互斥体或其他同步原语可能更合适。"

#: ../../howto/free-threading-extensions.rst:392
msgid "Building Extensions for the Free-Threaded Build"
msgstr "为自由线程构建进行扩展构建"

#: ../../howto/free-threading-extensions.rst:394
msgid ""
"C API extensions need to be built specifically for the free-threaded build. "
"The wheels, shared libraries, and binaries are indicated by a ``t`` suffix."
msgstr "C API 扩展需要专门为自由线程构建进行构建。构建的 wheel、共享库和二进制文件用后缀 ``t`` 指示。"

#: ../../howto/free-threading-extensions.rst:397
msgid ""
"`pypa/manylinux <https://github.com/pypa/manylinux>`_ supports the free-"
"threaded build, with the ``t`` suffix, such as ``python3.13t``."
msgstr ""
"`pypa/manylinux <https://github.com/pypa/manylinux>`_ 支持后缀为 ``t`` 的自由线程构建，如 "
"``python3.13t``。"

#: ../../howto/free-threading-extensions.rst:399
msgid ""
"`pypa/cibuildwheel <https://github.com/pypa/cibuildwheel>`_ supports the "
"free-threaded build if you set `CIBW_ENABLE to cpython-freethreading "
"<https://cibuildwheel.pypa.io/en/stable/options/#enable>`_."
msgstr ""
"如果你设置了 `cpython-freethreading 的 CIBW_ENABLE "
"<https://cibuildwheel.pypa.io/en/stable/options/#enable>`_ 则 "
"`pypa/cibuildwheel <https://github.com/pypa/cibuildwheel>`_ 将支持自由线程构建版。"

#: ../../howto/free-threading-extensions.rst:404
msgid "Limited C API and Stable ABI"
msgstr "受限的 C API 与稳定 ABI"

#: ../../howto/free-threading-extensions.rst:406
msgid ""
"The free-threaded build does not currently support the :ref:`Limited C API "
"<limited-c-api>` or the stable ABI.  If you use `setuptools "
"<https://setuptools.pypa.io/en/latest/setuptools.html>`_ to build your "
"extension and currently set ``py_limited_api=True`` you can use "
"``py_limited_api=not sysconfig.get_config_var(\"Py_GIL_DISABLED\")`` to opt "
"out of the limited API when building with the free-threaded build."
msgstr ""
"自由线程构建目前不支持 :ref:`受限 C API <limited-c-api>` 或稳定 ABI。 如果当前您使用 `setuptools "
"<https://setuptools.pypa.io/en/latest/setuptools.html>`_ 来构建您的扩展，并且设置了 "
"``py_limited_api=True``，您可以使用 ``py_limited_api=not "
"sysconfig.get_config_var(\"Py_GIL_DISABLED\")`` 在使用自由线程构建进行构建时不使用受限 API。"

#: ../../howto/free-threading-extensions.rst:414
msgid ""
"You will need to build separate wheels specifically for the free-threaded "
"build.  If you currently use the stable ABI, you can continue to build a "
"single wheel for multiple non-free-threaded Python versions."
msgstr ""
"您需要为自由线程构建单独构建 wheel。如果您当前使用稳定 ABI，则可以继续构建适用于多个非自由线程 Python 版本的单个 wheel。"

#: ../../howto/free-threading-extensions.rst:420
msgid "Windows"
msgstr "Windows"

#: ../../howto/free-threading-extensions.rst:422
msgid ""
"Due to a limitation of the official Windows installer, you will need to "
"manually define ``Py_GIL_DISABLED=1`` when building extensions from source."
msgstr "由于 Windows 官方安装程序的限制，从源代码构建扩展时需要手动定义 ``Py_GIL_DISABLED=1``。"

#: ../../howto/free-threading-extensions.rst:427
msgid ""
"`Porting Extension Modules to Support Free-Threading <https://py-free-"
"threading.github.io/porting/>`_: A community-maintained porting guide for "
"extension authors."
msgstr ""
"`Porting Extension Modules to Support Free-Threading <https://py-free-"
"threading.github.io/porting/>`_: 一份由社区维护的针对扩展开发者的移植指南。"
