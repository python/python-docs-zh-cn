# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# telnetning <telnetning@gmail.com>, 2021
# Alpha Du <alphanow@gmail.com>, 2021
# Shengjing Zhu <zsj950618@gmail.com>, 2021
# df2dc1c92e792f7ae8417c51df43db8f_594d92a <0f49be28017426edb1db1a2ab6e67088_717605>, 2021
# ppcfish <ppcfish@gmail.com>, 2021
# Freesand Leo <yuqinju@163.com>, 2022
# Dai Xu <daixu61@hotmail.com>, 2022
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-06-29 12:56+0000\n"
"PO-Revision-Date: 2021-06-28 00:52+0000\n"
"Last-Translator: Dai Xu <daixu61@hotmail.com>, 2022\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/clinic.rst:5
msgid "Argument Clinic How-To"
msgstr "Argument Clinic 的用法"

#: ../../howto/clinic.rst:0
msgid "author"
msgstr "作者"

#: ../../howto/clinic.rst:7
msgid "Larry Hastings"
msgstr "Larry Hastings"

#: ../../howto/clinic.rstNone
msgid "Abstract"
msgstr "摘要"

#: ../../howto/clinic.rst:12
msgid ""
"Argument Clinic is a preprocessor for CPython C files. Its purpose is to "
"automate all the boilerplate involved with writing argument parsing code for"
" \"builtins\". This document shows you how to convert your first C function "
"to work with Argument Clinic, and then introduces some advanced topics on "
"Argument Clinic usage."
msgstr ""
"Argument Clinic 是 CPython 的一个 C 文件预处理器。旨在自动处理所有与“内置”参数解析有关的代码。本文展示了将 C "
"函数转换为配合 Argument Clinic 工作的做法，还介绍了一些关于 Argument Clinic 用法的进阶内容。"

#: ../../howto/clinic.rst:19
msgid ""
"Currently Argument Clinic is considered internal-only for CPython.  Its use "
"is not supported for files outside CPython, and no guarantees are made "
"regarding backwards compatibility for future versions.  In other words: if "
"you maintain an external C extension for CPython, you're welcome to "
"experiment with Argument Clinic in your own code.  But the version of "
"Argument Clinic that ships with the next version of CPython *could* be "
"totally incompatible and break all your code."
msgstr ""
"目前 Argument Clinic 视作仅供 CPython 内部使用。不支持在 CPython "
"之外的文件中使用，也不保证未来版本会向下兼容。换句话说：如果维护的是 CPython 的外部 C 语言扩展，欢迎在自己的代码中试用 Argument "
"Clinic。但 Argument Clinic 与新版 CPython 中的版本 *可能* 完全不兼容，且会打乱全部代码。"

#: ../../howto/clinic.rst:29
msgid "The Goals Of Argument Clinic"
msgstr "Argument Clinic 的设计目标"

#: ../../howto/clinic.rst:31
msgid ""
"Argument Clinic's primary goal is to take over responsibility for all "
"argument parsing code inside CPython.  This means that, when you convert a "
"function to work with Argument Clinic, that function should no longer do any"
" of its own argument parsing—the code generated by Argument Clinic should be"
" a \"black box\" to you, where CPython calls in at the top, and your code "
"gets called at the bottom, with ``PyObject *args`` (and maybe ``PyObject "
"*kwargs``) magically converted into the C variables and types you need."
msgstr ""
"Argument Clinic 的主要目标，是接管 CPython 中的所有参数解析代码。这意味着，如果要把某个函数转换为配合 Argument "
"Clinic一起工作，则该函数不应再作任何参数解析工作——Argument Clinic 生成的代码应该是个“黑盒”，CPython "
"会在顶部发起调用，底部则调用自己的代码， ``PyObject *args`` （也许还有 ``PyObject *kwargs`` "
"）会神奇地转换成所需的 C 变量和类型。"

#: ../../howto/clinic.rst:41
msgid ""
"In order for Argument Clinic to accomplish its primary goal, it must be easy"
" to use.  Currently, working with CPython's argument parsing library is a "
"chore, requiring maintaining redundant information in a surprising number of"
" places. When you use Argument Clinic, you don't have to repeat yourself."
msgstr ""
"Argument Clinic 为了能完成主要目标，用起来必须方便。目前，使用 CPython "
"的参数解析库是一件苦差事，需要在很多地方维护冗余信息。如果使用 Argument Clinic，则不必再重复代码了。"

#: ../../howto/clinic.rst:47
msgid ""
"Obviously, no one would want to use Argument Clinic unless it's solving "
"their problem—and without creating new problems of its own. So it's "
"paramount that Argument Clinic generate correct code. It'd be nice if the "
"code was faster, too, but at the very least it should not introduce a major "
"speed regression.  (Eventually Argument Clinic *should* make a major speedup"
" possible—we could rewrite its code generator to produce tailor-made "
"argument parsing code, rather than calling the general-purpose CPython "
"argument parsing library.  That would make for the fastest argument parsing "
"possible!)"
msgstr ""
"显然，除非 Argument Clinic 解决了自身的问题，且没有产生新的问题，否则没有人会愿意用它。所以，Argument Clinic "
"最重要的事情就是生成正确的代码。如果能加速代码的运行当然更好，但至少不应引入明显的减速。（最终 Argument Clinic *应该* "
"可以实现较大的速度提升——代码生成器可以重写一下，以产生量身定做的参数解析代码，而不是调用通用的 CPython 参数解析库。 "
"这会让参数解析达到最佳速度！）"

#: ../../howto/clinic.rst:59
msgid ""
"Additionally, Argument Clinic must be flexible enough to work with any "
"approach to argument parsing.  Python has some functions with some very "
"strange parsing behaviors; Argument Clinic's goal is to support all of them."
msgstr ""
"此外，Argument Clinic 必须足够灵活，能够与任何参数解析的方法一起工作。Python "
"有一些函数具备一些非常奇怪的解析行为；Argument Clinic 的目标是支持所有这些函数。"

#: ../../howto/clinic.rst:64
msgid ""
"Finally, the original motivation for Argument Clinic was to provide "
"introspection \"signatures\" for CPython builtins. It used to be, the "
"introspection query functions would throw an exception if you passed in a "
"builtin.  With Argument Clinic, that's a thing of the past!"
msgstr ""
"最后，Argument Clinic 的初衷是为 CPython 内置程序提供内省“签名”。以前如果传入一个内置函数，内省查询函数会抛出异常。有了 "
"Argument Clinic，再不会发生这种问题了！"

#: ../../howto/clinic.rst:70
msgid ""
"One idea you should keep in mind, as you work with Argument Clinic: the more"
" information you give it, the better job it'll be able to do. Argument "
"Clinic is admittedly relatively simple right now.  But as it evolves it will"
" get more sophisticated, and it should be able to do many interesting and "
"smart things with all the information you give it."
msgstr ""
"在与 Argument Clinic 合作时，应该牢记一个理念：给它的信息越多，它做得就会越好。诚然，Argument Clinic "
"现在还比较简单。但会演变得越来越复杂，应该能够利用给出的全部信息干很多聪明而有趣的事情。"

#: ../../howto/clinic.rst:80
msgid "Basic Concepts And Usage"
msgstr "基本概念和用法"

#: ../../howto/clinic.rst:82
msgid ""
"Argument Clinic ships with CPython; you'll find it in "
"``Tools/clinic/clinic.py``. If you run that script, specifying a C file as "
"an argument:"
msgstr ""
"Argument Clinic 与 CPython 一起提供，位于 ``Tools/clinic/clinic.py`` 。若要运行它，请指定一个 C "
"文件作为参数。"

#: ../../howto/clinic.rst:89
msgid ""
"Argument Clinic will scan over the file looking for lines that look exactly "
"like this:"
msgstr "Argument Clinic 会扫描 C 文件，精确查找以下代码："

#: ../../howto/clinic.rst:96
msgid ""
"When it finds one, it reads everything up to a line that looks exactly like "
"this:"
msgstr "一旦找到一条后，就会读取所有内容，直至遇到以下代码："

#: ../../howto/clinic.rst:103
msgid ""
"Everything in between these two lines is input for Argument Clinic. All of "
"these lines, including the beginning and ending comment lines, are "
"collectively called an Argument Clinic \"block\"."
msgstr ""
"这两行之间的所有内容都是 Argument Clinic 的输入。所有行，包括开始和结束的注释行，统称为 Argument Clinic “块”。"

#: ../../howto/clinic.rst:107
msgid ""
"When Argument Clinic parses one of these blocks, it generates output.  This "
"output is rewritten into the C file immediately after the block, followed by"
" a comment containing a checksum. The Argument Clinic block now looks like "
"this:"
msgstr ""
"Argument Clinic 在解析某一块时，会生成输出信息。输出信息会紧跟着该块写入 C 文件中，后面还会跟着包含校验和的注释。现在 "
"Argument Clinic 块看起来应如下所示："

#: ../../howto/clinic.rst:120
msgid ""
"If you run Argument Clinic on the same file a second time, Argument Clinic "
"will discard the old output and write out the new output with a fresh "
"checksum line.  However, if the input hasn't changed, the output won't "
"change either."
msgstr ""
"如果对同一文件第二次运行 Argument "
"Clinic，则它会丢弃之前的输出信息，并写入带有新校验行的输出信息。不过如果输入没有变化，则输出也不会有变化。"

#: ../../howto/clinic.rst:124
msgid ""
"You should never modify the output portion of an Argument Clinic block.  "
"Instead, change the input until it produces the output you want.  (That's "
"the purpose of the checksum—to detect if someone changed the output, as "
"these edits would be lost the next time Argument Clinic writes out fresh "
"output.)"
msgstr ""
"不应去改动 Argument Clinic "
"块的输出部分。而应去修改输入，直到生成所需的输出信息。（这就是校验和的用途——检测是否有人改动了输出信息，因为在 Argument Clinic "
"下次写入新的输出时，这些改动都会丢失）。"

#: ../../howto/clinic.rst:129
msgid ""
"For the sake of clarity, here's the terminology we'll use with Argument "
"Clinic:"
msgstr "为了清晰起见，下面列出了 Argument Clinic 用到的术语："

#: ../../howto/clinic.rst:131
msgid ""
"The first line of the comment (``/*[clinic input]``) is the *start line*."
msgstr "注释的第一行 ``/*[clinic input]`` 是 *起始行* 。"

#: ../../howto/clinic.rst:132
msgid ""
"The last line of the initial comment (``[clinic start generated code]*/``) "
"is the *end line*."
msgstr "注释（``[clinic start generated code]*/``）的最后一行是 *结束行*。"

#: ../../howto/clinic.rst:133
msgid ""
"The last line (``/*[clinic end generated code: checksum=...]*/``) is the "
"*checksum line*."
msgstr "最后一行（``/*[clinic end generated code: checksum=...]*/``）是 *校验和行* 。"

#: ../../howto/clinic.rst:134
msgid "In between the start line and the end line is the *input*."
msgstr "在起始行和结束行之间是 *输入数据*。"

#: ../../howto/clinic.rst:135
msgid "In between the end line and the checksum line is the *output*."
msgstr "在结束行和校验和行之间是 *输出数据* 。"

#: ../../howto/clinic.rst:136
msgid ""
"All the text collectively, from the start line to the checksum line "
"inclusively, is the *block*.  (A block that hasn't been successfully "
"processed by Argument Clinic yet doesn't have output or a checksum line, but"
" it's still considered a block.)"
msgstr "从开始行到校验和行的所有文本，都是 *块*。（Argument Clinic 尚未处理成功的块，没有输出或校验和行，但仍视作一个块）。"

#: ../../howto/clinic.rst:143
msgid "Converting Your First Function"
msgstr "函数的转换"

#: ../../howto/clinic.rst:145
msgid ""
"The best way to get a sense of how Argument Clinic works is to convert a "
"function to work with it.  Here, then, are the bare minimum steps you'd need"
" to follow to convert a function to work with Argument Clinic.  Note that "
"for code you plan to check in to CPython, you really should take the "
"conversion farther, using some of the advanced concepts you'll see later on "
"in the document (like \"return converters\" and \"self converters\"). But "
"we'll keep it simple for this walkthrough so you can learn."
msgstr ""
"要想了解 Argument Clinic 是如何工作的，最好的方式就是转换一个函数与之合作。下面介绍需遵循的最基本步骤。请注意，若真的准备在 "
"CPython 中进行检查，则应进行更深入的转换，使用一些本文后续会介绍到的高级概念（比如 “返回转换” 和 "
"“自转换”）。但以下例子将维持简单，以供学习。"

#: ../../howto/clinic.rst:154
msgid "Let's dive in!"
msgstr "就此开始"

#: ../../howto/clinic.rst:156
msgid ""
"Make sure you're working with a freshly updated checkout of the CPython "
"trunk."
msgstr "请确保 CPython 是最新的已签出版本。"

#: ../../howto/clinic.rst:159
msgid ""
"Find a Python builtin that calls either :c:func:`PyArg_ParseTuple` or "
":c:func:`PyArg_ParseTupleAndKeywords`, and hasn't been converted to work "
"with Argument Clinic yet. For my example I'm using "
"``_pickle.Pickler.dump()``."
msgstr ""
"找到一个调用 :c:func:`PyArg_ParseTuple` 或 :c:func:`PyArg_ParseTupleAndKeywords` "
"，且未被转换为采用 Argument Clinic 的 Python 内置程序。这里用了 ``_pickle.Pickler.dump()``。"

#: ../../howto/clinic.rst:164
msgid ""
"If the call to the ``PyArg_Parse`` function uses any of the following format"
" units:"
msgstr "如果对 ``PyArg_Parse`` 函数的调用采用了以下格式化单元："

#: ../../howto/clinic.rst:176
msgid ""
"or if it has multiple calls to :c:func:`PyArg_ParseTuple`, you should choose"
" a different function.  Argument Clinic *does* support all of these "
"scenarios.  But these are advanced topics—let's do something simpler for "
"your first function."
msgstr ""
"或者多次调用 :c:func:`PyArg_ParseTuple`，则应再选一个函数。Argument Clinic *确实* 支持上述这些状况。 "
"但这些都是高阶内容——第一次就简单一些吧。"

#: ../../howto/clinic.rst:181
msgid ""
"Also, if the function has multiple calls to :c:func:`PyArg_ParseTuple` or "
":c:func:`PyArg_ParseTupleAndKeywords` where it supports different types for "
"the same argument, or if the function uses something besides PyArg_Parse "
"functions to parse its arguments, it probably isn't suitable for conversion "
"to Argument Clinic.  Argument Clinic doesn't support generic functions or "
"polymorphic parameters."
msgstr ""
"此外，如果多次调用 :c:func:`PyArg_ParseTuple` 或 :c:func:`PyArg_ParseTupleAndKeywords`"
" 且同一参数需支持不同的类型，或者用到 PyArg_Parse 以外的函数来解析参数，则可能不适合转换为 Argument Clinic 形式。 "
"Argument Clinic 不支持通用函数或多态参数。"

#: ../../howto/clinic.rst:188
msgid "Add the following boilerplate above the function, creating our block::"
msgstr "在函数上方添加以下模板，创建块："

#: ../../howto/clinic.rst:193
msgid ""
"Cut the docstring and paste it in between the ``[clinic]`` lines, removing "
"all the junk that makes it a properly quoted C string. When you're done you "
"should have just the text, based at the left margin, with no line wider than"
" 80 characters. (Argument Clinic will preserve indents inside the "
"docstring.)"
msgstr ""
"剪下文档字符串并粘贴到 ``[clinic]`` 行之间，去除所有的无用字符，使其成为一个正确引用的 C "
"字符串。最有应该只留下带有左侧缩进的文本，且行宽不大于 80 个字符。（参数 Clinic 将保留文档字符串中的缩进。）"

#: ../../howto/clinic.rst:199
msgid ""
"If the old docstring had a first line that looked like a function signature,"
" throw that line away.  (The docstring doesn't need it anymore—when you use "
"``help()`` on your builtin in the future, the first line will be built "
"automatically based on the function's signature.)"
msgstr ""
"如果文档字符串的第一行看起来像是函数的签名，就把这一行去掉吧。（(文档串不再需要用到它——将来对内置函数调用 ``help()`` "
"时，第一行将根据函数的签名自动建立。）"

#: ../../howto/clinic.rst:205 ../../howto/clinic.rst:226
#: ../../howto/clinic.rst:250 ../../howto/clinic.rst:308
#: ../../howto/clinic.rst:348 ../../howto/clinic.rst:375
#: ../../howto/clinic.rst:481 ../../howto/clinic.rst:533
msgid "Sample::"
msgstr "示例："

#: ../../howto/clinic.rst:211
msgid ""
"If your docstring doesn't have a \"summary\" line, Argument Clinic will "
"complain.  So let's make sure it has one.  The \"summary\" line should be a "
"paragraph consisting of a single 80-column line at the beginning of the "
"docstring."
msgstr ""
"如果文档字符串中没有“摘要”行，Argument Clinic 会报错。所以应确保带有摘要行。 "
"“摘要”行应为在文档字符串开头的一个段落，由一个80列的单行构成。"

#: ../../howto/clinic.rst:216
msgid ""
"(Our example docstring consists solely of a summary line, so the sample code"
" doesn't have to change for this step.)"
msgstr "（示例的文档字符串只包括一个摘要行，所以示例代码这一步不需改动）。"

#: ../../howto/clinic.rst:219
msgid ""
"Above the docstring, enter the name of the function, followed by a blank "
"line.  This should be the Python name of the function, and should be the "
"full dotted path to the function—it should start with the name of the "
"module, include any sub-modules, and if the function is a method on a class "
"it should include the class name too."
msgstr ""
"在文档字符串上方，输入函数的名称，后面是空行。这应是函数的 Python "
"名称，而且应是句点分隔的完整路径——以模块的名称开始，包含所有子模块名，若函数为类方法则还应包含类名。"

#: ../../howto/clinic.rst:234
msgid ""
"If this is the first time that module or class has been used with Argument "
"Clinic in this C file, you must declare the module and/or class.  Proper "
"Argument Clinic hygiene prefers declaring these in a separate block "
"somewhere near the top of the C file, in the same way that include files and"
" statics go at the top.  (In our sample code we'll just show the two blocks "
"next to each other.)"
msgstr ""
"如果是第一次在此 C 文件中用到 Argument Clinic 的模块或类，必须对其进行声明。清晰的 Argument Clinic 写法应于 C "
"文件顶部附近的某个单独块中声明这些，就像 include 文件和 statics 放在顶部一样。（在这里的示例代码中，将这两个块相邻给出。)"

#: ../../howto/clinic.rst:242
msgid ""
"The name of the class and module should be the same as the one seen by "
"Python.  Check the name defined in the :c:type:`PyModuleDef` or "
":c:type:`PyTypeObject` as appropriate."
msgstr ""
"类和模块的名称应与暴露给 Python 的相同。请适时检查 :c:type:`PyModuleDef` 或 :c:type:`PyTypeObject`"
" 中定义的名称。"

#: ../../howto/clinic.rst:246
msgid ""
"When you declare a class, you must also specify two aspects of its type in "
"C: the type declaration you'd use for a pointer to an instance of this "
"class, and a pointer to the :c:type:`PyTypeObject` for this class."
msgstr ""
"在声明某个类时，还必须指定其 C 语言类型的两个部分：用于指向该类实例的指针的类型声明，和指向该类 :c:type:`PyTypeObject` "
"的指针。"

#: ../../howto/clinic.rst:266
msgid ""
"Declare each of the parameters to the function.  Each parameter should get "
"its own line.  All the parameter lines should be indented from the function "
"name and the docstring."
msgstr "声明函数的所有参数。每个参数都应另起一行。所有的参数行都应对齐函数名和文档字符串进行缩进。"

#: ../../howto/clinic.rst:270
msgid "The general form of these parameter lines is as follows:"
msgstr "这些参数行的常规形式如下："

#: ../../howto/clinic.rst:276
msgid "If the parameter has a default value, add that after the converter:"
msgstr "如果参数带有缺省值，请加在转换器之后："

#: ../../howto/clinic.rst:283
msgid ""
"Argument Clinic's support for \"default values\" is quite sophisticated; "
"please see :ref:`the section below on default values <default_values>` for "
"more information."
msgstr ""
"Argument Clinic 对 “缺省值” 的支持方式相当复杂；更多信息请参见 :ref:`关于缺省值的部分 <default_values>` 。"

#: ../../howto/clinic.rst:287
msgid "Add a blank line below the parameters."
msgstr "在参数行下面添加一个空行。"

#: ../../howto/clinic.rst:289
msgid ""
"What's a \"converter\"?  It establishes both the type of the variable used "
"in C, and the method to convert the Python value into a C value at runtime. "
"For now you're going to use what's called a \"legacy converter\"—a "
"convenience syntax intended to make porting old code into Argument Clinic "
"easier."
msgstr ""
" “转换器”是什么？它既确定了 C 语言要采用的变量类型，又确定了运行时将 Python 值转换成 C "
"语言值的方法。现在需用到的是所谓“传统转换器”——快捷语法，旨在让旧代码更容易移植到 Argument Clinic。"

#: ../../howto/clinic.rst:296
msgid ""
"For each parameter, copy the \"format unit\" for that parameter from the "
"``PyArg_Parse()`` format argument and specify *that* as its converter, as a "
"quoted string.  (\"format unit\" is the formal name for the one-to-three "
"character substring of the ``format`` parameter that tells the argument "
"parsing function what the type of the variable is and how to convert it.  "
"For more on format units please see :ref:`arg-parsing`.)"
msgstr ""
"每个参数都要从``PyArg_Parse()`` 格式参数中复制其 “格式单元”，并以带引号字符串的形式指定其转换器。（“格式单元”是 "
"``format`` 参数的1-3个字符的正式名称，用于让参数解析函数知晓该变量的类型及转换方法。关于格式单位的更多信息，请参阅 :ref:`arg-"
"parsing` ）。"

#: ../../howto/clinic.rst:305
msgid ""
"For multicharacter format units like ``z#``, use the entire two-or-three "
"character string."
msgstr "对于像 ``z#`` 这样的多字符格式单元，要使用2-3个字符组成的整个字符串。"

#: ../../howto/clinic.rst:323
msgid ""
"If your function has ``|`` in the format string, meaning some parameters "
"have default values, you can ignore it.  Argument Clinic infers which "
"parameters are optional based on whether or not they have default values."
msgstr ""
"如果函数的格式字符串包含 ``|``，意味着有些参数带有缺省值，这可以忽略。Argument Clinic 根据参数是否有缺省值来推断哪些参数是可选的。"

#: ../../howto/clinic.rst:328
msgid ""
"If your function has ``$`` in the format string, meaning it takes keyword-"
"only arguments, specify ``*`` on a line by itself before the first keyword-"
"only argument, indented the same as the parameter lines."
msgstr "如果函数的格式字符串中包含 $，意味着只接受关键字参数，请在第一个关键字参数之前单独给出一行 ``*``，缩进与参数行对齐。"

#: ../../howto/clinic.rst:333
msgid "(``_pickle.Pickler.dump`` has neither, so our sample is unchanged.)"
msgstr "（``_pickle.Pickler.dump`` 两种格式字符串都没有，所以这里的示例不用改动。）"

#: ../../howto/clinic.rst:336
msgid ""
"If the existing C function calls :c:func:`PyArg_ParseTuple` (as opposed to "
":c:func:`PyArg_ParseTupleAndKeywords`), then all its arguments are "
"positional-only."
msgstr ""
"如果 C 函数调用的是 :c:func:`PyArg_ParseTuple` (而不是 "
":c:func:`PyArg_ParseTupleAndKeywords`)，那么其所有参数均是仅限位置参数。"

#: ../../howto/clinic.rst:340
msgid ""
"To mark all parameters as positional-only in Argument Clinic, add a ``/`` on"
" a line by itself after the last parameter, indented the same as the "
"parameter lines."
msgstr "若要在 Argument Clinic 中把所有参数都标记为只认位置，请在最后一个参数后面一行加入一个 ``/``，缩进程度与参数行对齐。"

#: ../../howto/clinic.rst:344
msgid ""
"Currently this is all-or-nothing; either all parameters are positional-only,"
" or none of them are.  (In the future Argument Clinic may relax this "
"restriction.)"
msgstr "目前这个标记是全体生效；要么所有参数都是只认位置，要么都不是。（以后 Argument Clinic 可能会放宽这一限制。）"

#: ../../howto/clinic.rst:364
msgid ""
"It's helpful to write a per-parameter docstring for each parameter. But per-"
"parameter docstrings are optional; you can skip this step if you prefer."
msgstr "为每个参数都编写一个文档字符串，这很有意义。但这是可选项；可以跳过这一步。"

#: ../../howto/clinic.rst:368
msgid ""
"Here's how to add a per-parameter docstring.  The first line of the per-"
"parameter docstring must be indented further than the parameter definition."
"  The left margin of this first line establishes the left margin for the "
"whole per-parameter docstring; all the text you write will be outdented by "
"this amount.  You can write as much text as you like, across multiple lines "
"if you wish."
msgstr ""
"下面介绍如何添加逐参数的文档字符串。逐参数文档字符串的第一行必须比参数定义多缩进一层。第一行的左边距即确定了所有逐参数文档字符串的左边距；所有文档字符串文本都要同等缩进。文本可以用多行编写。"

#: ../../howto/clinic.rst:392
msgid ""
"Save and close the file, then run ``Tools/clinic/clinic.py`` on it.  With "
"luck everything worked---your block now has output, and a ``.c.h`` file has "
"been generated! Reopen the file in your text editor to see::"
msgstr ""
"保存并关闭该文件，然后运行 ``Tools/clinic/clinic.py`` 。 运气好的话就万事大吉——程序块现在有了输出信息，并且生成了一个 "
"``.c.h`` 文件！在文本编辑器中重新打开该文件，可以看到："

#: ../../howto/clinic.rst:411
msgid ""
"Obviously, if Argument Clinic didn't produce any output, it's because it "
"found an error in your input.  Keep fixing your errors and retrying until "
"Argument Clinic processes your file without complaint."
msgstr ""
"显然，如果 Argument Clinic 未产生任何输出，那是因为在输入信息中发现了错误。继续修正错误并重试，直至 Argument Clinic "
"正确地处理好文件。"

#: ../../howto/clinic.rst:415
msgid ""
"For readability, most of the glue code has been generated to a ``.c.h`` "
"file.  You'll need to include that in your original ``.c`` file, typically "
"right after the clinic module block::"
msgstr ""
"为了便于阅读，大部分“胶水”代码已写入 ``.c.h`` 文件中。需在原 ``.c`` 文件中包含这个文件，通常是在 clinic  模块之后："

#: ../../howto/clinic.rst:421
msgid ""
"Double-check that the argument-parsing code Argument Clinic generated looks "
"basically the same as the existing code."
msgstr "请仔细检查 Argument Clinic 生成的参数解析代码，是否与原有代码基本相同。"

#: ../../howto/clinic.rst:424
msgid ""
"First, ensure both places use the same argument-parsing function. The "
"existing code must call either :c:func:`PyArg_ParseTuple` or "
":c:func:`PyArg_ParseTupleAndKeywords`; ensure that the code generated by "
"Argument Clinic calls the *exact* same function."
msgstr ""
"首先，确保两种代码使用相同的参数解析函数。原有代码必须调用  :c:func:`PyArg_ParseTuple` 或 "
":c:func:`PyArg_ParseTupleAndKeywords` ；确保 Argument Clinic 生成的代码调用 *完全* "
"相同的函数。"

#: ../../howto/clinic.rst:430
msgid ""
"Second, the format string passed in to :c:func:`PyArg_ParseTuple` or "
":c:func:`PyArg_ParseTupleAndKeywords` should be *exactly* the same as the "
"hand-written one in the existing function, up to the colon or semi-colon."
msgstr ""
"其次，传给 :c:func:`PyArg_ParseTuple` 或 :c:func:`PyArg_ParseTupleAndKeywords` "
"的格式字符串应该 *完全* 与原有函数中的相同，直到冒号或分号为止。"

#: ../../howto/clinic.rst:435
msgid ""
"(Argument Clinic always generates its format strings with a ``:`` followed "
"by the name of the function.  If the existing code's format string ends with"
" ``;``, to provide usage help, this change is harmless—don't worry about "
"it.)"
msgstr ""
"（Argument Clinic 生成的格式串一定是函数名后跟着 ``:``。如果现有代码的格式串以 ``;`` "
"结尾，这种改动不会影响使用，因此不必担心。）"

#: ../../howto/clinic.rst:440
msgid ""
"Third, for parameters whose format units require two arguments (like a "
"length variable, or an encoding string, or a pointer to a conversion "
"function), ensure that the second argument is *exactly* the same between the"
" two invocations."
msgstr "第三，如果格式单元需要指定两个参数（比如长度、编码字符串或指向转换函数的指针），请确保第二个参数在两次调用时 *完全* 相同。"

#: ../../howto/clinic.rst:445
msgid ""
"Fourth, inside the output portion of the block you'll find a preprocessor "
"macro defining the appropriate static :c:type:`PyMethodDef` structure for "
"this builtin::"
msgstr "第四，在输出部分会有一个预处理器宏，为该内置函数定义合适的静态 :c:type:`PyMethodDef` 结构："

#: ../../howto/clinic.rst:452
msgid ""
"This static structure should be *exactly* the same as the existing static "
":c:type:`PyMethodDef` structure for this builtin."
msgstr "此静态结构应与本内置函数现有的静态结构 :c:type:`PyMethodDef` *完全* 相同。"

#: ../../howto/clinic.rst:455
msgid ""
"If any of these items differ in *any way*, adjust your Argument Clinic "
"function specification and rerun ``Tools/clinic/clinic.py`` until they *are*"
" the same."
msgstr ""
"只要上述这几点存在不一致，请调整 Argument Clinic 函数定义，并重新运行 ``Tools/clinic/clinic.py`` ，直至 "
"*完全* 相同。"

#: ../../howto/clinic.rst:460
msgid ""
"Notice that the last line of its output is the declaration of your \"impl\" "
"function.  This is where the builtin's implementation goes. Delete the "
"existing prototype of the function you're modifying, but leave the opening "
"curly brace.  Now delete its argument parsing code and the declarations of "
"all the variables it dumps the arguments into. Notice how the Python "
"arguments are now arguments to this impl function; if the implementation "
"used different names for these variables, fix it."
msgstr ""
"注意，输出部分的最后一行是“实现”函数的声明。也就是该内置函数的实现代码所在。删除需要修改的函数的现有原型，但保留开头的大括号。再删除其参数解析代码和输入变量的所有声明。注意现在"
" Python 所见的参数即为此实现函数的参数；如果实现代码给这些变量采用了不同的命名，请进行修正。"

#: ../../howto/clinic.rst:468
msgid ""
"Let's reiterate, just because it's kind of weird.  Your code should now look"
" like this::"
msgstr "因为稍显怪异，所以还是重申一下。现在的代码应该如下所示："

#: ../../howto/clinic.rst:477
msgid ""
"Argument Clinic generated the checksum line and the function prototype just "
"above it.  You should write the opening (and closing) curly braces for the "
"function, and the implementation inside."
msgstr "上面是 Argument Clinic 生成的校验值和函数原型。函数应该带有闭合的大括号，实现代码位于其中。"

#: ../../howto/clinic.rst:522
msgid ""
"Remember the macro with the :c:type:`PyMethodDef` structure for this "
"function?  Find the existing :c:type:`PyMethodDef` structure for this "
"function and replace it with a reference to the macro.  (If the builtin is "
"at module scope, this will probably be very near the end of the file; if the"
" builtin is a class method, this will probably be below but relatively near "
"to the implementation.)"
msgstr ""
"还记得用到 :c:type:`PyMethodDef` 结构的宏吧？找到函数中已有的  :c:type:`PyMethodDef` "
"结构，并替换为宏的引用。（如果函数是模块级的，可能会在文件的末尾附近；如果函数是个类方法，则可能会在靠近实现代码的下方。)"

#: ../../howto/clinic.rst:529
msgid ""
"Note that the body of the macro contains a trailing comma.  So when you "
"replace the existing static :c:type:`PyMethodDef` structure with the macro, "
"*don't* add a comma to the end."
msgstr "注意，宏尾部带有一个逗号。所以若用宏替换已有的静态结构  :c:type:`PyMethodDef` 时，*请勿* 在结尾添加逗号了。"

#: ../../howto/clinic.rst:542
msgid ""
"Compile, then run the relevant portions of the regression-test suite. This "
"change should not introduce any new compile-time warnings or errors, and "
"there should be no externally-visible change to Python's behavior."
msgstr "编译，然后运行回归测试套件中的有关测试程序。不应引入新的编译警告或错误，且对 Python 也不应有外部可见的变化。"

#: ../../howto/clinic.rst:546
msgid ""
"Well, except for one difference: ``inspect.signature()`` run on your "
"function should now provide a valid signature!"
msgstr "差别只有一个，即 ``inspect.signature()`` 运行于新的函数上，现在应该新提供一个有效的签名！"

#: ../../howto/clinic.rst:549
msgid ""
"Congratulations, you've ported your first function to work with Argument "
"Clinic!"
msgstr "祝贺你，现在已经用 Argument Clinic 移植了第一个函数。"

#: ../../howto/clinic.rst:552
msgid "Advanced Topics"
msgstr "进阶"

#: ../../howto/clinic.rst:554
msgid ""
"Now that you've had some experience working with Argument Clinic, it's time "
"for some advanced topics."
msgstr "现在 Argument Clinic 的使用经验已具备了一些，该介绍一些高级内容了。"

#: ../../howto/clinic.rst:559
msgid "Symbolic default values"
msgstr ""

#: ../../howto/clinic.rst:561
msgid ""
"The default value you provide for a parameter can't be any arbitrary "
"expression.  Currently the following are explicitly supported:"
msgstr "提供给参数的默认值不能是表达式。目前明确支持以下形式："

#: ../../howto/clinic.rst:564
msgid "Numeric constants (integer and float)"
msgstr "数值型常数（整数和浮点数）。"

#: ../../howto/clinic.rst:565
msgid "String constants"
msgstr "字符串常量"

#: ../../howto/clinic.rst:566
msgid "``True``, ``False``, and ``None``"
msgstr "``True`` 、 ``False`` 和 ``None`` 。"

#: ../../howto/clinic.rst:567
msgid ""
"Simple symbolic constants like ``sys.maxsize``, which must start with the "
"name of the module"
msgstr "以模块名开头的简单符号常量，如 ``sys.maxsize``。"

#: ../../howto/clinic.rst:570
msgid ""
"In case you're curious, this is implemented in  ``from_builtin()`` in "
"``Lib/inspect.py``."
msgstr "如果你感到好奇，这是在  ``from_builtin()`` ( ``Lib/inspect.py``) 中实现的。"

#: ../../howto/clinic.rst:573
msgid ""
"(In the future, this may need to get even more elaborate, to allow full "
"expressions like ``CONSTANT - 1``.)"
msgstr "（未来可能需要加以细化，以便可以采用 ``CONSTANT - 1`` 之类的完整表达式。）"

#: ../../howto/clinic.rst:578
msgid "Renaming the C functions and variables generated by Argument Clinic"
msgstr "对 Argument Clinic 生成的 C 函数和变量进行重命名"

#: ../../howto/clinic.rst:580
msgid ""
"Argument Clinic automatically names the functions it generates for you. "
"Occasionally this may cause a problem, if the generated name collides with "
"the name of an existing C function.  There's an easy solution: override the "
"names used for the C functions.  Just add the keyword ``\"as\"`` to your "
"function declaration line, followed by the function name you wish to use. "
"Argument Clinic will use that function name for the base (generated) "
"function, then add ``\"_impl\"`` to the end and use that for the name of the"
" impl function."
msgstr ""
"Argument Clinic 会自动为其生成的函数命名。如果生成的名称与现有的 C 函数冲突，这偶尔可能会造成问题，有一个简单的解决方案：覆盖 C "
"函数的名称。只要在函数声明中加入关键字 ``\"as\"`` ，然后再加上要使用的函数名。Argument Clinic "
"将以该函数名为基础作为（生成的）函数名，然后在后面加上 ``\"_impl\"``，并用作实现函数的名称。"

#: ../../howto/clinic.rst:588
msgid ""
"For example, if we wanted to rename the C function names generated for "
"``pickle.Pickler.dump``, it'd look like this::"
msgstr "例如，若对 ``pickle.Pickler.dump`` 生成的 C 函数进行重命名，应如下所示："

#: ../../howto/clinic.rst:596
msgid ""
"The base function would now be named ``pickler_dumper()``, and the impl "
"function would now be named ``pickler_dumper_impl()``."
msgstr "原函数会被命名为 ``pickler_dumper()``，而实现函数现在被命名为``pickler_dumper_impl()``。"

#: ../../howto/clinic.rst:600
msgid ""
"Similarly, you may have a problem where you want to give a parameter a "
"specific Python name, but that name may be inconvenient in C.  Argument "
"Clinic allows you to give a parameter different names in Python and in C, "
"using the same ``\"as\"`` syntax::"
msgstr ""
"同样的问题依然会出现：想给某个参数取个 Python 用名，但在 C 语言中可能用不了。Argument Clinic 允许在 Python 和 C "
"中为同一个参数取不同的名字，依然是利用 ``\"as\"`` 语法："

#: ../../howto/clinic.rst:614
msgid ""
"Here, the name used in Python (in the signature and the ``keywords`` array) "
"would be ``file``, but the C variable would be named ``file_obj``."
msgstr ""
"这里 Python（签名和 ``keywords`` 数组中）中用的名称是 ``file``，而 C 语言中的变量命名为 ``file_obj``。"

#: ../../howto/clinic.rst:617
msgid "You can use this to rename the ``self`` parameter too!"
msgstr "``self`` 参数也可以进行重命名。"

#: ../../howto/clinic.rst:621
msgid "Converting functions using PyArg_UnpackTuple"
msgstr "函数转换会用到 PyArg_UnpackTuple"

#: ../../howto/clinic.rst:623
msgid ""
"To convert a function parsing its arguments with "
":c:func:`PyArg_UnpackTuple`, simply write out all the arguments, specifying "
"each as an ``object``.  You may specify the ``type`` argument to cast the "
"type as appropriate.  All arguments should be marked positional-only (add a "
"``/`` on a line by itself after the last argument)."
msgstr ""
"若要将函数转换为采用 :c:func:`PyArg_UnpackTuple` 解析其参数，只需写出所有参数，并将每个参数定义为 "
"``object``。可以指定 ``type`` 参数，以便能转换为合适的类型。所有参数都应标记为只认位置（在最后一个参数后面加上 ``/``）。"

#: ../../howto/clinic.rst:629
msgid ""
"Currently the generated code will use :c:func:`PyArg_ParseTuple`, but this "
"will change soon."
msgstr "目前，所生成的代码将会用到 :c:func:`PyArg_ParseTuple` ，但很快会做出改动。"

#: ../../howto/clinic.rst:633
msgid "Optional Groups"
msgstr "可选参数组"

#: ../../howto/clinic.rst:635
msgid ""
"Some legacy functions have a tricky approach to parsing their arguments: "
"they count the number of positional arguments, then use a ``switch`` "
"statement to call one of several different :c:func:`PyArg_ParseTuple` calls "
"depending on how many positional arguments there are.  (These functions "
"cannot accept keyword-only arguments.)  This approach was used to simulate "
"optional arguments back before :c:func:`PyArg_ParseTupleAndKeywords` was "
"created."
msgstr ""
"有些过时的函数用到了一种让人头疼的函数解析方式：计算位置参数的数量，据此用 ``switch`` 语句进行各个不同的 "
":c:func:`PyArg_ParseTuple` 调用。（这些函数不能接受只认关键字的参数。）在没有 "
":c:func:`PyArg_ParseTupleAndKeywords` 之前，这种方式曾被用于模拟可选参数。"

#: ../../howto/clinic.rst:642
msgid ""
"While functions using this approach can often be converted to use "
":c:func:`PyArg_ParseTupleAndKeywords`, optional arguments, and default "
"values, it's not always possible.  Some of these legacy functions have "
"behaviors :c:func:`PyArg_ParseTupleAndKeywords` doesn't directly support. "
"The most obvious example is the builtin function ``range()``, which has an "
"optional argument on the *left* side of its required argument! Another "
"example is ``curses.window.addch()``, which has a group of two arguments "
"that must always be specified together.  (The arguments are called ``x`` and"
" ``y``; if you call the function passing in ``x``, you must also pass in "
"``y``—and if you don't pass in ``x`` you may not pass in ``y`` either.)"
msgstr ""
"虽然这种函数通常可以转换为采用  :c:func:`PyArg_ParseTupleAndKeywords` "
"、可选参数和默认值的方式，但并不是全都可以做到。这些过时函数中， :c:func:`PyArg_ParseTupleAndKeywords` "
"并不能直接支持某些功能。最明显的例子是内置函数 ``range()``，它的必需参数的 *左* 边存在一个可选参数！另一个例子是 "
"``curses.window.addch()``，它的两个参数是一组，必须同时指定。（参数名为 ``x`` 和 ``y``；如果调用函数时传入了 "
"``x``，则必须同时传入``y``；如果未传入 ``x`` ，则也不能传入 ``y``）。"

#: ../../howto/clinic.rst:654
msgid ""
"In any case, the goal of Argument Clinic is to support argument parsing for "
"all existing CPython builtins without changing their semantics. Therefore "
"Argument Clinic supports this alternate approach to parsing, using what are "
"called *optional groups*. Optional groups are groups of arguments that must "
"all be passed in together. They can be to the left or the right of the "
"required arguments.  They can *only* be used with positional-only "
"parameters."
msgstr ""
"不管怎么说，Argument Clinic 的目标就是在不改变语义的情况下支持所有现有 CPython 内置参数的解析。因此，Argument "
"Clinic 采用所谓的 *可选组* 方案来支持这种解析方式。可选组是必须一起传入的参数组。他们可以在必需参数的左边或右边，*只能* "
"用于只认位置的参数。"

#: ../../howto/clinic.rst:662
msgid ""
"Optional groups are *only* intended for use when converting functions that "
"make multiple calls to :c:func:`PyArg_ParseTuple`! Functions that use *any* "
"other approach for parsing arguments should *almost never* be converted to "
"Argument Clinic using optional groups.  Functions using optional groups "
"currently cannot have accurate signatures in Python, because Python just "
"doesn't understand the concept.  Please avoid using optional groups wherever"
" possible."
msgstr ""
"可选组 *仅* 适用于多次调用 :c:func:`PyArg_ParseTuple` 的函数！采用 *任何* 其他方式解析参数的函数，应该 *几乎不* "
"采用可选组转换为 Argument Clinic 解析。目前，采用可选组的函数在 Python 中无法获得准确的签名，因为 Python "
"不能理解这个概念。请尽可能避免使用可选组。"

#: ../../howto/clinic.rst:671
msgid ""
"To specify an optional group, add a ``[`` on a line by itself before the "
"parameters you wish to group together, and a ``]`` on a line by itself after"
" these parameters.  As an example, here's how ``curses.window.addch`` uses "
"optional groups to make the first two parameters and the last parameter "
"optional::"
msgstr ""
"若要定义可选组，可在要分组的参数前面加上 ``[``，在这些参数后加上``]`` ，要在同一行上。举个例子，下面是 "
"``curses.window.addch`` 采用可选组的用法，前两个参数和最后一个参数可选："

#: ../../howto/clinic.rst:700
msgid "Notes:"
msgstr "注："

#: ../../howto/clinic.rst:702
msgid ""
"For every optional group, one additional parameter will be passed into the "
"impl function representing the group.  The parameter will be an int named "
"``group_{direction}_{number}``, where ``{direction}`` is either ``right`` or"
" ``left`` depending on whether the group is before or after the required "
"parameters, and ``{number}`` is a monotonically increasing number (starting "
"at 1) indicating how far away the group is from the required parameters.  "
"When the impl is called, this parameter will be set to zero if this group "
"was unused, and set to non-zero if this group was used. (By used or unused, "
"I mean whether or not the parameters received arguments in this invocation.)"
msgstr ""
"每一个可选组，都会额外传入一个代表分组的参数。 参数为 int 型，名为 ``group_{direction}_{number}``，其中 "
"``{direction}`` 取决于此参数组位于必需参数 ``right`` 还是 ``left``，而 ``{number}`` 是一个递增数字（从"
" 1 开始），表示此参数组与必需参数之间的距离。 在调用函数时，若未用到此参数组则此参数将设为零，若用到了参数组则该参数为非零。 "
"所谓的用到或未用到，是指在本次调用中形参是否收到了实参。"

#: ../../howto/clinic.rst:713
msgid ""
"If there are no required arguments, the optional groups will behave as if "
"they're to the right of the required arguments."
msgstr "如果不存在必需参数，可选组的行为等同于出现在必需参数的右侧。"

#: ../../howto/clinic.rst:716
msgid ""
"In the case of ambiguity, the argument parsing code favors parameters on the"
" left (before the required parameters)."
msgstr "在模棱两可的情况下，参数解析代码更倾向于参数左侧（在必需参数之前）。"

#: ../../howto/clinic.rst:719
msgid "Optional groups can only contain positional-only parameters."
msgstr "可选组只能包含只认位置的参数。"

#: ../../howto/clinic.rst:721
msgid ""
"Optional groups are *only* intended for legacy code.  Please do not use "
"optional groups for new code."
msgstr "可选组 *仅限* 用于过时代码。请勿在新的代码中使用可选组。"

#: ../../howto/clinic.rst:726
msgid "Using real Argument Clinic converters, instead of \"legacy converters\""
msgstr "采用真正的 Argument Clinic 转换器，而不是 “传统转换器”"

#: ../../howto/clinic.rst:728
msgid ""
"To save time, and to minimize how much you need to learn to achieve your "
"first port to Argument Clinic, the walkthrough above tells you to use "
"\"legacy converters\".  \"Legacy converters\" are a convenience, designed "
"explicitly to make porting existing code to Argument Clinic easier.  And to "
"be clear, their use is acceptable when porting code for Python 3.4."
msgstr ""
"为了节省时间，尽量减少要学习的内容，实现第一次适用 Argument Clinic "
"的移植，上述练习简述的是“传统转换器”的用法。“传统转换器”只是一种简便用法，目的就是更容易地让现有代码移植为适用于 Argument Clinic "
"。说白了，在移植 Python 3.4 的代码时，可以考虑采用。"

#: ../../howto/clinic.rst:735
msgid ""
"However, in the long term we probably want all our blocks to use Argument "
"Clinic's real syntax for converters.  Why?  A couple reasons:"
msgstr "不过从长远来看，可能希望所有代码块都采用真正的 Argument Clinic 转换器语法。原因如下："

#: ../../howto/clinic.rst:739
msgid ""
"The proper converters are far easier to read and clearer in their intent."
msgstr "合适的转换器可读性更好，意图也更清晰。"

#: ../../howto/clinic.rst:740
msgid ""
"There are some format units that are unsupported as \"legacy converters\", "
"because they require arguments, and the legacy converter syntax doesn't "
"support specifying arguments."
msgstr "有些格式单元是“传统转换器”无法支持的，因为这些格式需要带上参数，而传统转换器的语法不支持指定参数。"

#: ../../howto/clinic.rst:743
msgid ""
"In the future we may have a new argument parsing library that isn't "
"restricted to what :c:func:`PyArg_ParseTuple` supports; this flexibility "
"won't be available to parameters using legacy converters."
msgstr ""
"后续可能会有新版的参数解析库，提供超过 :c:func:`PyArg_ParseTuple` 支持的功能；而这种灵活性将无法适用于传统转换器转换的参数。"

#: ../../howto/clinic.rst:747
msgid ""
"Therefore, if you don't mind a little extra effort, please use the normal "
"converters instead of legacy converters."
msgstr "因此，若是不介意多花一点精力，请使用正常的转换器，而不是传统转换器。"

#: ../../howto/clinic.rst:750
msgid ""
"In a nutshell, the syntax for Argument Clinic (non-legacy) converters looks "
"like a Python function call.  However, if there are no explicit arguments to"
" the function (all functions take their default values), you may omit the "
"parentheses.  Thus ``bool`` and ``bool()`` are exactly the same converters."
msgstr ""
"简而言之，Argument Clinic（非传统）转换器的语法看起来像是 Python "
"函数调用。但如果函数没有明确的参数（所有函数都取默认值），则可以省略括号。因此 ``bool`` 和 ``bool()`` 是完全相同的转换器。"

#: ../../howto/clinic.rst:756
msgid ""
"All arguments to Argument Clinic converters are keyword-only. All Argument "
"Clinic converters accept the following arguments:"
msgstr "Argument Clinic 转换器的所有参数都只认关键字。所有 Argument Clinic 转换器均可接受以下参数："

#: ../../howto/clinic.rst:764 ../../howto/clinic.rst:1314
msgid "``c_default``"
msgstr "``c_default``"

#: ../../howto/clinic.rst:760
msgid ""
"The default value for this parameter when defined in C. Specifically, this "
"will be the initializer for the variable declared in the \"parse function\"."
"  See :ref:`the section on default values <default_values>` for how to use "
"this. Specified as a string."
msgstr ""
"该参数在 C 语言中的默认值。具体来说，将是在“解析函数”中声明的变量的初始化器。用法参见 :ref:`the section on default "
"values <default_values>` 。定义为字符串。"

#: ../../howto/clinic.rst:769
msgid "``annotation``"
msgstr "``annotation``"

#: ../../howto/clinic.rst:767
msgid ""
"The annotation value for this parameter.  Not currently supported, because "
":pep:`8` mandates that the Python library may not use annotations."
msgstr "参数的注解值。目前尚不支持，因为 :pep:`8` 规定 Python 库不得使用注解。"

#: ../../howto/clinic.rst:771
msgid ""
"In addition, some converters accept additional arguments.  Here is a list of"
" these arguments, along with their meanings:"
msgstr "此外，某些转换器还可接受额外的参数。下面列出了这些额外参数及其含义："

#: ../../howto/clinic.rst:780
msgid "``accept``"
msgstr "``accept``"

#: ../../howto/clinic.rst:775
msgid ""
"A set of Python types (and possibly pseudo-types); this restricts the "
"allowable Python argument to values of these types. (This is not a general-"
"purpose facility; as a rule it only supports specific lists of types as "
"shown in the legacy converter table.)"
msgstr ""
"一些 Python 类型的集合（可能还有伪类型）；用于限制只接受这些类型的 Python 参数。（并非通用特性；只支持传统转换器列表中给出的类型）。"

#: ../../howto/clinic.rst:780
msgid "To accept ``None``, add ``NoneType`` to this set."
msgstr "若要能接受 ``None``，请在集合中添加 ``NoneType``。"

#: ../../howto/clinic.rst:785
msgid "``bitwise``"
msgstr "``bitwise``"

#: ../../howto/clinic.rst:783
msgid ""
"Only supported for unsigned integers.  The native integer value of this "
"Python argument will be written to the parameter without any range checking,"
" even for negative values."
msgstr "仅用于无符号整数。写入形参的将是 Python 实参的原生整数值，不做任何越界检查，即便是负值也一样。"

#: ../../howto/clinic.rst:790 ../../howto/clinic.rst:1328
msgid "``converter``"
msgstr "``converter``"

#: ../../howto/clinic.rst:788
msgid ""
"Only supported by the ``object`` converter.  Specifies the name of a :ref:`C"
" \"converter function\" <o_ampersand>` to use to convert this object to a "
"native type."
msgstr "仅用于 ``object`` 转换器。为某个 :ref:`C 转换函数 <o_ampersand>` 指定名称，用于将对象转换为原生类型。"

#: ../../howto/clinic.rst:795
msgid "``encoding``"
msgstr "``encoding``"

#: ../../howto/clinic.rst:793
msgid ""
"Only supported for strings.  Specifies the encoding to use when converting "
"this string from a Python str (Unicode) value into a C ``char *`` value."
msgstr "仅用于字符串。指定将 Python str(Unicode) 转换为 C 语言的 ``char *`` 时应该采用的编码。"

#: ../../howto/clinic.rst:799
msgid "``subclass_of``"
msgstr "``subclass_of``"

#: ../../howto/clinic.rst:798
msgid ""
"Only supported for the ``object`` converter.  Requires that the Python value"
" be a subclass of a Python type, as expressed in C."
msgstr "仅用于 ``object`` 转换器。要求 Python 值是 Python 类型的子类，用 C 语言表示。"

#: ../../howto/clinic.rst:804 ../../howto/clinic.rst:1300
msgid "``type``"
msgstr "``type``"

#: ../../howto/clinic.rst:802
msgid ""
"Only supported for the ``object`` and ``self`` converters.  Specifies the C "
"type that will be used to declare the variable.  Default value is "
"``\"PyObject *\"``."
msgstr "仅用于 ``object`` 和 ``self`` 转换器。指定用于声明变量的 C 类型。 默认值是 ``\"PyObject *\"``。"

#: ../../howto/clinic.rst:810
msgid "``zeroes``"
msgstr "``zeroes``"

#: ../../howto/clinic.rst:807
msgid ""
"Only supported for strings.  If true, embedded NUL bytes (``'\\\\0'``) are "
"permitted inside the value.  The length of the string will be passed in to "
"the impl function, just after the string parameter, as a parameter named "
"``<parameter_name>_length``."
msgstr ""
"仅用于字符串。如果为 True，则允许在值中嵌入 NUL 字节（``'\\\\0'``）。字符串的长度将通过名为 "
"``<parameter_name>_length`` 的参数传入，跟在字符串参数的后面。"

#: ../../howto/clinic.rst:812
msgid ""
"Please note, not every possible combination of arguments will work. Usually "
"these arguments are implemented by specific ``PyArg_ParseTuple`` *format "
"units*, with specific behavior.  For example, currently you cannot call "
"``unsigned_short`` without also specifying ``bitwise=True``. Although it's "
"perfectly reasonable to think this would work, these semantics don't map to "
"any existing format unit.  So Argument Clinic doesn't support it.  (Or, at "
"least, not yet.)"
msgstr ""
"请注意，并不是所有参数的组合都能正常生效。通常这些参数是由相应的 ``PyArg_ParseTuple`` *格式单元* "
"实现的，行为是固定的。比如目前不能不指定 ``bitwise=True`` 就去调用 "
"``unsigned_short``。虽然完全有理由认为这样可行，但这些语义并没有映射到任何现有的格式单元。所以 Argument Clinic "
"并不支持。（或者说，至少目前还不支持。）"

#: ../../howto/clinic.rst:820
msgid ""
"Below is a table showing the mapping of legacy converters into real Argument"
" Clinic converters.  On the left is the legacy converter, on the right is "
"the text you'd replace it with."
msgstr "下表列出了传统转换器与真正的 Argument Clinic 转换器之间的映射关系。左边是传统的转换器，右边是应该换成的文本。"

#: ../../howto/clinic.rst:825
msgid "``'B'``"
msgstr "``'B'``"

#: ../../howto/clinic.rst:825
msgid "``unsigned_char(bitwise=True)``"
msgstr "``unsigned_char(bitwise=True)``"

#: ../../howto/clinic.rst:826
msgid "``'b'``"
msgstr "``'b'``"

#: ../../howto/clinic.rst:826
msgid "``unsigned_char``"
msgstr "``unsigned_char``"

#: ../../howto/clinic.rst:827
msgid "``'c'``"
msgstr "``'c'``"

#: ../../howto/clinic.rst:827
msgid "``char``"
msgstr "``char``"

#: ../../howto/clinic.rst:828
msgid "``'C'``"
msgstr "``'C'``"

#: ../../howto/clinic.rst:828
msgid "``int(accept={str})``"
msgstr "``int(accept={str})``"

#: ../../howto/clinic.rst:829
msgid "``'d'``"
msgstr "``'d'``"

#: ../../howto/clinic.rst:829
msgid "``double``"
msgstr "``double``"

#: ../../howto/clinic.rst:830
msgid "``'D'``"
msgstr "``'D'``"

#: ../../howto/clinic.rst:830
msgid "``Py_complex``"
msgstr "``Py_complex``"

#: ../../howto/clinic.rst:831
msgid "``'es'``"
msgstr "``'es'``"

#: ../../howto/clinic.rst:831
msgid "``str(encoding='name_of_encoding')``"
msgstr "``str(encoding='name_of_encoding')``"

#: ../../howto/clinic.rst:832
msgid "``'es#'``"
msgstr "``'es#'``"

#: ../../howto/clinic.rst:832
msgid "``str(encoding='name_of_encoding', zeroes=True)``"
msgstr "``str(encoding='name_of_encoding', zeroes=True)``"

#: ../../howto/clinic.rst:833
msgid "``'et'``"
msgstr "``'et'``"

#: ../../howto/clinic.rst:833
msgid "``str(encoding='name_of_encoding', accept={bytes, bytearray, str})``"
msgstr "``str(encoding='name_of_encoding', accept={bytes, bytearray, str})``"

#: ../../howto/clinic.rst:834
msgid "``'et#'``"
msgstr "``'et#'``"

#: ../../howto/clinic.rst:834
msgid ""
"``str(encoding='name_of_encoding', accept={bytes, bytearray, str}, "
"zeroes=True)``"
msgstr ""
"``str(encoding='name_of_encoding', accept={bytes, bytearray, str}, "
"zeroes=True)``"

#: ../../howto/clinic.rst:835
msgid "``'f'``"
msgstr "``'f'``"

#: ../../howto/clinic.rst:835
msgid "``float``"
msgstr "``float``"

#: ../../howto/clinic.rst:836
msgid "``'h'``"
msgstr "``'h'``"

#: ../../howto/clinic.rst:836
msgid "``short``"
msgstr "``short``"

#: ../../howto/clinic.rst:837
msgid "``'H'``"
msgstr "``'H'``"

#: ../../howto/clinic.rst:837
msgid "``unsigned_short(bitwise=True)``"
msgstr "``unsigned_short(bitwise=True)``"

#: ../../howto/clinic.rst:838
msgid "``'i'``"
msgstr "``'i'``"

#: ../../howto/clinic.rst:838
msgid "``int``"
msgstr "``int``"

#: ../../howto/clinic.rst:839
msgid "``'I'``"
msgstr "``'I'``"

#: ../../howto/clinic.rst:839
msgid "``unsigned_int(bitwise=True)``"
msgstr "``unsigned_int(bitwise=True)``"

#: ../../howto/clinic.rst:840
msgid "``'k'``"
msgstr "``'k'``"

#: ../../howto/clinic.rst:840
msgid "``unsigned_long(bitwise=True)``"
msgstr "``unsigned_long(bitwise=True)``"

#: ../../howto/clinic.rst:841
msgid "``'K'``"
msgstr "``'K'``"

#: ../../howto/clinic.rst:841
msgid "``unsigned_long_long(bitwise=True)``"
msgstr "``unsigned_long_long(bitwise=True)``"

#: ../../howto/clinic.rst:842
msgid "``'l'``"
msgstr "``'l'``"

#: ../../howto/clinic.rst:842
msgid "``long``"
msgstr "``long``"

#: ../../howto/clinic.rst:843
msgid "``'L'``"
msgstr "``'L'``"

#: ../../howto/clinic.rst:843
msgid "``long long``"
msgstr "``long long``"

#: ../../howto/clinic.rst:844
msgid "``'n'``"
msgstr "``'n'``"

#: ../../howto/clinic.rst:844
msgid "``Py_ssize_t``"
msgstr "``Py_ssize_t``"

#: ../../howto/clinic.rst:845
msgid "``'O'``"
msgstr "``'O'``"

#: ../../howto/clinic.rst:845
msgid "``object``"
msgstr "``object``"

#: ../../howto/clinic.rst:846
msgid "``'O!'``"
msgstr "``'O!'``"

#: ../../howto/clinic.rst:846
msgid "``object(subclass_of='&PySomething_Type')``"
msgstr "``object(subclass_of='&PySomething_Type')``"

#: ../../howto/clinic.rst:847
msgid "``'O&'``"
msgstr "``'O&'``"

#: ../../howto/clinic.rst:847
msgid "``object(converter='name_of_c_function')``"
msgstr "``object(converter='name_of_c_function')``"

#: ../../howto/clinic.rst:848
msgid "``'p'``"
msgstr "``'p'``"

#: ../../howto/clinic.rst:848
msgid "``bool``"
msgstr "``bool``"

#: ../../howto/clinic.rst:849
msgid "``'S'``"
msgstr "``'S'``"

#: ../../howto/clinic.rst:849
msgid "``PyBytesObject``"
msgstr "``PyBytesObject``"

#: ../../howto/clinic.rst:850
msgid "``'s'``"
msgstr "``'s'``"

#: ../../howto/clinic.rst:850
msgid "``str``"
msgstr "``str``"

#: ../../howto/clinic.rst:851
msgid "``'s#'``"
msgstr "``'s#'``"

#: ../../howto/clinic.rst:851
msgid "``str(zeroes=True)``"
msgstr "``str(zeroes=True)``"

#: ../../howto/clinic.rst:852
msgid "``'s*'``"
msgstr "``'s*'``"

#: ../../howto/clinic.rst:852
msgid "``Py_buffer(accept={buffer, str})``"
msgstr "``Py_buffer(accept={buffer, str})``"

#: ../../howto/clinic.rst:853
msgid "``'U'``"
msgstr "``'U'``"

#: ../../howto/clinic.rst:853
msgid "``unicode``"
msgstr "``unicode``"

#: ../../howto/clinic.rst:854
msgid "``'u'``"
msgstr "``'u'``"

#: ../../howto/clinic.rst:854
msgid "``Py_UNICODE``"
msgstr "``Py_UNICODE``"

#: ../../howto/clinic.rst:855
msgid "``'u#'``"
msgstr "``'u#'``"

#: ../../howto/clinic.rst:855
msgid "``Py_UNICODE(zeroes=True)``"
msgstr "``Py_UNICODE(zeroes=True)``"

#: ../../howto/clinic.rst:856
msgid "``'w*'``"
msgstr "``'w*'``"

#: ../../howto/clinic.rst:856
msgid "``Py_buffer(accept={rwbuffer})``"
msgstr "``Py_buffer(accept={rwbuffer})``"

#: ../../howto/clinic.rst:857
msgid "``'Y'``"
msgstr "``'Y'``"

#: ../../howto/clinic.rst:857
msgid "``PyByteArrayObject``"
msgstr "``PyByteArrayObject``"

#: ../../howto/clinic.rst:858
msgid "``'y'``"
msgstr "``'y'``"

#: ../../howto/clinic.rst:858
msgid "``str(accept={bytes})``"
msgstr "``str(accept={bytes})``"

#: ../../howto/clinic.rst:859
msgid "``'y#'``"
msgstr "``'y#'``"

#: ../../howto/clinic.rst:859
msgid "``str(accept={robuffer}, zeroes=True)``"
msgstr "``str(accept={robuffer}, zeroes=True)``"

#: ../../howto/clinic.rst:860
msgid "``'y*'``"
msgstr "``'y*'``"

#: ../../howto/clinic.rst:860
msgid "``Py_buffer``"
msgstr "``Py_buffer``"

#: ../../howto/clinic.rst:861
msgid "``'Z'``"
msgstr "``'Z'``"

#: ../../howto/clinic.rst:861
msgid "``Py_UNICODE(accept={str, NoneType})``"
msgstr "``Py_UNICODE(accept={str, NoneType})``"

#: ../../howto/clinic.rst:862
msgid "``'Z#'``"
msgstr "``'Z#'``"

#: ../../howto/clinic.rst:862
msgid "``Py_UNICODE(accept={str, NoneType}, zeroes=True)``"
msgstr "``Py_UNICODE(accept={str, NoneType}, zeroes=True)``"

#: ../../howto/clinic.rst:863
msgid "``'z'``"
msgstr "``'z'``"

#: ../../howto/clinic.rst:863
msgid "``str(accept={str, NoneType})``"
msgstr "``str(accept={str, NoneType})``"

#: ../../howto/clinic.rst:864
msgid "``'z#'``"
msgstr "``'z#'``"

#: ../../howto/clinic.rst:864
msgid "``str(accept={str, NoneType}, zeroes=True)``"
msgstr "``str(accept={str, NoneType}, zeroes=True)``"

#: ../../howto/clinic.rst:865
msgid "``'z*'``"
msgstr "``'z*'``"

#: ../../howto/clinic.rst:865
msgid "``Py_buffer(accept={buffer, str, NoneType})``"
msgstr "``Py_buffer(accept={buffer, str, NoneType})``"

#: ../../howto/clinic.rst:868
msgid ""
"As an example, here's our sample ``pickle.Pickler.dump`` using the proper "
"converter::"
msgstr "举个例子，下面是采用合适的转换器的例子 ``pickle.Pickler.dump``："

#: ../../howto/clinic.rst:881
msgid ""
"One advantage of real converters is that they're more flexible than legacy "
"converters.  For example, the ``unsigned_int`` converter (and all the "
"``unsigned_`` converters) can be specified without ``bitwise=True``.  Their "
"default behavior performs range checking on the value, and they won't accept"
" negative numbers.  You just can't do that with a legacy converter!"
msgstr ""
"真正的转换器有一个优点，就是比传统的转换器更加灵活。例如，``unsigned_int`` 转换器（以及所有 ``unsigned_`` "
"转换器）可以不设置 ``bitwise=True`` 。 他们默认会对数值进行范围检查，而且不会接受负数。 用传统转换器就做不到这一点。"

#: ../../howto/clinic.rst:887
msgid ""
"Argument Clinic will show you all the converters it has available.  For each"
" converter it'll show you all the parameters it accepts, along with the "
"default value for each parameter. Just run ``Tools/clinic/clinic.py "
"--converters`` to see the full list."
msgstr ""
"Argument Clinic 会列明其全部转换器。每个转换器都会给出可接受的全部参数，以及每个参数的默认值。只要运行 "
"``Tools/clinic/clinic.py --converters`` 就能得到完整的列表。"

#: ../../howto/clinic.rst:893
msgid "Py_buffer"
msgstr "Py_buffer"

#: ../../howto/clinic.rst:895
msgid ""
"When using the ``Py_buffer`` converter (or the ``'s*'``, ``'w*'``, ``'*y'``,"
" or ``'z*'`` legacy converters), you *must* not call "
":c:func:`PyBuffer_Release` on the provided buffer. Argument Clinic generates"
" code that does it for you (in the parsing function)."
msgstr ""
"在使用 ``Py_buffer`` 转换器（或者 ``'s*'``、``'w*'``、``'*y'`` 或 ``'z*'`` 传统转换器）时，*不可* "
"在所提供的缓冲区上调用 :c:func:`PyBuffer_Release`。 Argument Clinic "
"生成的代码会自动完成此操作（在解析函数中）。"

#: ../../howto/clinic.rst:903
msgid "Advanced converters"
msgstr "高级转换器"

#: ../../howto/clinic.rst:905
msgid ""
"Remember those format units you skipped for your first time because they "
"were advanced?  Here's how to handle those too."
msgstr "还记得编写第一个函数时跳过的那些格式单元吗，因为他们是高级内容？下面就来介绍这些内容。"

#: ../../howto/clinic.rst:908
msgid ""
"The trick is, all those format units take arguments—either conversion "
"functions, or types, or strings specifying an encoding. (But \"legacy "
"converters\" don't support arguments.  That's why we skipped them for your "
"first function.)  The argument you specified to the format unit is now an "
"argument to the converter; this argument is either ``converter`` (for "
"``O&``), ``subclass_of`` (for ``O!``), or ``encoding`` (for all the format "
"units that start with ``e``)."
msgstr ""
"其实诀窍在于，这些格式单元都需要给出参数——要么是转换函数，要么是类型，要么是指定编码的字符串。（但 "
"“传统转换器”不支持参数。这就是为什么第一个函数要跳过这些内容）。为格式单元指定的参数于是就成了转换器的参数；参数可以是 "
"``converter``（对于 ``O&``）、``subclass_of``（对于 ``O!``），或者是 ``encoding`` （对于 "
"``e`` 开头的格式单元）。"

#: ../../howto/clinic.rst:916
msgid ""
"When using ``subclass_of``, you may also want to use the other custom "
"argument for ``object()``: ``type``, which lets you set the type actually "
"used for the parameter.  For example, if you want to ensure that the object "
"is a subclass of ``PyUnicode_Type``, you probably want to use the converter "
"``object(type='PyUnicodeObject *', subclass_of='&PyUnicode_Type')``."
msgstr ""
"在使用 ``subclass_of`` 时，可能还需要用到 ``object()`` "
"的另一个自定义参数：``type``，用于设置参数的实际类型。例如，为了确保对象是 ``PyUnicode_Type`` 的子类，可能想采用转换器 "
"``object(type='PyUnicodeObject *', subclass_of='&PyUnicode_Type')``。"

#: ../../howto/clinic.rst:922
msgid ""
"One possible problem with using Argument Clinic: it takes away some possible"
" flexibility for the format units starting with ``e``.  When writing a "
"``PyArg_Parse`` call by hand, you could theoretically decide at runtime what"
" encoding string to pass in to :c:func:`PyArg_ParseTuple`.   But now this "
"string must be hard-coded at Argument-Clinic-preprocessing-time.  This "
"limitation is deliberate; it made supporting this format unit much easier, "
"and may allow for future optimizations. This restriction doesn't seem "
"unreasonable; CPython itself always passes in static hard-coded encoding "
"strings for parameters whose format units start with ``e``."
msgstr ""
"Argument Clinic 用起来可能存在一个问题：丧失了 ``e`` 开头的格式单位的一些灵活性。在手工编写 ``PyArg_Parse`` "
"调用时，理论上可以在运行时决定传给 :c:func:`PyArg_ParseTuple` 的编码字符串。但现在这个字符串必须在 Argument-"
"Clinic 预处理时进行硬编码。这个限制是故意设置的；以便简化对这种格式单元的支持，并允许以后进行优化。这个限制似乎并不合理；CPython "
"本身总是为 ``e`` 开头的格式单位参数传入静态的硬编码字符串。"

#: ../../howto/clinic.rst:935
msgid "Parameter default values"
msgstr "参数的默认值"

#: ../../howto/clinic.rst:937
msgid ""
"Default values for parameters can be any of a number of values. At their "
"simplest, they can be string, int, or float literals:"
msgstr "参数的默认值可以是多个值中的一个。最简单的可以是字符串、int 或 float 字面量。"

#: ../../howto/clinic.rst:946
msgid "They can also use any of Python's built-in constants:"
msgstr "还可以使用 Python 的任何内置常量。"

#: ../../howto/clinic.rst:954
msgid ""
"There's also special support for a default value of ``NULL``, and for simple"
" expressions, documented in the following sections."
msgstr "对默认值 ``NULL`` 和简单表达式还提供特别的支持，下面将一一介绍。"

#: ../../howto/clinic.rst:959
msgid "The ``NULL`` default value"
msgstr "默认值 ``NULL``"

#: ../../howto/clinic.rst:961
msgid ""
"For string and object parameters, you can set them to ``None`` to indicate "
"that there's no default.  However, that means the C variable will be "
"initialized to ``Py_None``.  For convenience's sakes, there's a special "
"value called ``NULL`` for just this reason: from Python's perspective it "
"behaves like a default value of ``None``, but the C variable is initialized "
"with ``NULL``."
msgstr ""
"对于字符串和对象参数而言，可以设为 ``None``，表示没有默认值。但这意味着会将 C 变量初始化为 "
"``Py_None``。为了方便起见，提供了一个特殊值``NULL``，目的就是为了让 Python 认为默认值就是 ``None``，而 C "
"变量则会初始化为 ``NULL``。"

#: ../../howto/clinic.rst:969
msgid "Expressions specified as default values"
msgstr "设为默认值的表达式"

#: ../../howto/clinic.rst:971
msgid ""
"The default value for a parameter can be more than just a literal value. It "
"can be an entire expression, using math operators and looking up attributes "
"on objects.  However, this support isn't exactly simple, because of some "
"non-obvious semantics."
msgstr "参数的默认值不仅可以是字面量。还可以是一个完整的表达式，可采用数学运算符及对象的属性。但这种支持并没有那么简单，因为存在一些不明显的语义。"

#: ../../howto/clinic.rst:976
msgid "Consider the following example:"
msgstr "请考虑以下例子："

#: ../../howto/clinic.rst:982
msgid ""
"``sys.maxsize`` can have different values on different platforms.  Therefore"
" Argument Clinic can't simply evaluate that expression locally and hard-code"
" it in C.  So it stores the default in such a way that it will get evaluated"
" at runtime, when the user asks for the function's signature."
msgstr ""
"``sys.maxsize`` 在不同的系统平台可能有不同的值。因此，Argument Clinic 不能简单地在本底环境对表达式求值并用 C "
"语言硬编码。所以默认值将用表达式的方式存储下来，运行的时候在请求函数签名时会被求值。"

#: ../../howto/clinic.rst:987
msgid ""
"What namespace is available when the expression is evaluated?  It's "
"evaluated in the context of the module the builtin came from.  So, if your "
"module has an attribute called \"``max_widgets``\", you may simply use it:"
msgstr ""
"在对表达式进行求值时，可以使用什么命名空间呢？求值过程运行于内置模块的上下文中。 因此，如果模块带有名为 ``max_widgets`` "
"的属性，直接引用即可。"

#: ../../howto/clinic.rst:995
msgid ""
"If the symbol isn't found in the current module, it fails over to looking in"
" ``sys.modules``.  That's how it can find ``sys.maxsize`` for example.  "
"(Since you don't know in advance what modules the user will load into their "
"interpreter, it's best to restrict yourself to modules that are preloaded by"
" Python itself.)"
msgstr ""
"如果表达式不在当前模块中，就会去 ``sys.modules`` 查找。比如 ``sys.maxsize`` "
"就是如此找到的。（因为事先不知道用户会加载哪些模块到解释器中，所以最好只用到 Python 会预加载的模块。）"

#: ../../howto/clinic.rst:1000
msgid ""
"Evaluating default values only at runtime means Argument Clinic can't "
"compute the correct equivalent C default value.  So you need to tell it "
"explicitly. When you use an expression, you must also specify the equivalent"
" expression in C, using the ``c_default`` parameter to the converter:"
msgstr ""
"仅当运行时才对缺省值求值，意味着 Argument Clinic 无法计算出正确的 C "
"缺省值。所以需显式给出。在使用表达式时，必须同时用转换器的``c_default`` 参数指定 C 语言中的等价表达式。"

#: ../../howto/clinic.rst:1009
msgid ""
"Another complication: Argument Clinic can't know in advance whether or not "
"the expression you supply is valid.  It parses it to make sure it looks "
"legal, but it can't *actually* know.  You must be very careful when using "
"expressions to specify values that are guaranteed to be valid at runtime!"
msgstr ""
"还有一个问题也比较复杂。Argument Clinic 无法事先知道表达式是否有效。 解析只能保证看起来是有效值，但无法 *实际* "
"知晓。在用表达式时须十分小心，确保在运行时能得到有效值。"

#: ../../howto/clinic.rst:1014
msgid ""
"Finally, because expressions must be representable as static C values, there"
" are many restrictions on legal expressions.  Here's a list of Python "
"features you're not permitted to use:"
msgstr "最后一点，由于表达式必须能表示为静态的 C 语言值，所以存在许多限制。 以下列出了不得使用的 Python 特性："

#: ../../howto/clinic.rst:1018
msgid "Function calls."
msgstr "功能"

#: ../../howto/clinic.rst:1019
msgid "Inline if statements (``3 if foo else 5``)."
msgstr "行内 if 语句（``3 if foo else 5`` ）"

#: ../../howto/clinic.rst:1020
msgid "Automatic sequence unpacking (``*[1, 2, 3]``)."
msgstr "序列类自动解包（``*[1, 2, 3]``）"

#: ../../howto/clinic.rst:1021
msgid "List/set/dict comprehensions and generator expressions."
msgstr ""

#: ../../howto/clinic.rst:1022
msgid "Tuple/list/set/dict literals."
msgstr ""

#: ../../howto/clinic.rst:1027
msgid "Using a return converter"
msgstr ""

#: ../../howto/clinic.rst:1029
msgid ""
"By default the impl function Argument Clinic generates for you returns "
"``PyObject *``. But your C function often computes some C type, then "
"converts it into the ``PyObject *`` at the last moment.  Argument Clinic "
"handles converting your inputs from Python types into native C types—why not"
" have it convert your return value from a native C type into a Python type "
"too?"
msgstr ""

#: ../../howto/clinic.rst:1035
msgid ""
"That's what a \"return converter\" does.  It changes your impl function to "
"return some C type, then adds code to the generated (non-impl) function to "
"handle converting that value into the appropriate ``PyObject *``."
msgstr ""

#: ../../howto/clinic.rst:1039
msgid ""
"The syntax for return converters is similar to that of parameter converters."
" You specify the return converter like it was a return annotation on the "
"function itself.  Return converters behave much the same as parameter "
"converters; they take arguments, the arguments are all keyword-only, and if "
"you're not changing any of the default arguments you can omit the "
"parentheses."
msgstr ""

#: ../../howto/clinic.rst:1045
msgid ""
"(If you use both ``\"as\"`` *and* a return converter for your function, the "
"``\"as\"`` should come before the return converter.)"
msgstr ""

#: ../../howto/clinic.rst:1048
msgid ""
"There's one additional complication when using return converters: how do you"
" indicate an error has occurred?  Normally, a function returns a valid "
"(non-``NULL``) pointer for success, and ``NULL`` for failure.  But if you "
"use an integer return converter, all integers are valid.  How can Argument "
"Clinic detect an error?  Its solution: each return converter implicitly "
"looks for a special value that indicates an error.  If you return that "
"value, and an error has been set (``PyErr_Occurred()`` returns a true "
"value), then the generated code will propagate the error.  Otherwise it will"
" encode the value you return like normal."
msgstr ""

#: ../../howto/clinic.rst:1057
msgid "Currently Argument Clinic supports only a few return converters:"
msgstr ""

#: ../../howto/clinic.rst:1072
msgid ""
"None of these take parameters.  For the first three, return -1 to indicate "
"error.  For ``DecodeFSDefault``, the return type is ``const char *``; return"
" a ``NULL`` pointer to indicate an error."
msgstr ""

#: ../../howto/clinic.rst:1076
msgid ""
"(There's also an experimental ``NoneType`` converter, which lets you return "
"``Py_None`` on success or ``NULL`` on failure, without having to increment "
"the reference count on ``Py_None``.  I'm not sure it adds enough clarity to "
"be worth using.)"
msgstr ""

#: ../../howto/clinic.rst:1081
msgid ""
"To see all the return converters Argument Clinic supports, along with their "
"parameters (if any), just run ``Tools/clinic/clinic.py --converters`` for "
"the full list."
msgstr ""

#: ../../howto/clinic.rst:1087
msgid "Cloning existing functions"
msgstr ""

#: ../../howto/clinic.rst:1089
msgid ""
"If you have a number of functions that look similar, you may be able to use "
"Clinic's \"clone\" feature.  When you clone an existing function, you reuse:"
msgstr ""

#: ../../howto/clinic.rst:1093
msgid "its parameters, including"
msgstr ""

#: ../../howto/clinic.rst:1095
msgid "their names,"
msgstr ""

#: ../../howto/clinic.rst:1097
msgid "their converters, with all parameters,"
msgstr ""

#: ../../howto/clinic.rst:1099
msgid "their default values,"
msgstr ""

#: ../../howto/clinic.rst:1101
msgid "their per-parameter docstrings,"
msgstr ""

#: ../../howto/clinic.rst:1103
msgid ""
"their *kind* (whether they're positional only, positional or keyword, or "
"keyword only), and"
msgstr ""

#: ../../howto/clinic.rst:1106
msgid "its return converter."
msgstr ""

#: ../../howto/clinic.rst:1108
msgid ""
"The only thing not copied from the original function is its docstring; the "
"syntax allows you to specify a new docstring."
msgstr ""

#: ../../howto/clinic.rst:1111
msgid "Here's the syntax for cloning a function::"
msgstr ""

#: ../../howto/clinic.rst:1119
msgid ""
"(The functions can be in different modules or classes.  I wrote "
"``module.class`` in the sample just to illustrate that you must use the full"
" path to *both* functions.)"
msgstr ""

#: ../../howto/clinic.rst:1123
msgid ""
"Sorry, there's no syntax for partially-cloning a function, or cloning a "
"function then modifying it.  Cloning is an all-or nothing proposition."
msgstr ""

#: ../../howto/clinic.rst:1126
msgid ""
"Also, the function you are cloning from must have been previously defined in"
" the current file."
msgstr ""

#: ../../howto/clinic.rst:1130
msgid "Calling Python code"
msgstr ""

#: ../../howto/clinic.rst:1132
msgid ""
"The rest of the advanced topics require you to write Python code which lives"
" inside your C file and modifies Argument Clinic's runtime state.  This is "
"simple: you simply define a Python block."
msgstr ""

#: ../../howto/clinic.rst:1136
msgid ""
"A Python block uses different delimiter lines than an Argument Clinic "
"function block.  It looks like this::"
msgstr ""

#: ../../howto/clinic.rst:1143
msgid ""
"All the code inside the Python block is executed at the time it's parsed.  "
"All text written to stdout inside the block is redirected into the "
"\"output\" after the block."
msgstr ""

#: ../../howto/clinic.rst:1147
msgid ""
"As an example, here's a Python block that adds a static integer variable to "
"the C code::"
msgstr ""

#: ../../howto/clinic.rst:1158
msgid "Using a \"self converter\""
msgstr ""

#: ../../howto/clinic.rst:1160
msgid ""
"Argument Clinic automatically adds a \"self\" parameter for you using a "
"default converter.  It automatically sets the ``type`` of this parameter to "
"the \"pointer to an instance\" you specified when you declared the type.  "
"However, you can override Argument Clinic's converter and specify one "
"yourself. Just add your own ``self`` parameter as the first parameter in a "
"block, and ensure that its converter is an instance of ``self_converter`` or"
" a subclass thereof."
msgstr ""

#: ../../howto/clinic.rst:1169
msgid ""
"What's the point?  This lets you override the type of ``self``, or give it a"
" different default name."
msgstr ""

#: ../../howto/clinic.rst:1172
msgid ""
"How do you specify the custom type you want to cast ``self`` to? If you only"
" have one or two functions with the same type for ``self``, you can directly"
" use Argument Clinic's existing ``self`` converter, passing in the type you "
"want to use as the ``type`` parameter::"
msgstr ""

#: ../../howto/clinic.rst:1188
msgid ""
"On the other hand, if you have a lot of functions that will use the same "
"type for ``self``, it's best to create your own converter, subclassing "
"``self_converter`` but overwriting the ``type`` member::"
msgstr ""

#: ../../howto/clinic.rst:1210
msgid "Using a \"defining class\" converter"
msgstr ""

#: ../../howto/clinic.rst:1212
msgid ""
"Argument Clinic facilitates gaining access to the defining class of a "
"method. This is useful for :ref:`heap type <heap-types>` methods that need "
"to fetch module level state.  Use :c:func:`PyType_FromModuleAndSpec` to "
"associate a new heap type with a module.  You can now use "
":c:func:`PyType_GetModuleState` on the defining class to fetch the module "
"state, for example from a module method."
msgstr ""

#: ../../howto/clinic.rst:1218
msgid ""
"Example from ``Modules/zlibmodule.c``.  First, ``defining_class`` is added "
"to the clinic input::"
msgstr ""

#: ../../howto/clinic.rst:1230
msgid ""
"After running the Argument Clinic tool, the following function signature is "
"generated::"
msgstr ""

#: ../../howto/clinic.rst:1240
msgid ""
"The following code can now use ``PyType_GetModuleState(cls)`` to fetch the "
"module state::"
msgstr ""

#: ../../howto/clinic.rst:1246
msgid ""
"Each method may only have one argument using this converter, and it must "
"appear after ``self``, or, if ``self`` is not used, as the first argument.  "
"The argument will be of type ``PyTypeObject *``.  The argument will not "
"appear in the ``__text_signature__``."
msgstr ""

#: ../../howto/clinic.rst:1251
msgid ""
"The ``defining_class`` converter is not compatible with ``__init__`` and "
"``__new__`` methods, which cannot use the ``METH_METHOD`` convention."
msgstr ""

#: ../../howto/clinic.rst:1254
msgid ""
"It is not possible to use ``defining_class`` with slot methods.  In order to"
" fetch the module state from such methods, use ``_PyType_GetModuleByDef`` to"
" look up the module and then :c:func:`PyModule_GetState` to fetch the module"
" state.  Example from the ``setattro`` slot method in "
"``Modules/_threadmodule.c``::"
msgstr ""

#: ../../howto/clinic.rst:1269
msgid "See also :pep:`573`."
msgstr ""

#: ../../howto/clinic.rst:1273
msgid "Writing a custom converter"
msgstr ""

#: ../../howto/clinic.rst:1275
msgid ""
"As we hinted at in the previous section... you can write your own "
"converters! A converter is simply a Python class that inherits from "
"``CConverter``. The main purpose of a custom converter is if you have a "
"parameter using the ``O&`` format unit—parsing this parameter means calling "
"a :c:func:`PyArg_ParseTuple` \"converter function\"."
msgstr ""

#: ../../howto/clinic.rst:1281
msgid ""
"Your converter class should be named ``*something*_converter``. If the name "
"follows this convention, then your converter class will be automatically "
"registered with Argument Clinic; its name will be the name of your class "
"with the ``_converter`` suffix stripped off.  (This is accomplished with a "
"metaclass.)"
msgstr ""

#: ../../howto/clinic.rst:1287
msgid ""
"You shouldn't subclass ``CConverter.__init__``.  Instead, you should write a"
" ``converter_init()`` function.  ``converter_init()`` always accepts a "
"``self`` parameter; after that, all additional parameters *must* be keyword-"
"only.  Any arguments passed in to the converter in Argument Clinic will be "
"passed along to your ``converter_init()``."
msgstr ""

#: ../../howto/clinic.rst:1294
msgid ""
"There are some additional members of ``CConverter`` you may wish to specify "
"in your subclass.  Here's the current list:"
msgstr ""

#: ../../howto/clinic.rst:1298
msgid ""
"The C type to use for this variable. ``type`` should be a Python string "
"specifying the type, e.g. ``int``. If this is a pointer type, the type "
"string should end with ``' *'``."
msgstr ""

#: ../../howto/clinic.rst:1304
msgid "``default``"
msgstr ""

#: ../../howto/clinic.rst:1303
msgid ""
"The Python default value for this parameter, as a Python value. Or the magic"
" value ``unspecified`` if there is no default."
msgstr ""

#: ../../howto/clinic.rst:1309
msgid "``py_default``"
msgstr ""

#: ../../howto/clinic.rst:1307
msgid ""
"``default`` as it should appear in Python code, as a string. Or ``None`` if "
"there is no default."
msgstr ""

#: ../../howto/clinic.rst:1312
msgid ""
"``default`` as it should appear in C code, as a string. Or ``None`` if there"
" is no default."
msgstr ""

#: ../../howto/clinic.rst:1325
msgid "``c_ignored_default``"
msgstr ""

#: ../../howto/clinic.rst:1317
msgid ""
"The default value used to initialize the C variable when there is no "
"default, but not specifying a default may result in an \"uninitialized "
"variable\" warning.  This can easily happen when using option "
"groups—although properly-written code will never actually use this value, "
"the variable does get passed in to the impl, and the C compiler will "
"complain about the \"use\" of the uninitialized value.  This value should "
"always be a non-empty string."
msgstr ""

#: ../../howto/clinic.rst:1328
msgid "The name of the C converter function, as a string."
msgstr ""

#: ../../howto/clinic.rst:1333
msgid "``impl_by_reference``"
msgstr ""

#: ../../howto/clinic.rst:1331
msgid ""
"A boolean value.  If true, Argument Clinic will add a ``&`` in front of the "
"name of the variable when passing it into the impl function."
msgstr ""

#: ../../howto/clinic.rst:1339
msgid "``parse_by_reference``"
msgstr ""

#: ../../howto/clinic.rst:1336
msgid ""
"A boolean value.  If true, Argument Clinic will add a ``&`` in front of the "
"name of the variable when passing it into :c:func:`PyArg_ParseTuple`."
msgstr ""

#: ../../howto/clinic.rst:1341
msgid ""
"Here's the simplest example of a custom converter, from "
"``Modules/zlibmodule.c``::"
msgstr ""

#: ../../howto/clinic.rst:1352
msgid ""
"This block adds a converter to Argument Clinic named ``ssize_t``.  "
"Parameters declared as ``ssize_t`` will be declared as type ``Py_ssize_t``, "
"and will be parsed by the ``'O&'`` format unit, which will call the "
"``ssize_t_converter`` converter function.  ``ssize_t`` variables "
"automatically support default values."
msgstr ""

#: ../../howto/clinic.rst:1358
msgid ""
"More sophisticated custom converters can insert custom C code to handle "
"initialization and cleanup. You can see more examples of custom converters "
"in the CPython source tree; grep the C files for the string ``CConverter``."
msgstr ""

#: ../../howto/clinic.rst:1364
msgid "Writing a custom return converter"
msgstr ""

#: ../../howto/clinic.rst:1366
msgid ""
"Writing a custom return converter is much like writing a custom converter.  "
"Except it's somewhat simpler, because return converters are themselves much "
"simpler."
msgstr ""

#: ../../howto/clinic.rst:1370
msgid ""
"Return converters must subclass ``CReturnConverter``. There are no examples "
"yet of custom return converters, because they are not widely used yet.  If "
"you wish to write your own return converter, please read "
"``Tools/clinic/clinic.py``, specifically the implementation of "
"``CReturnConverter`` and all its subclasses."
msgstr ""

#: ../../howto/clinic.rst:1378
msgid "METH_O and METH_NOARGS"
msgstr ""

#: ../../howto/clinic.rst:1380
msgid ""
"To convert a function using ``METH_O``, make sure the function's single "
"argument is using the ``object`` converter, and mark the arguments as "
"positional-only::"
msgstr ""

#: ../../howto/clinic.rst:1392
msgid ""
"To convert a function using ``METH_NOARGS``, just don't specify any "
"arguments."
msgstr ""

#: ../../howto/clinic.rst:1395
msgid ""
"You can still use a self converter, a return converter, and specify a "
"``type`` argument to the object converter for ``METH_O``."
msgstr ""

#: ../../howto/clinic.rst:1399
msgid "tp_new and tp_init functions"
msgstr ""

#: ../../howto/clinic.rst:1401
msgid ""
"You can convert ``tp_new`` and ``tp_init`` functions.  Just name them "
"``__new__`` or ``__init__`` as appropriate.  Notes:"
msgstr ""

#: ../../howto/clinic.rst:1404
msgid ""
"The function name generated for ``__new__`` doesn't end in ``__new__`` like "
"it would by default.  It's just the name of the class, converted into a "
"valid C identifier."
msgstr ""

#: ../../howto/clinic.rst:1408
msgid "No ``PyMethodDef`` ``#define`` is generated for these functions."
msgstr ""

#: ../../howto/clinic.rst:1410
msgid "``__init__`` functions return ``int``, not ``PyObject *``."
msgstr ""

#: ../../howto/clinic.rst:1412
msgid "Use the docstring as the class docstring."
msgstr ""

#: ../../howto/clinic.rst:1414
msgid ""
"Although ``__new__`` and ``__init__`` functions must always accept both the "
"``args`` and ``kwargs`` objects, when converting you may specify any "
"signature for these functions that you like. (If your function doesn't "
"support keywords, the parsing function generated will throw an exception if "
"it receives any.)"
msgstr ""

#: ../../howto/clinic.rst:1421
msgid "Changing and redirecting Clinic's output"
msgstr ""

#: ../../howto/clinic.rst:1423
msgid ""
"It can be inconvenient to have Clinic's output interspersed with your "
"conventional hand-edited C code.  Luckily, Clinic is configurable: you can "
"buffer up its output for printing later (or earlier!), or write its output "
"to a separate file.  You can also add a prefix or suffix to every line of "
"Clinic's generated output."
msgstr ""

#: ../../howto/clinic.rst:1429
msgid ""
"While changing Clinic's output in this manner can be a boon to readability, "
"it may result in Clinic code using types before they are defined, or your "
"code attempting to use Clinic-generated code before it is defined. These "
"problems can be easily solved by rearranging the declarations in your file, "
"or moving where Clinic's generated code goes.  (This is why the default "
"behavior of Clinic is to output everything into the current block; while "
"many people consider this hampers readability, it will never require "
"rearranging your code to fix definition-before-use problems.)"
msgstr ""

#: ../../howto/clinic.rst:1438
msgid "Let's start with defining some terminology:"
msgstr ""

#: ../../howto/clinic.rst:1465
msgid "*field*"
msgstr ""

#: ../../howto/clinic.rst:1441
msgid ""
"A field, in this context, is a subsection of Clinic's output. For example, "
"the ``#define`` for the ``PyMethodDef`` structure is a field, called "
"``methoddef_define``.  Clinic has seven different fields it can output per "
"function definition:"
msgstr ""

#: ../../howto/clinic.rst:1456
msgid ""
"All the names are of the form ``\"<a>_<b>\"``, where ``\"<a>\"`` is the "
"semantic object represented (the parsing function, the impl function, the "
"docstring, or the methoddef structure) and ``\"<b>\"`` represents what kind "
"of statement the field is.  Field names that end in ``\"_prototype\"`` "
"represent forward declarations of that thing, without the actual body/data "
"of the thing; field names that end in ``\"_definition\"`` represent the "
"actual definition of the thing, with the body/data of the thing.  "
"(``\"methoddef\"`` is special, it's the only one that ends with "
"``\"_define\"``, representing that it's a preprocessor #define.)"
msgstr ""

#: ../../howto/clinic.rst:1499
msgid "*destination*"
msgstr ""

#: ../../howto/clinic.rst:1468
msgid ""
"A destination is a place Clinic can write output to.  There are five built-"
"in destinations:"
msgstr ""

#: ../../howto/clinic.rst:1473 ../../howto/clinic.rst:1548
#: ../../howto/clinic.rst:1626
msgid "``block``"
msgstr ""

#: ../../howto/clinic.rst:1472
msgid ""
"The default destination: printed in the output section of the current Clinic"
" block."
msgstr ""

#: ../../howto/clinic.rst:1479 ../../howto/clinic.rst:1575
#: ../../howto/clinic.rst:1629
msgid "``buffer``"
msgstr ""

#: ../../howto/clinic.rst:1476
msgid ""
"A text buffer where you can save text for later.  Text sent here is appended"
" to the end of any existing text.  It's an error to have any text left in "
"the buffer when Clinic finishes processing a file."
msgstr ""

#: ../../howto/clinic.rst:1490 ../../howto/clinic.rst:1561
#: ../../howto/clinic.rst:1655
msgid "``file``"
msgstr ""

#: ../../howto/clinic.rst:1482
msgid ""
"A separate \"clinic file\" that will be created automatically by Clinic. The"
" filename chosen for the file is ``{basename}.clinic{extension}``, where "
"``basename`` and ``extension`` were assigned the output from "
"``os.path.splitext()`` run on the current file.  (Example: the ``file`` "
"destination for ``_pickle.c`` would be written to ``_pickle.clinic.c``.)"
msgstr ""

#: ../../howto/clinic.rst:1489
msgid ""
"**Important: When using a** ``file`` **destination, you** *must check in* "
"**the generated file!**"
msgstr ""

#: ../../howto/clinic.rst:1495 ../../howto/clinic.rst:1588
#: ../../howto/clinic.rst:1659
msgid "``two-pass``"
msgstr ""

#: ../../howto/clinic.rst:1493
msgid ""
"A buffer like ``buffer``.  However, a two-pass buffer can only be dumped "
"once, and it prints out all text sent to it during all processing, even from"
" Clinic blocks *after* the dumping point."
msgstr ""

#: ../../howto/clinic.rst:1499 ../../howto/clinic.rst:1622
msgid "``suppress``"
msgstr ""

#: ../../howto/clinic.rst:1498
msgid "The text is suppressed—thrown away."
msgstr ""

#: ../../howto/clinic.rst:1501
msgid ""
"Clinic defines five new directives that let you reconfigure its output."
msgstr ""

#: ../../howto/clinic.rst:1503
msgid "The first new directive is ``dump``:"
msgstr ""

#: ../../howto/clinic.rst:1509
msgid ""
"This dumps the current contents of the named destination into the output of "
"the current block, and empties it.  This only works with ``buffer`` and "
"``two-pass`` destinations."
msgstr ""

#: ../../howto/clinic.rst:1513
msgid ""
"The second new directive is ``output``.  The most basic form of ``output`` "
"is like this:"
msgstr ""

#: ../../howto/clinic.rst:1520
msgid ""
"This tells Clinic to output *field* to *destination*.  ``output`` also "
"supports a special meta-destination, called ``everything``, which tells "
"Clinic to output *all* fields to that *destination*."
msgstr ""

#: ../../howto/clinic.rst:1524
msgid "``output`` has a number of other functions:"
msgstr ""

#: ../../howto/clinic.rst:1533
msgid ""
"``output push`` and ``output pop`` allow you to push and pop configurations "
"on an internal configuration stack, so that you can temporarily modify the "
"output configuration, then easily restore the previous configuration.  "
"Simply push before your change to save the current configuration, then pop "
"when you wish to restore the previous configuration."
msgstr ""

#: ../../howto/clinic.rst:1540
msgid ""
"``output preset`` sets Clinic's output to one of several built-in preset "
"configurations, as follows:"
msgstr ""

#: ../../howto/clinic.rst:1544
msgid ""
"Clinic's original starting configuration.  Writes everything immediately "
"after the input block."
msgstr ""

#: ../../howto/clinic.rst:1547
msgid ""
"Suppress the ``parser_prototype`` and ``docstring_prototype``, write "
"everything else to ``block``."
msgstr ""

#: ../../howto/clinic.rst:1551
msgid ""
"Designed to write everything to the \"clinic file\" that it can. You then "
"``#include`` this file near the top of your file. You may need to rearrange "
"your file to make this work, though usually this just means creating forward"
" declarations for various ``typedef`` and ``PyTypeObject`` definitions."
msgstr ""

#: ../../howto/clinic.rst:1557
msgid ""
"Suppress the ``parser_prototype`` and ``docstring_prototype``, write the "
"``impl_definition`` to ``block``, and write everything else to ``file``."
msgstr ""

#: ../../howto/clinic.rst:1561
msgid "The default filename is ``\"{dirname}/clinic/{basename}.h\"``."
msgstr ""

#: ../../howto/clinic.rst:1564
msgid ""
"Save up most of the output from Clinic, to be written into your file near "
"the end.  For Python files implementing modules or builtin types, it's "
"recommended that you dump the buffer just above the static structures for "
"your module or builtin type; these are normally very near the end.  Using "
"``buffer`` may require even more editing than ``file``, if your file has "
"static ``PyMethodDef`` arrays defined in the middle of the file."
msgstr ""

#: ../../howto/clinic.rst:1573
msgid ""
"Suppress the ``parser_prototype``, ``impl_prototype``, and "
"``docstring_prototype``, write the ``impl_definition`` to ``block``, and "
"write everything else to ``file``."
msgstr ""

#: ../../howto/clinic.rst:1578
msgid ""
"Similar to the ``buffer`` preset, but writes forward declarations to the "
"``two-pass`` buffer, and definitions to the ``buffer``. This is similar to "
"the ``buffer`` preset, but may require less editing than ``buffer``.  Dump "
"the ``two-pass`` buffer near the top of your file, and dump the ``buffer`` "
"near the end just like you would when using the ``buffer`` preset."
msgstr ""

#: ../../howto/clinic.rst:1585
msgid ""
"Suppresses the ``impl_prototype``, write the ``impl_definition`` to "
"``block``, write ``docstring_prototype``, ``methoddef_define``, and "
"``parser_prototype`` to ``two-pass``, write everything else to ``buffer``."
msgstr ""

#: ../../howto/clinic.rst:1599
msgid "``partial-buffer``"
msgstr ""

#: ../../howto/clinic.rst:1591
msgid ""
"Similar to the ``buffer`` preset, but writes more things to ``block``, only "
"writing the really big chunks of generated code to ``buffer``. This avoids "
"the definition-before-use problem of ``buffer`` completely, at the small "
"cost of having slightly more stuff in the block's output. Dump the "
"``buffer`` near the end, just like you would when using the ``buffer`` "
"preset."
msgstr ""

#: ../../howto/clinic.rst:1598
msgid ""
"Suppresses the ``impl_prototype``, write the ``docstring_definition`` and "
"``parser_definition`` to ``buffer``, write everything else to ``block``."
msgstr ""

#: ../../howto/clinic.rst:1601
msgid "The third new directive is ``destination``:"
msgstr ""

#: ../../howto/clinic.rst:1607
msgid "This performs an operation on the destination named ``name``."
msgstr ""

#: ../../howto/clinic.rst:1609
msgid "There are two defined subcommands: ``new`` and ``clear``."
msgstr ""

#: ../../howto/clinic.rst:1611
msgid "The ``new`` subcommand works like this:"
msgstr ""

#: ../../howto/clinic.rst:1617
msgid ""
"This creates a new destination with name ``<name>`` and type ``<type>``."
msgstr ""

#: ../../howto/clinic.rst:1619
msgid "There are five destination types:"
msgstr ""

#: ../../howto/clinic.rst:1622
msgid "Throws the text away."
msgstr ""

#: ../../howto/clinic.rst:1625
msgid ""
"Writes the text to the current block.  This is what Clinic originally did."
msgstr ""

#: ../../howto/clinic.rst:1629
msgid "A simple text buffer, like the \"buffer\" builtin destination above."
msgstr ""

#: ../../howto/clinic.rst:1632
msgid ""
"A text file.  The file destination takes an extra argument, a template to "
"use for building the filename, like so:"
msgstr ""

#: ../../howto/clinic.rst:1635
msgid "destination <name> new <type> <file_template>"
msgstr ""

#: ../../howto/clinic.rst:1637
msgid ""
"The template can use three strings internally that will be replaced by bits "
"of the filename:"
msgstr ""

#: ../../howto/clinic.rst:1640
msgid "{path}"
msgstr ""

#: ../../howto/clinic.rst:1641
msgid "The full path to the file, including directory and full filename."
msgstr ""

#: ../../howto/clinic.rst:1642
msgid "{dirname}"
msgstr ""

#: ../../howto/clinic.rst:1643
msgid "The name of the directory the file is in."
msgstr ""

#: ../../howto/clinic.rst:1644
msgid "{basename}"
msgstr ""

#: ../../howto/clinic.rst:1645
msgid "Just the name of the file, not including the directory."
msgstr ""

#: ../../howto/clinic.rst:1647
msgid "{basename_root}"
msgstr ""

#: ../../howto/clinic.rst:1647
msgid ""
"Basename with the extension clipped off (everything up to but not including "
"the last '.')."
msgstr ""

#: ../../howto/clinic.rst:1651
msgid "{basename_extension}"
msgstr ""

#: ../../howto/clinic.rst:1650
msgid ""
"The last '.' and everything after it.  If the basename does not contain a "
"period, this will be the empty string."
msgstr ""

#: ../../howto/clinic.rst:1653
msgid ""
"If there are no periods in the filename, {basename} and {filename} are the "
"same, and {extension} is empty.  \"{basename}{extension}\" is always exactly"
" the same as \"{filename}\".\""
msgstr ""

#: ../../howto/clinic.rst:1658
msgid "A two-pass buffer, like the \"two-pass\" builtin destination above."
msgstr ""

#: ../../howto/clinic.rst:1661
msgid "The ``clear`` subcommand works like this:"
msgstr ""

#: ../../howto/clinic.rst:1667
msgid ""
"It removes all the accumulated text up to this point in the destination. (I "
"don't know what you'd need this for, but I thought maybe it'd be useful "
"while someone's experimenting.)"
msgstr ""

#: ../../howto/clinic.rst:1671
msgid "The fourth new directive is ``set``:"
msgstr ""

#: ../../howto/clinic.rst:1678
msgid ""
"``set`` lets you set two internal variables in Clinic. ``line_prefix`` is a "
"string that will be prepended to every line of Clinic's output; "
"``line_suffix`` is a string that will be appended to every line of Clinic's "
"output."
msgstr ""

#: ../../howto/clinic.rst:1682
msgid "Both of these support two format strings:"
msgstr ""

#: ../../howto/clinic.rst:1685
msgid "``{block comment start}``"
msgstr ""

#: ../../howto/clinic.rst:1685
msgid ""
"Turns into the string ``/*``, the start-comment text sequence for C files."
msgstr ""

#: ../../howto/clinic.rst:1688
msgid "``{block comment end}``"
msgstr ""

#: ../../howto/clinic.rst:1688
msgid ""
"Turns into the string ``*/``, the end-comment text sequence for C files."
msgstr ""

#: ../../howto/clinic.rst:1690
msgid ""
"The final new directive is one you shouldn't need to use directly, called "
"``preserve``:"
msgstr ""

#: ../../howto/clinic.rst:1697
msgid ""
"This tells Clinic that the current contents of the output should be kept, "
"unmodified. This is used internally by Clinic when dumping output into "
"``file`` files; wrapping it in a Clinic block lets Clinic use its existing "
"checksum functionality to ensure the file was not modified by hand before it"
" gets overwritten."
msgstr ""

#: ../../howto/clinic.rst:1704
msgid "The #ifdef trick"
msgstr ""

#: ../../howto/clinic.rst:1706
msgid ""
"If you're converting a function that isn't available on all platforms, "
"there's a trick you can use to make life a little easier.  The existing code"
" probably looks like this::"
msgstr ""

#: ../../howto/clinic.rst:1717
msgid ""
"And then in the ``PyMethodDef`` structure at the bottom the existing code "
"will have:"
msgstr ""

#: ../../howto/clinic.rst:1726
msgid ""
"In this scenario, you should enclose the body of your impl function inside "
"the ``#ifdef``, like so::"
msgstr ""

#: ../../howto/clinic.rst:1740
msgid ""
"Then, remove those three lines from the ``PyMethodDef`` structure, replacing"
" them with the macro Argument Clinic generated:"
msgstr ""

#: ../../howto/clinic.rst:1747
msgid ""
"(You can find the real name for this macro inside the generated code. Or you"
" can calculate it yourself: it's the name of your function as defined on the"
" first line of your block, but with periods changed to underscores, "
"uppercased, and ``\"_METHODDEF\"`` added to the end.)"
msgstr ""

#: ../../howto/clinic.rst:1752
msgid ""
"Perhaps you're wondering: what if ``HAVE_FUNCTIONNAME`` isn't defined? The "
"``MODULE_FUNCTIONNAME_METHODDEF`` macro won't be defined either!"
msgstr ""

#: ../../howto/clinic.rst:1755
msgid ""
"Here's where Argument Clinic gets very clever.  It actually detects that the"
" Argument Clinic block might be deactivated by the ``#ifdef``.  When that "
"happens, it generates a little extra code that looks like this::"
msgstr ""

#: ../../howto/clinic.rst:1763
msgid ""
"That means the macro always works.  If the function is defined, this turns "
"into the correct structure, including the trailing comma.  If the function "
"is undefined, this turns into nothing."
msgstr ""

#: ../../howto/clinic.rst:1767
msgid ""
"However, this causes one ticklish problem: where should Argument Clinic put "
"this extra code when using the \"block\" output preset?  It can't go in the "
"output block, because that could be deactivated by the ``#ifdef``.  (That's "
"the whole point!)"
msgstr ""

#: ../../howto/clinic.rst:1771
msgid ""
"In this situation, Argument Clinic writes the extra code to the \"buffer\" "
"destination. This may mean that you get a complaint from Argument Clinic:"
msgstr ""

#: ../../howto/clinic.rst:1779
msgid ""
"When this happens, just open your file, find the ``dump buffer`` block that "
"Argument Clinic added to your file (it'll be at the very bottom), then move "
"it above the ``PyMethodDef`` structure where that macro is used."
msgstr ""

#: ../../howto/clinic.rst:1786
msgid "Using Argument Clinic in Python files"
msgstr ""

#: ../../howto/clinic.rst:1788
msgid ""
"It's actually possible to use Argument Clinic to preprocess Python files. "
"There's no point to using Argument Clinic blocks, of course, as the output "
"wouldn't make any sense to the Python interpreter.  But using Argument "
"Clinic to run Python blocks lets you use Python as a Python preprocessor!"
msgstr ""

#: ../../howto/clinic.rst:1793
msgid ""
"Since Python comments are different from C comments, Argument Clinic blocks "
"embedded in Python files look slightly different.  They look like this:"
msgstr ""
