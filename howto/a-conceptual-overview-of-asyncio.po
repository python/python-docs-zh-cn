# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# ProgramRipper, 2025
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-29 15:18+0000\n"
"PO-Revision-Date: 2025-08-09 15:10+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:5
msgid "A Conceptual Overview of :mod:`!asyncio`"
msgstr ":mod:`!asyncio` 的概念概述"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:7
msgid ""
"This :ref:`HOWTO <how-tos>` article seeks to help you build a sturdy mental "
"model of how :mod:`asyncio` fundamentally works, helping you understand the "
"how and why behind the recommended patterns."
msgstr ""
"这篇 :ref:`指南 <how-tos>` 文章旨在帮助您构建一个关于 :mod:`asyncio` "
"基本运作原理的坚固心智模型，帮助您理解推荐模式背后的原理和原因。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:11
msgid ""
"You might be curious about some key :mod:`!asyncio` concepts. You'll be "
"comfortably able to answer these questions by the end of this article:"
msgstr "您可能会对 :mod:`!asyncio` 的一些关键概念感到好奇。读完本文后，您将能够轻松地回答这些问题："

#: ../../howto/a-conceptual-overview-of-asyncio.rst:15
msgid "What's happening behind the scenes when an object is awaited?"
msgstr "当一个对象被等待时，幕后发生了什么？"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:16
msgid ""
"How does :mod:`!asyncio` differentiate between a task which doesn't need "
"CPU-time (such as a network request or file read) as opposed to a task that "
"does (such as computing n-factorial)?"
msgstr ""
":mod:`!asyncio` 如何区分不需要 CPU 时间的任务（如网络请求或文件读取）和需要 CPU 时间的任务（如计算 n 的阶乘）？"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:19
msgid ""
"How to write an asynchronous variant of an operation, such as an async sleep"
" or database request."
msgstr "如何编写一个操作的异步变体，例如异步的休眠或数据库请求。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:24
msgid ""
"The `guide <https://github.com/anordin95/a-conceptual-overview-of-asyncio/ "
"tree/main>`_ that inspired this HOWTO article, by Alexander Nordin."
msgstr ""
"启发这篇指南文章的 `指南 <https://github.com/anordin95/a-conceptual-overview-of-"
"asyncio/ tree/main>`_ ，作者是 Alexander Nordin。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:26
msgid ""
"This in-depth `YouTube tutorial series <https://www.youtube.com/ "
"watch?v=Xbl7XjFYsN4&list=PLhNSoGM2ik6SIkVGXWBwerucXjgP1rHmB>`_ on "
"``asyncio`` created by Python core team member, Łukasz Langa."
msgstr ""
"这套深入讲解 ``asyncio`` 的 `YouTube 教程系列 <https://www.youtube.com/ "
"watch?v=Xbl7XjFYsN4&list=PLhNSoGM2ik6SIkVGXWBwerucXjgP1rHmB>`_，由 Python "
"核心团队成员 Łukasz Langa 制作。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:29
msgid ""
"`500 Lines or Less: A Web Crawler With asyncio Coroutines <https:// "
"aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html>`_ by A. "
"Jesse Jiryu Davis and Guido van Rossum."
msgstr ""
"`500 Lines or Less: A Web Crawler With asyncio Coroutines <https:// "
"aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html>`_，作者是 A. "
"Jesse Jiryu Davis 和 Guido van Rossum。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:35
msgid "A conceptual overview part 1: the high-level"
msgstr "概念概述第 1 部分：高层次"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:37
msgid ""
"In part 1, we'll cover the main, high-level building blocks of "
":mod:`!asyncio`: the event loop, coroutine functions, coroutine objects, "
"tasks and ``await``."
msgstr ""
"在第 1 部分中，我们将介绍 :mod:`!asyncio` 的主要高层次基本单元：事件循环、协程函数、协程对象、任务和 ``await``。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:42
msgid "Event Loop"
msgstr "事件循环"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:44
msgid ""
"Everything in :mod:`!asyncio` happens relative to the event loop. It's the "
"star of the show. It's like an orchestra conductor. It's behind the scenes "
"managing resources. Some power is explicitly granted to it, but a lot of its"
" ability to get things done comes from the respect and cooperation of its "
"worker bees."
msgstr ""
":mod:`!asyncio` "
"中的一切都与事件循环相关。它是演出的主角。它就像乐队指挥。它在幕后管理资源。它拥有一些明确的权力，但它完成工作的能力很大程度上来自于工蜂们的尊重与合作。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:51
msgid ""
"In more technical terms, the event loop contains a collection of jobs to be "
"run. Some jobs are added directly by you, and some indirectly by "
":mod:`!asyncio`. The event loop takes a job from its backlog of work and "
"invokes it (or \"gives it control\"), similar to calling a function, and "
"then that job runs. Once it pauses or completes, it returns control to the "
"event loop. The event loop will then select another job from its pool and "
"invoke it. You can *roughly* think of the collection of jobs as a queue: "
"jobs are added and then processed one at a time, generally (but not always) "
"in order. This process repeats indefinitely with the event loop cycling "
"endlessly onwards. If there are no more jobs pending execution, the event "
"loop is smart enough to rest and avoid needlessly wasting CPU cycles, and "
"will come back when there's more work to be done."
msgstr ""
"用更专业的术语来说，事件循环包含一组待运行的作业。有些作业由您直接添加，有些则由:mod:`!asyncio` "
"间接添加。事件循环会从其待处理的工作队列中取出一个作业并唤起它（或者说“赋予其控制权”），类似于调用函数，然后该作业就会运行。一旦作业暂停或完成，它就会将控制权交还给事件循环。之后，事件循环会从作业池中选择另一项作业并唤起它。您可以"
" *粗略地* "
"把这组作业看作一个队列：作业被添加，然后被逐个处理，一般（但不总是）按顺序进行。此过程无限重复，事件循环也随之无限循环。如果没有待执行的作业，事件循环会智能地休息一下，避免无谓地浪费"
" CPU 周期，并在有更多工作需要处理时再恢复运行。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:65
msgid ""
"Effective execution relies on jobs sharing well and cooperating; a greedy "
"job could hog control and leave the other jobs to starve, rendering the "
"overall event loop approach rather useless."
msgstr "有效的执行依赖于作业的良好共享和合作；一个贪婪的作业可能会霸占控制权，让其他作业陷入饥饿，从而使整个事件循环机制变得毫无用处。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:71
msgid ""
"import asyncio\n"
"\n"
"# This creates an event loop and indefinitely cycles through\n"
"# its collection of jobs.\n"
"event_loop = asyncio.new_event_loop()\n"
"event_loop.run_forever()"
msgstr ""
"import asyncio\n"
"\n"
"# 这会创建一个事件循环并无限循环地执行其作业集合。\n"
"event_loop = asyncio.new_event_loop()\n"
"event_loop.run_forever()"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:80
msgid "Asynchronous functions and coroutines"
msgstr "异步函数和协程"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:82
msgid "This is a basic, boring Python function::"
msgstr "这是一个基本的、无趣的Python 函数："

#: ../../howto/a-conceptual-overview-of-asyncio.rst:84
msgid ""
"def hello_printer():\n"
"    print(\n"
"        \"Hi, I am a lowly, simple printer, though I have all I \"\n"
"        \"need in life -- \\nfresh paper and my dearly beloved octopus \"\n"
"        \"partner in crime.\"\n"
"    )"
msgstr ""
"def hello_printer():\n"
"    print(\n"
"        \"Hi, I am a lowly, simple printer, though I have all I \"\n"
"        \"need in life -- \\nfresh paper and my dearly beloved octopus \"\n"
"        \"partner in crime.\"\n"
"    )"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:91
msgid "Calling a regular function invokes its logic or body::"
msgstr "调用一个普通函数会执行它的逻辑或函数体："

#: ../../howto/a-conceptual-overview-of-asyncio.rst:93
msgid ""
">>> hello_printer()\n"
"Hi, I am a lowly, simple printer, though I have all I need in life --\n"
"fresh paper and my dearly beloved octopus partner in crime."
msgstr ""
">>> hello_printer()\n"
"Hi, I am a lowly, simple printer, though I have all I need in life --\n"
"fresh paper and my dearly beloved octopus partner in crime."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:97
msgid ""
"The :ref:`async def <async def>`, as opposed to just a plain ``def``, makes "
"this an asynchronous function (or \"coroutine function\"). Calling it "
"creates and returns a :ref:`coroutine <coroutine>` object."
msgstr ""
"与普通的 ``def`` 不同，:ref:`async def <async def>` 使它成为一个异步函数（或“协程函数”）。调用它会创建并返回一个"
" :ref:`协程 <coroutine>` 对象。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:103
msgid ""
"async def loudmouth_penguin(magic_number: int):\n"
"    print(\n"
"     \"I am a super special talking penguin. Far cooler than that printer. \"\n"
"     f\"By the way, my lucky number is: {magic_number}.\"\n"
"    )"
msgstr ""
"async def loudmouth_penguin(magic_number: int):\n"
"    print(\n"
"     \"I am a super special talking penguin. Far cooler than that printer. \"\n"
"     f\"By the way, my lucky number is: {magic_number}.\"\n"
"    )"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:109
msgid ""
"Calling the async function, ``loudmouth_penguin``, does not execute the "
"print statement; instead, it creates a coroutine object::"
msgstr "调用异步函数 ``loudmouth_penguin`` 不会执行打印语句 ；相反，它会创建一个协程对象："

#: ../../howto/a-conceptual-overview-of-asyncio.rst:112
msgid ""
">>> loudmouth_penguin(magic_number=3)\n"
"<coroutine object loudmouth_penguin at 0x104ed2740>"
msgstr ""
">>> loudmouth_penguin(magic_number=3)\n"
"<coroutine object loudmouth_penguin at 0x104ed2740>"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:115
msgid ""
"The terms \"coroutine function\" and \"coroutine object\" are often "
"conflated as coroutine. That can be confusing! In this article, coroutine "
"specifically refers to a coroutine object, or more precisely, an instance of"
" :data:`types.CoroutineType` (native coroutine). Note that coroutines can "
"also exist as instances of :class:`collections.abc.Coroutine` -- a "
"distinction that matters for type checking."
msgstr ""
"“协程函数”和“协程对象”这两个术语经常被统称为协程。这可能会引起混淆！在本文中，协程特指协程 对象，或者更准确地说，是 "
":data:`types.CoroutineType` 的实例 （原生协程 ）。请注意，协程也可以作为 "
":class:`collections.abc.Coroutine` 的实例存在——这一点对于类型检查来说很重要。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:124
msgid ""
"A coroutine represents the function's body or logic. A coroutine has to be "
"explicitly started; again, merely creating the coroutine does not start it. "
"Notably, the coroutine can be paused and resumed at various points within "
"the function's body. That pausing and resuming ability is what allows for "
"asynchronous behavior!"
msgstr ""
"协程代表函数体或逻辑。协程必须显式启动；同样的，仅仅创建协程并不能启动它。值得注意的是，协程可以在函数体的不同位置暂停和恢复。这种暂停和恢复能力使得异步行为成为可能！"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:131
msgid ""
"Coroutines and coroutine functions were built by leveraging the "
"functionality of :term:`generators <generator iterator>` and "
":term:`generator functions <generator>`. Recall, a generator function is a "
"function that :keyword:`yield`\\s, like this one::"
msgstr ""
"协程和协程函数是利用 :term:`生成器 <generator iterator>` 和 :term:`生成器函数 <generator>` "
"构建的。回想一下，生成器函数是一个会 :keyword:`yield` 的函数，就像这样："

#: ../../howto/a-conceptual-overview-of-asyncio.rst:137
msgid ""
"def get_random_number():\n"
"    # This would be a bad random number generator!\n"
"    print(\"Hi\")\n"
"    yield 1\n"
"    print(\"Hello\")\n"
"    yield 7\n"
"    print(\"Howdy\")\n"
"    yield 4\n"
"    ..."
msgstr ""
"def get_random_number():\n"
"    # 这将是一个糟糕的随机数生成器！\n"
"    print(\"Hi\")\n"
"    yield 1\n"
"    print(\"Hello\")\n"
"    yield 7\n"
"    print(\"Howdy\")\n"
"    yield 4\n"
"    ..."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:147
msgid ""
"Similar to a coroutine function, calling a generator function does not run "
"it. Instead, it creates a generator object::"
msgstr "与协程函数类似，调用生成器函数并不会运行该函数，而是创建一个生成器对象："

#: ../../howto/a-conceptual-overview-of-asyncio.rst:150
msgid ""
">>> get_random_number()\n"
"<generator object get_random_number at 0x1048671c0>"
msgstr ""
">>> get_random_number()\n"
"<generator object get_random_number at 0x1048671c0>"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:153
msgid ""
"You can proceed to the next ``yield`` of a generator by using the built-in "
"function :func:`next`. In other words, the generator runs, then pauses. For "
"example::"
msgstr "您可以通过内置函数 :func:`next` 执行生成器到下一个 ``yield``。换句话说，生成器运行，然后暂停。例如："

#: ../../howto/a-conceptual-overview-of-asyncio.rst:158
msgid ""
">>> generator = get_random_number()\n"
">>> next(generator)\n"
"Hi\n"
"1\n"
">>> next(generator)\n"
"Hello\n"
"7"
msgstr ""
">>> generator = get_random_number()\n"
">>> next(generator)\n"
"Hi\n"
"1\n"
">>> next(generator)\n"
"Hello\n"
"7"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:168
msgid "Tasks"
msgstr "任务"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:170
msgid ""
"Roughly speaking, :ref:`tasks <asyncio-task-obj>` are coroutines (not "
"coroutine functions) tied to an event loop. A task also maintains a list of "
"callback functions whose importance will become clear in a moment when we "
"discuss :keyword:`await`. The recommended way to create tasks is via "
":func:`asyncio.create_task`."
msgstr ""
"粗略地说，:ref:`任务 <asyncio-task-obj>` "
"是绑定到事件循环的协程（而非协程函数）。任务还维护一个回调函数列表，这些回调函数的重要性在稍后讨论 :keyword:`await` "
"时会更加清晰。推荐使用 :func:`asyncio.create_task` 创建任务。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:176
msgid ""
"Creating a task automatically schedules it for execution (by adding a "
"callback to run it in the event loop's to-do list, that is, collection of "
"jobs)."
msgstr "创建任务会自动安排它的执行（通过在事件循环的待办事项列表（即作业集合）中添加回调函数来运行它）。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:179
msgid ""
"Since there's only one event loop (in each thread), :mod:`!asyncio` takes "
"care of associating the task with the event loop for you. As such, there's "
"no need to specify the event loop."
msgstr "由于（每个线程中）只有一个事件循环，:mod:`!asyncio` 会帮您把任务与事件循环关联起来。因此，您无需指定事件循环。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:185
msgid ""
"coroutine = loudmouth_penguin(magic_number=5)\n"
"# This creates a Task object and schedules its execution via the event loop.\n"
"task = asyncio.create_task(coroutine)"
msgstr ""
"coroutine = loudmouth_penguin(magic_number=5)\n"
"# 这将创建一个 Task 对象并通过事件循环安排其执行。\n"
"task = asyncio.create_task(coroutine)"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:189
msgid ""
"Earlier, we manually created the event loop and set it to run forever. In "
"practice, it's recommended to use (and common to see) :func:`asyncio.run`, "
"which takes care of managing the event loop and ensuring the provided "
"coroutine finishes before advancing. For example, many async programs follow"
" this setup::"
msgstr ""
"之前，我们手动创建了事件循环并将其设置为永久运行。实际上，推荐（且常见）的做法是使用 "
":func:`asyncio.run`，它负责管理事件循环并确保提供的协程在继续执行之前结束。例如，许多异步程序都遵循以下设置："

#: ../../howto/a-conceptual-overview-of-asyncio.rst:195
msgid ""
"import asyncio\n"
"\n"
"async def main():\n"
"    # Perform all sorts of wacky, wild asynchronous things...\n"
"    ...\n"
"\n"
"if __name__ == \"__main__\":\n"
"    asyncio.run(main())\n"
"    # The program will not reach the following print statement until the\n"
"    # coroutine main() finishes.\n"
"    print(\"coroutine main() is done!\")"
msgstr ""
"import asyncio\n"
"\n"
"async def main():\n"
"    # 执行各种稀奇古怪、天马行空的异步操作……\n"
"    ...\n"
"\n"
"if __name__ == \"__main__\":\n"
"    asyncio.run(main())\n"
"    # 直到协程 main() 结束，程序才会到达下面的打印语句。\n"
"    print(\"coroutine main() is done!\")"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:207
msgid ""
"It's important to be aware that the task itself is not added to the event "
"loop, only a callback to the task is. This matters if the task object you "
"created is garbage collected before it's called by the event loop. For "
"example, consider this program:"
msgstr ""
"需要注意的是，任务本身不会被添加到事件循环中，只有任务的回调函数才会被添加到事件循环中。如果您创建的任务对象在被事件循环调用之前就被垃圾回收了，这就会产生问题。例如，考虑这个程序："

#: ../../howto/a-conceptual-overview-of-asyncio.rst:213
msgid ""
"async def hello():\n"
"    print(\"hello!\")\n"
"\n"
"async def main():\n"
"    asyncio.create_task(hello())\n"
"    # Other asynchronous instructions which run for a while\n"
"    # and cede control to the event loop...\n"
"    ...\n"
"\n"
"asyncio.run(main())"
msgstr ""
"async def hello():\n"
"    print(\"hello!\")\n"
"\n"
"async def main():\n"
"    asyncio.create_task(hello())\n"
"    # 其他异步指令运行一段时间并将控制权交还给事件循环......\n"
"    ...\n"
"\n"
"asyncio.run(main())"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:227
msgid ""
"Because there's no reference to the task object created on line 5, it "
"*might* be garbage collected before the event loop invokes it. Later "
"instructions in the coroutine ``main()`` hand control back to the event loop"
" so it can invoke other jobs. When the event loop eventually tries to run "
"the task, it might fail and discover the task object does not exist! This "
"can also happen even if a coroutine keeps a reference to a task but "
"completes before that task finishes. When the coroutine exits, local "
"variables go out of scope and may be subject to garbage collection. In "
"practice, ``asyncio`` and Python's garbage collector work pretty hard to "
"ensure this sort of thing doesn't happen. But that's no reason to be "
"reckless!"
msgstr ""
"由于没有对第 5 行创建的任务对象的引用，它 *可能* 在事件循环调用它之前就被垃圾回收了。协程 ``main()`` "
"中的后续指令将控制权交还给事件循环，以便它可以调用其他作业。当事件循环最终尝试运行该任务时，它可能会失败并发现任务对象不存在！即使协程持有对某个任务的引用，但如果协程在该任务结束之前就完成了，也可能发生这种情况。当协程退出时，局部变量超出范围，可能被垃圾回收。实际上，``asyncio``"
" 和 Python 的垃圾回收器会非常努力地确保此类事情不会发生。但这并不是鲁莽行事的理由！"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:243
msgid "await"
msgstr "await"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:245
msgid ""
":keyword:`await` is a Python keyword that's commonly used in one of two "
"different ways::"
msgstr ":keyword:`await` 是一个 Python 关键字，通常以两种不同的方式使用："

#: ../../howto/a-conceptual-overview-of-asyncio.rst:248
msgid ""
"await task\n"
"await coroutine"
msgstr ""
"await task\n"
"await coroutine"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:251
msgid ""
"In a crucial way, the behavior of ``await`` depends on the type of object "
"being awaited."
msgstr "从关键方面来说，``await`` 的行为取决于所等待对象的类型。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:254
msgid ""
"Awaiting a task will cede control from the current task or coroutine to the "
"event loop. In the process of relinquishing control, a few important things "
"happen. We'll use the following code example to illustrate::"
msgstr "等待任务会将控制权从当前任务或协程交还给事件循环。在交还控制权的过程中，会发生一些重要的事情。我们将使用以下代码示例来说明："

#: ../../howto/a-conceptual-overview-of-asyncio.rst:259
msgid ""
"async def plant_a_tree():\n"
"    dig_the_hole_task = asyncio.create_task(dig_the_hole())\n"
"    await dig_the_hole_task\n"
"\n"
"    # Other instructions associated with planting a tree.\n"
"    ..."
msgstr ""
"async def plant_a_tree():\n"
"    dig_the_hole_task = asyncio.create_task(dig_the_hole())\n"
"    await dig_the_hole_task\n"
"\n"
"    # 与植树相关的其他指令。\n"
"    ..."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:266
msgid ""
"In this example, imagine the event loop has passed control to the start of "
"the coroutine ``plant_a_tree()``. As seen above, the coroutine creates a "
"task and then awaits it. The ``await dig_the_hole_task`` instruction adds a "
"callback (which will resume ``plant_a_tree()``) to the ``dig_the_hole_task``"
" object's list of callbacks. And then, the instruction cedes control to the "
"event loop. Some time later, the event loop will pass control to "
"``dig_the_hole_task`` and the task will finish whatever it needs to do. Once"
" the task finishes, it will add its various callbacks to the event loop, in "
"this case, a call to resume ``plant_a_tree()``."
msgstr ""
"在这个例子中，假设事件循环已经将控制权交给了协程 ``plant_a_tree()`` 的开始部分。如上所示，协程创建了一个任务，然后对其执行了 "
"await。``await dig_the_hole_task`` 这条指令会将一个回调函数（用于恢复 ``plant_a_tree()`` "
"的执行）添加到 ``dig_the_hole_task`` "
"对象的回调函数列表中。随后，这条指令将控制权交还给事件循环。过一段时间后，事件循环会将控制权传递给 "
"``dig_the_hole_task``，该任务会完成它需要做的工作。一旦任务结束，它会将它的各种回调函数添加到事件循环中，在这里是恢复 "
"``plant_a_tree()`` 的执行。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:277
msgid ""
"Generally speaking, when the awaited task finishes (``dig_the_hole_task``), "
"the original task or coroutine (``plant_a_tree()``) is added back to the "
"event loops to-do list to be resumed."
msgstr ""
"一般来说，当等待的任务（``dig_the_hole_task``）完成时，原先的任务或协程（``plant_a_tree()``）将被添加回事件循环待办事项列表以恢复运行。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:281
msgid ""
"This is a basic, yet reliable mental model. In practice, the control "
"handoffs are slightly more complex, but not by much. In part 2, we'll walk "
"through the details that make this possible."
msgstr "这是一个基础但可靠的思维模型。实际操作中，控制权交接会稍微复杂一些，但不会复杂太多。在第 2 部分中，我们将逐步讲解实现这一目标的细节。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:285
msgid ""
"**Unlike tasks, awaiting a coroutine does not hand control back to the event"
" loop!** Wrapping a coroutine in a task first, then awaiting that would cede"
" control. The behavior of ``await coroutine`` is effectively the same as "
"invoking a regular, synchronous Python function. Consider this program::"
msgstr ""
"**与任务不同，等待协程并不会将控制权交还给事件循环！** 先将协程包装到任务中，然后再等待，会导致控制权交还。``await coroutine`` "
"的行为实际上与调用常规的同步 Python 函数相同。考虑以下程序："

#: ../../howto/a-conceptual-overview-of-asyncio.rst:293
msgid ""
"import asyncio\n"
"\n"
"async def coro_a():\n"
"   print(\"I am coro_a(). Hi!\")\n"
"\n"
"async def coro_b():\n"
"   print(\"I am coro_b(). I sure hope no one hogs the event loop...\")\n"
"\n"
"async def main():\n"
"   task_b = asyncio.create_task(coro_b())\n"
"   num_repeats = 3\n"
"   for _ in range(num_repeats):\n"
"      await coro_a()\n"
"   await task_b\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"async def coro_a():\n"
"   print(\"I am coro_a(). Hi!\")\n"
"\n"
"async def coro_b():\n"
"   print(\"I am coro_b(). I sure hope no one hogs the event loop...\")\n"
"\n"
"async def main():\n"
"   task_b = asyncio.create_task(coro_b())\n"
"   num_repeats = 3\n"
"   for _ in range(num_repeats):\n"
"      await coro_a()\n"
"   await task_b\n"
"\n"
"asyncio.run(main())"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:310
msgid ""
"The first statement in the coroutine ``main()`` creates ``task_b`` and "
"schedules it for execution via the event loop. Then, ``coro_a()`` is "
"repeatedly awaited. Control never cedes to the event loop which is why we "
"see the output of all three ``coro_a()`` invocations before ``coro_b()``'s "
"output:"
msgstr ""
"协程 ``main()`` 中的第一条语句创建 ``task_b``，并通过事件循环调度它执行。然后，重复等待 "
"``coro_a()``。控制权从未被交还给事件循环，这就是为什么我们在 ``coro_b()`` 的输出之前看到了所有三个 ``coro_a()`` "
"调用的输出："

#: ../../howto/a-conceptual-overview-of-asyncio.rst:316
msgid ""
"I am coro_a(). Hi!\n"
"I am coro_a(). Hi!\n"
"I am coro_a(). Hi!\n"
"I am coro_b(). I sure hope no one hogs the event loop..."
msgstr ""
"I am coro_a(). Hi!\n"
"I am coro_a(). Hi!\n"
"I am coro_a(). Hi!\n"
"I am coro_b(). I sure hope no one hogs the event loop..."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:323
msgid ""
"If we change ``await coro_a()`` to ``await asyncio.create_task(coro_a())``, "
"the behavior changes. The coroutine ``main()`` cedes control to the event "
"loop with that statement. The event loop then proceeds through its backlog "
"of work, calling ``task_b`` and then the task which wraps ``coro_a()`` "
"before resuming the coroutine ``main()``."
msgstr ""
"如果我们将 ``await coro_a()`` 改为 ``await "
"asyncio.create_task(coro_a())``，行为就会发生变化。协程 ``main()`` "
"会通过该语句将控制权交还给事件循环。然后，事件循环会继续处理其积压的工作，先调用 ``task_b``，然后调用包装 ``coro_a()`` "
"的任务，最后恢复协程 ``main()``。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:330
msgid ""
"I am coro_b(). I sure hope no one hogs the event loop...\n"
"I am coro_a(). Hi!\n"
"I am coro_a(). Hi!\n"
"I am coro_a(). Hi!"
msgstr ""
"I am coro_b(). I sure hope no one hogs the event loop...\n"
"I am coro_a(). Hi!\n"
"I am coro_a(). Hi!\n"
"I am coro_a(). Hi!"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:337
msgid ""
"This behavior of ``await coroutine`` can trip a lot of people up! That "
"example highlights how using only ``await coroutine`` could unintentionally "
"hog control from other tasks and effectively stall the event loop. "
":func:`asyncio.run` can help you detect such occurences via the "
"``debug=True`` flag which accordingly enables :ref:`debug mode <asyncio-"
"debug-mode>`. Among other things, it will log any coroutines that monopolize"
" execution for 100ms or longer."
msgstr ""
"这种 ``await coroutine`` 的行为可能会让很多人犯错！这个例子强调了仅使用 ``await coroutine`` "
"可能会无意中霸占其他任务的控制权，并导致事件循环停滞。:func:`asyncio.run` 可以通过 ``debug=True`` "
"标志来检测此类情况，该标志会相应地启用 :ref:`调试模式 <asyncio-debug-mode>`。此外，它还会记录任何独占执行时间 100 "
"毫秒或更长时间的协程。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:347
msgid ""
"The design intentionally trades off some conceptual clarity around usage of "
"``await`` for improved performance. Each time a task is awaited, control "
"needs to be passed all the way up the call stack to the event loop. That "
"might sound minor, but in a large program with many ``await``'s and a deep "
"callstack that overhead can add up to a meaningful performance drag."
msgstr ""
"该设计有意牺牲了 ``await`` "
"用法的一些概念清晰度，以提升性能。每次等待任务时，控制权都需要沿着调用栈一路向上传递到事件循环。这听起来可能微不足道，但在一个包含大量 "
"``await`` 和深度调用栈的大型程序中，这种开销累积起来可能会严重拖累性能。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:356
msgid "A conceptual overview part 2: the nuts and bolts"
msgstr "概念概述第 2 部分：基本要点"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:358
msgid ""
"Part 2 goes into detail on the mechanisms :mod:`!asyncio` uses to manage "
"control flow. This is where the magic happens. You'll come away from this "
"section knowing what ``await`` does behind the scenes and how to make your "
"own asynchronous operators."
msgstr ""
"第 2 部分将详细介绍 :mod:`!asyncio` 用于管理控制流的机制。这正是魔法发生的地方。读完本节后，您将了解 ``await`` "
"在幕后做了什么，以及如何创建您自己的异步运算符。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:366
msgid "The inner workings of coroutines"
msgstr "协程的内部工作原理"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:368
msgid ":mod:`!asyncio` leverages four components to pass around control."
msgstr ":mod:`!asyncio` 利用四个组件来传递控制权。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:370
msgid ""
":meth:`coroutine.send(arg) <generator.send>` is the method used to start or "
"resume a coroutine. If the coroutine was paused and is now being resumed, "
"the argument ``arg`` will be sent in as the return value of the ``yield`` "
"statement which originally paused it. If the coroutine is being used for the"
" first time (as opposed to being resumed) ``arg`` must be ``None``."
msgstr ""
":meth:`coroutine.send(arg) <generator.send>`` 是用于启动或恢复协程的方法。如果协程已暂停且正在恢复，则参数"
" ``arg`` 将作为原先暂停它的 ``yield`` 语句的返回值发送。如果协程是首次被使用（而不是被恢复），``arg`` 必须为 "
"``None``。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:378
msgid ""
"class Rock:\n"
"    def __await__(self):\n"
"        value_sent_in = yield 7\n"
"        print(f\"Rock.__await__ resuming with value: {value_sent_in}.\")\n"
"        return value_sent_in\n"
"\n"
"async def main():\n"
"    print(\"Beginning coroutine main().\")\n"
"    rock = Rock()\n"
"    print(\"Awaiting rock...\")\n"
"    value_from_rock = await rock\n"
"    print(f\"Coroutine received value: {value_from_rock} from rock.\")\n"
"    return 23\n"
"\n"
"coroutine = main()\n"
"intermediate_result = coroutine.send(None)\n"
"print(f\"Coroutine paused and returned intermediate value: {intermediate_result}.\")\n"
"\n"
"print(f\"Resuming coroutine and sending in value: 42.\")\n"
"try:\n"
"    coroutine.send(42)\n"
"except StopIteration as e:\n"
"    returned_value = e.value\n"
"print(f\"Coroutine main() finished and provided value: {returned_value}.\")"
msgstr ""
"class Rock:\n"
"    def __await__(self):\n"
"        value_sent_in = yield 7\n"
"        print(f\"Rock.__await__ resuming with value: {value_sent_in}.\")\n"
"        return value_sent_in\n"
"\n"
"async def main():\n"
"    print(\"Beginning coroutine main().\")\n"
"    rock = Rock()\n"
"    print(\"Awaiting rock...\")\n"
"    value_from_rock = await rock\n"
"    print(f\"Coroutine received value: {value_from_rock} from rock.\")\n"
"    return 23\n"
"\n"
"coroutine = main()\n"
"intermediate_result = coroutine.send(None)\n"
"print(f\"Coroutine paused and returned intermediate value: {intermediate_result}.\")\n"
"\n"
"print(f\"Resuming coroutine and sending in value: 42.\")\n"
"try:\n"
"    coroutine.send(42)\n"
"except StopIteration as e:\n"
"    returned_value = e.value\n"
"print(f\"Coroutine main() finished and provided value: {returned_value}.\")"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:406
msgid ""
":ref:`yield <yieldexpr>`, like usual, pauses execution and returns control "
"to the caller. In the example above, the ``yield``, on line 3, is called by "
"``... = await rock`` on line 11. More broadly speaking, ``await`` calls the "
":meth:`~object.__await__` method of the given object. ``await`` also does "
"one more very special thing: it propagates (or \"passes along\") any "
"``yield``\\ s it receives up the call-chain. In this case, that's back to "
"``... = coroutine.send(None)`` on line 16."
msgstr ""
":ref:`yield <yieldexpr>` 像往常一样暂停执行并将控制权返回给调用者。 在上面的例子中，第 3 行的 ``yield``, 被第 "
"11 行的 ``... = await rock`` 调用。 更广泛地说，``await`` 调用了给定对象的 "
":meth:`~object.__await__` 方法。 ``await`` 还做了一件非常特别的事情：它会将接收到的任何 ``yield`` "
"沿着调用链向上传播（或“传递”）。 在本例中，这又回到了第 16 行的 ``... = coroutine.send(None)``。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:416
msgid ""
"The coroutine is resumed via the ``coroutine.send(42)`` call on line 21. The"
" coroutine picks back up from where it ``yield``\\ ed (or paused) on line 3 "
"and executes the remaining statements in its body. When a coroutine "
"finishes, it raises a :exc:`StopIteration` exception with the return value "
"attached in the :attr:`~StopIteration.value` attribute."
msgstr ""
"协程通过第 21 行的 ``coroutine.send(42)`` 调用恢复。协程从第 3 行 ``yield`` (或暂停) "
"的位置继续执行，并执行其主体中的剩余语句。协程完成后，它会引发一个 :exc:`StopIteration` 异常，并将返回值附加在 "
":attr:`~StopIteration.value` 属性中。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:422
msgid "That snippet produces this output:"
msgstr "该代码片段产生以下输出："

#: ../../howto/a-conceptual-overview-of-asyncio.rst:424
msgid ""
"Beginning coroutine main().\n"
"Awaiting rock...\n"
"Coroutine paused and returned intermediate value: 7.\n"
"Resuming coroutine and sending in value: 42.\n"
"Rock.__await__ resuming with value: 42.\n"
"Coroutine received value: 42 from rock.\n"
"Coroutine main() finished and provided value: 23."
msgstr ""
"Beginning coroutine main().\n"
"Awaiting rock...\n"
"Coroutine paused and returned intermediate value: 7.\n"
"Resuming coroutine and sending in value: 42.\n"
"Rock.__await__ resuming with value: 42.\n"
"Coroutine received value: 42 from rock.\n"
"Coroutine main() finished and provided value: 23."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:434
msgid ""
"It's worth pausing for a moment here and making sure you followed the "
"various ways that control flow and values were passed. A lot of important "
"ideas were covered and it's worth ensuring your understanding is firm."
msgstr "这里值得暂停一下，确保您已经理解了控制流和值传递的各种方式。我们涵盖了很多重要的概念，确保您理解得足够牢固。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:438
msgid ""
"The only way to yield (or effectively cede control) from a coroutine is to "
"``await`` an object that ``yield``\\ s in its ``__await__`` method. That "
"might sound odd to you. You might be thinking:"
msgstr ""
"从协程中“yield”（或有效地放弃控制权）的唯一方法是 ``await`` 一个在其 ``__await__`` 方法中 ``yield`` "
"的对象。这听起来可能有点奇怪。你可能会想："

#: ../../howto/a-conceptual-overview-of-asyncio.rst:442
msgid ""
"1. What about a ``yield`` directly within the coroutine function? The "
"coroutine function becomes an :ref:`async generator function <asynchronous-"
"generator-functions>`, a different beast entirely."
msgstr ""
"1. 那么在协程函数中直接使用 ``yield`` 会怎么样呢？协程函数会变成一个 :ref:`异步生成器函数 <asynchronous-"
"generator-functions>`，一个完全不同的东西。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:447
msgid ""
"2. What about a :ref:`yield from <yieldexpr>` within the coroutine function "
"to a (plain) generator? That causes the error: ``SyntaxError: yield from not"
" allowed in a coroutine.`` This was intentionally designed for the sake of "
"simplicity -- mandating only one way of using coroutines. Initially "
"``yield`` was barred as well, but was re-accepted to allow for async "
"generators. Despite that, ``yield from`` and ``await`` effectively do the "
"same thing."
msgstr ""
"2. 如果在协程函数中对（普通）生成器使用 :ref:`yield from <yieldexpr>` "
"会怎么样？这会导致错误：``SyntaxError: yield from not allowed in a "
"coroutine.``。这是故意为简单起见而设计的——强制规定只能以一种方式使用协程。最初 ``yield`` "
"也被禁止，但后来为了支持异步生成器而被重新接受。尽管如此，``yield from`` 和 ``await`` 实际上做的事情是一样的。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:458
msgid "Futures"
msgstr "Futures"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:460
msgid ""
"A :ref:`future <asyncio-future-obj>` is an object meant to represent a "
"computation's status and result. The term is a nod to the idea of something "
"still to come or not yet happened, and the object is a way to keep an eye on"
" that something."
msgstr ""
":ref:`Future <asyncio-future-obj>` 是一个用来表示计算状态和结果的对象。该术语指的是尚未发生的事情，而 Future "
"对象则是一种用来关注这些事情的方式。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:465
msgid ""
"A future has a few important attributes. One is its state which can be "
"either \"pending\", \"cancelled\" or \"done\". Another is its result, which "
"is set when the state transitions to done. Unlike a coroutine, a future does"
" not represent the actual computation to be done; instead, it represents the"
" status and result of that computation, kind of like a status light (red, "
"yellow or green) or indicator."
msgstr ""
"Future "
"有几个重要的属性。其一是它的状态，可以是“待处理”、“已取消”或“已完成”。其二是它的结果，当状态转换为“已完成”时设置。与协程不同，Future "
"并不表示要执行的实际计算；相反，它表示该计算的状态和结果，有点像状态灯（红色、黄色或绿色）或指示灯。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:472
msgid ""
":class:`asyncio.Task` subclasses :class:`asyncio.Future` in order to gain "
"these various capabilities. The prior section said tasks store a list of "
"callbacks, which wasn't entirely accurate. It's actually the ``Future`` "
"class that implements this logic, which ``Task`` inherits."
msgstr ""
"为了获得这些功能，:class:`asyncio.Task` 继承了 :class:`asyncio.Future` "
"类。上一节提到任务存储了一个回调函数列表，这并不完全准确。实际上，实现这些逻辑的是 ``Future`` 类，而 ``Task`` 继承了它。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:479
msgid ""
"Futures may also be used directly (not via tasks). Tasks mark themselves as "
"done when their coroutine is complete. Futures are much more versatile and "
"will be marked as done when you say so. In this way, they're the flexible "
"interface for you to make your own conditions for waiting and resuming."
msgstr ""
"Future 也可以被直接使用（无需通过任务）。任务会在协程完成后将自身标记为已完成。Future "
"的功能更加丰富，只要您指定，它就会被标记为已完成。因此，Future 是一个灵活的接口，您可以自定义等待和恢复的条件。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:487
msgid "A homemade asyncio.sleep"
msgstr "自制 asyncio.sleep"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:489
msgid ""
"We'll go through an example of how you could leverage a future to create "
"your own variant of asynchronous sleep (``async_sleep``) which mimics "
":func:`asyncio.sleep`."
msgstr ""
"我们将通过一个例子来说明如何利用 Future 来创建自己的异步睡眠变体（``async_sleep``），模仿了 "
":func:`asyncio.sleep`。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:493
msgid ""
"This snippet registers a few tasks with the event loop and then awaits a "
"coroutine wrapped in a task: ``async_sleep(3)``. We want that task to finish"
" only after three seconds have elapsed, but without preventing other tasks "
"from running."
msgstr ""
"这段代码在事件循环中注册了一些任务，然后等待一个包装在任务中的协程：``async_sleep(3)``。我们希望该任务在三秒后才结束，但不会阻止其他任务的运行。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:500
msgid ""
"async def other_work():\n"
"    print(\"I like work. Work work.\")\n"
"\n"
"async def main():\n"
"    # Add a few other tasks to the event loop, so there's something\n"
"    # to do while asynchronously sleeping.\n"
"    work_tasks = [\n"
"        asyncio.create_task(other_work()),\n"
"        asyncio.create_task(other_work()),\n"
"        asyncio.create_task(other_work())\n"
"    ]\n"
"    print(\n"
"        \"Beginning asynchronous sleep at time: \"\n"
"        f\"{datetime.datetime.now().strftime(\"%H:%M:%S\")}.\"\n"
"    )\n"
"    await asyncio.create_task(async_sleep(3))\n"
"    print(\n"
"        \"Done asynchronous sleep at time: \"\n"
"        f\"{datetime.datetime.now().strftime(\"%H:%M:%S\")}.\"\n"
"    )\n"
"    # asyncio.gather effectively awaits each task in the collection.\n"
"    await asyncio.gather(*work_tasks)"
msgstr ""
"async def other_work():\n"
"    print(\"I like work. Work work.\")\n"
"\n"
"async def main():\n"
"    # 向事件循环添加一些其他任务，这样在异步休眠时就可以做一些事情。\n"
"    work_tasks = [\n"
"        asyncio.create_task(other_work()),\n"
"        asyncio.create_task(other_work()),\n"
"        asyncio.create_task(other_work())\n"
"    ]\n"
"    print(\n"
"        \"Beginning asynchronous sleep at time: \"\n"
"        f\"{datetime.datetime.now().strftime(\"%H:%M:%S\")}.\"\n"
"    )\n"
"    await asyncio.create_task(async_sleep(3))\n"
"    print(\n"
"        \"Done asynchronous sleep at time: \"\n"
"        f\"{datetime.datetime.now().strftime(\"%H:%M:%S\")}.\"\n"
"    )\n"
"    # asyncio.gather 有效地等待集合中的每个任务。\n"
"    await asyncio.gather(*work_tasks)"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:524
msgid ""
"Below, we use a future to enable custom control over when that task will be "
"marked as done. If :meth:`future.set_result() <asyncio.Future.set_result>` "
"(the method responsible for marking that future as done) is never called, "
"then this task will never finish. We've also enlisted the help of another "
"task, which we'll see in a moment, that will monitor how much time has "
"elapsed and, accordingly, call ``future.set_result()``."
msgstr ""
"下面，我们使用 Future 来自定义控制何时将任务标记为已完成。如果 :meth:`future.set_result() "
"<asyncio.Future.set_result>`（负责将该 Future "
"标记为已完成的方法）从未被调用，那么该任务将永远不会结束。我们还借助了另一个任务（稍后会看到），它将监视已过去的时间，并相应地调用 "
"``future.set_result()``。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:535
msgid ""
"async def async_sleep(seconds: float):\n"
"    future = asyncio.Future()\n"
"    time_to_wake = time.time() + seconds\n"
"    # Add the watcher-task to the event loop.\n"
"    watcher_task = asyncio.create_task(_sleep_watcher(future, time_to_wake))\n"
"    # Block until the future is marked as done.\n"
"    await future"
msgstr ""
"async def async_sleep(seconds: float):\n"
"    future = asyncio.Future()\n"
"    time_to_wake = time.time() + seconds\n"
"    # 将监视任务添加到事件循环。\n"
"    watcher_task = asyncio.create_task(_sleep_watcher(future, time_to_wake))\n"
"    # 阻塞直到 future 被标记为已完成。\n"
"    await future"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:543
msgid ""
"Below, we'll use a rather bare object, ``YieldToEventLoop()``, to ``yield`` "
"from ``__await__`` in order to cede control to the event loop. This is "
"effectively the same as calling ``asyncio.sleep(0)``, but this approach "
"offers more clarity, not to mention it's somewhat cheating to use "
"``asyncio.sleep`` when showcasing how to implement it!"
msgstr ""
"下面，我们将使用一个相当简单的对象 ``YieldToEventLoop()``，从 ``__await__`` 中 "
"``yield``，从而将控制权移交给事件循环。这实际上与调用 ``asyncio.sleep(0)`` "
"相同，但这种方法更清晰，更不用说在展示如何实现它时使用 ``asyncio.sleep`` 有点作弊！"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:549
msgid ""
"As usual, the event loop cycles through its tasks, giving them control and "
"receiving control back when they pause or finish. The ``watcher_task``, "
"which runs the coroutine ``_sleep_watcher(...)``, will be invoked once per "
"full cycle of the event loop. On each resumption, it'll check the time and "
"if not enough has elapsed, then it'll pause once again and hand control back"
" to the event loop. Eventually, enough time will have elapsed, and "
"``_sleep_watcher(...)`` will mark the future as done, and then itself finish"
" too by breaking out of the infinite ``while`` loop. Given this helper task "
"is only invoked once per cycle of the event loop, you'd be correct to note "
"that this asynchronous sleep will sleep *at least* three seconds, rather "
"than exactly three seconds. Note this is also of true of ``asyncio.sleep``."
msgstr ""
"与往常一样，事件循环会循环执行其任务，将控制权移交给它们，并在任务暂停或完成时收回。运行协程 ``_sleep_watcher(...)`` 的 "
"``watcher_task`` "
"会在事件循环的每个完整周期中被调用一次。每次恢复时，它都会检查时间，如果时间不够，则会再次暂停并将控制权交还给事件循环。最终，当时间足够时，``_sleep_watcher(...)``"
" 会将 Future 标记为已完成，然后自身也会通过跳出无限的 ``while`` "
"循环来结束。鉴于此辅助任务在事件循环的每个周期中仅调用一次，因此您应该注意到，此异步睡眠将 *至少* "
"睡眠三秒，而不是恰好三秒。请注意，``asyncio.sleep`` 也是如此。"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:565
msgid ""
"class YieldToEventLoop:\n"
"    def __await__(self):\n"
"        yield\n"
"\n"
"async def _sleep_watcher(future, time_to_wake):\n"
"    while True:\n"
"        if time.time() >= time_to_wake:\n"
"            # This marks the future as done.\n"
"            future.set_result(None)\n"
"            break\n"
"        else:\n"
"            await YieldToEventLoop()"
msgstr ""
"class YieldToEventLoop:\n"
"    def __await__(self):\n"
"        yield\n"
"\n"
"async def _sleep_watcher(future, time_to_wake):\n"
"    while True:\n"
"        if time.time() >= time_to_wake:\n"
"            # 这标记 future 为已完成。\n"
"            future.set_result(None)\n"
"            break\n"
"        else:\n"
"            await YieldToEventLoop()"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:578
msgid "Here is the full program's output:"
msgstr "以下是程序的完整输出："

#: ../../howto/a-conceptual-overview-of-asyncio.rst:580
msgid ""
"$ python custom-async-sleep.py\n"
"Beginning asynchronous sleep at time: 14:52:22.\n"
"I like work. Work work.\n"
"I like work. Work work.\n"
"I like work. Work work.\n"
"Done asynchronous sleep at time: 14:52:25."
msgstr ""
"$ python custom-async-sleep.py\n"
"Beginning asynchronous sleep at time: 14:52:22.\n"
"I like work. Work work.\n"
"I like work. Work work.\n"
"I like work. Work work.\n"
"Done asynchronous sleep at time: 14:52:25."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:589
msgid ""
"You might feel this implementation of asynchronous sleep was unnecessarily "
"convoluted. And, well, it was. The example was meant to showcase the "
"versatility of futures with a simple example that could be mimicked for more"
" complex needs. For reference, you could implement it without futures, like "
"so::"
msgstr ""
"你可能会觉得这种异步睡眠的实现过于复杂。确实如此。这个例子旨在通过一个简单的示例来展示 Future "
"的多功能性，以便可以模仿更复杂的需求。作为参考，你可以不使用 Future 来实现它，如下所示："

#: ../../howto/a-conceptual-overview-of-asyncio.rst:596
msgid ""
"async def simpler_async_sleep(seconds):\n"
"    time_to_wake = time.time() + seconds\n"
"    while True:\n"
"        if time.time() >= time_to_wake:\n"
"            return\n"
"        else:\n"
"            await YieldToEventLoop()"
msgstr ""
"async def simpler_async_sleep(seconds):\n"
"    time_to_wake = time.time() + seconds\n"
"    while True:\n"
"        if time.time() >= time_to_wake:\n"
"            return\n"
"        else:\n"
"            await YieldToEventLoop()"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:604
msgid ""
"But, that's all for now. Hopefully you're ready to more confidently dive "
"into some async programming or check out advanced topics in the :mod:`rest "
"of the documentation <asyncio>`."
msgstr "好了，目前就这些了。希望你已经准备好更自信地深入研究异步编程，或者查看 :mod:`文档其他部分 <asyncio>` 中的进阶主题。"
