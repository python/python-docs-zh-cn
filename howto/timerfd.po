# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 15:00+0000\n"
"PO-Revision-Date: 2025-07-18 19:21+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/timerfd.rst:5
msgid "timer file descriptor HOWTO"
msgstr "定时器文件描述符指南"

#: ../../howto/timerfd.rst:0
msgid "Release"
msgstr "发布版本"

#: ../../howto/timerfd.rst:7
msgid "1.13"
msgstr "1.13"

#: ../../howto/timerfd.rst:9
msgid ""
"This HOWTO discusses Python's support for the linux timer file descriptor."
msgstr "本指南讨论了 Python 对 linux 定时器文件描述符的支持。"

#: ../../howto/timerfd.rst:13
msgid "Examples"
msgstr "例子"

#: ../../howto/timerfd.rst:15
msgid ""
"The following example shows how to use a timer file descriptor to execute a "
"function twice a second:"
msgstr "下面的例子演示了如何使用定时器文件描述符每秒钟执行两次某个函数："

#: ../../howto/timerfd.rst:18
msgid ""
"# Practical scripts should use really use a non-blocking timer,\n"
"# we use a blocking timer here for simplicity.\n"
"import os, time\n"
"\n"
"# Create the timer file descriptor\n"
"fd = os.timerfd_create(time.CLOCK_REALTIME)\n"
"\n"
"# Start the timer in 1 second, with an interval of half a second\n"
"os.timerfd_settime(fd, initial=1, interval=0.5)\n"
"\n"
"try:\n"
"    # Process timer events four times.\n"
"    for _ in range(4):\n"
"        # read() will block until the timer expires\n"
"        _ = os.read(fd, 8)\n"
"        print(\"Timer expired\")\n"
"finally:\n"
"    # Remember to close the timer file descriptor!\n"
"    os.close(fd)"
msgstr ""
"# 真正实用的脚本应当使用非阻塞型定时器，\n"
"# 这里我们使用阻塞型定时器是出于简单化考虑。\n"
"import os, time\n"
"\n"
"# 创建定时器文件描述符\n"
"fd = os.timerfd_create(time.CLOCK_REALTIME)\n"
"\n"
"# 在 1 秒种时启动定时器，间隔时间为半秒\n"
"os.timerfd_settime(fd, initial=1, interval=0.5)\n"
"\n"
"try:\n"
"    # 处理定时器事件四次。\n"
"    for _ in range(4):\n"
"        # read() 将会阻塞直到定时器过期\n"
"        _ = os.read(fd, 8)\n"
"        print(\"Timer expired\")\n"
"finally:\n"
"    # 记住要关闭定时器文件描述符！\n"
"    os.close(fd)"

#: ../../howto/timerfd.rst:40
msgid ""
"To avoid the precision loss caused by the :class:`float` type, timer file "
"descriptors allow specifying initial expiration and interval in integer "
"nanoseconds with ``_ns`` variants of the functions."
msgstr ""
"为避免 :class:`float` 类型导致的精度损失，定时器文件描述符允许使用这些函数的 ``_ns`` "
"变种形式以整数纳秒值指定初始到期时间和间隔。"

#: ../../howto/timerfd.rst:44
msgid ""
"This example shows how :func:`~select.epoll` can be used with timer file "
"descriptors to wait until the file descriptor is ready for reading:"
msgstr "这个例子演示了如何使用 :func:`~select.epoll` 配合定时器文件描述符来执行等待直到文件描述符准备好读取："

#: ../../howto/timerfd.rst:47
msgid ""
"import os, time, select, socket, sys\n"
"\n"
"# Create an epoll object\n"
"ep = select.epoll()\n"
"\n"
"# In this example, use loopback address to send \"stop\" command to the server.\n"
"#\n"
"# $ telnet 127.0.0.1 1234\n"
"# Trying 127.0.0.1...\n"
"# Connected to 127.0.0.1.\n"
"# Escape character is '^]'.\n"
"# stop\n"
"# Connection closed by foreign host.\n"
"#\n"
"sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"sock.bind((\"127.0.0.1\", 1234))\n"
"sock.setblocking(False)\n"
"sock.listen(1)\n"
"ep.register(sock, select.EPOLLIN)\n"
"\n"
"# Create timer file descriptors in non-blocking mode.\n"
"num = 3\n"
"fds = []\n"
"for _ in range(num):\n"
"    fd = os.timerfd_create(time.CLOCK_REALTIME, flags=os.TFD_NONBLOCK)\n"
"    fds.append(fd)\n"
"    # Register the timer file descriptor for read events\n"
"    ep.register(fd, select.EPOLLIN)\n"
"\n"
"# Start the timer with os.timerfd_settime_ns() in nanoseconds.\n"
"# Timer 1 fires every 0.25 seconds; timer 2 every 0.5 seconds; etc\n"
"for i, fd in enumerate(fds, start=1):\n"
"    one_sec_in_nsec = 10**9\n"
"    i = i * one_sec_in_nsec\n"
"    os.timerfd_settime_ns(fd, initial=i//4, interval=i//4)\n"
"\n"
"timeout = 3\n"
"try:\n"
"    conn = None\n"
"    is_active = True\n"
"    while is_active:\n"
"        # Wait for the timer to expire for 3 seconds.\n"
"        # epoll.poll() returns a list of (fd, event) pairs.\n"
"        # fd is a file descriptor.\n"
"        # sock and conn[=returned value of socket.accept()] are socket objects, not file descriptors.\n"
"        # So use sock.fileno() and conn.fileno() to get the file descriptors.\n"
"        events = ep.poll(timeout)\n"
"\n"
"        # If more than one timer file descriptors are ready for reading at once,\n"
"        # epoll.poll() returns a list of (fd, event) pairs.\n"
"        #\n"
"        # In this example settings,\n"
"        #    1st timer fires every 0.25 seconds in 0.25 seconds. (0.25, 0.5, 0.75, 1.0, ...)\n"
"        #    2nd timer every 0.5 seconds in 0.5 seconds. (0.5, 1.0, 1.5, 2.0, ...)\n"
"        #    3rd timer every 0.75 seconds in 0.75 seconds. (0.75, 1.5, 2.25, 3.0, ...)\n"
"        #\n"
"        #    In 0.25 seconds, only 1st timer fires.\n"
"        #    In 0.5 seconds, 1st timer and 2nd timer fires at once.\n"
"        #    In 0.75 seconds, 1st timer and 3rd timer fires at once.\n"
"        #    In 1.5 seconds, 1st timer, 2nd timer and 3rd timer fires at once.\n"
"        #\n"
"        # If a timer file descriptor is signaled more than once since\n"
"        # the last os.read() call, os.read() returns the number of signaled\n"
"        # as host order of class bytes.\n"
"        print(f\"Signaled events={events}\")\n"
"        for fd, event in events:\n"
"            if event & select.EPOLLIN:\n"
"                if fd == sock.fileno():\n"
"                    # Check if there is a connection request.\n"
"                    print(f\"Accepting connection {fd}\")\n"
"                    conn, addr = sock.accept()\n"
"                    conn.setblocking(False)\n"
"                    print(f\"Accepted connection {conn} from {addr}\")\n"
"                    ep.register(conn, select.EPOLLIN)\n"
"                elif conn and fd == conn.fileno():\n"
"                    # Check if there is data to read.\n"
"                    print(f\"Reading data {fd}\")\n"
"                    data = conn.recv(1024)\n"
"                    if data:\n"
"                        # You should catch UnicodeDecodeError exception for safety.\n"
"                        cmd = data.decode()\n"
"                        if cmd.startswith(\"stop\"):\n"
"                            print(f\"Stopping server\")\n"
"                            is_active = False\n"
"                        else:\n"
"                            print(f\"Unknown command: {cmd}\")\n"
"                    else:\n"
"                        # No more data, close connection\n"
"                        print(f\"Closing connection {fd}\")\n"
"                        ep.unregister(conn)\n"
"                        conn.close()\n"
"                        conn = None\n"
"                elif fd in fds:\n"
"                    print(f\"Reading timer {fd}\")\n"
"                    count = int.from_bytes(os.read(fd, 8), byteorder=sys.byteorder)\n"
"                    print(f\"Timer {fds.index(fd) + 1} expired {count} times\")\n"
"                else:\n"
"                    print(f\"Unknown file descriptor {fd}\")\n"
"finally:\n"
"    for fd in fds:\n"
"        ep.unregister(fd)\n"
"        os.close(fd)\n"
"    ep.close()"
msgstr ""
"import os, time, select, socket, sys\n"
"\n"
"# 创建一个轮询对象\n"
"ep = select.epoll()\n"
"\n"
"# 在本例中，使用回环地址向服务器发送 \"stop\" 命令。\n"
"#\n"
"# $ telnet 127.0.0.1 1234\n"
"# Trying 127.0.0.1...\n"
"# Connected to 127.0.0.1.\n"
"# Escape character is '^]'.\n"
"# stop\n"
"# Connection closed by foreign host.\n"
"#\n"
"sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"sock.bind((\"127.0.0.1\", 1234))\n"
"sock.setblocking(False)\n"
"sock.listen(1)\n"
"ep.register(sock, select.EPOLLIN)\n"
"\n"
"# 以非阻塞模式创建定时器文件描述符。\n"
"num = 3\n"
"fds = []\n"
"for _ in range(num):\n"
"    fd = os.timerfd_create(time.CLOCK_REALTIME, flags=os.TFD_NONBLOCK)\n"
"    fds.append(fd)\n"
"    # 注册定时器文件描述符用于读取事件\n"
"    ep.register(fd, select.EPOLLIN)\n"
"\n"
"# 以纳秒精度的 os.timerfd_settime_ns() 启动定时器。\n"
"# 定时器 1 间隔为 0.25 秒；定时器 2 间隔为 0.5 秒；依此类推\n"
"for i, fd in enumerate(fds, start=1):\n"
"    one_sec_in_nsec = 10**9\n"
"    i = i * one_sec_in_nsec\n"
"    os.timerfd_settime_ns(fd, initial=i//4, interval=i//4)\n"
"\n"
"timeout = 3\n"
"try:\n"
"    conn = None\n"
"    is_active = True\n"
"    while is_active:\n"
"        # 等待定时器 3 秒到期。\n"
"        # epoll.poll() 返回一个 (fd, event) 对的列表。\n"
"        # fd 是一个文件描述符。\n"
"        # sock 和 conn[=socket.accept() 的返回值] 是套接字对象，而不是文件描述符。\n"
"        # 因此使用 sock.fileno() 和 conn.fileno() 来获取文件描述符。\n"
"        events = ep.poll(timeout)\n"
"\n"
"        # 如果同时有多个定时器文件描述符准备读取，\n"
"        # epoll.poll() 将返回一个 (fd, event) 对的列表。\n"
"        #\n"
"        # 在本例的设置中，\n"
"        #    第 1 个定时器在 0.25 秒后间隔 0.25 秒启动。 (0.25, 0.5, 0.75, 1.0, ...)\n"
"        #    第 2 个定时器在 0.5 秒后间隔 0.5 秒启动。 (0.5, 1.0, 1.5, 2.0, ...)\n"
"        #    第 3 个定时器在 0.75 秒后间隔 0.75 秒启动。 (0.75, 1.5, 2.25, 3.0, ...)\n"
"        #\n"
"        #    在 0.25 秒时，只有第 1 个定时器启动。\n"
"        #    在 0.5 秒时，第 1 个定时器和第 2 个定时器同时启动。\n"
"        #    在 0.75 秒时，第 1 个定时器和第 3 个定时器同时启动。\n"
"        #    在 1.5 秒时，第 1 个定时器、第 2 个定时器和第 3 个定时器同时启动。\n"
"        #\n"
"        # 如果一个定时器文件描述符自上次 os.read() 调用后\n"
"        # 多次发出信号，os.read() 将以主机的类字节顺序\n"
"        # 返回发出信号的次数。\n"
"        print(f\"Signaled events={events}\")\n"
"        for fd, event in events:\n"
"            if event & select.EPOLLIN:\n"
"                if fd == sock.fileno():\n"
"                    # 检查是否有连接请求。\n"
"                    print(f\"Accepting connection {fd}\")\n"
"                    conn, addr = sock.accept()\n"
"                    conn.setblocking(False)\n"
"                    print(f\"Accepted connection {conn} from {addr}\")\n"
"                    ep.register(conn, select.EPOLLIN)\n"
"                elif conn and fd == conn.fileno():\n"
"                    # 检查是否有数据要读取。\n"
"                    print(f\"Reading data {fd}\")\n"
"                    data = conn.recv(1024)\n"
"                    if data:\n"
"                        # 安全起见你应当捕获 UnicodeDecodeError 异常。\n"
"                        cmd = data.decode()\n"
"                        if cmd.startswith(\"stop\"):\n"
"                            print(f\"Stopping server\")\n"
"                            is_active = False\n"
"                        else:\n"
"                            print(f\"Unknown command: {cmd}\")\n"
"                    else:\n"
"                        # 已无数据，关闭连接\n"
"                        print(f\"Closing connection {fd}\")\n"
"                        ep.unregister(conn)\n"
"                        conn.close()\n"
"                        conn = None\n"
"                elif fd in fds:\n"
"                    print(f\"Reading timer {fd}\")\n"
"                    count = int.from_bytes(os.read(fd, 8), byteorder=sys.byteorder)\n"
"                    print(f\"Timer {fds.index(fd) + 1} expired {count} times\")\n"
"                else:\n"
"                    print(f\"Unknown file descriptor {fd}\")\n"
"finally:\n"
"    for fd in fds:\n"
"        ep.unregister(fd)\n"
"        os.close(fd)\n"
"    ep.close()"

#: ../../howto/timerfd.rst:153
msgid ""
"This example shows how :func:`~select.select` can be used with timer file "
"descriptors to wait until the file descriptor is ready for reading:"
msgstr "这个例子演示了如何使用 :func:`~select.select` 配合定时器文件描述符来执行等待直接文件描述符准备好读取："

#: ../../howto/timerfd.rst:156
msgid ""
"import os, time, select, socket, sys\n"
"\n"
"# In this example, use loopback address to send \"stop\" command to the server.\n"
"#\n"
"# $ telnet 127.0.0.1 1234\n"
"# Trying 127.0.0.1...\n"
"# Connected to 127.0.0.1.\n"
"# Escape character is '^]'.\n"
"# stop\n"
"# Connection closed by foreign host.\n"
"#\n"
"sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"sock.bind((\"127.0.0.1\", 1234))\n"
"sock.setblocking(False)\n"
"sock.listen(1)\n"
"\n"
"# Create timer file descriptors in non-blocking mode.\n"
"num = 3\n"
"fds = [os.timerfd_create(time.CLOCK_REALTIME, flags=os.TFD_NONBLOCK)\n"
"       for _ in range(num)]\n"
"select_fds = fds + [sock]\n"
"\n"
"# Start the timers with os.timerfd_settime() in seconds.\n"
"# Timer 1 fires every 0.25 seconds; timer 2 every 0.5 seconds; etc\n"
"for i, fd in enumerate(fds, start=1):\n"
"   os.timerfd_settime(fd, initial=i/4, interval=i/4)\n"
"\n"
"timeout = 3\n"
"try:\n"
"    conn = None\n"
"    is_active = True\n"
"    while is_active:\n"
"       # Wait for the timer to expire for 3 seconds.\n"
"       # select.select() returns a list of file descriptors or objects.\n"
"       rfd, wfd, xfd = select.select(select_fds, select_fds, select_fds, timeout)\n"
"       for fd in rfd:\n"
"           if fd == sock:\n"
"               # Check if there is a connection request.\n"
"               print(f\"Accepting connection {fd}\")\n"
"               conn, addr = sock.accept()\n"
"               conn.setblocking(False)\n"
"               print(f\"Accepted connection {conn} from {addr}\")\n"
"               select_fds.append(conn)\n"
"           elif conn and fd == conn:\n"
"               # Check if there is data to read.\n"
"               print(f\"Reading data {fd}\")\n"
"               data = conn.recv(1024)\n"
"               if data:\n"
"                   # You should catch UnicodeDecodeError exception for safety.\n"
"                   cmd = data.decode()\n"
"                   if cmd.startswith(\"stop\"):\n"
"                       print(f\"Stopping server\")\n"
"                       is_active = False\n"
"                   else:\n"
"                       print(f\"Unknown command: {cmd}\")\n"
"               else:\n"
"                   # No more data, close connection\n"
"                   print(f\"Closing connection {fd}\")\n"
"                   select_fds.remove(conn)\n"
"                   conn.close()\n"
"                   conn = None\n"
"           elif fd in fds:\n"
"               print(f\"Reading timer {fd}\")\n"
"               count = int.from_bytes(os.read(fd, 8), byteorder=sys.byteorder)\n"
"               print(f\"Timer {fds.index(fd) + 1} expired {count} times\")\n"
"           else:\n"
"               print(f\"Unknown file descriptor {fd}\")\n"
"finally:\n"
"    for fd in fds:\n"
"       os.close(fd)\n"
"    sock.close()\n"
"    sock = None"
msgstr ""
"import os, time, select, socket, sys\n"
"\n"
"# 在本例中，使用回环地址向服务器发送 \"stop\" 命令。\n"
"#\n"
"# $ telnet 127.0.0.1 1234\n"
"# Trying 127.0.0.1...\n"
"# Connected to 127.0.0.1.\n"
"# Escape character is '^]'.\n"
"# stop\n"
"# Connection closed by foreign host.\n"
"#\n"
"sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"sock.bind((\"127.0.0.1\", 1234))\n"
"sock.setblocking(False)\n"
"sock.listen(1)\n"
"\n"
"# 以非阻塞模式创建定时器文件描述符。\n"
"num = 3\n"
"fds = [os.timerfd_create(time.CLOCK_REALTIME, flags=os.TFD_NONBLOCK)\n"
"       for _ in range(num)]\n"
"select_fds = fds + [sock]\n"
"\n"
"# 使用 os.timerfd_settime() 启动指定秒数的定时器。\n"
"# 定时器 1 间隔为 0.25 秒；定时器 2 间隔为 0.5 秒；依此类推\n"
"for i, fd in enumerate(fds, start=1):\n"
"   os.timerfd_settime(fd, initial=i/4, interval=i/4)\n"
"\n"
"timeout = 3\n"
"try:\n"
"    conn = None\n"
"    is_active = True\n"
"    while is_active:\n"
"       # 等待定时器 3 秒到期。\n"
"       # select.select() 返回一个文件描述符或对象的列表。\n"
"       rfd, wfd, xfd = select.select(select_fds, select_fds, select_fds, timeout)\n"
"       for fd in rfd:\n"
"           if fd == sock:\n"
"               # 检查是否有连接请求。\n"
"               print(f\"Accepting connection {fd}\")\n"
"               conn, addr = sock.accept()\n"
"               conn.setblocking(False)\n"
"               print(f\"Accepted connection {conn} from {addr}\")\n"
"               select_fds.append(conn)\n"
"           elif conn and fd == conn:\n"
"               # 检查中否有数据要读取。\n"
"               print(f\"Reading data {fd}\")\n"
"               data = conn.recv(1024)\n"
"               if data:\n"
"                   # 安全起见你应当捕获 UnicodeDecodeError 异常。\n"
"                   cmd = data.decode()\n"
"                   if cmd.startswith(\"stop\"):\n"
"                       print(f\"Stopping server\")\n"
"                       is_active = False\n"
"                   else:\n"
"                       print(f\"Unknown command: {cmd}\")\n"
"               else:\n"
"                   # 已无数据，关闭连接\n"
"                   print(f\"Closing connection {fd}\")\n"
"                   select_fds.remove(conn)\n"
"                   conn.close()\n"
"                   conn = None\n"
"           elif fd in fds:\n"
"               print(f\"Reading timer {fd}\")\n"
"               count = int.from_bytes(os.read(fd, 8), byteorder=sys.byteorder)\n"
"               print(f\"Timer {fds.index(fd) + 1} expired {count} times\")\n"
"           else:\n"
"               print(f\"Unknown file descriptor {fd}\")\n"
"finally:\n"
"    for fd in fds:\n"
"       os.close(fd)\n"
"    sock.close()\n"
"    sock = None"
