# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 15:15+0000\n"
"PO-Revision-Date: 2025-07-18 19:21+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/enum.rst:5
msgid "Enum HOWTO"
msgstr "Enum 指南"

#: ../../howto/enum.rst:11
msgid ""
"An :class:`Enum` is a set of symbolic names bound to unique values.  They "
"are similar to global variables, but they offer a more useful :func:`repr`, "
"grouping, type-safety, and a few other features."
msgstr ""
":class:`Enum` 是一组绑定到唯一值的符号名称。 它们类似于全局变量，但提供了更好用的 "
":func:`repr`、分组、类型安全和一些其他特性。"

#: ../../howto/enum.rst:15
msgid ""
"They are most useful when you have a variable that can take one of a limited"
" selection of values.  For example, the days of the week::"
msgstr "它们最适用于当某个变量可选的值有限时。例如，从一周中选取一天："

#: ../../howto/enum.rst:18
msgid ""
">>> from enum import Enum\n"
">>> class Weekday(Enum):\n"
"...     MONDAY = 1\n"
"...     TUESDAY = 2\n"
"...     WEDNESDAY = 3\n"
"...     THURSDAY = 4\n"
"...     FRIDAY = 5\n"
"...     SATURDAY = 6\n"
"...     SUNDAY = 7"
msgstr ""
">>> from enum import Enum\n"
">>> class Weekday(Enum):\n"
"...     MONDAY = 1\n"
"...     TUESDAY = 2\n"
"...     WEDNESDAY = 3\n"
"...     THURSDAY = 4\n"
"...     FRIDAY = 5\n"
"...     SATURDAY = 6\n"
"...     SUNDAY = 7"

#: ../../howto/enum.rst:28
msgid "Or perhaps the RGB primary colors::"
msgstr "或是 RGB 三原色："

#: ../../howto/enum.rst:30
msgid ""
">>> from enum import Enum\n"
">>> class Color(Enum):\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...     BLUE = 3"
msgstr ""
">>> from enum import Enum\n"
">>> class Color(Enum):\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...     BLUE = 3"

#: ../../howto/enum.rst:36
msgid ""
"As you can see, creating an :class:`Enum` is as simple as writing a class "
"that inherits from :class:`Enum` itself."
msgstr "正如你所见，创建一个 :class:`Enum` 就是简单地写一个继承 :class:`Enum` 的类。"

#: ../../howto/enum.rst:39
msgid "Case of Enum Members"
msgstr "枚举成员名的大小写"

#: ../../howto/enum.rst:41
msgid ""
"Because Enums are used to represent constants, and to help avoid issues with"
" name clashes between mixin-class methods/attributes and enum names, we "
"strongly recommend using UPPER_CASE names for members, and will be using "
"that style in our examples."
msgstr ""
"由于枚举被用来代表常量，并有助于避免混入类方法/属性和枚举名之间发生名称冲突，我们强烈建议用大写形式的名称表示成员，我们将在我们的示例中使用此风格。"

#: ../../howto/enum.rst:46
msgid ""
"Depending on the nature of the enum a member's value may or may not be "
"important, but either way that value can be used to get the corresponding "
"member::"
msgstr "根据枚举的性质，某个成员的值可能不一定用得上，但无论如何都能用那个值构造对应的成员："

#: ../../howto/enum.rst:50
msgid ""
">>> Weekday(3)\n"
"<Weekday.WEDNESDAY: 3>"
msgstr ""
">>> Weekday(3)\n"
"<Weekday.WEDNESDAY: 3>"

#: ../../howto/enum.rst:53
msgid ""
"As you can see, the ``repr()`` of a member shows the enum name, the member "
"name, and the value.  The ``str()`` of a member shows only the enum name and"
" member name::"
msgstr "如你所见，成员的 ``repr()`` 会显示枚举名称、成员名称和值。 成员的 ``str()`` 只会显示枚举名称和成员名称::"

#: ../../howto/enum.rst:57
msgid ""
">>> print(Weekday.THURSDAY)\n"
"Weekday.THURSDAY"
msgstr ""
">>> print(Weekday.THURSDAY)\n"
"Weekday.THURSDAY"

#: ../../howto/enum.rst:60
msgid "The *type* of an enumeration member is the enum it belongs to::"
msgstr "枚举成员的 *类型* 就是其所属的枚举::"

#: ../../howto/enum.rst:62
msgid ""
">>> type(Weekday.MONDAY)\n"
"<enum 'Weekday'>\n"
">>> isinstance(Weekday.FRIDAY, Weekday)\n"
"True"
msgstr ""
">>> type(Weekday.MONDAY)\n"
"<enum 'Weekday'>\n"
">>> isinstance(Weekday.FRIDAY, Weekday)\n"
"True"

#: ../../howto/enum.rst:67
msgid ""
"Enum members have an attribute that contains just their :attr:`!name`::"
msgstr "枚举成员带有一个只包含了它们的 :attr:`!name` 的属性::"

#: ../../howto/enum.rst:69
msgid ""
">>> print(Weekday.TUESDAY.name)\n"
"TUESDAY"
msgstr ""
">>> print(Weekday.TUESDAY.name)\n"
"TUESDAY"

#: ../../howto/enum.rst:72
msgid "Likewise, they have an attribute for their :attr:`!value`::"
msgstr "类似地，它们还有一个包含其 :attr:`!value` 的属性::"

#: ../../howto/enum.rst:75
msgid ""
">>> Weekday.WEDNESDAY.value\n"
"3"
msgstr ""
">>> Weekday.WEDNESDAY.value\n"
"3"

#: ../../howto/enum.rst:78
msgid ""
"Unlike many languages that treat enumerations solely as name/value pairs, "
"Python Enums can have behavior added.  For example, :class:`datetime.date` "
"has two methods for returning the weekday: :meth:`~datetime.date.weekday` "
"and :meth:`~datetime.date.isoweekday`. The difference is that one of them "
"counts from 0-6 and the other from 1-7. Rather than keep track of that "
"ourselves we can add a method to the :class:`!Weekday` enum to extract the "
"day from the :class:`~datetime.date` instance and return the matching enum "
"member::"
msgstr ""
"不同于许多只把枚举当作名称/值对的的语言，Python 枚举还可以添加行为。 例如，:class:`datetime.date` "
"有两个方法用来返回星期序号: :meth:`~datetime.date.weekday` 和 "
":meth:`~datetime.date.isoweekday`。 两者的区别在于一个是以 0-6 计数而另一个是以 1-7。 "
"这一点无须我们自己来记住而是可以向 :class:`!Weekday` 枚举添加一个方法用来从 :class:`~datetime.date` "
"实例提取日期并返回匹配的枚举成员::"

#: ../../howto/enum.rst:87
msgid ""
"@classmethod\n"
"def from_date(cls, date):\n"
"    return cls(date.isoweekday())"
msgstr ""
"@classmethod\n"
"def from_date(cls, date):\n"
"    return cls(date.isoweekday())"

#: ../../howto/enum.rst:91
msgid "The complete :class:`!Weekday` enum now looks like this::"
msgstr "完整的 :class:`!Weekday` 枚举现在看起来是这样的::"

#: ../../howto/enum.rst:93
msgid ""
">>> class Weekday(Enum):\n"
"...     MONDAY = 1\n"
"...     TUESDAY = 2\n"
"...     WEDNESDAY = 3\n"
"...     THURSDAY = 4\n"
"...     FRIDAY = 5\n"
"...     SATURDAY = 6\n"
"...     SUNDAY = 7\n"
"...     #\n"
"...     @classmethod\n"
"...     def from_date(cls, date):\n"
"...         return cls(date.isoweekday())"
msgstr ""
">>> class Weekday(Enum):\n"
"...     MONDAY = 1\n"
"...     TUESDAY = 2\n"
"...     WEDNESDAY = 3\n"
"...     THURSDAY = 4\n"
"...     FRIDAY = 5\n"
"...     SATURDAY = 6\n"
"...     SUNDAY = 7\n"
"...     #\n"
"...     @classmethod\n"
"...     def from_date(cls, date):\n"
"...         return cls(date.isoweekday())"

#: ../../howto/enum.rst:106
msgid "Now we can find out what today is!  Observe::"
msgstr "现在可以知道今天是星期几了::"

#: ../../howto/enum.rst:108
msgid ""
">>> from datetime import date\n"
">>> Weekday.from_date(date.today())\n"
"<Weekday.TUESDAY: 2>"
msgstr ""
">>> from datetime import date\n"
">>> Weekday.from_date(date.today())\n"
"<Weekday.TUESDAY: 2>"

#: ../../howto/enum.rst:112
msgid ""
"Of course, if you're reading this on some other day, you'll see that day "
"instead."
msgstr "当然，如果换个日子读到这篇文章，应该看到当天是周几。"

#: ../../howto/enum.rst:114
msgid ""
"This :class:`!Weekday` enum is great if our variable only needs one day, but"
" what if we need several?  Maybe we're writing a function to plot chores "
"during a week, and don't want to use a :class:`list` -- we could use a "
"different type of :class:`Enum`::"
msgstr ""
"如果我们的变量只需记录一天那么这个 :class:`!Weekday` 枚举很好用，但是如果我们需要记录好几天呢？ "
"可能我们要写一个函数来描述一星期内的家务，并且不想使用 :class:`list` —— 我们可以使用另一种类型的 :class:`Enum`::"

#: ../../howto/enum.rst:119
msgid ""
">>> from enum import Flag\n"
">>> class Weekday(Flag):\n"
"...     MONDAY = 1\n"
"...     TUESDAY = 2\n"
"...     WEDNESDAY = 4\n"
"...     THURSDAY = 8\n"
"...     FRIDAY = 16\n"
"...     SATURDAY = 32\n"
"...     SUNDAY = 64"
msgstr ""
">>> from enum import Flag\n"
">>> class Weekday(Flag):\n"
"...     MONDAY = 1\n"
"...     TUESDAY = 2\n"
"...     WEDNESDAY = 4\n"
"...     THURSDAY = 8\n"
"...     FRIDAY = 16\n"
"...     SATURDAY = 32\n"
"...     SUNDAY = 64"

#: ../../howto/enum.rst:129
msgid ""
"We've changed two things: we're inherited from :class:`Flag`, and the values"
" are all powers of 2."
msgstr "这里做了两处改动：继承了 :class:`Flag`，而且值都是2的幂。"

#: ../../howto/enum.rst:132
msgid ""
"Just like the original :class:`!Weekday` enum above, we can have a single "
"selection::"
msgstr "就像上面的原始 :class:`!Weekday` 枚举一样，我们可以有单个选择::"

#: ../../howto/enum.rst:134
msgid ""
">>> first_week_day = Weekday.MONDAY\n"
">>> first_week_day\n"
"<Weekday.MONDAY: 1>"
msgstr ""
">>> first_week_day = Weekday.MONDAY\n"
">>> first_week_day\n"
"<Weekday.MONDAY: 1>"

#: ../../howto/enum.rst:138
msgid ""
"But :class:`Flag` also allows us to combine several members into a single "
"variable::"
msgstr "但 :class:`Flag` 也允许将几个成员并入一个变量::"

#: ../../howto/enum.rst:141
msgid ""
">>> weekend = Weekday.SATURDAY | Weekday.SUNDAY\n"
">>> weekend\n"
"<Weekday.SATURDAY|SUNDAY: 96>"
msgstr ""
">>> weekend = Weekday.SATURDAY | Weekday.SUNDAY\n"
">>> weekend\n"
"<Weekday.SATURDAY|SUNDAY: 96>"

#: ../../howto/enum.rst:145
msgid "You can even iterate over a :class:`Flag` variable::"
msgstr "甚至可以在一个 :class:`Flag` 变量上进行迭代::"

#: ../../howto/enum.rst:147
msgid ""
">>> for day in weekend:\n"
"...     print(day)\n"
"Weekday.SATURDAY\n"
"Weekday.SUNDAY"
msgstr ""
">>> for day in weekend:\n"
"...     print(day)\n"
"Weekday.SATURDAY\n"
"Weekday.SUNDAY"

#: ../../howto/enum.rst:152
msgid "Okay, let's get some chores set up::"
msgstr "好吧，让我们来安排家务吧::"

#: ../../howto/enum.rst:154
msgid ""
">>> chores_for_ethan = {\n"
"...     'feed the cat': Weekday.MONDAY | Weekday.WEDNESDAY | Weekday.FRIDAY,\n"
"...     'do the dishes': Weekday.TUESDAY | Weekday.THURSDAY,\n"
"...     'answer SO questions': Weekday.SATURDAY,\n"
"...     }"
msgstr ""
">>> chores_for_ethan = {\n"
"...     'feed the cat': Weekday.MONDAY | Weekday.WEDNESDAY | Weekday.FRIDAY,\n"
"...     'do the dishes': Weekday.TUESDAY | Weekday.THURSDAY,\n"
"...     'answer SO questions': Weekday.SATURDAY,\n"
"...     }"

#: ../../howto/enum.rst:160
msgid "And a function to display the chores for a given day::"
msgstr "一个显示某天家务的函数::"

#: ../../howto/enum.rst:162
msgid ""
">>> def show_chores(chores, day):\n"
"...     for chore, days in chores.items():\n"
"...         if day in days:\n"
"...             print(chore)\n"
"...\n"
">>> show_chores(chores_for_ethan, Weekday.SATURDAY)\n"
"answer SO questions"
msgstr ""
">>> def show_chores(chores, day):\n"
"...     for chore, days in chores.items():\n"
"...         if day in days:\n"
"...             print(chore)\n"
"...\n"
">>> show_chores(chores_for_ethan, Weekday.SATURDAY)\n"
"answer SO questions"

#: ../../howto/enum.rst:170
msgid ""
"In cases where the actual values of the members do not matter, you can save "
"yourself some work and use :func:`auto` for the values::"
msgstr "对于成员的实际取值无关紧要的情况，你可以省事地使用 :func:`auto` 来设置值::"

#: ../../howto/enum.rst:173
msgid ""
">>> from enum import auto\n"
">>> class Weekday(Flag):\n"
"...     MONDAY = auto()\n"
"...     TUESDAY = auto()\n"
"...     WEDNESDAY = auto()\n"
"...     THURSDAY = auto()\n"
"...     FRIDAY = auto()\n"
"...     SATURDAY = auto()\n"
"...     SUNDAY = auto()\n"
"...     WEEKEND = SATURDAY | SUNDAY"
msgstr ""
">>> from enum import auto\n"
">>> class Weekday(Flag):\n"
"...     MONDAY = auto()\n"
"...     TUESDAY = auto()\n"
"...     WEDNESDAY = auto()\n"
"...     THURSDAY = auto()\n"
"...     FRIDAY = auto()\n"
"...     SATURDAY = auto()\n"
"...     SUNDAY = auto()\n"
"...     WEEKEND = SATURDAY | SUNDAY"

#: ../../howto/enum.rst:189
msgid "Programmatic access to enumeration members and their attributes"
msgstr "枚举成员及其属性的编程访问"

#: ../../howto/enum.rst:191
msgid ""
"Sometimes it's useful to access members in enumerations programmatically "
"(i.e. situations where ``Color.RED`` won't do because the exact color is not"
" known at program-writing time).  ``Enum`` allows such access::"
msgstr ""
"有时，要在程序中访问枚举成员（如，开发时不知道颜色的确切值，``Color.RED`` 不适用的情况）。``Enum`` 支持如下访问方式::"

#: ../../howto/enum.rst:195
msgid ""
">>> Color(1)\n"
"<Color.RED: 1>\n"
">>> Color(3)\n"
"<Color.BLUE: 3>"
msgstr ""
">>> Color(1)\n"
"<Color.RED: 1>\n"
">>> Color(3)\n"
"<Color.BLUE: 3>"

#: ../../howto/enum.rst:200
msgid "If you want to access enum members by *name*, use item access::"
msgstr "若要用 *名称* 访问枚举成员时，可使用枚举项::"

#: ../../howto/enum.rst:202
msgid ""
">>> Color['RED']\n"
"<Color.RED: 1>\n"
">>> Color['GREEN']\n"
"<Color.GREEN: 2>"
msgstr ""
">>> Color['RED']\n"
"<Color.RED: 1>\n"
">>> Color['GREEN']\n"
"<Color.GREEN: 2>"

#: ../../howto/enum.rst:207
msgid ""
"If you have an enum member and need its :attr:`!name` or :attr:`!value`::"
msgstr "如果你有一个枚举成员并需要它的 :attr:`!name` 或 :attr:`!value`::"

#: ../../howto/enum.rst:209
msgid ""
">>> member = Color.RED\n"
">>> member.name\n"
"'RED'\n"
">>> member.value\n"
"1"
msgstr ""
">>> member = Color.RED\n"
">>> member.name\n"
"'RED'\n"
">>> member.value\n"
"1"

#: ../../howto/enum.rst:217
msgid "Duplicating enum members and values"
msgstr "重复的枚举成员和值"

#: ../../howto/enum.rst:219
msgid "Having two enum members with the same name is invalid::"
msgstr "两个枚举成员的名称不能相同::"

#: ../../howto/enum.rst:221
msgid ""
">>> class Shape(Enum):\n"
"...     SQUARE = 2\n"
"...     SQUARE = 3\n"
"...\n"
"Traceback (most recent call last):\n"
"...\n"
"TypeError: 'SQUARE' already defined as 2"
msgstr ""
">>> class Shape(Enum):\n"
"...     SQUARE = 2\n"
"...     SQUARE = 3\n"
"...\n"
"Traceback (most recent call last):\n"
"...\n"
"TypeError: 'SQUARE' already defined as 2"

#: ../../howto/enum.rst:229
msgid ""
"However, an enum member can have other names associated with it.  Given two "
"entries ``A`` and ``B`` with the same value (and ``A`` defined first), ``B``"
" is an alias for the member ``A``.  By-value lookup of the value of ``A`` "
"will return the member ``A``.  By-name lookup of ``A`` will return the "
"member ``A``. By-name lookup of ``B`` will also return the member ``A``::"
msgstr ""
"然而，一个枚举成员可以关联多个其他名称。如果两个枚举项 ``A`` 和 ``B`` 具有相同值（并且首先定义的是 ``A`` ），则 ``B`` 是成员"
" ``A`` 的别名。对 ``A`` 按值检索将会返回成员 ``A``。按名称检索 ``B`` 也会返回成员 ``A``::"

#: ../../howto/enum.rst:235
msgid ""
">>> class Shape(Enum):\n"
"...     SQUARE = 2\n"
"...     DIAMOND = 1\n"
"...     CIRCLE = 3\n"
"...     ALIAS_FOR_SQUARE = 2\n"
"...\n"
">>> Shape.SQUARE\n"
"<Shape.SQUARE: 2>\n"
">>> Shape.ALIAS_FOR_SQUARE\n"
"<Shape.SQUARE: 2>\n"
">>> Shape(2)\n"
"<Shape.SQUARE: 2>"
msgstr ""
">>> class Shape(Enum):\n"
"...     SQUARE = 2\n"
"...     DIAMOND = 1\n"
"...     CIRCLE = 3\n"
"...     ALIAS_FOR_SQUARE = 2\n"
"...\n"
">>> Shape.SQUARE\n"
"<Shape.SQUARE: 2>\n"
">>> Shape.ALIAS_FOR_SQUARE\n"
"<Shape.SQUARE: 2>\n"
">>> Shape(2)\n"
"<Shape.SQUARE: 2>"

#: ../../howto/enum.rst:250
msgid ""
"Attempting to create a member with the same name as an already defined "
"attribute (another member, a method, etc.) or attempting to create an "
"attribute with the same name as a member is not allowed."
msgstr "不允许创建与已定义属性（其他成员、方法等）同名的成员，也不支持创建与现有成员同名的属性。"

#: ../../howto/enum.rst:256
msgid "Ensuring unique enumeration values"
msgstr "确保枚举值唯一"

#: ../../howto/enum.rst:258
msgid ""
"By default, enumerations allow multiple names as aliases for the same value."
" When this behavior isn't desired, you can use the :func:`unique` "
"decorator::"
msgstr "默认情况下，枚举允许多个名称作为同一个值的别名。若不想如此，可以使用 :func:`unique` 装饰器::"

#: ../../howto/enum.rst:261
msgid ""
">>> from enum import Enum, unique\n"
">>> @unique\n"
"... class Mistake(Enum):\n"
"...     ONE = 1\n"
"...     TWO = 2\n"
"...     THREE = 3\n"
"...     FOUR = 3\n"
"...\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: duplicate values found in <enum 'Mistake'>: FOUR -> THREE"
msgstr ""
">>> from enum import Enum, unique\n"
">>> @unique\n"
"... class Mistake(Enum):\n"
"...     ONE = 1\n"
"...     TWO = 2\n"
"...     THREE = 3\n"
"...     FOUR = 3\n"
"...\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: duplicate values found in <enum 'Mistake'>: FOUR -> THREE"

#: ../../howto/enum.rst:275
msgid "Using automatic values"
msgstr "使用自动设定的值"

#: ../../howto/enum.rst:277
msgid "If the exact value is unimportant you can use :class:`auto`::"
msgstr "如果具体的枚举值无所谓是什么，可以使用 :class:`auto`::"

#: ../../howto/enum.rst:279
msgid ""
">>> from enum import Enum, auto\n"
">>> class Color(Enum):\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...\n"
">>> [member.value for member in Color]\n"
"[1, 2, 3]"
msgstr ""
">>> from enum import Enum, auto\n"
">>> class Color(Enum):\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...\n"
">>> [member.value for member in Color]\n"
"[1, 2, 3]"

#: ../../howto/enum.rst:288
msgid ""
"The values are chosen by :func:`~Enum._generate_next_value_`, which can be "
"overridden::"
msgstr "枚举值由 :func:`~Enum._generate_next_value_` 来选取，它可以被重写::"

#: ../../howto/enum.rst:291
msgid ""
">>> class AutoName(Enum):\n"
"...     @staticmethod\n"
"...     def _generate_next_value_(name, start, count, last_values):\n"
"...         return name\n"
"...\n"
">>> class Ordinal(AutoName):\n"
"...     NORTH = auto()\n"
"...     SOUTH = auto()\n"
"...     EAST = auto()\n"
"...     WEST = auto()\n"
"...\n"
">>> [member.value for member in Ordinal]\n"
"['NORTH', 'SOUTH', 'EAST', 'WEST']"
msgstr ""
">>> class AutoName(Enum):\n"
"...     @staticmethod\n"
"...     def _generate_next_value_(name, start, count, last_values):\n"
"...         return name\n"
"...\n"
">>> class Ordinal(AutoName):\n"
"...     NORTH = auto()\n"
"...     SOUTH = auto()\n"
"...     EAST = auto()\n"
"...     WEST = auto()\n"
"...\n"
">>> [member.value for member in Ordinal]\n"
"['NORTH', 'SOUTH', 'EAST', 'WEST']"

#: ../../howto/enum.rst:307
msgid ""
"The :meth:`~Enum._generate_next_value_` method must be defined before any "
"members."
msgstr ":meth:`~Enum._generate_next_value_` 方法必须在任何成员之前定义。"

#: ../../howto/enum.rst:310
msgid "Iteration"
msgstr "迭代遍历"

#: ../../howto/enum.rst:312
msgid "Iterating over the members of an enum does not provide the aliases::"
msgstr "对枚举成员的迭代遍历不会列出别名::"

#: ../../howto/enum.rst:314
msgid ""
">>> list(Shape)\n"
"[<Shape.SQUARE: 2>, <Shape.DIAMOND: 1>, <Shape.CIRCLE: 3>]\n"
">>> list(Weekday)\n"
"[<Weekday.MONDAY: 1>, <Weekday.TUESDAY: 2>, <Weekday.WEDNESDAY: 4>, <Weekday.THURSDAY: 8>, <Weekday.FRIDAY: 16>, <Weekday.SATURDAY: 32>, <Weekday.SUNDAY: 64>]"
msgstr ""
">>> list(Shape)\n"
"[<Shape.SQUARE: 2>, <Shape.DIAMOND: 1>, <Shape.CIRCLE: 3>]\n"
">>> list(Weekday)\n"
"[<Weekday.MONDAY: 1>, <Weekday.TUESDAY: 2>, <Weekday.WEDNESDAY: 4>, <Weekday.THURSDAY: 8>, <Weekday.FRIDAY: 16>, <Weekday.SATURDAY: 32>, <Weekday.SUNDAY: 64>]"

#: ../../howto/enum.rst:319
msgid ""
"Note that the aliases ``Shape.ALIAS_FOR_SQUARE`` and ``Weekday.WEEKEND`` "
"aren't shown."
msgstr "请注意 ``Shape.ALIAS_FOR_SQUARE`` 和 ``Weekday.WEEKEND`` 等别名不会被显示。"

#: ../../howto/enum.rst:321
msgid ""
"The special attribute ``__members__`` is a read-only ordered mapping of "
"names to members.  It includes all names defined in the enumeration, "
"including the aliases::"
msgstr "特殊属性 ``__members__`` 是一个名称与成员间的只读有序映射。包含了枚举中定义的所有名称，包括别名::"

#: ../../howto/enum.rst:325
msgid ""
">>> for name, member in Shape.__members__.items():\n"
"...     name, member\n"
"...\n"
"('SQUARE', <Shape.SQUARE: 2>)\n"
"('DIAMOND', <Shape.DIAMOND: 1>)\n"
"('CIRCLE', <Shape.CIRCLE: 3>)\n"
"('ALIAS_FOR_SQUARE', <Shape.SQUARE: 2>)"
msgstr ""
">>> for name, member in Shape.__members__.items():\n"
"...     name, member\n"
"...\n"
"('SQUARE', <Shape.SQUARE: 2>)\n"
"('DIAMOND', <Shape.DIAMOND: 1>)\n"
"('CIRCLE', <Shape.CIRCLE: 3>)\n"
"('ALIAS_FOR_SQUARE', <Shape.SQUARE: 2>)"

#: ../../howto/enum.rst:333
msgid ""
"The ``__members__`` attribute can be used for detailed programmatic access "
"to the enumeration members.  For example, finding all the aliases::"
msgstr "``__members__`` 属性可用于获取枚举成员的详细信息。比如查找所有别名::"

#: ../../howto/enum.rst:336
msgid ""
">>> [name for name, member in Shape.__members__.items() if member.name != name]\n"
"['ALIAS_FOR_SQUARE']"
msgstr ""
">>> [name for name, member in Shape.__members__.items() if member.name != name]\n"
"['ALIAS_FOR_SQUARE']"

#: ../../howto/enum.rst:341
msgid ""
"Aliases for flags include values with multiple flags set, such as ``3``, and"
" no flags set, i.e. ``0``."
msgstr "旗标的别名包括带有多个旗标设置的值，如 ``3``，以及不设置任何旗标，即 ``0``。"

#: ../../howto/enum.rst:346
msgid "Comparisons"
msgstr "比较运算"

#: ../../howto/enum.rst:348
msgid "Enumeration members are compared by identity::"
msgstr "枚举成员是按 ID 进行比较的::"

#: ../../howto/enum.rst:350
msgid ""
">>> Color.RED is Color.RED\n"
"True\n"
">>> Color.RED is Color.BLUE\n"
"False\n"
">>> Color.RED is not Color.BLUE\n"
"True"
msgstr ""
">>> Color.RED is Color.RED\n"
"True\n"
">>> Color.RED is Color.BLUE\n"
"False\n"
">>> Color.RED is not Color.BLUE\n"
"True"

#: ../../howto/enum.rst:357
msgid ""
"Ordered comparisons between enumeration values are *not* supported.  Enum "
"members are not integers (but see `IntEnum`_ below)::"
msgstr "枚举值之间无法进行有序的比较。枚举的成员不是整数（另请参阅下文 `IntEnum`_）::"

#: ../../howto/enum.rst:360
msgid ""
">>> Color.RED < Color.BLUE\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: '<' not supported between instances of 'Color' and 'Color'"
msgstr ""
">>> Color.RED < Color.BLUE\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: '<' not supported between instances of 'Color' and 'Color'"

#: ../../howto/enum.rst:365
msgid "Equality comparisons are defined though::"
msgstr "相等性比较的定义如下::"

#: ../../howto/enum.rst:367
msgid ""
">>> Color.BLUE == Color.RED\n"
"False\n"
">>> Color.BLUE != Color.RED\n"
"True\n"
">>> Color.BLUE == Color.BLUE\n"
"True"
msgstr ""
">>> Color.BLUE == Color.RED\n"
"False\n"
">>> Color.BLUE != Color.RED\n"
"True\n"
">>> Color.BLUE == Color.BLUE\n"
"True"

#: ../../howto/enum.rst:374
msgid ""
"Comparisons against non-enumeration values will always compare not equal "
"(again, :class:`IntEnum` was explicitly designed to behave differently, see "
"below)::"
msgstr "与非枚举值的比较将总是不等的（同样 :class:`IntEnum` 有意设计为其他的做法，参见下文）::"

#: ../../howto/enum.rst:378
msgid ""
">>> Color.BLUE == 2\n"
"False"
msgstr ""
">>> Color.BLUE == 2\n"
"False"

#: ../../howto/enum.rst:383
msgid ""
"It is possible to reload modules -- if a reloaded module contains enums, "
"they will be recreated, and the new members may not compare identical/equal "
"to the original members."
msgstr "重载模块是可能的 -- 如果载入的模块包含枚举，它们将被重新创建，而新成员的标识号/相等性比较不一定会通过。"

#: ../../howto/enum.rst:388
msgid "Allowed members and attributes of enumerations"
msgstr "合法的枚举成员和属性"

#: ../../howto/enum.rst:390
msgid ""
"Most of the examples above use integers for enumeration values.  Using "
"integers is short and handy (and provided by default by the `Functional "
"API`_), but not strictly enforced.  In the vast majority of use-cases, one "
"doesn't care what the actual value of an enumeration is.  But if the value "
"*is* important, enumerations can have arbitrary values."
msgstr ""
"以上大多数示例都用了整数作为枚举值。使用整数确实简短方便（并且是 `Functional API`_ "
"默认提供的值），但并非强制要求。绝大多数情况下，人们并不关心枚举的实际值是什么。但如果值确实重要，可以使用任何值。"

#: ../../howto/enum.rst:396
msgid ""
"Enumerations are Python classes, and can have methods and special methods as"
" usual.  If we have this enumeration::"
msgstr "枚举是 Python 的类，可带有普通方法和特殊方法。假设有如下枚举::"

#: ../../howto/enum.rst:399
msgid ""
">>> class Mood(Enum):\n"
"...     FUNKY = 1\n"
"...     HAPPY = 3\n"
"...\n"
"...     def describe(self):\n"
"...         # self is the member here\n"
"...         return self.name, self.value\n"
"...\n"
"...     def __str__(self):\n"
"...         return 'my custom str! {0}'.format(self.value)\n"
"...\n"
"...     @classmethod\n"
"...     def favorite_mood(cls):\n"
"...         # cls here is the enumeration\n"
"...         return cls.HAPPY\n"
"..."
msgstr ""
">>> class Mood(Enum):\n"
"...     FUNKY = 1\n"
"...     HAPPY = 3\n"
"...\n"
"...     def describe(self):\n"
"...         # 在这里 self 是成员\n"
"...         return self.name, self.value\n"
"...\n"
"...     def __str__(self):\n"
"...         return 'my custom str! {0}'.format(self.value)\n"
"...\n"
"...     @classmethod\n"
"...     def favorite_mood(cls):\n"
"...         # 在这里 cls 是枚举\n"
"...         return cls.HAPPY\n"
"..."

#: ../../howto/enum.rst:416
msgid "Then::"
msgstr "那么::"

#: ../../howto/enum.rst:418
msgid ""
">>> Mood.favorite_mood()\n"
"<Mood.HAPPY: 3>\n"
">>> Mood.HAPPY.describe()\n"
"('HAPPY', 3)\n"
">>> str(Mood.FUNKY)\n"
"'my custom str! 1'"
msgstr ""
">>> Mood.favorite_mood()\n"
"<Mood.HAPPY: 3>\n"
">>> Mood.HAPPY.describe()\n"
"('HAPPY', 3)\n"
">>> str(Mood.FUNKY)\n"
"'my custom str! 1'"

#: ../../howto/enum.rst:425
msgid ""
"The rules for what is allowed are as follows: names that start and end with "
"a single underscore are reserved by enum and cannot be used; all other "
"attributes defined within an enumeration will become members of this "
"enumeration, with the exception of special methods (:meth:`~object.__str__`,"
" :meth:`~object.__add__`, etc.), descriptors (methods are also descriptors),"
" and variable names listed in :attr:`~Enum._ignore_`."
msgstr ""
"对于允许内容的规则如下：以单下划线开始和结尾的名称是由枚举保留而不可使用的；在枚举中定义的其他属性将成为该枚举的成员，例外项则包括特殊方法 "
"(:meth:`~object.__str__`, :meth:`~object.__add__`, etc.)、描述器 (方法也属于描述器) 以及在 "
":attr:`~Enum._ignore_` 中列出的变量名。"

#: ../../howto/enum.rst:432
msgid ""
"Note:  if your enumeration defines :meth:`~object.__new__` and/or "
":meth:`~object.__init__`, any value(s) given to the enum member will be "
"passed into those methods. See `Planet`_ for an example."
msgstr ""
"注意：如果你的枚举定义了 :meth:`~object.__new__` 和/或 "
":meth:`~object.__init__`，则给予枚举成员的任何值都将被传递给这些方法。 参见 `Planet`_ 中的示例。"

#: ../../howto/enum.rst:438
msgid ""
"The :meth:`~object.__new__` method, if defined, is used during creation of "
"the Enum members; it is then replaced by Enum's :meth:`~object.__new__` "
"which is used after class creation for lookup of existing members.  See "
":ref:`new-vs-init` for more details."
msgstr ""
"如果定义了 :meth:`~object.__new__` 方法，它会在创建 Enum 成员期间被使用；随后它将被 Enum 的 "
":meth:`~object.__new__` 所替换，该方法会在类创建后被用于查找现有成员。 详情参见 :ref:`new-vs-init`。"

#: ../../howto/enum.rst:445
msgid "Restricted Enum subclassing"
msgstr "受限的 Enum 子类化"

#: ../../howto/enum.rst:447
msgid ""
"A new :class:`Enum` class must have one base enum class, up to one concrete "
"data type, and as many :class:`object`-based mixin classes as needed.  The "
"order of these base classes is::"
msgstr ""
"新建的 :class:`Enum` 类必须包含：一个枚举基类、至多一种数据类型和按需提供的基于 :class:`object` "
"的混合类。这些基类的顺序如下::"

#: ../../howto/enum.rst:451
msgid ""
"class EnumName([mix-in, ...,] [data-type,] base-enum):\n"
"    pass"
msgstr ""
"class EnumName([mix-in, ...,] [data-type,] base-enum):\n"
"    pass"

#: ../../howto/enum.rst:454
msgid ""
"Also, subclassing an enumeration is allowed only if the enumeration does not"
" define any members.  So this is forbidden::"
msgstr "仅当未定义任何成员时，枚举类才允许被子类化。因此不得有以下写法::"

#: ../../howto/enum.rst:457
msgid ""
">>> class MoreColor(Color):\n"
"...     PINK = 17\n"
"...\n"
"Traceback (most recent call last):\n"
"...\n"
"TypeError: <enum 'MoreColor'> cannot extend <enum 'Color'>"
msgstr ""
">>> class MoreColor(Color):\n"
"...     PINK = 17\n"
"...\n"
"Traceback (most recent call last):\n"
"...\n"
"TypeError: <enum 'MoreColor'> cannot extend <enum 'Color'>"

#: ../../howto/enum.rst:464
msgid "But this is allowed::"
msgstr "但以下代码是可以的::"

#: ../../howto/enum.rst:466
msgid ""
">>> class Foo(Enum):\n"
"...     def some_behavior(self):\n"
"...         pass\n"
"...\n"
">>> class Bar(Foo):\n"
"...     HAPPY = 1\n"
"...     SAD = 2\n"
"..."
msgstr ""
">>> class Foo(Enum):\n"
"...     def some_behavior(self):\n"
"...         pass\n"
"...\n"
">>> class Bar(Foo):\n"
"...     HAPPY = 1\n"
"...     SAD = 2\n"
"..."

#: ../../howto/enum.rst:475
msgid ""
"Allowing subclassing of enums that define members would lead to a violation "
"of some important invariants of types and instances.  On the other hand, it "
"makes sense to allow sharing some common behavior between a group of "
"enumerations. (See `OrderedEnum`_ for an example.)"
msgstr ""
"如果定义了成员的枚举也能被子类化，则类型与实例的某些重要不可变规则将会被破坏。另一方面，一组枚举类共享某些操作也是合理的。（请参阅例程 "
"`OrderedEnum`_ ）"

#: ../../howto/enum.rst:484
msgid "Dataclass support"
msgstr "数据类支持"

#: ../../howto/enum.rst:486
msgid ""
"When inheriting from a :class:`~dataclasses.dataclass`, the "
":meth:`~Enum.__repr__` omits the inherited class' name.  For example::"
msgstr ""
"当从 :class:`~dataclasses.dataclass` 继承时，:meth:`~Enum.__repr__` 将忽略被继承类的名称。 "
"例如::"

#: ../../howto/enum.rst:489
msgid ""
">>> from dataclasses import dataclass, field\n"
">>> @dataclass\n"
"... class CreatureDataMixin:\n"
"...     size: str\n"
"...     legs: int\n"
"...     tail: bool = field(repr=False, default=True)\n"
"...\n"
">>> class Creature(CreatureDataMixin, Enum):\n"
"...     BEETLE = 'small', 6\n"
"...     DOG = 'medium', 4\n"
"...\n"
">>> Creature.DOG\n"
"<Creature.DOG: size='medium', legs=4>"
msgstr ""
">>> from dataclasses import dataclass, field\n"
">>> @dataclass\n"
"... class CreatureDataMixin:\n"
"...     size: str\n"
"...     legs: int\n"
"...     tail: bool = field(repr=False, default=True)\n"
"...\n"
">>> class Creature(CreatureDataMixin, Enum):\n"
"...     BEETLE = 'small', 6\n"
"...     DOG = 'medium', 4\n"
"...\n"
">>> Creature.DOG\n"
"<Creature.DOG: size='medium', legs=4>"

#: ../../howto/enum.rst:503
msgid ""
"Use the :func:`~dataclasses.dataclass` argument ``repr=False`` to use the "
"standard :func:`repr`."
msgstr ""
"使用 :func:`~dataclasses.dataclass` 参数 ``repr=False`` 来使用标准的 :func:`repr`。"

#: ../../howto/enum.rst:506
msgid ""
"Only the dataclass fields are shown in the value area, not the dataclass' "
"name."
msgstr "只有数据类字段会被显示在值区域中，数据类名称不会被显示。"

#: ../../howto/enum.rst:512
msgid ""
"Adding :func:`~dataclasses.dataclass` decorator to :class:`Enum` and its "
"subclasses is not supported. It will not raise any errors, but it will "
"produce very strange results at runtime, such as members being equal to each"
" other::"
msgstr ""
"向 :class:`Enum` 及其子类添加 :func:`~dataclasses.dataclass` 装饰器是不受支持的。 "
"它不会引发任何错误，但会在运行时产生非常怪异的结果，例如不同的成员彼此相等::"

#: ../../howto/enum.rst:517
msgid ""
">>> @dataclass               # don't do this: it does not make any sense\n"
"... class Color(Enum):\n"
"...    RED = 1\n"
"...    BLUE = 2\n"
"...\n"
">>> Color.RED is Color.BLUE\n"
"False\n"
">>> Color.RED == Color.BLUE  # problem is here: they should not be equal\n"
"True"
msgstr ""
">>> @dataclass               # 不要这样做：没有任何意义\n"
"... class Color(Enum):\n"
"...    RED = 1\n"
"...    BLUE = 2\n"
"...\n"
">>> Color.RED is Color.BLUE\n"
"False\n"
">>> Color.RED == Color.BLUE  # 问题在这里：它们不应该相等\n"
"True"

#: ../../howto/enum.rst:529
msgid "Pickling"
msgstr "打包（pickle）"

#: ../../howto/enum.rst:531
msgid "Enumerations can be pickled and unpickled::"
msgstr "枚举类型可以被打包和解包::"

#: ../../howto/enum.rst:533
msgid ""
">>> from test.test_enum import Fruit\n"
">>> from pickle import dumps, loads\n"
">>> Fruit.TOMATO is loads(dumps(Fruit.TOMATO))\n"
"True"
msgstr ""
">>> from test.test_enum import Fruit\n"
">>> from pickle import dumps, loads\n"
">>> Fruit.TOMATO is loads(dumps(Fruit.TOMATO))\n"
"True"

#: ../../howto/enum.rst:538
msgid ""
"The usual restrictions for pickling apply: picklable enums must be defined "
"in the top level of a module, since unpickling requires them to be "
"importable from that module."
msgstr "打包的常规限制同样适用于枚举类型：必须在模块的最高层级定义，因为解包操作要求可从该模块导入。"

#: ../../howto/enum.rst:544
msgid ""
"With pickle protocol version 4 it is possible to easily pickle enums nested "
"in other classes."
msgstr "用 pickle 协议版本 4 可以轻松地将嵌入其他类中的枚举进行打包。"

#: ../../howto/enum.rst:547
msgid ""
"It is possible to modify how enum members are pickled/unpickled by defining "
":meth:`~object.__reduce_ex__` in the enumeration class.  The default method "
"is by-value, but enums with complicated values may want to use by-name::"
msgstr ""
"通过在枚举类中定义 :meth:`~object.__reduce_ex__`，可以修改枚举成员的 pickled/unpicled "
"方式。默认方法是根据值进行的，但具有复杂值的枚举可能需要根据名称进行::"

#: ../../howto/enum.rst:551
msgid ""
">>> import enum\n"
">>> class MyEnum(enum.Enum):\n"
"...     __reduce_ex__ = enum.pickle_by_enum_name"
msgstr ""
">>> import enum\n"
">>> class MyEnum(enum.Enum):\n"
"...     __reduce_ex__ = enum.pickle_by_enum_name"

#: ../../howto/enum.rst:557
msgid ""
"Using by-name for flags is not recommended, as unnamed aliases will not "
"unpickle."
msgstr "不建议为旗标使用基于名称的方式，因为未命名的别名将无法解封。"

#: ../../howto/enum.rst:562
msgid "Functional API"
msgstr "函数式 API"

#: ../../howto/enum.rst:564
msgid ""
"The :class:`Enum` class is callable, providing the following functional "
"API::"
msgstr ":class:`Enum` 类可调用并提供了以下函数式 API："

#: ../../howto/enum.rst:566
msgid ""
">>> Animal = Enum('Animal', 'ANT BEE CAT DOG')\n"
">>> Animal\n"
"<enum 'Animal'>\n"
">>> Animal.ANT\n"
"<Animal.ANT: 1>\n"
">>> list(Animal)\n"
"[<Animal.ANT: 1>, <Animal.BEE: 2>, <Animal.CAT: 3>, <Animal.DOG: 4>]"
msgstr ""
">>> Animal = Enum('Animal', 'ANT BEE CAT DOG')\n"
">>> Animal\n"
"<enum 'Animal'>\n"
">>> Animal.ANT\n"
"<Animal.ANT: 1>\n"
">>> list(Animal)\n"
"[<Animal.ANT: 1>, <Animal.BEE: 2>, <Animal.CAT: 3>, <Animal.DOG: 4>]"

#: ../../howto/enum.rst:574
msgid ""
"The semantics of this API resemble :class:`~collections.namedtuple`. The "
"first argument of the call to :class:`Enum` is the name of the enumeration."
msgstr ""
"该 API 的语义类似于 :class:`~collections.namedtuple`。调用 :class:`Enum` 的第一个参数是枚举的名称。"

#: ../../howto/enum.rst:577
msgid ""
"The second argument is the *source* of enumeration member names.  It can be "
"a whitespace-separated string of names, a sequence of names, a sequence of "
"2-tuples with key/value pairs, or a mapping (e.g. dictionary) of names to "
"values.  The last two options enable assigning arbitrary values to "
"enumerations; the others auto-assign increasing integers starting with 1 "
"(use the ``start`` parameter to specify a different starting value).  A new "
"class derived from :class:`Enum` is returned.  In other words, the above "
"assignment to :class:`!Animal` is equivalent to::"
msgstr ""
"第二个参数是枚举成员名称的 *来源*。它可以是以空白分隔的名称字符串、名称序列、包含键/值对的 2 "
"元组序列或名称到值的映射（如字典）。后两个选项可为枚举指定任意值；其他选项则自动指定从 1 开始的递增整数（使用 ``start`` "
"参数可指定不同的起始值）。返回值是一个从 :class:`Enum` 派生的新类。也就是说，上述对 :class:`!Animal` 的赋值相当于："

#: ../../howto/enum.rst:586
msgid ""
">>> class Animal(Enum):\n"
"...     ANT = 1\n"
"...     BEE = 2\n"
"...     CAT = 3\n"
"...     DOG = 4\n"
"..."
msgstr ""
">>> class Animal(Enum):\n"
"...     ANT = 1\n"
"...     BEE = 2\n"
"...     CAT = 3\n"
"...     DOG = 4\n"
"..."

#: ../../howto/enum.rst:593
msgid ""
"The reason for defaulting to ``1`` as the starting number and not ``0`` is "
"that ``0`` is ``False`` in a boolean sense, but by default enum members all "
"evaluate to ``True``."
msgstr ""
"默认从 ``1`` 开始而非 ``0`` ，因为 ``0`` 是布尔值 ``False`` ，但默认的枚举成员都被视作 ``True`` 。"

#: ../../howto/enum.rst:597
msgid ""
"Pickling enums created with the functional API can be tricky as frame stack "
"implementation details are used to try and figure out which module the "
"enumeration is being created in (e.g. it will fail if you use a utility "
"function in a separate module, and also may not work on IronPython or "
"Jython). The solution is to specify the module name explicitly as follows::"
msgstr ""
"对使用函数式 API "
"创建的枚举进行封存，可能会很棘手，因为要使用栈帧的实现细节来尝试找出枚举是在哪个模块中创建的（例如当你使用了另一个模块中的实用函数时它就可能失败，在 "
"IronPython 或 Jython 上也可能无效）。解决办法是像下面这样显式地指定模块名称："

#: ../../howto/enum.rst:603
msgid ">>> Animal = Enum('Animal', 'ANT BEE CAT DOG', module=__name__)"
msgstr ">>> Animal = Enum('Animal', 'ANT BEE CAT DOG', module=__name__)"

#: ../../howto/enum.rst:607
msgid ""
"If ``module`` is not supplied, and Enum cannot determine what it is, the new"
" Enum members will not be unpicklable; to keep errors closer to the source, "
"pickling will be disabled."
msgstr ""
"如果未提供 ``module``，且 Enum 无法确定是哪个模块，新的 Enum 成员将不可被解封；为了让错误尽量靠近源头，封存将被禁用。"

#: ../../howto/enum.rst:611
msgid ""
"The new pickle protocol 4 also, in some circumstances, relies on "
":attr:`~type.__qualname__` being set to the location where pickle will be "
"able to find the class.  For example, if the class was made available in "
"class SomeData in the global scope::"
msgstr ""
"在某些情况下，新的 pickle 版本 4 协议还需要 :attr:`~type.__qualname__` 在 pickle 能够找到类的位置。 "
"例如，如果该类是在全局作用域内的 SomeData 类中可见::"

#: ../../howto/enum.rst:616
msgid ""
">>> Animal = Enum('Animal', 'ANT BEE CAT DOG', qualname='SomeData.Animal')"
msgstr ""
">>> Animal = Enum('Animal', 'ANT BEE CAT DOG', qualname='SomeData.Animal')"

#: ../../howto/enum.rst:618
msgid "The complete signature is::"
msgstr "完整的签名为::"

#: ../../howto/enum.rst:620
msgid ""
"Enum(\n"
"    value='NewEnumName',\n"
"    names=<...>,\n"
"    *,\n"
"    module='...',\n"
"    qualname='...',\n"
"    type=<mixed-in class>,\n"
"    start=1,\n"
"    )"
msgstr ""
"Enum(\n"
"    value='NewEnumName',\n"
"    names=<...>,\n"
"    *,\n"
"    module='...',\n"
"    qualname='...',\n"
"    type=<mixed-in class>,\n"
"    start=1,\n"
"    )"

#: ../../howto/enum.rst:630
msgid "*value*: What the new enum class will record as its name."
msgstr "*value*: 新枚举类将会作为其名称记录的值。"

#: ../../howto/enum.rst:632
msgid ""
"*names*: The enum members.  This can be a whitespace- or comma-separated "
"string (values will start at 1 unless otherwise specified)::"
msgstr "*names*: 枚举的成员。 这可以是一个用空格或逗号分隔的字符串（值将从 1 开始除非另外指定）::"

#: ../../howto/enum.rst:635
msgid "'RED GREEN BLUE' | 'RED,GREEN,BLUE' | 'RED, GREEN, BLUE'"
msgstr "'RED GREEN BLUE' | 'RED,GREEN,BLUE' | 'RED, GREEN, BLUE'"

#: ../../howto/enum.rst:637
msgid "or an iterator of names::"
msgstr "或是一个名称的迭代器对象::"

#: ../../howto/enum.rst:639
msgid "['RED', 'GREEN', 'BLUE']"
msgstr "['RED', 'GREEN', 'BLUE']"

#: ../../howto/enum.rst:641
msgid "or an iterator of (name, value) pairs::"
msgstr "或是一个 (名称, 值) 对的迭代器对象::"

#: ../../howto/enum.rst:643
msgid "[('CYAN', 4), ('MAGENTA', 5), ('YELLOW', 6)]"
msgstr "[('CYAN', 4), ('MAGENTA', 5), ('YELLOW', 6)]"

#: ../../howto/enum.rst:645
msgid "or a mapping::"
msgstr "或是一个映射对象::"

#: ../../howto/enum.rst:647
msgid "{'CHARTREUSE': 7, 'SEA_GREEN': 11, 'ROSEMARY': 42}"
msgstr "{'CHARTREUSE': 7, 'SEA_GREEN': 11, 'ROSEMARY': 42}"

#: ../../howto/enum.rst:649
msgid "*module*: name of module where new enum class can be found."
msgstr "*module*: 新枚举类所在的模块名。"

#: ../../howto/enum.rst:651
msgid "*qualname*: where in module new enum class can be found."
msgstr "*qualname*: 新枚举类在模块内的位置。"

#: ../../howto/enum.rst:653
msgid "*type*: type to mix in to new enum class."
msgstr "*type*: 要混入到新枚举类的类型。"

#: ../../howto/enum.rst:655
msgid "*start*: number to start counting at if only names are passed in."
msgstr "*start*: 当只传入名称时要使用的起始计数编号。"

#: ../../howto/enum.rst:657
msgid "The *start* parameter was added."
msgstr "增加了 *start* 形参。"

#: ../../howto/enum.rst:662
msgid "Derived Enumerations"
msgstr "派生的枚举"

#: ../../howto/enum.rst:665
msgid "IntEnum"
msgstr "IntEnum"

#: ../../howto/enum.rst:667
msgid ""
"The first variation of :class:`Enum` that is provided is also a subclass of "
":class:`int`.  Members of an :class:`IntEnum` can be compared to integers; "
"by extension, integer enumerations of different types can also be compared "
"to each other::"
msgstr ""
"所提供的第一个变种 :class:`Enum` 同时也是 :class:`int` 的一个子类。 :class:`IntEnum` "
"的成员可与整数进行比较；通过扩展，不同类型的整数枚举也可以相互进行比较::"

#: ../../howto/enum.rst:672
msgid ""
">>> from enum import IntEnum\n"
">>> class Shape(IntEnum):\n"
"...     CIRCLE = 1\n"
"...     SQUARE = 2\n"
"...\n"
">>> class Request(IntEnum):\n"
"...     POST = 1\n"
"...     GET = 2\n"
"...\n"
">>> Shape == 1\n"
"False\n"
">>> Shape.CIRCLE == 1\n"
"True\n"
">>> Shape.CIRCLE == Request.POST\n"
"True"
msgstr ""
">>> from enum import IntEnum\n"
">>> class Shape(IntEnum):\n"
"...     CIRCLE = 1\n"
"...     SQUARE = 2\n"
"...\n"
">>> class Request(IntEnum):\n"
"...     POST = 1\n"
"...     GET = 2\n"
"...\n"
">>> Shape == 1\n"
"False\n"
">>> Shape.CIRCLE == 1\n"
"True\n"
">>> Shape.CIRCLE == Request.POST\n"
"True"

#: ../../howto/enum.rst:688
msgid ""
"However, they still can't be compared to standard :class:`Enum` "
"enumerations::"
msgstr "不过，它们仍然不可与标准 :class:`Enum` 枚举进行比较::"

#: ../../howto/enum.rst:690
msgid ""
">>> class Shape(IntEnum):\n"
"...     CIRCLE = 1\n"
"...     SQUARE = 2\n"
"...\n"
">>> class Color(Enum):\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...\n"
">>> Shape.CIRCLE == Color.RED\n"
"False"
msgstr ""
">>> class Shape(IntEnum):\n"
"...     CIRCLE = 1\n"
"...     SQUARE = 2\n"
"...\n"
">>> class Color(Enum):\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...\n"
">>> Shape.CIRCLE == Color.RED\n"
"False"

#: ../../howto/enum.rst:701
msgid ""
":class:`IntEnum` values behave like integers in other ways you'd expect::"
msgstr ":class:`IntEnum` 值在其他方面的行为都如你预期的一样类似于整数::"

#: ../../howto/enum.rst:703
msgid ""
">>> int(Shape.CIRCLE)\n"
"1\n"
">>> ['a', 'b', 'c'][Shape.CIRCLE]\n"
"'b'\n"
">>> [i for i in range(Shape.SQUARE)]\n"
"[0, 1]"
msgstr ""
">>> int(Shape.CIRCLE)\n"
"1\n"
">>> ['a', 'b', 'c'][Shape.CIRCLE]\n"
"'b'\n"
">>> [i for i in range(Shape.SQUARE)]\n"
"[0, 1]"

#: ../../howto/enum.rst:712
msgid "StrEnum"
msgstr "StrEnum"

#: ../../howto/enum.rst:714
msgid ""
"The second variation of :class:`Enum` that is provided is also a subclass of"
" :class:`str`.  Members of a :class:`StrEnum` can be compared to strings; by"
" extension, string enumerations of different types can also be compared to "
"each other."
msgstr ""
"所提供的第二种 :class:`Enum` 变体同时也是 :class:`str` 的一个子类。 :class:`StrEnum` "
"的成员可与字符串进行比较；通过扩展，不同类型的字符串枚举也可以相互进行比较。"

#: ../../howto/enum.rst:723
msgid "IntFlag"
msgstr "IntFlag"

#: ../../howto/enum.rst:725
msgid ""
"The next variation of :class:`Enum` provided, :class:`IntFlag`, is also "
"based on :class:`int`.  The difference being :class:`IntFlag` members can be"
" combined using the bitwise operators (&, \\|, ^, ~) and the result is still"
" an :class:`IntFlag` member, if possible.  Like :class:`IntEnum`, "
":class:`IntFlag` members are also integers and can be used wherever an "
":class:`int` is used."
msgstr ""
"所提供的下一种 :class:`Enum` 变体 :class:`IntFlag` 也是基于 :class:`int` 的。 不同之处在于 "
":class:`IntFlag` 成员可以用位运算符 (&, \\|, ^, ~) 进行组合并且如果可能的话其结果仍将是 "
":class:`IntFlag` 成员。 与 :class:`IntEnum` 类似，:class:`IntFlag` 成员也是整数并且可以用于任何使用"
" :class:`int` 的地方。"

#: ../../howto/enum.rst:733
msgid ""
"Any operation on an :class:`IntFlag` member besides the bit-wise operations "
"will lose the :class:`IntFlag` membership."
msgstr "除位操作外，其他所有对 :class:`IntFlag` 成员的操作，都会失去 :class:`IntFlag` 成员资格。"

#: ../../howto/enum.rst:736
msgid ""
"Bit-wise operations that result in invalid :class:`IntFlag` values will lose"
" the :class:`IntFlag` membership.  See :class:`FlagBoundary` for details."
msgstr ""
"导致 :class:`IntFlag` 值无效的位操作将失去 :class:`IntFlag` 成员资格。详见 "
":class:`FlagBoundary`。"

#: ../../howto/enum.rst:743
msgid "Sample :class:`IntFlag` class::"
msgstr "示例 :class:`IntFlag` 类::"

#: ../../howto/enum.rst:745
msgid ""
">>> from enum import IntFlag\n"
">>> class Perm(IntFlag):\n"
"...     R = 4\n"
"...     W = 2\n"
"...     X = 1\n"
"...\n"
">>> Perm.R | Perm.W\n"
"<Perm.R|W: 6>\n"
">>> Perm.R + Perm.W\n"
"6\n"
">>> RW = Perm.R | Perm.W\n"
">>> Perm.R in RW\n"
"True"
msgstr ""
">>> from enum import IntFlag\n"
">>> class Perm(IntFlag):\n"
"...     R = 4\n"
"...     W = 2\n"
"...     X = 1\n"
"...\n"
">>> Perm.R | Perm.W\n"
"<Perm.R|W: 6>\n"
">>> Perm.R + Perm.W\n"
"6\n"
">>> RW = Perm.R | Perm.W\n"
">>> Perm.R in RW\n"
"True"

#: ../../howto/enum.rst:759
msgid "It is also possible to name the combinations::"
msgstr "对于组合同样可以进行命名::"

#: ../../howto/enum.rst:761
msgid ""
">>> class Perm(IntFlag):\n"
"...     R = 4\n"
"...     W = 2\n"
"...     X = 1\n"
"...     RWX = 7\n"
"...\n"
">>> Perm.RWX\n"
"<Perm.RWX: 7>\n"
">>> ~Perm.RWX\n"
"<Perm: 0>\n"
">>> Perm(7)\n"
"<Perm.RWX: 7>"
msgstr ""
">>> class Perm(IntFlag):\n"
"...     R = 4\n"
"...     W = 2\n"
"...     X = 1\n"
"...     RWX = 7\n"
"...\n"
">>> Perm.RWX\n"
"<Perm.RWX: 7>\n"
">>> ~Perm.RWX\n"
"<Perm: 0>\n"
">>> Perm(7)\n"
"<Perm.RWX: 7>"

#: ../../howto/enum.rst:776
msgid ""
"Named combinations are considered aliases.  Aliases do not show up during "
"iteration, but can be returned from by-value lookups."
msgstr "命名的枚举组合被视作别名。别名在迭代过程中不会显示，但可以通过值查询返回。"

#: ../../howto/enum.rst:781
msgid ""
"Another important difference between :class:`IntFlag` and :class:`Enum` is "
"that if no flags are set (the value is 0), its boolean evaluation is "
":data:`False`::"
msgstr ""
":class:`IntFlag` 和 :class:`Enum` 的另一个重要区别在于如果没有设置任何旗标（值为 0），则其布尔值为 "
":data:`False`::"

#: ../../howto/enum.rst:784
msgid ""
">>> Perm.R & Perm.X\n"
"<Perm: 0>\n"
">>> bool(Perm.R & Perm.X)\n"
"False"
msgstr ""
">>> Perm.R & Perm.X\n"
"<Perm: 0>\n"
">>> bool(Perm.R & Perm.X)\n"
"False"

#: ../../howto/enum.rst:789
msgid ""
"Because :class:`IntFlag` members are also subclasses of :class:`int` they "
"can be combined with them (but may lose :class:`IntFlag` membership::"
msgstr ""
"因为 :class:`IntFlag` 成员也是 :class:`int` 的子类，他们可以相互组合（但可能会失去 :class:`IntFlag` "
"成员资格::"

#: ../../howto/enum.rst:792
msgid ""
">>> Perm.X | 4\n"
"<Perm.R|X: 5>\n"
"\n"
">>> Perm.X + 8\n"
"9"
msgstr ""
">>> Perm.X | 4\n"
"<Perm.R|X: 5>\n"
"\n"
">>> Perm.X + 8\n"
"9"

#: ../../howto/enum.rst:800
msgid ""
"The negation operator, ``~``, always returns an :class:`IntFlag` member with"
" a positive value::"
msgstr "否运算符 ``~``，始终会返回一个 :class:`IntFlag` 成员的正值::"

#: ../../howto/enum.rst:803
msgid ""
">>> (~Perm.X).value == (Perm.R|Perm.W).value == 6\n"
"True"
msgstr ""
">>> (~Perm.X).value == (Perm.R|Perm.W).value == 6\n"
"True"

#: ../../howto/enum.rst:806
msgid ":class:`IntFlag` members can also be iterated over::"
msgstr ":class:`IntFlag` 成员也可被迭代遍历::"

#: ../../howto/enum.rst:808
msgid ""
">>> list(RW)\n"
"[<Perm.R: 4>, <Perm.W: 2>]"
msgstr ""
">>> list(RW)\n"
"[<Perm.R: 4>, <Perm.W: 2>]"

#: ../../howto/enum.rst:815
msgid "Flag"
msgstr "标志"

#: ../../howto/enum.rst:817
msgid ""
"The last variation is :class:`Flag`.  Like :class:`IntFlag`, :class:`Flag` "
"members can be combined using the bitwise operators (&, \\|, ^, ~).  Unlike "
":class:`IntFlag`, they cannot be combined with, nor compared against, any "
"other :class:`Flag` enumeration, nor :class:`int`.  While it is possible to "
"specify the values directly it is recommended to use :class:`auto` as the "
"value and let :class:`Flag` select an appropriate value."
msgstr ""
"最后一个变体是 :class:`Flag`。与 :class:`IntFlag` 类似，:class:`Flag` 成员可用按位运算符 (&, \\|,"
" ^, ~) 组合。与 :class:`IntFlag` 不同的是，它们不可与其它 :class:`Flag` 枚举或 :class:`int` "
"进行组合或比较。 虽然可以直接指定值，但推荐使用 :class:`auto` 作为值来让 :class:`Flag` 选择适当的值。"

#: ../../howto/enum.rst:826
msgid ""
"Like :class:`IntFlag`, if a combination of :class:`Flag` members results in "
"no flags being set, the boolean evaluation is :data:`False`::"
msgstr ""
"与 :class:`IntFlag` 类似，如果 :class:`Flag` 成员的某种组合导致没有设置任何旗标，则其布尔值为 "
":data:`False`::"

#: ../../howto/enum.rst:829
msgid ""
">>> from enum import Flag, auto\n"
">>> class Color(Flag):\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...\n"
">>> Color.RED & Color.GREEN\n"
"<Color: 0>\n"
">>> bool(Color.RED & Color.GREEN)\n"
"False"
msgstr ""
">>> from enum import Flag, auto\n"
">>> class Color(Flag):\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...\n"
">>> Color.RED & Color.GREEN\n"
"<Color: 0>\n"
">>> bool(Color.RED & Color.GREEN)\n"
"False"

#: ../../howto/enum.rst:840
msgid ""
"Individual flags should have values that are powers of two (1, 2, 4, 8, "
"...), while combinations of flags will not::"
msgstr "单个旗标的值应当为二的乘方 (1, 2, 4, 8, ...)，而旗标的组合则无此限制::"

#: ../../howto/enum.rst:843
msgid ""
">>> class Color(Flag):\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...     WHITE = RED | BLUE | GREEN\n"
"...\n"
">>> Color.WHITE\n"
"<Color.WHITE: 7>"
msgstr ""
">>> class Color(Flag):\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...     WHITE = RED | BLUE | GREEN\n"
"...\n"
">>> Color.WHITE\n"
"<Color.WHITE: 7>"

#: ../../howto/enum.rst:852
msgid ""
"Giving a name to the \"no flags set\" condition does not change its boolean "
"value::"
msgstr "对 \"no flags set\" 条件指定一个名称并不会改变其布尔值::"

#: ../../howto/enum.rst:855
msgid ""
">>> class Color(Flag):\n"
"...     BLACK = 0\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...\n"
">>> Color.BLACK\n"
"<Color.BLACK: 0>\n"
">>> bool(Color.BLACK)\n"
"False"
msgstr ""
">>> class Color(Flag):\n"
"...     BLACK = 0\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...\n"
">>> Color.BLACK\n"
"<Color.BLACK: 0>\n"
">>> bool(Color.BLACK)\n"
"False"

#: ../../howto/enum.rst:866
msgid ":class:`Flag` members can also be iterated over::"
msgstr ":class:`Flag` 成员也可被迭代遍历::"

#: ../../howto/enum.rst:868
msgid ""
">>> purple = Color.RED | Color.BLUE\n"
">>> list(purple)\n"
"[<Color.RED: 1>, <Color.BLUE: 2>]"
msgstr ""
">>> purple = Color.RED | Color.BLUE\n"
">>> list(purple)\n"
"[<Color.RED: 1>, <Color.BLUE: 2>]"

#: ../../howto/enum.rst:876
msgid ""
"For the majority of new code, :class:`Enum` and :class:`Flag` are strongly "
"recommended, since :class:`IntEnum` and :class:`IntFlag` break some semantic"
" promises of an enumeration (by being comparable to integers, and thus by "
"transitivity to other unrelated enumerations).  :class:`IntEnum` and "
":class:`IntFlag` should be used only in cases where :class:`Enum` and "
":class:`Flag` will not do; for example, when integer constants are replaced "
"with enumerations, or for interoperability with other systems."
msgstr ""
"对于大多数新代码，强烈推荐使用 :class:`Enum` 和 :class:`Flag`，因为 :class:`IntEnum` 和 "
":class:`IntFlag` 打破了枚举的某些语义约定（例如可以同整数进行比较，并因而导致此行为被传递给其他无关的枚举）。 "
":class:`IntEnum` 和 :class:`IntFlag` 的使用应当仅限于 :class:`Enum` 和 :class:`Flag` "
"无法使用的场合；例如，当使用枚举替代整数常量时，或是与其他系统进行交互操作时。"

#: ../../howto/enum.rst:886
msgid "Others"
msgstr "其他事项"

#: ../../howto/enum.rst:888
msgid ""
"While :class:`IntEnum` is part of the :mod:`enum` module, it would be very "
"simple to implement independently::"
msgstr "虽然 :class:`IntEnum` 是 :mod:`enum` 模块的一部分，但要独立实现也应该相当容易::"

#: ../../howto/enum.rst:891
msgid ""
"class IntEnum(int, ReprEnum):   # or Enum instead of ReprEnum\n"
"    pass"
msgstr ""
"class IntEnum(int, ReprEnum):   # 或用 Enum 而不是 ReprEnum\n"
"    pass"

#: ../../howto/enum.rst:894
msgid ""
"This demonstrates how similar derived enumerations can be defined; for "
"example a :class:`!FloatEnum` that mixes in :class:`float` instead of "
":class:`int`."
msgstr ""
"这里演示了类似的派生枚举可以如何被定义；例如，一个混入了 :class:`float` 而不是 :class:`int` 的 "
":class:`!FloatEnum`。"

#: ../../howto/enum.rst:897
msgid "Some rules:"
msgstr "几条规则："

#: ../../howto/enum.rst:899
msgid ""
"When subclassing :class:`Enum`, mix-in types must appear before the "
":class:`Enum` class itself in the sequence of bases, as in the "
":class:`IntEnum` example above."
msgstr ""
"当子类化 :class:`Enum` 时，混入类型必须出现在基类序列中的 :class:`Enum` 类本身之前，如以上 "
":class:`IntEnum` 的例子所示。"

#: ../../howto/enum.rst:902
msgid ""
"Mix-in types must be subclassable. For example, :class:`bool` and "
":class:`range` are not subclassable and will throw an error during Enum "
"creation if used as the mix-in type."
msgstr ""
"混入类型必须是可子类化的。 例如，:class:`bool` 和 :class:`range` "
"是不可子类化的因而如果被用作混入类型就将在枚举创建期间抛出错误。"

#: ../../howto/enum.rst:905
msgid ""
"While :class:`Enum` can have members of any type, once you mix in an "
"additional type, all the members must have values of that type, e.g. "
":class:`int` above.  This restriction does not apply to mix-ins which only "
"add methods and don't specify another type."
msgstr ""
"虽然 :class:`Enum` 可以拥有任意类型的成员，不过一旦你混合了附加类型，则所有成员必须为相应类型的值，如在上面的例子中即为 "
":class:`int`。 此限制不适用于仅添加方法而未指定另一数据类型的混合类。"

#: ../../howto/enum.rst:909
msgid ""
"When another data type is mixed in, the :attr:`~Enum.value` attribute is "
"*not the same* as the enum member itself, although it is equivalent and will"
" compare equal."
msgstr "当混合了另一数据类型时，:attr:`~Enum.value` 属性将 *不同于* 枚举成员本身，不过它们仍会保持等价且比较结果也相等。"

#: ../../howto/enum.rst:912
msgid ""
"A ``data type`` is a mixin that defines :meth:`~object.__new__`, or a "
":class:`~dataclasses.dataclass`"
msgstr ""
"``data type`` 是一个定义了 :meth:`~object.__new__` 的混入对象，或者是一个 "
":class:`~dataclasses.dataclass`"

#: ../../howto/enum.rst:914
msgid ""
"%-style formatting:  ``%s`` and ``%r`` call the :class:`Enum` class's "
":meth:`~object.__str__` and :meth:`~object.__repr__` respectively; other "
"codes (such as ``%i`` or ``%h`` for IntEnum) treat the enum member as its "
"mixed-in type."
msgstr ""
"% 形式的格式化： ``%s`` 和 ``%r`` 会分别调用 :class:`Enum` 类的 :meth:`~object.__str__` 和 "
":meth:`~object.__repr__`；其他代码（如 ``%i`` 或 ``%h`` 用于 IntEnum）会将枚举成员当作对应的混入类型。"

#: ../../howto/enum.rst:917
msgid ""
":ref:`Formatted string literals <f-strings>`, :meth:`str.format`, and "
":func:`format` will use the enum's :meth:`~object.__str__` method."
msgstr ""
":ref:`格式化字符串字面值 <f-strings>`, :meth:`str.format` 和 :func:`format` 将使用枚举的 "
":meth:`~object.__str__` 方法。"

#: ../../howto/enum.rst:922
msgid ""
"Because :class:`IntEnum`, :class:`IntFlag`, and :class:`StrEnum` are "
"designed to be drop-in replacements for existing constants, their "
":meth:`~object.__str__` method has been reset to their data types' "
":meth:`~object.__str__` method."
msgstr ""
"由于 :class:`IntEnum`, :class:`IntFlag` 和 :class:`StrEnum` 被设计为现有常量的无缝替换，它们的 "
":meth:`~object.__str__` 方法已被重置为其数据类型的 :meth:`~object.__str__` 方法。"

#: ../../howto/enum.rst:930
msgid "When to use :meth:`~object.__new__` vs. :meth:`~object.__init__`"
msgstr "何时应使用 :meth:`~object.__new__` 或 :meth:`~object.__init__`"

#: ../../howto/enum.rst:932
msgid ""
":meth:`~object.__new__` must be used whenever you want to customize the "
"actual value of the :class:`Enum` member.  Any other modifications may go in"
" either :meth:`~object.__new__` or :meth:`~object.__init__`, with "
":meth:`~object.__init__` being preferred."
msgstr ""
"当你想要定制 :class:`Enum` 成员的实际值时你必须使用 :meth:`~object.__new__`。 任何其他修改则可使用 "
":meth:`~object.__new__` 或 :meth:`~object.__init__`，其中 "
":meth:`~object.__init__` 更为推荐。"

#: ../../howto/enum.rst:936
msgid ""
"For example, if you want to pass several items to the constructor, but only "
"want one of them to be the value::"
msgstr "举例来说，如果你要向构造器传入多个条目，但只希望将其中一个作为值::"

#: ../../howto/enum.rst:939
msgid ""
">>> class Coordinate(bytes, Enum):\n"
"...     \"\"\"\n"
"...     Coordinate with binary codes that can be indexed by the int code.\n"
"...     \"\"\"\n"
"...     def __new__(cls, value, label, unit):\n"
"...         obj = bytes.__new__(cls, [value])\n"
"...         obj._value_ = value\n"
"...         obj.label = label\n"
"...         obj.unit = unit\n"
"...         return obj\n"
"...     PX = (0, 'P.X', 'km')\n"
"...     PY = (1, 'P.Y', 'km')\n"
"...     VX = (2, 'V.X', 'km/s')\n"
"...     VY = (3, 'V.Y', 'km/s')\n"
"...\n"
"\n"
">>> print(Coordinate['PY'])\n"
"Coordinate.PY\n"
"\n"
">>> print(Coordinate(3))\n"
"Coordinate.VY"
msgstr ""
">>> class Coordinate(bytes, Enum):\n"
"...     \"\"\"\n"
"...     Coordinate with binary codes that can be indexed by the int code.\n"
"...     \"\"\"\n"
"...     def __new__(cls, value, label, unit):\n"
"...         obj = bytes.__new__(cls, [value])\n"
"...         obj._value_ = value\n"
"...         obj.label = label\n"
"...         obj.unit = unit\n"
"...         return obj\n"
"...     PX = (0, 'P.X', 'km')\n"
"...     PY = (1, 'P.Y', 'km')\n"
"...     VX = (2, 'V.X', 'km/s')\n"
"...     VY = (3, 'V.Y', 'km/s')\n"
"...\n"
"\n"
">>> print(Coordinate['PY'])\n"
"Coordinate.PY\n"
"\n"
">>> print(Coordinate(3))\n"
"Coordinate.VY"

#: ../../howto/enum.rst:963
msgid ""
"*Do not* call ``super().__new__()``, as the lookup-only ``__new__`` is the "
"one that is found; instead, use the data type directly."
msgstr "*不要* 调用 ``super().__new__()``，因为只能找到仅用于查找的 ``__new__``；请改为直接使用该数据类型。"

#: ../../howto/enum.rst:968
msgid "Finer Points"
msgstr "细节要点"

#: ../../howto/enum.rst:971
msgid "Supported ``__dunder__`` names"
msgstr "支持的 ``__dunder__`` 名称"

#: ../../howto/enum.rst:973
msgid ""
":attr:`~enum.EnumType.__members__` is a read-only ordered mapping of "
"``member_name``:``member`` items.  It is only available on the class."
msgstr ""
":attr:`~enum.EnumType.__members__` 是一个由 ``member_name``:``member`` "
"条目组成的只读有序映射。 它只在类上可用。"

#: ../../howto/enum.rst:976
msgid ""
":meth:`~object.__new__`, if specified, must create and return the enum "
"members; it is also a very good idea to set the member's "
":attr:`~Enum._value_` appropriately.  Once all the members are created it is"
" no longer used."
msgstr ""
"如果指定了 :meth:`~object.__new__`，它必须创建并返回枚举成员；相应地设置成员的 :attr:`~Enum._value_` "
"也是一个很好的主意。 一旦所有成员都创建完成它将不再被使用。"

#: ../../howto/enum.rst:982
msgid "Supported ``_sunder_`` names"
msgstr "支持的 ``_sunder_`` 名称"

#: ../../howto/enum.rst:984
msgid ":attr:`~Enum._name_` -- name of the member"
msgstr ":attr:`~Enum._name_` -- 成员的名称"

#: ../../howto/enum.rst:985
msgid ""
":attr:`~Enum._value_` -- value of the member; can be set in ``__new__``"
msgstr ":attr:`~Enum._value_` -- 成员的值；可在 ``__new__`` 中设置"

#: ../../howto/enum.rst:986
msgid ""
":meth:`~Enum._missing_` -- a lookup function used when a value is not found;"
" may be overridden"
msgstr ":meth:`~Enum._missing_` -- 当未找到某个值时所使用的查找函数；可被重写"

#: ../../howto/enum.rst:988
msgid ""
":attr:`~Enum._ignore_` -- a list of names, either as a :class:`list` or a "
":class:`str`, that will not be transformed into members, and will be removed"
" from the final class"
msgstr ""
":attr:`~Enum._ignore_` -- 一个名称列表，可以为 :class:`list` 或 "
":class:`str`，它不会被转化为成员，并将从最终类中移除"

#: ../../howto/enum.rst:991
msgid ""
":meth:`~Enum._generate_next_value_` -- used to get an appropriate value for "
"an enum member; may be overridden"
msgstr ":meth:`~Enum._generate_next_value_` -- 用于为枚举成员获取适当的值；可被重写"

#: ../../howto/enum.rst:993
msgid ""
":meth:`~Enum._add_alias_` -- adds a new name as an alias to an existing "
"member."
msgstr ""

#: ../../howto/enum.rst:995
msgid ""
":meth:`~Enum._add_value_alias_` -- adds a new value as an alias to an "
"existing member.  See `MultiValueEnum`_ for an example."
msgstr ""

#: ../../howto/enum.rst:1000
msgid ""
"For standard :class:`Enum` classes the next value chosen is the highest "
"value seen incremented by one."
msgstr "对于标准的 :class:`Enum` 类来说下一个被选择的值将是已有的最高值加一。"

#: ../../howto/enum.rst:1003
msgid ""
"For :class:`Flag` classes the next value chosen will be the next highest "
"power-of-two."
msgstr "对于 :class:`Flag` 类来说下一个选择的值将是下一个最高的二的幂数。"

#: ../../howto/enum.rst:1006
msgid ""
"Prior versions would use the last seen value instead of the highest value."
msgstr "在之前版本中将会使用最近的值而不是最高的值。"

#: ../../howto/enum.rst:1009
msgid "``_missing_``, ``_order_``, ``_generate_next_value_``"
msgstr "``_missing_``, ``_order_``, ``_generate_next_value_``"

#: ../../howto/enum.rst:1010
msgid "``_ignore_``"
msgstr "``_ignore_``"

#: ../../howto/enum.rst:1011
msgid "``_add_alias_``, ``_add_value_alias_``"
msgstr "``_add_alias_``, ``_add_value_alias_``"

#: ../../howto/enum.rst:1013
msgid ""
"To help keep Python 2 / Python 3 code in sync an :attr:`~Enum._order_` "
"attribute can be provided.  It will be checked against the actual order of "
"the enumeration and raise an error if the two do not match::"
msgstr ""
"用于帮助 Python 2 / Python 3 代码保持同步以便提供 :attr:`~Enum._order_` 属性。 "
"它将与枚举的实际顺序进行检查并会在两者不匹配时引发错误::"

#: ../../howto/enum.rst:1017
msgid ""
">>> class Color(Enum):\n"
"...     _order_ = 'RED GREEN BLUE'\n"
"...     RED = 1\n"
"...     BLUE = 3\n"
"...     GREEN = 2\n"
"...\n"
"Traceback (most recent call last):\n"
"...\n"
"TypeError: member order does not match _order_:\n"
"  ['RED', 'BLUE', 'GREEN']\n"
"  ['RED', 'GREEN', 'BLUE']"
msgstr ""
">>> class Color(Enum):\n"
"...     _order_ = 'RED GREEN BLUE'\n"
"...     RED = 1\n"
"...     BLUE = 3\n"
"...     GREEN = 2\n"
"...\n"
"Traceback (most recent call last):\n"
"...\n"
"TypeError: member order does not match _order_:\n"
"  ['RED', 'BLUE', 'GREEN']\n"
"  ['RED', 'GREEN', 'BLUE']"

#: ../../howto/enum.rst:1031
msgid ""
"In Python 2 code the :attr:`~Enum._order_` attribute is necessary as "
"definition order is lost before it can be recorded."
msgstr "在 Python 2 代码中 :attr:`~Enum._order_` 属性是必须的，因为定义顺序在被记录之前就已丢失。"

#: ../../howto/enum.rst:1036
msgid "_Private__names"
msgstr "_Private__names"

#: ../../howto/enum.rst:1038
msgid ""
":ref:`Private names <private-name-mangling>` are not converted to enum "
"members, but remain normal attributes."
msgstr ":ref:`私有名称 <private-name-mangling>` 不会被转换为枚举成员，而是保持为普通属性。"

#: ../../howto/enum.rst:1045
msgid "``Enum`` member type"
msgstr "``Enum`` 成员类型"

#: ../../howto/enum.rst:1047
msgid ""
"Enum members are instances of their enum class, and are normally accessed as"
" ``EnumClass.member``.  In certain situations, such as writing custom enum "
"behavior, being able to access one member directly from another is useful, "
"and is supported; however, in order to avoid name clashes between member "
"names and attributes/methods from mixed-in classes, upper-case names are "
"strongly recommended."
msgstr ""
"枚举成员是其枚举类的实例，并且通常以 ``EnumClass.member`` 的形式来访问。 "
"在特定场景下，如编写自定义枚举行为，可直接从一个成员访问另一个成员的能力是很有用的，并且是受支持的；但是，为了避免成员名与混入类属性/方法之间发生名称冲突，强烈建议使用大写形式的名称。"

#: ../../howto/enum.rst:1058
msgid "Creating members that are mixed with other data types"
msgstr "创建与其他数据类型混合的成员"

#: ../../howto/enum.rst:1060
msgid ""
"When subclassing other data types, such as :class:`int` or :class:`str`, "
"with an :class:`Enum`, all values after the ``=`` are passed to that data "
"type's constructor.  For example::"
msgstr ""
"当使用 :class:`Enum` 来子类化其他数据类型，如 :class:`int` 或 :class:`str` 时，所有在 ``=`` "
"之后的值都会被传递给该数据类型的构造器。 例如::"

#: ../../howto/enum.rst:1064
msgid ""
">>> class MyEnum(IntEnum):      # help(int) -> int(x, base=10) -> integer\n"
"...     example = '11', 16      # so x='11' and base=16\n"
"...\n"
">>> MyEnum.example.value        # and hex(11) is...\n"
"17"
msgstr ""
">>> class MyEnum(IntEnum):      # help(int) -> int(x, base=10) -> integer\n"
"...     example = '11', 16      # 这样 x='11' 而 base=16\n"
"...\n"
">>> MyEnum.example.value        # 而 hex(11) 为...\n"
"17"

#: ../../howto/enum.rst:1072
msgid "Boolean value of ``Enum`` classes and members"
msgstr "``Enum`` 类和成员的布尔值"

#: ../../howto/enum.rst:1074
msgid ""
"Enum classes that are mixed with non-:class:`Enum` types (such as "
":class:`int`, :class:`str`, etc.) are evaluated according to the mixed-in "
"type's rules; otherwise, all members evaluate as :data:`True`.  To make your"
" own enum's boolean evaluation depend on the member's value add the "
"following to your class::"
msgstr ""
"与非 :class:`Enum` 类型（如 :class:`int`、:class:`str` "
"等）混合的枚举类会根据混合类型的规则进行计算；否则，所有成员都计算为 "
":data:`True`。为了使你自己的枚举的布尔值取决于成员的值，请在你的类中添加以下内容::"

#: ../../howto/enum.rst:1080
msgid ""
"def __bool__(self):\n"
"    return bool(self.value)"
msgstr ""
"def __bool__(self):\n"
"    return bool(self.value)"

#: ../../howto/enum.rst:1083
msgid "Plain :class:`Enum` classes always evaluate as :data:`True`."
msgstr "普通的 :class:`Enum` 类总是计算为 :data:`True`。"

#: ../../howto/enum.rst:1087
msgid "``Enum`` classes with methods"
msgstr "带有方法的 ``Enum`` 类"

#: ../../howto/enum.rst:1089
msgid ""
"If you give your enum subclass extra methods, like the `Planet`_ class "
"below, those methods will show up in a :func:`dir` of the member, but not of"
" the class::"
msgstr ""
"如果你给你的枚举子类提供了额外的方法，如下面的 `Planet`_ 类那样，这些方法将显示在成员的，而不是类的 :func:`dir` 中::"

#: ../../howto/enum.rst:1093
msgid ""
">>> dir(Planet)\n"
"['EARTH', 'JUPITER', 'MARS', 'MERCURY', 'NEPTUNE', 'SATURN', 'URANUS', 'VENUS', '__class__', '__doc__', '__members__', '__module__']\n"
">>> dir(Planet.EARTH)\n"
"['__class__', '__doc__', '__module__', 'mass', 'name', 'radius', 'surface_gravity', 'value']"
msgstr ""
">>> dir(Planet)\n"
"['EARTH', 'JUPITER', 'MARS', 'MERCURY', 'NEPTUNE', 'SATURN', 'URANUS', 'VENUS', '__class__', '__doc__', '__members__', '__module__']\n"
">>> dir(Planet.EARTH)\n"
"['__class__', '__doc__', '__module__', 'mass', 'name', 'radius', 'surface_gravity', 'value']"

#: ../../howto/enum.rst:1100
msgid "Combining members of ``Flag``"
msgstr "组合 ``Flag`` 的成员"

#: ../../howto/enum.rst:1102
msgid ""
"Iterating over a combination of :class:`Flag` members will only return the "
"members that are comprised of a single bit::"
msgstr "遍历 :class:`Flag` 成员的组合将只返回由一个比特组成的成员::"

#: ../../howto/enum.rst:1105
msgid ""
">>> class Color(Flag):\n"
"...     RED = auto()\n"
"...     GREEN = auto()\n"
"...     BLUE = auto()\n"
"...     MAGENTA = RED | BLUE\n"
"...     YELLOW = RED | GREEN\n"
"...     CYAN = GREEN | BLUE\n"
"...\n"
">>> Color(3)  # named combination\n"
"<Color.YELLOW: 3>\n"
">>> Color(7)      # not named combination\n"
"<Color.RED|GREEN|BLUE: 7>"
msgstr ""
">>> class Color(Flag):\n"
"...     RED = auto()\n"
"...     GREEN = auto()\n"
"...     BLUE = auto()\n"
"...     MAGENTA = RED | BLUE\n"
"...     YELLOW = RED | GREEN\n"
"...     CYAN = GREEN | BLUE\n"
"...\n"
">>> Color(3)  # named combination\n"
"<Color.YELLOW: 3>\n"
">>> Color(7)      # not named combination\n"
"<Color.RED|GREEN|BLUE: 7>"

#: ../../howto/enum.rst:1120
msgid "``Flag`` and ``IntFlag`` minutia"
msgstr "``Flag`` 和 ``IntFlag`` 的细节"

#: ../../howto/enum.rst:1122
msgid "Using the following snippet for our examples::"
msgstr "使用以下代码段作为我们的例子::"

#: ../../howto/enum.rst:1124
msgid ""
">>> class Color(IntFlag):\n"
"...     BLACK = 0\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...     BLUE = 4\n"
"...     PURPLE = RED | BLUE\n"
"...     WHITE = RED | GREEN | BLUE\n"
"..."
msgstr ""
">>> class Color(IntFlag):\n"
"...     BLACK = 0\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...     BLUE = 4\n"
"...     PURPLE = RED | BLUE\n"
"...     WHITE = RED | GREEN | BLUE\n"
"..."

#: ../../howto/enum.rst:1133
msgid "the following are true:"
msgstr "下列情况为True:"

#: ../../howto/enum.rst:1135
msgid "single-bit flags are canonical"
msgstr "单比特标志是典型的"

#: ../../howto/enum.rst:1136
msgid "multi-bit and zero-bit flags are aliases"
msgstr "多比特和零比特标志是别名"

#: ../../howto/enum.rst:1137
msgid "only canonical flags are returned during iteration::"
msgstr "迭代过程中只返回典型的标志::"

#: ../../howto/enum.rst:1139
msgid ""
">>> list(Color.WHITE)\n"
"[<Color.RED: 1>, <Color.GREEN: 2>, <Color.BLUE: 4>]"
msgstr ""
">>> list(Color.WHITE)\n"
"[<Color.RED: 1>, <Color.GREEN: 2>, <Color.BLUE: 4>]"

#: ../../howto/enum.rst:1142
msgid ""
"negating a flag or flag set returns a new flag/flag set with the "
"corresponding positive integer value::"
msgstr "取负一个标志或标志集会返回一个新的标志/标志集和其对应的正整数值::"

#: ../../howto/enum.rst:1145
msgid ""
">>> Color.BLUE\n"
"<Color.BLUE: 4>\n"
"\n"
">>> ~Color.BLUE\n"
"<Color.RED|GREEN: 3>"
msgstr ""
">>> Color.BLUE\n"
"<Color.BLUE: 4>\n"
"\n"
">>> ~Color.BLUE\n"
"<Color.RED|GREEN: 3>"

#: ../../howto/enum.rst:1151
msgid "names of pseudo-flags are constructed from their members' names::"
msgstr "伪标志的名称是由其成员的名称构建的::"

#: ../../howto/enum.rst:1153
msgid ""
">>> (Color.RED | Color.GREEN).name\n"
"'RED|GREEN'\n"
"\n"
">>> class Perm(IntFlag):\n"
"...     R = 4\n"
"...     W = 2\n"
"...     X = 1\n"
"...\n"
">>> (Perm.R & Perm.W).name is None  # effectively Perm(0)\n"
"True"
msgstr ""
">>> (Color.RED | Color.GREEN).name\n"
"'RED|GREEN'\n"
"\n"
">>> class Perm(IntFlag):\n"
"...     R = 4\n"
"...     W = 2\n"
"...     X = 1\n"
"...\n"
">>> (Perm.R & Perm.W).name is None  # effectively Perm(0)\n"
"True"

#: ../../howto/enum.rst:1164
msgid "multi-bit flags, aka aliases, can be returned from operations::"
msgstr "多位标志，又称别名，可以从操作中返回::"

#: ../../howto/enum.rst:1166
msgid ""
">>> Color.RED | Color.BLUE\n"
"<Color.PURPLE: 5>\n"
"\n"
">>> Color(7)  # or Color(-1)\n"
"<Color.WHITE: 7>\n"
"\n"
">>> Color(0)\n"
"<Color.BLACK: 0>"
msgstr ""
">>> Color.RED | Color.BLUE\n"
"<Color.PURPLE: 5>\n"
"\n"
">>> Color(7)  # or Color(-1)\n"
"<Color.WHITE: 7>\n"
"\n"
">>> Color(0)\n"
"<Color.BLACK: 0>"

#: ../../howto/enum.rst:1175
msgid ""
"membership / containment checking: zero-valued flags are always considered "
"to be contained::"
msgstr "成员 / 包含检测：零值旗标总是会被视为包含::"

#: ../../howto/enum.rst:1178
msgid ""
">>> Color.BLACK in Color.WHITE\n"
"True"
msgstr ""
">>> Color.BLACK in Color.WHITE\n"
"True"

#: ../../howto/enum.rst:1181
msgid ""
"otherwise, only if all bits of one flag are in the other flag will True be "
"returned::"
msgstr "在其他情况下，仅当一个旗标的所有比特位都包含于另一个旗标中才会返回 True::"

#: ../../howto/enum.rst:1184
msgid ""
">>> Color.PURPLE in Color.WHITE\n"
"True\n"
"\n"
">>> Color.GREEN in Color.PURPLE\n"
"False"
msgstr ""
">>> Color.PURPLE in Color.WHITE\n"
"True\n"
"\n"
">>> Color.GREEN in Color.PURPLE\n"
"False"

#: ../../howto/enum.rst:1190
msgid ""
"There is a new boundary mechanism that controls how out-of-range / invalid "
"bits are handled: ``STRICT``, ``CONFORM``, ``EJECT``, and ``KEEP``:"
msgstr ""
"有一个新的边界机制，控制如何处理超出范围的/无效的比特:``STRICT``，``CONFORM``，``EJECT``，``KEEP``。"

#: ../../howto/enum.rst:1193
msgid "STRICT --> raises an exception when presented with invalid values"
msgstr "STRICT --> 当出现无效的值时，会触发一个异常。"

#: ../../howto/enum.rst:1194
msgid "CONFORM --> discards any invalid bits"
msgstr "CONFORM --> 丢弃任何无效的比特"

#: ../../howto/enum.rst:1195
msgid ""
"EJECT --> lose Flag status and become a normal int with the given value"
msgstr "EJECT --> 失去Flag的状态，成为一个普通的int，其值为给定值。"

#: ../../howto/enum.rst:1196
msgid "KEEP --> keep the extra bits"
msgstr "KEEP --> 保留额外的比特"

#: ../../howto/enum.rst:1198
msgid "keeps Flag status and extra bits"
msgstr "保留Flag状态和额外的比特"

#: ../../howto/enum.rst:1199
msgid "extra bits do not show up in iteration"
msgstr "额外的比特不会在迭代中显示出来"

#: ../../howto/enum.rst:1200
msgid "extra bits do show up in repr() and str()"
msgstr "在repr()和str()中确实显示了额外的比特"

#: ../../howto/enum.rst:1202
msgid ""
"The default for Flag is ``STRICT``, the default for ``IntFlag`` is "
"``EJECT``, and the default for ``_convert_`` is ``KEEP`` (see "
"``ssl.Options`` for an example of when ``KEEP`` is needed)."
msgstr ""
"默认的标志为 "
"``STRICT``，``IntFlag``默认为``EJECT``，``_convert_``默认为``KEEP``（需要``KEEP``的例子见``ssl.Options``）。"

#: ../../howto/enum.rst:1210
msgid "How are Enums and Flags different?"
msgstr "枚举和旗标有何差异？"

#: ../../howto/enum.rst:1212
msgid ""
"Enums have a custom metaclass that affects many aspects of both derived "
":class:`Enum` classes and their instances (members)."
msgstr "Enum有一个自定义的元类，它影响到派生的 :class:`Enum` 类和它们的实例（成员）的许多方面。"

#: ../../howto/enum.rst:1217
msgid "Enum Classes"
msgstr "枚举类"

#: ../../howto/enum.rst:1219
msgid ""
"The :class:`EnumType` metaclass is responsible for providing the "
":meth:`~object.__contains__`, :meth:`~object.__dir__`, "
":meth:`~object.__iter__` and other methods that allow one to do things with "
"an :class:`Enum` class that fail on a typical class, such as ``list(Color)``"
" or ``some_enum_var in Color``.  :class:`EnumType` is responsible for "
"ensuring that various other methods on the final :class:`Enum` class are "
"correct (such as :meth:`~object.__new__`, :meth:`~object.__getnewargs__`, "
":meth:`~object.__str__` and :meth:`~object.__repr__`)."
msgstr ""
":class:`EnumType` 元类负责提供 :meth:`~object.__contains__`, "
":meth:`~object.__dir__`, :meth:`~object.__iter__` 及其他方法来允许人们在 :class:`Enum` "
"类上做一些在常规类上会失败的事情，比如 ``list(Color)`` 或 ``some_enum_var in Color``。 "
":class:`EnumType` 负责确保最终的 :class:`Enum` 类上的各种其他方法是正确的（比如 "
":meth:`~object.__new__`, :meth:`~object.__getnewargs__`, "
":meth:`~object.__str__` 和 :meth:`~object.__repr__` 等）。"

#: ../../howto/enum.rst:1228
msgid "Flag Classes"
msgstr "旗标类"

#: ../../howto/enum.rst:1230
msgid ""
"Flags have an expanded view of aliasing: to be canonical, the value of a "
"flag needs to be a power-of-two value, and not a duplicate name.  So, in "
"addition to the :class:`Enum` definition of alias, a flag with no value "
"(a.k.a. ``0``) or with more than one power-of-two value (e.g. ``3``) is "
"considered an alias."
msgstr ""
"旗标具有扩展的别名视图：为了符合规范，旗标的值必须为二的乘方，且名称不可重复。 因此，除了别名的定义 :class:`Enum` 之外，没有值 (即 "
"``0``) 或是几个二的乘方值之和 (如 ``3``) 的旗标也会被视为别名。"

#: ../../howto/enum.rst:1236
msgid "Enum Members (aka instances)"
msgstr "枚举成员（即实例）"

#: ../../howto/enum.rst:1238
msgid ""
"The most interesting thing about enum members is that they are singletons. "
":class:`EnumType` creates them all while it is creating the enum class "
"itself, and then puts a custom :meth:`~object.__new__` in place to ensure "
"that no new ones are ever instantiated by returning only the existing member"
" instances."
msgstr ""
"有关枚举成员的最有趣的一点在于它们都是单例。 :class:`EnumType` 会在创建枚举类本身时全部创建它们，然后放置一个自定义的 "
":meth:`~object.__new__` 以通过只返回现有的成员实例来确保没有新的成员被实例化。"

#: ../../howto/enum.rst:1244
msgid "Flag Members"
msgstr "旗标成员"

#: ../../howto/enum.rst:1246
msgid ""
"Flag members can be iterated over just like the :class:`Flag` class, and "
"only the canonical members will be returned.  For example::"
msgstr "旗标成员可以如 :class:`Flag` 类一样被迭代，并且只有规范的成员会被返回。 例如::"

#: ../../howto/enum.rst:1249
msgid ""
">>> list(Color)\n"
"[<Color.RED: 1>, <Color.GREEN: 2>, <Color.BLUE: 4>]"
msgstr ""
">>> list(Color)\n"
"[<Color.RED: 1>, <Color.GREEN: 2>, <Color.BLUE: 4>]"

#: ../../howto/enum.rst:1252
msgid "(Note that ``BLACK``, ``PURPLE``, and ``WHITE`` do not show up.)"
msgstr "（请注意 ``BLACK``, ``PURPLE`` 和 ``WHITE`` 将不显示。）"

#: ../../howto/enum.rst:1254
msgid ""
"Inverting a flag member returns the corresponding positive value, rather "
"than a negative value --- for example::"
msgstr "对一个旗标成员取反将返回对应的正值，而不是负值 --- 例如::"

#: ../../howto/enum.rst:1257
msgid ""
">>> ~Color.RED\n"
"<Color.GREEN|BLUE: 6>"
msgstr ""
">>> ~Color.RED\n"
"<Color.GREEN|BLUE: 6>"

#: ../../howto/enum.rst:1260
msgid ""
"Flag members have a length corresponding to the number of power-of-two "
"values they contain.  For example::"
msgstr "旗标成员具有与它们所包含的二的乘方值的数量相对应的长度。 例如::"

#: ../../howto/enum.rst:1263
msgid ""
">>> len(Color.PURPLE)\n"
"2"
msgstr ""
">>> len(Color.PURPLE)\n"
"2"

#: ../../howto/enum.rst:1270
msgid "Enum Cookbook"
msgstr "枚举指导手册"

#: ../../howto/enum.rst:1273
msgid ""
"While :class:`Enum`, :class:`IntEnum`, :class:`StrEnum`, :class:`Flag`, and "
":class:`IntFlag` are expected to cover the majority of use-cases, they "
"cannot cover them all.  Here are recipes for some different types of "
"enumerations that can be used directly, or as examples for creating one's "
"own."
msgstr ""
"虽然 :class:`Enum`, :class:`IntEnum`, :class:`StrEnum`, :class:`Flag` 和 "
":class:`IntFlag` 有望能涵盖大多数的使用情况，但它们不能涵盖所有情况。 "
"这里有一些不同类型的枚举的方法，可以直接使用，或者作为创建定制枚举的范例。"

#: ../../howto/enum.rst:1280
msgid "Omitting values"
msgstr "省略值"

#: ../../howto/enum.rst:1282
msgid ""
"In many use-cases, one doesn't care what the actual value of an enumeration "
"is. There are several ways to define this type of simple enumeration:"
msgstr "在许多应用场景中，人们并不关心枚举的实际值是什么。 有几种方式可用来定义这种类型的简单枚举:"

#: ../../howto/enum.rst:1285
msgid "use instances of :class:`auto` for the value"
msgstr "使用 :class:`auto` 的实例作为值"

#: ../../howto/enum.rst:1286
msgid "use instances of :class:`object` as the value"
msgstr "使用 :class:`object` 的实例作为值"

#: ../../howto/enum.rst:1287
msgid "use a descriptive string as the value"
msgstr "使用描述性的字符串作为值"

#: ../../howto/enum.rst:1288
msgid ""
"use a tuple as the value and a custom :meth:`~object.__new__` to replace the"
" tuple with an :class:`int` value"
msgstr "使用一个元组作为值并用自定义的 :meth:`~object.__new__` 以一个 :class:`int` 值来替代该元组"

#: ../../howto/enum.rst:1291
msgid ""
"Using any of these methods signifies to the user that these values are not "
"important, and also enables one to add, remove, or reorder members without "
"having to renumber the remaining members."
msgstr "使用以上任何一种方法均可向用户指明值并不重要，并且使人能够添加、移除或重排序成员而不必改变其余成员的数值。"

#: ../../howto/enum.rst:1297
msgid "Using :class:`auto`"
msgstr "使用 :class:`auto`"

#: ../../howto/enum.rst:1299
msgid "Using :class:`auto` would look like::"
msgstr "使用 :class:`auto` 的形式如下::"

#: ../../howto/enum.rst:1301
msgid ""
">>> class Color(Enum):\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN: 3>"
msgstr ""
">>> class Color(Enum):\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN: 3>"

#: ../../howto/enum.rst:1311
msgid "Using :class:`object`"
msgstr "使用 :class:`object`"

#: ../../howto/enum.rst:1313
msgid "Using :class:`object` would look like::"
msgstr "使用 :class:`object` 的形式如下::"

#: ../../howto/enum.rst:1315
msgid ""
">>> class Color(Enum):\n"
"...     RED = object()\n"
"...     GREEN = object()\n"
"...     BLUE = object()\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN: <object object at 0x...>>"
msgstr ""
">>> class Color(Enum):\n"
"...     RED = object()\n"
"...     GREEN = object()\n"
"...     BLUE = object()\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN: <object object at 0x...>>"

#: ../../howto/enum.rst:1323
msgid ""
"This is also a good example of why you might want to write your own "
":meth:`~object.__repr__`::"
msgstr "这也是一个可以说明为什么你会需要编写自己的 :meth:`~object.__repr__` 的好例子::"

#: ../../howto/enum.rst:1326
msgid ""
">>> class Color(Enum):\n"
"...     RED = object()\n"
"...     GREEN = object()\n"
"...     BLUE = object()\n"
"...     def __repr__(self):\n"
"...         return \"<%s.%s>\" % (self.__class__.__name__, self._name_)\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN>"
msgstr ""
">>> class Color(Enum):\n"
"...     RED = object()\n"
"...     GREEN = object()\n"
"...     BLUE = object()\n"
"...     def __repr__(self):\n"
"...         return \"<%s.%s>\" % (self.__class__.__name__, self._name_)\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN>"

#: ../../howto/enum.rst:1339
msgid "Using a descriptive string"
msgstr "使用描述性字符串"

#: ../../howto/enum.rst:1341
msgid "Using a string as the value would look like::"
msgstr "使用字符串作为值的形式如下::"

#: ../../howto/enum.rst:1343
msgid ""
">>> class Color(Enum):\n"
"...     RED = 'stop'\n"
"...     GREEN = 'go'\n"
"...     BLUE = 'too fast!'\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN: 'go'>"
msgstr ""
">>> class Color(Enum):\n"
"...     RED = 'stop'\n"
"...     GREEN = 'go'\n"
"...     BLUE = 'too fast!'\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN: 'go'>"

#: ../../howto/enum.rst:1353
msgid "Using a custom :meth:`~object.__new__`"
msgstr "使用自定义的 :meth:`~object.__new__`"

#: ../../howto/enum.rst:1355
msgid "Using an auto-numbering :meth:`~object.__new__` would look like::"
msgstr "使用自动编号的 :meth:`~object.__new__` 看起来会是这样::"

#: ../../howto/enum.rst:1357
msgid ""
">>> class AutoNumber(Enum):\n"
"...     def __new__(cls):\n"
"...         value = len(cls.__members__) + 1\n"
"...         obj = object.__new__(cls)\n"
"...         obj._value_ = value\n"
"...         return obj\n"
"...\n"
">>> class Color(AutoNumber):\n"
"...     RED = ()\n"
"...     GREEN = ()\n"
"...     BLUE = ()\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN: 2>"
msgstr ""
">>> class AutoNumber(Enum):\n"
"...     def __new__(cls):\n"
"...         value = len(cls.__members__) + 1\n"
"...         obj = object.__new__(cls)\n"
"...         obj._value_ = value\n"
"...         return obj\n"
"...\n"
">>> class Color(AutoNumber):\n"
"...     RED = ()\n"
"...     GREEN = ()\n"
"...     BLUE = ()\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN: 2>"

#: ../../howto/enum.rst:1372
msgid ""
"To make a more general purpose ``AutoNumber``, add ``*args`` to the "
"signature::"
msgstr "要实现更通用的 ``AutoNumber``，请添加 ``*args`` 到签名中::"

#: ../../howto/enum.rst:1374
msgid ""
">>> class AutoNumber(Enum):\n"
"...     def __new__(cls, *args):      # this is the only change from above\n"
"...         value = len(cls.__members__) + 1\n"
"...         obj = object.__new__(cls)\n"
"...         obj._value_ = value\n"
"...         return obj\n"
"..."
msgstr ""
">>> class AutoNumber(Enum):\n"
"...     def __new__(cls, *args):      # 这是相比上面的唯一改变\n"
"...         value = len(cls.__members__) + 1\n"
"...         obj = object.__new__(cls)\n"
"...         obj._value_ = value\n"
"...         return obj\n"
"..."

#: ../../howto/enum.rst:1382
msgid ""
"Then when you inherit from ``AutoNumber`` you can write your own "
"``__init__`` to handle any extra arguments::"
msgstr "这样当你从 ``AutoNumber`` 继承时你将可以编写你自己的 ``__init__`` 来处理任何附加参数::"

#: ../../howto/enum.rst:1385
msgid ""
">>> class Swatch(AutoNumber):\n"
"...     def __init__(self, pantone='unknown'):\n"
"...         self.pantone = pantone\n"
"...     AUBURN = '3497'\n"
"...     SEA_GREEN = '1246'\n"
"...     BLEACHED_CORAL = () # New color, no Pantone code yet!\n"
"...\n"
">>> Swatch.SEA_GREEN\n"
"<Swatch.SEA_GREEN: 2>\n"
">>> Swatch.SEA_GREEN.pantone\n"
"'1246'\n"
">>> Swatch.BLEACHED_CORAL.pantone\n"
"'unknown'"
msgstr ""
">>> class Swatch(AutoNumber):\n"
"...     def __init__(self, pantone='unknown'):\n"
"...         self.pantone = pantone\n"
"...     AUBURN = '3497'\n"
"...     SEA_GREEN = '1246'\n"
"...     BLEACHED_CORAL = () # 新的颜色，还没有 Pantone 代码！\n"
"...\n"
">>> Swatch.SEA_GREEN\n"
"<Swatch.SEA_GREEN: 2>\n"
">>> Swatch.SEA_GREEN.pantone\n"
"'1246'\n"
">>> Swatch.BLEACHED_CORAL.pantone\n"
"'unknown'"

#: ../../howto/enum.rst:1401
msgid ""
"The :meth:`~object.__new__` method, if defined, is used during creation of "
"the Enum members; it is then replaced by Enum's :meth:`~object.__new__` "
"which is used after class creation for lookup of existing members."
msgstr ""
"如果定义了 :meth:`~object.__new__` 方法，它会在创建 Enum 成员期间被使用；随后它将被 Enum 的 "
":meth:`~object.__new__` 所替换，该方法会在类创建后被用来查找现有成员。"

#: ../../howto/enum.rst:1407
msgid ""
"*Do not* call ``super().__new__()``, as the lookup-only ``__new__`` is the "
"one that is found; instead, use the data type directly -- e.g.::"
msgstr ""
"*不要* 调用 ``super().__new__()``，因为只能找到仅用于查找的 ``__new__``；请改为直接使用该数据类型 -- 例如::"

#: ../../howto/enum.rst:1410
msgid "obj = int.__new__(cls, value)"
msgstr "obj = int.__new__(cls, value)"

#: ../../howto/enum.rst:1414
msgid "OrderedEnum"
msgstr "OrderedEnum"

#: ../../howto/enum.rst:1416
msgid ""
"An ordered enumeration that is not based on :class:`IntEnum` and so "
"maintains the normal :class:`Enum` invariants (such as not being comparable "
"to other enumerations)::"
msgstr ""
"一个有序枚举，它不是基于 :class:`IntEnum`，因此保持了正常的 :class:`Enum` 不变特性（例如不可与其他枚举进行比较）::"

#: ../../howto/enum.rst:1420
msgid ""
">>> class OrderedEnum(Enum):\n"
"...     def __ge__(self, other):\n"
"...         if self.__class__ is other.__class__:\n"
"...             return self.value >= other.value\n"
"...         return NotImplemented\n"
"...     def __gt__(self, other):\n"
"...         if self.__class__ is other.__class__:\n"
"...             return self.value > other.value\n"
"...         return NotImplemented\n"
"...     def __le__(self, other):\n"
"...         if self.__class__ is other.__class__:\n"
"...             return self.value <= other.value\n"
"...         return NotImplemented\n"
"...     def __lt__(self, other):\n"
"...         if self.__class__ is other.__class__:\n"
"...             return self.value < other.value\n"
"...         return NotImplemented\n"
"...\n"
">>> class Grade(OrderedEnum):\n"
"...     A = 5\n"
"...     B = 4\n"
"...     C = 3\n"
"...     D = 2\n"
"...     F = 1\n"
"...\n"
">>> Grade.C < Grade.A\n"
"True"
msgstr ""
">>> class OrderedEnum(Enum):\n"
"...     def __ge__(self, other):\n"
"...         if self.__class__ is other.__class__:\n"
"...             return self.value >= other.value\n"
"...         return NotImplemented\n"
"...     def __gt__(self, other):\n"
"...         if self.__class__ is other.__class__:\n"
"...             return self.value > other.value\n"
"...         return NotImplemented\n"
"...     def __le__(self, other):\n"
"...         if self.__class__ is other.__class__:\n"
"...             return self.value <= other.value\n"
"...         return NotImplemented\n"
"...     def __lt__(self, other):\n"
"...         if self.__class__ is other.__class__:\n"
"...             return self.value < other.value\n"
"...         return NotImplemented\n"
"...\n"
">>> class Grade(OrderedEnum):\n"
"...     A = 5\n"
"...     B = 4\n"
"...     C = 3\n"
"...     D = 2\n"
"...     F = 1\n"
"...\n"
">>> Grade.C < Grade.A\n"
"True"

#: ../../howto/enum.rst:1450
msgid "DuplicateFreeEnum"
msgstr "DuplicateFreeEnum"

#: ../../howto/enum.rst:1452
msgid ""
"Raises an error if a duplicate member value is found instead of creating an "
"alias::"
msgstr "如果发现重复的成员名称则会引发一个错误而不是创建一个别名::"

#: ../../howto/enum.rst:1455
msgid ""
">>> class DuplicateFreeEnum(Enum):\n"
"...     def __init__(self, *args):\n"
"...         cls = self.__class__\n"
"...         if any(self.value == e.value for e in cls):\n"
"...             a = self.name\n"
"...             e = cls(self.value).name\n"
"...             raise ValueError(\n"
"...                 \"aliases not allowed in DuplicateFreeEnum:  %r --> %r\"\n"
"...                 % (a, e))\n"
"...\n"
">>> class Color(DuplicateFreeEnum):\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...     BLUE = 3\n"
"...     GRENE = 2\n"
"...\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ValueError: aliases not allowed in DuplicateFreeEnum:  'GRENE' --> 'GREEN'"
msgstr ""
">>> class DuplicateFreeEnum(Enum):\n"
"...     def __init__(self, *args):\n"
"...         cls = self.__class__\n"
"...         if any(self.value == e.value for e in cls):\n"
"...             a = self.name\n"
"...             e = cls(self.value).name\n"
"...             raise ValueError(\n"
"...                 \"aliases not allowed in DuplicateFreeEnum:  %r --> %r\"\n"
"...                 % (a, e))\n"
"...\n"
">>> class Color(DuplicateFreeEnum):\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...     BLUE = 3\n"
"...     GRENE = 2\n"
"...\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ValueError: aliases not allowed in DuplicateFreeEnum:  'GRENE' --> 'GREEN'"

#: ../../howto/enum.rst:1477
msgid ""
"This is a useful example for subclassing Enum to add or change other "
"behaviors as well as disallowing aliases.  If the only desired change is "
"disallowing aliases, the :func:`unique` decorator can be used instead."
msgstr ""
"这个例子适用于子类化 Enum 来添加或改变禁用别名以及其他行为。 如果需要的改变只是禁用别名，也可以选择使用 :func:`unique` 装饰器。"

#: ../../howto/enum.rst:1483
msgid "MultiValueEnum"
msgstr "MultiValueEnum"

#: ../../howto/enum.rst:1485
msgid "Supports having more than one value per member::"
msgstr "支持每个成员有多个值::"

#: ../../howto/enum.rst:1487
msgid ""
">>> class MultiValueEnum(Enum):\n"
"...     def __new__(cls, value, *values):\n"
"...         self = object.__new__(cls)\n"
"...         self._value_ = value\n"
"...         for v in values:\n"
"...             self._add_value_alias_(v)\n"
"...         return self\n"
"...\n"
">>> class DType(MultiValueEnum):\n"
"...     float32 = 'f', 8\n"
"...     double64 = 'd', 9\n"
"...\n"
">>> DType('f')\n"
"<DType.float32: 'f'>\n"
">>> DType(9)\n"
"<DType.double64: 'd'>"
msgstr ""
">>> class MultiValueEnum(Enum):\n"
"...     def __new__(cls, value, *values):\n"
"...         self = object.__new__(cls)\n"
"...         self._value_ = value\n"
"...         for v in values:\n"
"...             self._add_value_alias_(v)\n"
"...         return self\n"
"...\n"
">>> class DType(MultiValueEnum):\n"
"...     float32 = 'f', 8\n"
"...     double64 = 'd', 9\n"
"...\n"
">>> DType('f')\n"
"<DType.float32: 'f'>\n"
">>> DType(9)\n"
"<DType.double64: 'd'>"

#: ../../howto/enum.rst:1506
msgid "Planet"
msgstr "Planet"

#: ../../howto/enum.rst:1508
msgid ""
"If :meth:`~object.__new__` or :meth:`~object.__init__` is defined, the value"
" of the enum member will be passed to those methods::"
msgstr ""
"如果定义了 :meth:`~object.__new__` 或 :meth:`~object.__init__`，则枚举成员的值将被传给这些方法::"

#: ../../howto/enum.rst:1511
msgid ""
">>> class Planet(Enum):\n"
"...     MERCURY = (3.303e+23, 2.4397e6)\n"
"...     VENUS   = (4.869e+24, 6.0518e6)\n"
"...     EARTH   = (5.976e+24, 6.37814e6)\n"
"...     MARS    = (6.421e+23, 3.3972e6)\n"
"...     JUPITER = (1.9e+27,   7.1492e7)\n"
"...     SATURN  = (5.688e+26, 6.0268e7)\n"
"...     URANUS  = (8.686e+25, 2.5559e7)\n"
"...     NEPTUNE = (1.024e+26, 2.4746e7)\n"
"...     def __init__(self, mass, radius):\n"
"...         self.mass = mass       # in kilograms\n"
"...         self.radius = radius   # in meters\n"
"...     @property\n"
"...     def surface_gravity(self):\n"
"...         # universal gravitational constant  (m3 kg-1 s-2)\n"
"...         G = 6.67300E-11\n"
"...         return G * self.mass / (self.radius * self.radius)\n"
"...\n"
">>> Planet.EARTH.value\n"
"(5.976e+24, 6378140.0)\n"
">>> Planet.EARTH.surface_gravity\n"
"9.802652743337129"
msgstr ""
">>> class Planet(Enum):\n"
"...     MERCURY = (3.303e+23, 2.4397e6)\n"
"...     VENUS   = (4.869e+24, 6.0518e6)\n"
"...     EARTH   = (5.976e+24, 6.37814e6)\n"
"...     MARS    = (6.421e+23, 3.3972e6)\n"
"...     JUPITER = (1.9e+27,   7.1492e7)\n"
"...     SATURN  = (5.688e+26, 6.0268e7)\n"
"...     URANUS  = (8.686e+25, 2.5559e7)\n"
"...     NEPTUNE = (1.024e+26, 2.4746e7)\n"
"...     def __init__(self, mass, radius):\n"
"...         self.mass = mass       # in kilograms\n"
"...         self.radius = radius   # in meters\n"
"...     @property\n"
"...     def surface_gravity(self):\n"
"...         # universal gravitational constant  (m3 kg-1 s-2)\n"
"...         G = 6.67300E-11\n"
"...         return G * self.mass / (self.radius * self.radius)\n"
"...\n"
">>> Planet.EARTH.value\n"
"(5.976e+24, 6378140.0)\n"
">>> Planet.EARTH.surface_gravity\n"
"9.802652743337129"

#: ../../howto/enum.rst:1537
msgid "TimePeriod"
msgstr "TimePeriod"

#: ../../howto/enum.rst:1539
msgid "An example to show the :attr:`~Enum._ignore_` attribute in use::"
msgstr "一个演示如何使用 :attr:`~Enum._ignore_` 属性的例子::"

#: ../../howto/enum.rst:1541
msgid ""
">>> from datetime import timedelta\n"
">>> class Period(timedelta, Enum):\n"
"...     \"different lengths of time\"\n"
"...     _ignore_ = 'Period i'\n"
"...     Period = vars()\n"
"...     for i in range(367):\n"
"...         Period['day_%d' % i] = i\n"
"...\n"
">>> list(Period)[:2]\n"
"[<Period.day_0: datetime.timedelta(0)>, <Period.day_1: datetime.timedelta(days=1)>]\n"
">>> list(Period)[-2:]\n"
"[<Period.day_365: datetime.timedelta(days=365)>, <Period.day_366: datetime.timedelta(days=366)>]"
msgstr ""
">>> from datetime import timedelta\n"
">>> class Period(timedelta, Enum):\n"
"...     \"different lengths of time\"\n"
"...     _ignore_ = 'Period i'\n"
"...     Period = vars()\n"
"...     for i in range(367):\n"
"...         Period['day_%d' % i] = i\n"
"...\n"
">>> list(Period)[:2]\n"
"[<Period.day_0: datetime.timedelta(0)>, <Period.day_1: datetime.timedelta(days=1)>]\n"
">>> list(Period)[-2:]\n"
"[<Period.day_365: datetime.timedelta(days=365)>, <Period.day_366: datetime.timedelta(days=366)>]"

#: ../../howto/enum.rst:1558
msgid "Subclassing EnumType"
msgstr "子类化 EnumType"

#: ../../howto/enum.rst:1560
msgid ""
"While most enum needs can be met by customizing :class:`Enum` subclasses, "
"either with class decorators or custom functions, :class:`EnumType` can be "
"subclassed to provide a different Enum experience."
msgstr ""
"虽然大多数枚举需求可以通过自定义 :class:`Enum` 子类来满足，无论是用类装饰器还是自定义函数，:class:`EnumType` "
"可以被子类化以提供不同的枚举体验。"
