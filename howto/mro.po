# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# 乐成 王, 2024
# Freesand Leo <yuqinju@163.com>, 2024
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-04-26 14:13+0000\n"
"PO-Revision-Date: 2024-04-19 14:15+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2024\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/mro.rst:4
msgid "The Python 2.3 Method Resolution Order"
msgstr "Python 2.3 方法解析顺序"

#: ../../howto/mro.rst:8
msgid ""
"This is a historical document, provided as an appendix to the official "
"documentation. The Method Resolution Order discussed here was *introduced* "
"in Python 2.3, but it is still used in later versions -- including Python 3."
msgstr ""
"这是一份历史性的文档，作为官方文档的附录提供。 这里所讨论的方法解析顺序在 Python 2.3 中 *被引入*，但在之后的版本中仍然被使用 -- 包括"
" Python 3。"

#: ../../howto/mro.rst:13
msgid "By `Michele Simionato <https://www.phyast.pitt.edu/~micheles/>`__."
msgstr "由 `Michele Simionato <https://www.phyast.pitt.edu/~micheles/>`__ 撰写。"

#: ../../howto/mro.rst:0
msgid "Abstract"
msgstr "摘要"

#: ../../howto/mro.rst:17
msgid ""
"*This document is intended for Python programmers who want to understand the"
" C3 Method Resolution Order used in Python 2.3. Although it is not intended "
"for newbies, it is quite pedagogical with many worked out examples.  I am "
"not aware of other publicly available documents with the same scope, "
"therefore it should be useful.*"
msgstr ""
"*本文档的目标读者是那些希望理解 Python 2.3 中使用的 C3 方法解析顺序的 Python 程序员。 "
"虽然它不是为新手准备的，但它具有很强的教学性，包含许多实用的例子。 据我所知还没有其他公开文档涵盖相同的领域，因此它应该是有用的。*"

#: ../../howto/mro.rst:23
msgid "Disclaimer:"
msgstr "免责声明："

#: ../../howto/mro.rst:25
msgid ""
"*I donate this document to the Python Software Foundation, under the Python "
"2.3 license.  As usual in these circumstances, I warn the reader that what "
"follows* should *be correct, but I don't give any warranty.  Use it at your "
"own risk and peril!*"
msgstr ""
"*我将此文档捐赠给 Python 软件基金会，采用 Python 2.3 许可。 如在这种情况下通常做法，我警示读者下面的内容* 应该 "
"*是正确的，但我不提供任何保证。 请自行承担使用风险与损害！*"

#: ../../howto/mro.rst:30
msgid "Acknowledgments:"
msgstr "致谢："

#: ../../howto/mro.rst:32
msgid ""
"*All the people of the Python mailing list who sent me their support. Paul "
"Foley who pointed out various imprecisions and made me to add the part on "
"local precedence ordering. David Goodger for help with the formatting in "
"reStructuredText. David Mertz for help with the editing. Finally, Guido van "
"Rossum who enthusiastically added this document to the official Python 2.3 "
"home-page.*"
msgstr ""
"*Python 邮件列表中所有对我表示支持的人。 Paul Foley，他指出了各种不精确之处并让我添加了本地优先排序的部分。 David "
"Goodger 在 reStructuredText 格式化方面的帮助。David Mertz 在编辑方面提供的帮助。 最后，Guido van "
"Rossum 热心地将本文档添加到官方 Python 2.3 主页。*"

#: ../../howto/mro.rst:40
msgid "The beginning"
msgstr "开始"

#: ../../howto/mro.rst:42
msgid "*Felix qui potuit rerum cognoscere causas* -- Virgilius"
msgstr "*Felix qui potuit rerum cognoscere causas* -- Virgilius"

#: ../../howto/mro.rst:44
msgid ""
"Everything started with a post by Samuele Pedroni to the Python development "
"mailing list [#]_.  In his post, Samuele showed that the Python 2.2 method "
"resolution order is not monotonic and he proposed to replace it with the C3 "
"method resolution order.  Guido agreed with his arguments and therefore now "
"Python 2.3 uses C3.  The C3 method itself has nothing to do with Python, "
"since it was invented by people working on Dylan and it is described in a "
"paper intended for lispers [#]_.  The present paper gives a (hopefully) "
"readable discussion of the C3 algorithm for Pythonistas who want to "
"understand the reasons for the change."
msgstr ""
"事情开始于 Samuele Pedroni 在 Python 开发邮件列表上的一个帖子 [#]_。 在他的帖子里，Samuele 表示 Python "
"2.2 方法解析顺序不是单调的并提议用 C3 方法解析顺序来替代它。 Guido 认同他的意见因此现在 Python 2.3 使用了 C3。 C3 "
"方法本身与 Python 没有关系，因为它由使用 Dylan 的人发明并在一篇针对 lisp 程序员的论文中描述 [#]_。 "
"本文给出了面向希望理解这项改变的理由的 Python 使用者的（尽可能）易读的 C3 算法相关讨论。"

#: ../../howto/mro.rst:55
msgid ""
"First of all, let me point out that what I am going to say only applies to "
"the *new style classes* introduced in Python 2.2:  *classic classes* "
"maintain their old method resolution order, depth first and then left to "
"right.  Therefore, there is no breaking of old code for classic classes; and"
" even if in principle there could be breaking of code for Python 2.2 new "
"style classes, in practice the cases in which the C3 resolution order "
"differs from the Python 2.2 method resolution order are so rare that no real"
" breaking of code is expected.  Therefore:"
msgstr ""
"首先，我要指出我即将介绍的情况仅作用于在 Python 2.2 中引入的 *新式类*: *经典类* 将保持其原有的方法解析顺序，深度优先并且从左至右。 "
"因此，不存在对经典类原有代码的破坏；而且虽然在原理上存在对 Python 2.2 新式类代码的破坏，但在实践中 C3 解析顺序与 Python 2.2 "
"方法解析顺序存在不同的情况是如此稀少以至于不会真正破坏原有代码。 所以："

#: ../../howto/mro.rst:64
msgid "*Don't be scared!*"
msgstr "*不必害怕！*"

#: ../../howto/mro.rst:66
msgid ""
"Moreover, unless you make strong use of multiple inheritance and you have "
"non-trivial hierarchies, you don't need to understand the C3 algorithm, and "
"you can easily skip this paper.  On the other hand, if you really want to "
"know how multiple inheritance works, then this paper is for you.  The good "
"news is that things are not as complicated as you might expect."
msgstr ""
"此外，除非你高强度地使用多重继承并且有复杂的层级结构，否则你就不需要理解 C3 算法，可以轻松地跳过本文。 "
"另一方面，如果你真的想知道多重继承是如何工作的，那么本文就是为你准备的。 好消息是事情并没有你想象的那么复杂。"

#: ../../howto/mro.rst:73
msgid "Let me begin with some basic definitions."
msgstr "让我们从一些基本的定义开始。"

#: ../../howto/mro.rst:75
msgid ""
"Given a class C in a complicated multiple inheritance hierarchy, it is a "
"non-trivial task to specify the order in which methods are overridden, i.e. "
"to specify the order of the ancestors of C."
msgstr "在一个复杂的多重继承层级结构中给定一个类 C，要指明方法的覆盖顺序，即 C 的祖先的顺序是一项并不轻松的任务。"

#: ../../howto/mro.rst:79
msgid ""
"The list of the ancestors of a class C, including the class itself, ordered "
"from the nearest ancestor to the furthest, is called the class precedence "
"list or the *linearization* of C."
msgstr "类 C 的祖先列表（包括类本身）从最近的祖先到最远的祖先排序，称为类优先级列表或 C 的 *线性化*。"

#: ../../howto/mro.rst:83
msgid ""
"The *Method Resolution Order* (MRO) is the set of rules that construct the "
"linearization.  In the Python literature, the idiom \"the MRO of C\" is also"
" used as a synonymous for the linearization of the class C."
msgstr ""
"*方法解析顺序* (MRO) 是构造线性化的规则集合。 在 Python 的语境中，术语 \"C 的 MRO\" 也会被用作类 C 的线性化的同义词。"

#: ../../howto/mro.rst:88
msgid ""
"For instance, in the case of single inheritance hierarchy, if C is a "
"subclass of C1, and C1 is a subclass of C2, then the linearization of C is "
"simply the list [C, C1 , C2].  However, with multiple inheritance "
"hierarchies, the construction of the linearization is more cumbersome, since"
" it is more difficult to construct a linearization that respects *local "
"precedence ordering* and *monotonicity*."
msgstr ""
"举例来说，在单继承层级结构的情况下，如果 C 是 C1 的子类，而 C1 是 C2 的子类，那么 C 的线性化就是简单的列表 [C, C1 , C2]。"
" 但是，对于多继承层级结构，线性化的构造就比较麻烦了，因为要构造一个尊重 *局部优先级排序* 和 *单调性* 的线性化将更为困难。"

#: ../../howto/mro.rst:96
msgid ""
"I will discuss the local precedence ordering later, but I can give the "
"definition of monotonicity here.  A MRO is monotonic when the following is "
"true:  *if C1 precedes C2 in the linearization of C, then C1 precedes C2 in "
"the linearization of any subclass of C*. Otherwise, the innocuous operation "
"of deriving a new class could change the resolution order of methods, "
"potentially introducing very subtle bugs.  Examples where this happens will "
"be shown later."
msgstr ""
"我稍后会讨论局部优先级顺序问题，但我可以先在这里给出单调性的定义。 当以下情况为真时一个 MRO 就是单调的: *如果在 C 的线性化中 C1 先于 "
"C2，那么在 C 的任何子类的线性化中 C1 都先于 C2*。 "
"在其他情况下，派生新类的无害操作就可能会改变方法的解析顺序，从而可能引入非常微妙的程序错误。 稍后将举例说明这种情况。"

#: ../../howto/mro.rst:104
msgid ""
"Not all classes admit a linearization.  There are cases, in complicated "
"hierarchies, where it is not possible to derive a class such that its "
"linearization respects all the desired properties."
msgstr "并非所有的类都允许线性化。 在复杂的层级结构中，有些情况下不可能派生出一个类使其线性化遵循所有需要的属性。"

#: ../../howto/mro.rst:108
msgid "Here I give an example of this situation. Consider the hierarchy"
msgstr "在此我举一个例子来说明这种情况。 考虑以下层级结构"

#: ../../howto/mro.rst:116
msgid ""
"which can be represented with the following inheritance graph, where I have "
"denoted with O the ``object`` class, which is the beginning of any hierarchy"
" for new style classes:"
msgstr "它可以用以下继承图来表示，其中我用 O 来标记 ``object`` 类，它是任何新式类层级结构的起点："

#: ../../howto/mro.rst:133
msgid ""
"In this case, it is not possible to derive a new class C from A and B, since"
" X precedes Y in A, but Y precedes X in B, therefore the method resolution "
"order would be ambiguous in C."
msgstr ""
"在此情况下，从 A 和 B 派生新类是不可能的，因为在 A 中 X 先于 Y，但在 B 中 Y 先于 X，因此在 C 中方法解析顺序将出现歧义。"

#: ../../howto/mro.rst:137
msgid ""
"Python 2.3 raises an exception in this situation (TypeError:  MRO conflict "
"among bases Y, X) forbidding the naive programmer from creating ambiguous "
"hierarchies.  Python 2.2 instead does not raise an exception, but chooses an"
" *ad hoc* ordering (CABXYO in this case)."
msgstr ""
"Python 2.3 在此情况下会引发异常 (TypeError:  MRO conflict among bases Y, X) "
"以防止程序员在无意中创建有歧义的层级结构。 Python 2.2 不会引发异常，而是会选择一个 *临时* 顺序 (在本例中为 CABXYO)。"

#: ../../howto/mro.rst:143
msgid "The C3 Method Resolution Order"
msgstr "C3 方法解析顺序"

#: ../../howto/mro.rst:145
msgid ""
"Let me introduce a few simple notations which will be useful for the "
"following discussion.  I will use the shortcut notation::"
msgstr "让我们引入一些适用于接下来的讨论的简单标记法。 我会使用这样的快捷标记::"

#: ../../howto/mro.rst:150
msgid "to indicate the list of classes [C1, C2, ... , CN]."
msgstr "来表示类列表 [C1, C2, ... , CN]。"

#: ../../howto/mro.rst:152
msgid "The *head* of the list is its first element::"
msgstr "列表的 *head* 是其第一个元素::"

#: ../../howto/mro.rst:156
msgid "whereas the *tail* is the rest of the list::"
msgstr "而 *tail* 则是列表的其余元素::"

#: ../../howto/mro.rst:160
msgid "I shall also use the notation::"
msgstr "我还将使用这样的标记::"

#: ../../howto/mro.rst:164
msgid "to denote the sum of the lists [C] + [C1, C2, ... ,CN]."
msgstr "来表示列表 [C] + [C1，C2，...，CN] 的总和。"

#: ../../howto/mro.rst:166
msgid "Now I can explain how the MRO works in Python 2.3."
msgstr "现在我就可以解释 MRO 在 Python 2.3 中的工作原理了。"

#: ../../howto/mro.rst:168
msgid ""
"Consider a class C in a multiple inheritance hierarchy, with C inheriting "
"from the base classes B1, B2, ...  , BN.  We want to compute the "
"linearization L[C] of the class C. The rule is the following:"
msgstr "考虑多重继承层级结构中的类 C，C 继承自基类 B1, B2, ... , BN。 我们想要计算类 C 的线性化 L[C]。 规则如下："

#: ../../howto/mro.rst:173
msgid ""
"*the linearization of C is the sum of C plus the merge of the linearizations"
" of the parents and the list of the parents.*"
msgstr "*C 的线性化就是 C 加上父类的线性化和父类列表的执行合并的总和。*"

#: ../../howto/mro.rst:176
msgid "In symbolic notation::"
msgstr "使用符号标记法::"

#: ../../howto/mro.rst:180
msgid ""
"In particular, if C is the ``object`` class, which has no parents, the "
"linearization is trivial::"
msgstr "特别地，如果 C 为 ``object`` 类，它是没有父类的，其线性化很简单::"

#: ../../howto/mro.rst:185
msgid ""
"However, in general one has to compute the merge according to the following "
"prescription:"
msgstr "不过，在通常情况下我们需要根据以下预设规则来计算合并结果："

#: ../../howto/mro.rst:188
msgid ""
"*take the head of the first list, i.e L[B1][0]; if this head is not in the "
"tail of any of the other lists, then add it to the linearization of C and "
"remove it from the lists in the merge, otherwise look at the head of the "
"next list and take it, if it is a good head.  Then repeat the operation "
"until all the class are removed or it is impossible to find good heads.  In "
"this case, it is impossible to construct the merge, Python 2.3 will refuse "
"to create the class C and will raise an exception.*"
msgstr ""
"*取第一个列表的 head，即 L[B1][0]；如果这个 head 不在任何其他列表的 tail 内，则将其添加到 C "
"的线性化中，并在合并结果中将其从列表中移除，否则如果下一个列表的 head 是好的 head 则使用它。 "
"然后重复上述操作直到所有类都被移除或是无法找到好的 head。 在这种情况下将无法构造合并结果，Python 2.3 将拒绝创建类 C 并将引发 "
"异常。*"

#: ../../howto/mro.rst:197
msgid ""
"This prescription ensures that the merge operation *preserves* the ordering,"
" if the ordering can be preserved.  On the other hand, if the order cannot "
"be preserved (as in the example of serious order disagreement discussed "
"above) then the merge cannot be computed."
msgstr ""
"这一预设规则可以确保合并操作 *保留* 顺序，如果顺序能被保留的话。 "
"在另一方面，如果顺序无法被保留（如上文讨论的顺序严重不一致的例子）则无法计算合并结果。"

#: ../../howto/mro.rst:202
msgid ""
"The computation of the merge is trivial if C has only one parent (single "
"inheritance); in this case::"
msgstr "如果 C 只有一个父类（单一继承）则合并结果的计算将很简单；在这种情况下::"

#: ../../howto/mro.rst:207
msgid ""
"However, in the case of multiple inheritance things are more cumbersome and "
"I don't expect you can understand the rule without a couple of examples ;-)"
msgstr "不过，对于多重继承的情况事情就会比较麻烦，如果不举几个例子我估计你是无法理解具体规则的 ;-)"

#: ../../howto/mro.rst:212
msgid "Examples"
msgstr "例子"

#: ../../howto/mro.rst:214
msgid "First example. Consider the following hierarchy:"
msgstr "第一个例子。 考虑以下层级结构："

#: ../../howto/mro.rst:224
msgid "In this case the inheritance graph can be drawn as:"
msgstr "在这种情况下继承图可以绘制为："

#: ../../howto/mro.rst:251
msgid "The linearizations of O,D,E and F are trivial::"
msgstr "O、D、E 和 F 的线性化很简单::"

#: ../../howto/mro.rst:258
msgid "The linearization of B can be computed as::"
msgstr "B 的线性化可以被计算为::"

#: ../../howto/mro.rst:262
msgid ""
"We see that D is a good head, therefore we take it and we are reduced to "
"compute ``merge(O,EO,E)``.  Now O is not a good head, since it is in the "
"tail of the sequence EO.  In this case the rule says that we have to skip to"
" the next sequence.  Then we see that E is a good head; we take it and we "
"are reduced to compute ``merge(O,O)`` which gives O. Therefore::"
msgstr ""
"我们看到 D 是一个好的 head，因此我们使用它这样就可以简化为计算 ``merge(O,EO,E)``。 现在 O 不是一个好的 "
"head，因为它在序列 EO 的 tail 内。 在这种情况下规则要求我们必须跳到下一个序列。 然后我们可以看到 E 是一个好的 "
"head；我们使用它这样就可以简化为计算 ``merge(O,O)`` 从而得到 O。 因此::"

#: ../../howto/mro.rst:270
msgid "Using the same procedure one finds::"
msgstr "使用同样的步骤我们将发现::"

#: ../../howto/mro.rst:277
msgid "Now we can compute::"
msgstr "现在我们可以计算::"

#: ../../howto/mro.rst:287
msgid ""
"In this example, the linearization is ordered in a pretty nice way according"
" to the inheritance level, in the sense that lower levels (i.e. more "
"specialized classes) have higher precedence (see the inheritance graph).  "
"However, this is not the general case."
msgstr "在这个例子中，线性化按照继承级别进行了良好的排序，即级别越低（即更特化的类）优先级越高（见继承图）。 然而，这并不是一般的情况。"

#: ../../howto/mro.rst:292
msgid ""
"I leave as an exercise for the reader to compute the linearization for my "
"second example:"
msgstr "我把计算第二个例子的线性化作为一个练习留给读者完成："

#: ../../howto/mro.rst:303
msgid ""
"The only difference with the previous example is the change B(D,E) --> "
"B(E,D); however even such a little modification completely changes the "
"ordering of the hierarchy:"
msgstr "与前一例子的唯一区别在于 B(D,E) --> B(E,D)；然而即使是这样一个小小的改动也完全改变了层级结构的顺序："

#: ../../howto/mro.rst:332
msgid ""
"Notice that the class E, which is in the second level of the hierarchy, "
"precedes the class C, which is in the first level of the hierarchy, i.e. E "
"is more specialized than C, even if it is in a higher level."
msgstr "请注意处在层级结构第二层级的类 E，它先于处在层级结构第一层级的类 C，也就是说，E 比 C 更特化，即便它处在更高的层级。"

#: ../../howto/mro.rst:336
msgid ""
"A lazy programmer can obtain the MRO directly from Python 2.2, since in this"
" case it coincides with the Python 2.3 linearization.  It is enough to "
"invoke the .mro() method of class A:"
msgstr ""
"懒惰的程序员可以直接获取 Python 2.2 的 MRO，因为在这种情况下它与 Python 2.3 的线性化相吻合。 只需发起调用类 A 的 "
".mro() 方法即可："

#: ../../howto/mro.rst:345
msgid ""
"Finally, let me consider the example discussed in the first section, "
"involving a serious order disagreement.  In this case, it is straightforward"
" to compute the linearizations of O, X, Y, A and B:"
msgstr "最后，让我来讲解第一小节所讨论的例子，其中涉及严重的顺序不一致问题。 在这种情况下，可以直接计算 O、X、Y、A 和 B 的线性化："

#: ../../howto/mro.rst:357
msgid ""
"However, it is impossible to compute the linearization for a class C that "
"inherits from A and B::"
msgstr "然而，要计算继承自 A 和 B 的类 C 的线性化则是不可能的::"

#: ../../howto/mro.rst:364
msgid ""
"At this point we cannot merge the lists XYO and YXO, since X is in the tail "
"of YXO whereas Y is in the tail of XYO:  therefore there are no good heads "
"and the C3 algorithm stops.  Python 2.3 raises an error and refuses to "
"create the class C."
msgstr ""
"此时我们无法合并列表 XYO 和 YXO，因为 X 在 YXO 的 tail 内，而 Y 在 XYO 的 tail 内：因此没有好的 head 从而 "
"C3 算法将停止。 Python 2.3 将引发一个错误并拒绝创建类 C。"

#: ../../howto/mro.rst:370
msgid "Bad Method Resolution Orders"
msgstr "坏的方法解析顺序"

#: ../../howto/mro.rst:372
msgid ""
"A MRO is *bad* when it breaks such fundamental properties as local "
"precedence ordering and monotonicity.  In this section, I will show that "
"both the MRO for classic classes and the MRO for new style classes in Python"
" 2.2 are bad."
msgstr ""
"当一个 MOR 破坏了诸如局部优先顺序和单调性等基本属性时它就是 *坏的*。 在本节中，我将证明 Python 2.2 中经典类的 MRO 和新式类的 "
"MRO 都是坏的。"

#: ../../howto/mro.rst:377
msgid ""
"It is easier to start with the local precedence ordering.  Consider the "
"following example:"
msgstr "从局部优先顺序开始会更简单。 请看下面的例子："

#: ../../howto/mro.rst:384
msgid "with inheritance diagram"
msgstr "继承图如下"

#: ../../howto/mro.rst:399
msgid ""
"We see that class G inherits from F and E, with F *before* E:  therefore we "
"would expect the attribute *G.remember2buy* to be inherited by "
"*F.rembermer2buy* and not by *E.remember2buy*:  nevertheless Python 2.2 "
"gives"
msgstr ""
"我们看到类 G 继承自 F 和 E，其中 F *先于* E：因此我们预期属性 *G.remember2buy* 会被 *F.rembermer2buy*"
" 而不是被 *E.remember2buy* 继承：然而 Python 2.2 给出的结果是"

#: ../../howto/mro.rst:407
msgid ""
"This is a breaking of local precedence ordering since the order in the local"
" precedence list, i.e. the list of the parents of G, is not preserved in the"
" Python 2.2 linearization of G::"
msgstr "这是对局部优先顺序的破坏因为在 Python 2.2 对 G 进行线性化时，局部优先列表即 G 的父类列表中的顺序并不会被保留::"

#: ../../howto/mro.rst:413
msgid ""
"One could argue that the reason why F follows E in the Python 2.2 "
"linearization is that F is less specialized than E, since F is the "
"superclass of E; nevertheless the breaking of local precedence ordering is "
"quite non-intuitive and error prone.  This is particularly true since it is "
"a different from old style classes:"
msgstr ""
"有人可能会说在 Python 2.2 的线性化中 F 在 E 之后的原因是 F 的特化程度低于 E，因为 F 是 E "
"的超类；然而打破局部优先排序是相当反直觉且容易导致错误的。 这一点因为它与旧式类不同而尤其明显："

#: ../../howto/mro.rst:425
msgid ""
"In this case the MRO is GFEF and the local precedence ordering is preserved."
msgstr "在这种情况下 MRO 为 GFEF 并保留了局部优先顺序。"

#: ../../howto/mro.rst:428
msgid ""
"As a general rule, hierarchies such as the previous one should be avoided, "
"since it is unclear if F should override E or viceversa. Python 2.3 solves "
"the ambiguity by raising an exception in the creation of class G, "
"effectively stopping the programmer from generating ambiguous hierarchies.  "
"The reason for that is that the C3 algorithm fails when the merge::"
msgstr ""
"作为一般规则，应该避免像前面这样的层级结构，因为不清楚 F 是否应该重写 E，反之亦然。 Python 2.3 在创建类 G "
"时通过引发异常解决了这种歧义性问题，有效阻止了程序员生成有歧义的层级结构。 其原因是 C3 算法在执行以下合并时将失败::"

#: ../../howto/mro.rst:437
msgid ""
"cannot be computed, because F is in the tail of EFO and E is in the tail of "
"FE."
msgstr "这是无法计算的，因为 F 在 EFO 的 tail 内而 E 在 FE 的 tail 内。"

#: ../../howto/mro.rst:440
msgid ""
"The real solution is to design a non-ambiguous hierarchy, i.e. to derive G "
"from E and F (the more specific first) and not from F and E; in this case "
"the MRO is GEF without any doubt."
msgstr ""
"真正的解决办法是设计一个无歧义的层级结构，即从 E 和 F（更具体的说是第一个）而不是从 F 和 E 派生出 G；在这种情况下 MRO 毫无疑问就是 "
"GEF。"

#: ../../howto/mro.rst:456
msgid ""
"Python 2.3 forces the programmer to write good hierarchies (or, at least, "
"less error-prone ones)."
msgstr "Python 2.3 会强迫程序员编写好的（或者，至少不那么容易出错的）层级结构。"

#: ../../howto/mro.rst:459
msgid ""
"On a related note, let me point out that the Python 2.3 algorithm is smart "
"enough to recognize obvious mistakes, as the duplication of classes in the "
"list of parents:"
msgstr "与此相关的一点，我要指出 Python 2.3 的算法足够聪明，它能识别明显的错误，比如父类列表中重复的类："

#: ../../howto/mro.rst:469
msgid ""
"Python 2.2 (both for classic classes and new style classes) in this "
"situation, would not raise any exception."
msgstr "在这种情况下，Python 2.2（包括经典类和新式类）则不会引发任何异常。"

#: ../../howto/mro.rst:472
msgid ""
"Finally, I would like to point out two lessons we have learned from this "
"example:"
msgstr "最后，我想指出我们从这个例子中汲取的两点教训："

#: ../../howto/mro.rst:475
msgid ""
"despite the name, the MRO determines the resolution order of attributes, not"
" only of methods;"
msgstr "尽管名称如此，MRO 是决定属性的解析顺序，而不仅仅是方法的解析顺序；"

#: ../../howto/mro.rst:478
msgid ""
"the default food for Pythonistas is spam !  (but you already knew that ;-)"
msgstr "Python 爱好者的默认食物是 spam !  (不过你已经知道这一点了 ;-)"

#: ../../howto/mro.rst:481
msgid ""
"Having discussed the issue of local precedence ordering, let me now consider"
" the issue of monotonicity.  My goal is to show that neither the MRO for "
"classic classes nor that for Python 2.2 new style classes is monotonic."
msgstr "在讨论了局部优先顺序问题之后，现在再让我来讲解单调性。 我的目标是证明经典类和 Python 2.2 新式类的 MRO 都不是单调的。"

#: ../../howto/mro.rst:486
msgid ""
"To prove that the MRO for classic classes is non-monotonic is rather "
"trivial, it is enough to look at the diamond diagram:"
msgstr "要证明经典类的 MRO 是非单调的相当简单，只要看一下这个钻石形图就够了："

#: ../../howto/mro.rst:500
msgid "One easily discerns the inconsistency::"
msgstr "人们很容易发现其中的不一致性::"

#: ../../howto/mro.rst:505
msgid ""
"On the other hand, there are no problems with the Python 2.2 and 2.3 MROs, "
"they give both::"
msgstr "另一方面，Python 2.2 和 Python 2.3 的 MRO 则没有问题，它们都将给出以下结果::"

#: ../../howto/mro.rst:510
msgid ""
"Guido points out in his essay [#]_ that the classic MRO is not so bad in "
"practice, since one can typically avoids diamonds for classic classes. But "
"all new style classes inherit from ``object``, therefore diamonds are "
"unavoidable and inconsistencies shows up in every multiple inheritance "
"graph."
msgstr ""
"Guido 在他的文章 [#]_ 中指出经典的 MRO 在实践中并没有那么坏，因为人们通常可以避免经典类形成钻石形继承图。 但是所有新式类都继承自 "
"``object``，因此钻石形继承图是不可避免的并且在每个多重继承图中都会出现不一致性。"

#: ../../howto/mro.rst:516
msgid ""
"The MRO of Python 2.2 makes breaking monotonicity difficult, but not "
"impossible.  The following example, originally provided by Samuele Pedroni, "
"shows that the MRO of Python 2.2 is non-monotonic:"
msgstr ""
"Python 2.2 的 MRO 使打破单调性变得困难，但并非不可能。 下面是最初由 Samuele Pedroni 提供的例子，显示 Python "
"2.2 的 MRO 是非单调的："

#: ../../howto/mro.rst:530
msgid ""
"Here are the linearizations according to the C3 MRO (the reader should "
"verify these linearizations as an exercise and draw the inheritance diagram "
";-) ::"
msgstr "以下是根据 C3 MRO 进行的线性化 (读者应当将验证这些线性化作为练习并绘制继承图 ;-) ::"

#: ../../howto/mro.rst:544
msgid ""
"Python 2.2 gives exactly the same linearizations for A, B, C, D, E, K1, K2 "
"and K3, but a different linearization for Z::"
msgstr "Python 2.2 对 A、B、C、D、E、K1、K2 和 K3 给出了完全相同的线性化，但对 Z 则给出了不同的线性化::"

#: ../../howto/mro.rst:549
msgid ""
"It is clear that this linearization is *wrong*, since A comes before D "
"whereas in the linearization of K3 A comes *after* D. In other words, in K3 "
"methods derived by D override methods derived by A, but in Z, which still is"
" a subclass of K3, methods derived by A override methods derived by D!  This"
" is a violation of monotonicity.  Moreover, the Python 2.2 linearization of "
"Z is also inconsistent with local precedence ordering, since the local "
"precedence list of the class Z is [K1, K2, K3] (K2 precedes K3), whereas in "
"the linearization of Z K2 *follows* K3.  These problems explain why the 2.2 "
"rule has been dismissed in favor of the C3 rule."
msgstr ""
"很明显这种线性化是 *错误* 的，因为 A 在 D 之前，而在 K3 的线性化中 A 在 D 之后。 换句话说，在 K3 中由 D 派生的方法会重写由 "
"A 派生的方法，但在仍为 K3 子类的 Z 中，由 A 派生的方法会重写由 D 派生的方法！ 这破坏了单调性。 此外，Z 的 Python 2.2 "
"线性化也与局部优先顺序不一致，因为类 Z 的局部优先列表是 [K1, K2, K3] (K2 先于 K3)，而在 Z 的线性化中则是 K2 *跟随* "
"K3。 这些问题解释了为什么 2.2 规则被否定而改用 C3 规则。"

#: ../../howto/mro.rst:561
msgid "The end"
msgstr "结束"

#: ../../howto/mro.rst:563
msgid ""
"This section is for the impatient reader, who skipped all the previous "
"sections and jumped immediately to the end.  This section is for the lazy "
"programmer too, who didn't want to exercise her/his brain. Finally, it is "
"for the programmer with some hubris, otherwise s/he would not be reading a "
"paper on the C3 method resolution order in multiple inheritance hierarchies "
";-) These three virtues taken all together (and *not* separately) deserve a "
"prize:  the prize is a short Python 2.2 script that allows you to compute "
"the 2.3 MRO without risk to your brain.  Simply change the last line to play"
" with the various examples I have discussed in this paper.::"
msgstr ""
"本节是为没有耐心的读者准备的，他们会跳过前面的所有章节，直接跳到结尾。 这部分也是为懒惰的程序员准备的，因为他们不想动脑筋。 "
"最后，这部分也是为有些自负的程序员准备的，否则他/她就不会去阅读一篇关于多重继承层次结构中的 C3 方法解析顺序的论文了 ;-) 这三个优点合在一起（而"
" *不是* 分开）应该得到一个奖励：这个奖励就是一个简短的 Python 2.2 脚本，它可以在不影响你的大脑的情况下计算 2.3 MRO。 "
"只需修改最后一行就可以尝试我在本文中讨论的各种示例::"

#: ../../howto/mro.rst:656
msgid "That's all folks,"
msgstr "就是这样了朋友们，"

#: ../../howto/mro.rst:658
msgid "enjoy !"
msgstr "好好享受吧！"

#: ../../howto/mro.rst:662
msgid "Resources"
msgstr "参考资源"

#: ../../howto/mro.rst:664
msgid ""
"The thread on python-dev started by Samuele Pedroni: "
"https://mail.python.org/pipermail/python-dev/2002-October/029035.html"
msgstr ""
"由 Samuele Pedroni 在 python-dev 发起的讨论: "
"https://mail.python.org/pipermail/python-dev/2002-October/029035.html"

#: ../../howto/mro.rst:667
msgid ""
"The paper *A Monotonic Superclass Linearization for Dylan*: "
"https://doi.org/10.1145/236337.236343"
msgstr ""
"论文 *A Monotonic Superclass Linearization for Dylan*: "
"https://doi.org/10.1145/236337.236343"

#: ../../howto/mro.rst:670
msgid ""
"Guido van Rossum's essay, *Unifying types and classes in Python 2.2*: "
"https://web.archive.org/web/20140210194412/http://www.python.org/download/releases/2.2.2/descrintro"
msgstr ""
"Guido van Rossum 的文章，*Unifying types and classes in Python 2.2*: "
"https://web.archive.org/web/20140210194412/http://www.python.org/download/releases/2.2.2/descrintro"
