# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# banxi <banxi1988@gmail.com>, 2021
# ww song <sww4718168@gmail.com>, 2021
# df2dc1c92e792f7ae8417c51df43db8f_594d92a <0f49be28017426edb1db1a2ab6e67088_717605>, 2021
# ppcfish <ppcfish@gmail.com>, 2021
# WH-2099 <wh2099@outlook.com>, 2021
# lian Wu (Wulian) <xiguawulian@gmail.com>, 2024
# Zhikang Yan <2951256653@qq.com>, 2024
# Freesand Leo <yuqinju@163.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-08 02:53-0300\n"
"PO-Revision-Date: 2021-06-28 00:53+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/descriptor.rst:5
msgid "Descriptor Guide"
msgstr "描述器指南"

#: ../../howto/descriptor.rst:0
msgid "Author"
msgstr "作者"

#: ../../howto/descriptor.rst:7
msgid "Raymond Hettinger"
msgstr "Raymond Hettinger（译者：wh2099 at outlook dot com）"

#: ../../howto/descriptor.rst:0
msgid "Contact"
msgstr "联系方式"

#: ../../howto/descriptor.rst:8
msgid "<python at rcn dot com>"
msgstr "<python at rcn dot com>"

#: ../../howto/descriptor.rst:11
msgid "Contents"
msgstr "目录"

#: ../../howto/descriptor.rst:13
msgid ""
":term:`Descriptors <descriptor>` let objects customize attribute lookup, "
"storage, and deletion."
msgstr ":term:`描述器 <descriptor>` 让对象能够自定义属性查找、存储和删除的操作。"

#: ../../howto/descriptor.rst:16
msgid "This guide has four major sections:"
msgstr "本指南主要分为四个部分："

#: ../../howto/descriptor.rst:18
msgid ""
"The \"primer\" gives a basic overview, moving gently from simple examples, "
"adding one feature at a time.  Start here if you're new to descriptors."
msgstr "“入门” 部分从简单的示例着手，逐步添加特性，从而给出基本的概述。如果你是刚接触到描述器，请从这里开始。"

#: ../../howto/descriptor.rst:21
msgid ""
"The second section shows a complete, practical descriptor example.  If you "
"already know the basics, start there."
msgstr "第二部分展示了完整的、实用的描述器示例。如果您已经掌握了基础知识，请从此处开始。"

#: ../../howto/descriptor.rst:24
msgid ""
"The third section provides a more technical tutorial that goes into the "
"detailed mechanics of how descriptors work.  Most people don't need this "
"level of detail."
msgstr "第三部分提供了更多技术教程，详细介绍了描述器如何工作。大多数人并不需要深入到这种程度。"

#: ../../howto/descriptor.rst:28
msgid ""
"The last section has pure Python equivalents for built-in descriptors that "
"are written in C.  Read this if you're curious about how functions turn into"
" bound methods or about the implementation of common tools like "
":func:`classmethod`, :func:`staticmethod`, :func:`property`, and "
":term:`__slots__`."
msgstr ""
"最后一部分有对内置描述器（用 C 编写）的纯 Python 等价实现。如果您想了解函数如何变成绑定方法或对 :func:`classmethod`， "
":func:`staticmethod`，:func:`property` 和 :term:`__slots__` "
"这类常见工具的实现感兴趣，请阅读此部分。"

#: ../../howto/descriptor.rst:36
msgid "Primer"
msgstr "入门"

#: ../../howto/descriptor.rst:38
msgid ""
"In this primer, we start with the most basic possible example and then we'll"
" add new capabilities one by one."
msgstr "现在，让我们从最基本的示例开始，然后逐步添加新功能。"

#: ../../howto/descriptor.rst:43
msgid "Simple example: A descriptor that returns a constant"
msgstr "简单示例：返回常量的描述器"

#: ../../howto/descriptor.rst:45
msgid ""
"The :class:`!Ten` class is a descriptor whose :meth:`~object.__get__` method"
" always returns the constant ``10``:"
msgstr ":class:`!Ten` 类是一个描述器，其 :meth:`~object.__get__` 方法始终返回常量 ``10``:"

#: ../../howto/descriptor.rst:48
msgid ""
"class Ten:\n"
"    def __get__(self, obj, objtype=None):\n"
"        return 10"
msgstr ""
"class Ten:\n"
"    def __get__(self, obj, objtype=None):\n"
"        return 10"

#: ../../howto/descriptor.rst:54
msgid ""
"To use the descriptor, it must be stored as a class variable in another "
"class:"
msgstr "要使用描述器，它必须作为一个类变量存储在另一个类中："

#: ../../howto/descriptor.rst:56
msgid ""
"class A:\n"
"    x = 5                       # Regular class attribute\n"
"    y = Ten()                   # Descriptor instance"
msgstr ""
"class A:\n"
"    x = 5                       # 常规类属性\n"
"    y = Ten()                   # 描述器实例"

#: ../../howto/descriptor.rst:62
msgid ""
"An interactive session shows the difference between normal attribute lookup "
"and descriptor lookup:"
msgstr "用交互式会话查看普通属性查找和描述器查找之间的区别："

#: ../../howto/descriptor.rst:65
msgid ""
">>> a = A()                     # Make an instance of class A\n"
">>> a.x                         # Normal attribute lookup\n"
"5\n"
">>> a.y                         # Descriptor lookup\n"
"10"
msgstr ""
">>> a = A()                     # 创建一个类 A 的实例\n"
">>> a.x                         # 正常属性查找\n"
"5\n"
">>> a.y                         # 描述器查找\n"
"10"

#: ../../howto/descriptor.rst:73
msgid ""
"In the ``a.x`` attribute lookup, the dot operator finds ``'x': 5`` in the "
"class dictionary.  In the ``a.y`` lookup, the dot operator finds a "
"descriptor instance, recognized by its ``__get__`` method. Calling that "
"method returns ``10``."
msgstr ""
"在 ``a.x`` 属性查找中，点运算符会找到存储在类字典中的 ``'x': 5``。 在 ``a.y`` 查找中，点运算符会根据描述器实例的 "
"``__get__`` 方法将其识别出来，调用该方法并返回 ``10`` 。"

#: ../../howto/descriptor.rst:78
msgid ""
"Note that the value ``10`` is not stored in either the class dictionary or "
"the instance dictionary.  Instead, the value ``10`` is computed on demand."
msgstr "请注意，值 ``10`` 既不存储在类字典中也不存储在实例字典中。相反，值 ``10`` 是在调用时才取到的。"

#: ../../howto/descriptor.rst:81
msgid ""
"This example shows how a simple descriptor works, but it isn't very useful. "
"For retrieving constants, normal attribute lookup would be better."
msgstr "这个简单的例子展示了一个描述器是如何工作的，但它不是很有用。在查找常量时，用常规属性查找会更好。"

#: ../../howto/descriptor.rst:84
msgid ""
"In the next section, we'll create something more useful, a dynamic lookup."
msgstr "在下一节中，我们将创建更有用的东西，即动态查找。"

#: ../../howto/descriptor.rst:88
msgid "Dynamic lookups"
msgstr "动态查找"

#: ../../howto/descriptor.rst:90
msgid ""
"Interesting descriptors typically run computations instead of returning "
"constants:"
msgstr "有趣的描述器通常运行计算而不是返回常量："

#: ../../howto/descriptor.rst:93
msgid ""
"import os\n"
"\n"
"class DirectorySize:\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        return len(os.listdir(obj.dirname))\n"
"\n"
"class Directory:\n"
"\n"
"    size = DirectorySize()              # Descriptor instance\n"
"\n"
"    def __init__(self, dirname):\n"
"        self.dirname = dirname          # Regular instance attribute"
msgstr ""
"import os\n"
"\n"
"class DirectorySize:\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        return len(os.listdir(obj.dirname))\n"
"\n"
"class Directory:\n"
"\n"
"    size = DirectorySize()              # 描述器实例\n"
"\n"
"    def __init__(self, dirname):\n"
"        self.dirname = dirname          # 常规实例属性"

#: ../../howto/descriptor.rst:109
msgid ""
"An interactive session shows that the lookup is dynamic — it computes "
"different, updated answers each time::"
msgstr "交互式会话显示查找是动态的，每次都会计算不同的，经过更新的返回值::"

#: ../../howto/descriptor.rst:112
msgid ""
">>> s = Directory('songs')\n"
">>> g = Directory('games')\n"
">>> s.size                              # The songs directory has twenty files\n"
"20\n"
">>> g.size                              # The games directory has three files\n"
"3\n"
">>> os.remove('games/chess')            # Delete a game\n"
">>> g.size                              # File count is automatically updated\n"
"2"
msgstr ""
">>> s = Directory('songs')\n"
">>> g = Directory('games')\n"
">>> s.size                              # songs 目录有二十个文件\n"
"20\n"
">>> g.size                              # games 目录有三个文件\n"
"3\n"
">>> os.remove('games/chess')            # 删除一个 game\n"
">>> g.size                              # 文件计数将自动更新\n"
"2"

#: ../../howto/descriptor.rst:122
msgid ""
"Besides showing how descriptors can run computations, this example also "
"reveals the purpose of the parameters to :meth:`~object.__get__`.  The "
"*self* parameter is *size*, an instance of *DirectorySize*.  The *obj* "
"parameter is either *g* or *s*, an instance of *Directory*.  It is the *obj*"
" parameter that lets the :meth:`~object.__get__` method learn the target "
"directory.  The *objtype* parameter is the class *Directory*."
msgstr ""
"除了说明描述器如何运行计算，这个例子也揭示了传给 :meth:`~object.__get__` 的形参的目的。 *self* 形参为 "
"*size*，即一个 *DirectorySize* 的实例。 *obj* 形参为 *g* 或 *s*，即一个 *Directory* 的实例。 "
"*obj* 形参让 :meth:`~object.__get__` 方法获知目标目录。 *objtype* 形参为 *Directory* 类。"

#: ../../howto/descriptor.rst:131
msgid "Managed attributes"
msgstr "托管属性"

#: ../../howto/descriptor.rst:133
msgid ""
"A popular use for descriptors is managing access to instance data.  The "
"descriptor is assigned to a public attribute in the class dictionary while "
"the actual data is stored as a private attribute in the instance dictionary."
"  The descriptor's :meth:`~object.__get__` and :meth:`~object.__set__` "
"methods are triggered when the public attribute is accessed."
msgstr ""
"描述器的一种流行用法是管理对实例数据的访问。 描述器被分配给类字典中的公有属性，而实际数据则作为私有属性存储在实例字典中。 描述器的 "
":meth:`~object.__get__` 和 :meth:`~object.__set__` 方法会在公有属性被访问时被触发。"

#: ../../howto/descriptor.rst:139
msgid ""
"In the following example, *age* is the public attribute and *_age* is the "
"private attribute.  When the public attribute is accessed, the descriptor "
"logs the lookup or update:"
msgstr "在下面的例子中，*age* 是公开属性，*_age* 是私有属性。当访问公开属性时，描述器会记录下查找或更新的日志："

#: ../../howto/descriptor.rst:143
msgid ""
"import logging\n"
"\n"
"logging.basicConfig(level=logging.INFO)\n"
"\n"
"class LoggedAgeAccess:\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        value = obj._age\n"
"        logging.info('Accessing %r giving %r', 'age', value)\n"
"        return value\n"
"\n"
"    def __set__(self, obj, value):\n"
"        logging.info('Updating %r to %r', 'age', value)\n"
"        obj._age = value\n"
"\n"
"class Person:\n"
"\n"
"    age = LoggedAgeAccess()             # Descriptor instance\n"
"\n"
"    def __init__(self, name, age):\n"
"        self.name = name                # Regular instance attribute\n"
"        self.age = age                  # Calls __set__()\n"
"\n"
"    def birthday(self):\n"
"        self.age += 1                   # Calls both __get__() and __set__()"
msgstr ""
"import logging\n"
"\n"
"logging.basicConfig(level=logging.INFO)\n"
"\n"
"class LoggedAgeAccess:\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        value = obj._age\n"
"        logging.info('Accessing %r giving %r', 'age', value)\n"
"        return value\n"
"\n"
"    def __set__(self, obj, value):\n"
"        logging.info('Updating %r to %r', 'age', value)\n"
"        obj._age = value\n"
"\n"
"class Person:\n"
"\n"
"    age = LoggedAgeAccess()             # 描述器实例\n"
"\n"
"    def __init__(self, name, age):\n"
"        self.name = name                # 常规实例属性\n"
"        self.age = age                  # 调用 __set__()\n"
"\n"
"    def birthday(self):\n"
"        self.age += 1                   # 调用 __get__() 和 __set__()"

#: ../../howto/descriptor.rst:172
msgid ""
"An interactive session shows that all access to the managed attribute *age* "
"is logged, but that the regular attribute *name* is not logged:"
msgstr "交互式会话展示中，对托管属性 *age* 的所有访问都被记录了下来，但常规属性 *name* 则未被记录："

#: ../../howto/descriptor.rst:181
msgid ""
">>> mary = Person('Mary M', 30)         # The initial age update is logged\n"
"INFO:root:Updating 'age' to 30\n"
">>> dave = Person('David D', 40)\n"
"INFO:root:Updating 'age' to 40\n"
"\n"
">>> vars(mary)                          # The actual data is in a private attribute\n"
"{'name': 'Mary M', '_age': 30}\n"
">>> vars(dave)\n"
"{'name': 'David D', '_age': 40}\n"
"\n"
">>> mary.age                            # Access the data and log the lookup\n"
"INFO:root:Accessing 'age' giving 30\n"
"30\n"
">>> mary.birthday()                     # Updates are logged as well\n"
"INFO:root:Accessing 'age' giving 30\n"
"INFO:root:Updating 'age' to 31\n"
"\n"
">>> dave.name                           # Regular attribute lookup isn't logged\n"
"'David D'\n"
">>> dave.age                            # Only the managed attribute is logged\n"
"INFO:root:Accessing 'age' giving 40\n"
"40"
msgstr ""
">>> mary = Person('Mary M', 30)         # 初始年龄更新会被记录\n"
"INFO:root:Updating 'age' to 30\n"
">>> dave = Person('David D', 40)\n"
"INFO:root:Updating 'age' to 40\n"
"\n"
">>> vars(mary)                          # 私有属性中的实际数据\n"
"{'name': 'Mary M', '_age': 30}\n"
">>> vars(dave)\n"
"{'name': 'David D', '_age': 40}\n"
"\n"
">>> mary.age                            # 访问数据并记录查找操作\n"
"INFO:root:Accessing 'age' giving 30\n"
"30\n"
">>> mary.birthday()                     # 更新也会被记录\n"
"INFO:root:Accessing 'age' giving 30\n"
"INFO:root:Updating 'age' to 31\n"
"\n"
">>> dave.name                           # 常规属性查找不会被记录\n"
"'David D'\n"
">>> dave.age                            # 只有被管理的属性会被记录\n"
"INFO:root:Accessing 'age' giving 40\n"
"40"

#: ../../howto/descriptor.rst:206
msgid ""
"One major issue with this example is that the private name *_age* is "
"hardwired in the *LoggedAgeAccess* class.  That means that each instance can"
" only have one logged attribute and that its name is unchangeable.  In the "
"next example, we'll fix that problem."
msgstr ""
"此示例的一个主要问题是私有名称 *_age* 在类 *LoggedAgeAccess* "
"中是硬耦合的。这意味着每个实例只能有一个用于记录的属性，并且其名称不可更改。"

#: ../../howto/descriptor.rst:213
msgid "Customized names"
msgstr "定制名称"

#: ../../howto/descriptor.rst:215
msgid ""
"When a class uses descriptors, it can inform each descriptor about which "
"variable name was used."
msgstr "当一个类使用描述器时，它可以告知每个描述器使用了什么变量名。"

#: ../../howto/descriptor.rst:218
msgid ""
"In this example, the :class:`!Person` class has two descriptor instances, "
"*name* and *age*.  When the :class:`!Person` class is defined, it makes a "
"callback to :meth:`~object.__set_name__` in *LoggedAccess* so that the field"
" names can be recorded, giving each descriptor its own *public_name* and "
"*private_name*:"
msgstr ""
"在此示例中，:class:`!Person` 类具有两个描述器实例 *name* 和 *age*。 当 :class:`!Person` "
"类被定义时，它将在 *LoggedAccess* 中执行对 :meth:`~object.__set_name__` "
"的回调以便记录字段名称，给予每个描述器自己的 *public_name* 和 *private_name*:"

#: ../../howto/descriptor.rst:223
msgid ""
"import logging\n"
"\n"
"logging.basicConfig(level=logging.INFO)\n"
"\n"
"class LoggedAccess:\n"
"\n"
"    def __set_name__(self, owner, name):\n"
"        self.public_name = name\n"
"        self.private_name = '_' + name\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        value = getattr(obj, self.private_name)\n"
"        logging.info('Accessing %r giving %r', self.public_name, value)\n"
"        return value\n"
"\n"
"    def __set__(self, obj, value):\n"
"        logging.info('Updating %r to %r', self.public_name, value)\n"
"        setattr(obj, self.private_name, value)\n"
"\n"
"class Person:\n"
"\n"
"    name = LoggedAccess()                # First descriptor instance\n"
"    age = LoggedAccess()                 # Second descriptor instance\n"
"\n"
"    def __init__(self, name, age):\n"
"        self.name = name                 # Calls the first descriptor\n"
"        self.age = age                   # Calls the second descriptor\n"
"\n"
"    def birthday(self):\n"
"        self.age += 1"
msgstr ""
"import logging\n"
"\n"
"logging.basicConfig(level=logging.INFO)\n"
"\n"
"class LoggedAccess:\n"
"\n"
"    def __set_name__(self, owner, name):\n"
"        self.public_name = name\n"
"        self.private_name = '_' + name\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        value = getattr(obj, self.private_name)\n"
"        logging.info('Accessing %r giving %r', self.public_name, value)\n"
"        return value\n"
"\n"
"    def __set__(self, obj, value):\n"
"        logging.info('Updating %r to %r', self.public_name, value)\n"
"        setattr(obj, self.private_name, value)\n"
"\n"
"class Person:\n"
"\n"
"    name = LoggedAccess()                # 第一个描述器实例\n"
"    age = LoggedAccess()                 # 第二个描述器实例\n"
"\n"
"    def __init__(self, name, age):\n"
"        self.name = name                 # 调用第一个描述器\n"
"        self.age = age                   # 调用第二个描述器\n"
"\n"
"    def birthday(self):\n"
"        self.age += 1"

#: ../../howto/descriptor.rst:256
msgid ""
"An interactive session shows that the :class:`!Person` class has called "
":meth:`~object.__set_name__` so that the field names would be recorded.  "
"Here we call :func:`vars` to look up the descriptor without triggering it:"
msgstr ""
"交互式会话显示 :class:`!Person` 类调用了 :meth:`~object.__set_name__` 以使字段名称可被记录。 "
"在这里我们调用 :func:`vars` 来查找描述器而不触发它："

#: ../../howto/descriptor.rst:260
msgid ""
">>> vars(vars(Person)['name'])\n"
"{'public_name': 'name', 'private_name': '_name'}\n"
">>> vars(vars(Person)['age'])\n"
"{'public_name': 'age', 'private_name': '_age'}"
msgstr ""
">>> vars(vars(Person)['name'])\n"
"{'public_name': 'name', 'private_name': '_name'}\n"
">>> vars(vars(Person)['age'])\n"
"{'public_name': 'age', 'private_name': '_age'}"

#: ../../howto/descriptor.rst:267
msgid "The new class now logs access to both *name* and *age*:"
msgstr "现在，新类会记录对 *name* 和 *age* 二者的访问："

#: ../../howto/descriptor.rst:275
msgid ""
">>> pete = Person('Peter P', 10)\n"
"INFO:root:Updating 'name' to 'Peter P'\n"
"INFO:root:Updating 'age' to 10\n"
">>> kate = Person('Catherine C', 20)\n"
"INFO:root:Updating 'name' to 'Catherine C'\n"
"INFO:root:Updating 'age' to 20"
msgstr ""
">>> pete = Person('Peter P', 10)\n"
"INFO:root:Updating 'name' to 'Peter P'\n"
"INFO:root:Updating 'age' to 10\n"
">>> kate = Person('Catherine C', 20)\n"
"INFO:root:Updating 'name' to 'Catherine C'\n"
"INFO:root:Updating 'age' to 20"

#: ../../howto/descriptor.rst:284
msgid "The two *Person* instances contain only the private names:"
msgstr "这两个 *Person* 实例仅包含私有名称:"

#: ../../howto/descriptor.rst:286
msgid ""
">>> vars(pete)\n"
"{'_name': 'Peter P', '_age': 10}\n"
">>> vars(kate)\n"
"{'_name': 'Catherine C', '_age': 20}"
msgstr ""
">>> vars(pete)\n"
"{'_name': 'Peter P', '_age': 10}\n"
">>> vars(kate)\n"
"{'_name': 'Catherine C', '_age': 20}"

#: ../../howto/descriptor.rst:295
msgid "Closing thoughts"
msgstr "结束语"

#: ../../howto/descriptor.rst:297
msgid ""
"A :term:`descriptor` is what we call any object that defines "
":meth:`~object.__get__`, :meth:`~object.__set__`, or "
":meth:`~object.__delete__`."
msgstr ""
":term:`descriptor` 是指任何定义了 :meth:`~object.__get__`, :meth:`~object.__set__` "
"或 :meth:`~object.__delete__` 的对象。"

#: ../../howto/descriptor.rst:300
msgid ""
"Optionally, descriptors can have a :meth:`~object.__set_name__` method.  "
"This is only used in cases where a descriptor needs to know either the class"
" where it was created or the name of class variable it was assigned to.  "
"(This method, if present, is called even if the class is not a descriptor.)"
msgstr ""
"作为可选项，描述器可以有 :meth:`~object.__set_name__` 方法。 "
"这仅会被用于当描述器需要知道创建它的类或它被分配的类变量名称等场合。 （此方法如果存在，那么即使所在类并不是一个描述器仍会被调用。）"

#: ../../howto/descriptor.rst:305
msgid ""
"Descriptors get invoked by the dot operator during attribute lookup.  If a "
"descriptor is accessed indirectly with "
"``vars(some_class)[descriptor_name]``, the descriptor instance is returned "
"without invoking it."
msgstr ""
"在属性查找期间，描述器由点运算符调用。如果使用 ``vars(some_class)[descriptor_name]`` "
"间接访问描述器，则返回描述器实例而不调用它。"

#: ../../howto/descriptor.rst:309
msgid ""
"Descriptors only work when used as class variables.  When put in instances, "
"they have no effect."
msgstr "描述器仅在用作类变量时起作用。放入实例时，它们将失效。"

#: ../../howto/descriptor.rst:312
msgid ""
"The main motivation for descriptors is to provide a hook allowing objects "
"stored in class variables to control what happens during attribute lookup."
msgstr "描述器的主要目的是提供一个挂钩，允许存储在类变量中的对象控制在属性查找期间发生的情况。"

#: ../../howto/descriptor.rst:315
msgid ""
"Traditionally, the calling class controls what happens during lookup. "
"Descriptors invert that relationship and allow the data being looked-up to "
"have a say in the matter."
msgstr "传统上，调用类控制查找过程中发生的事情。描述器反转了这种关系，并允许正在被查询的数据对此进行干涉。"

#: ../../howto/descriptor.rst:319
msgid ""
"Descriptors are used throughout the language.  It is how functions turn into"
" bound methods.  Common tools like :func:`classmethod`, "
":func:`staticmethod`, :func:`property`, and "
":func:`functools.cached_property` are all implemented as descriptors."
msgstr ""
"描述器的使用贯穿了整个语言。就是它让函数变成绑定方法。常见工具诸如 :func:`classmethod`， "
":func:`staticmethod`，:func:`property` 和 :func:`functools.cached_property` "
"都作为描述器实现。"

#: ../../howto/descriptor.rst:326
msgid "Complete Practical Example"
msgstr "完整的实际例子"

#: ../../howto/descriptor.rst:328
msgid ""
"In this example, we create a practical and powerful tool for locating "
"notoriously hard to find data corruption bugs."
msgstr "在此示例中，我们创建了一个实用而强大的工具来查找难以发现的数据损坏错误。"

#: ../../howto/descriptor.rst:333
msgid "Validator class"
msgstr "验证器类"

#: ../../howto/descriptor.rst:335
msgid ""
"A validator is a descriptor for managed attribute access.  Prior to storing "
"any data, it verifies that the new value meets various type and range "
"restrictions.  If those restrictions aren't met, it raises an exception to "
"prevent data corruption at its source."
msgstr ""
"验证器是一个用于托管属性访问的描述器。在存储任何数据之前，它会验证新值是否满足各种类型和范围限制。如果不满足这些限制，它将引发异常，从源头上防止数据损坏。"

#: ../../howto/descriptor.rst:340
msgid ""
"This :class:`!Validator` class is both an :term:`abstract base class` and a "
"managed attribute descriptor:"
msgstr ""
"这个 :class:`!Validator` 类既是一个 :term:`abstract base class` 也是一个被管理的属性描述器："

#: ../../howto/descriptor.rst:343
msgid ""
"from abc import ABC, abstractmethod\n"
"\n"
"class Validator(ABC):\n"
"\n"
"    def __set_name__(self, owner, name):\n"
"        self.private_name = '_' + name\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        return getattr(obj, self.private_name)\n"
"\n"
"    def __set__(self, obj, value):\n"
"        self.validate(value)\n"
"        setattr(obj, self.private_name, value)\n"
"\n"
"    @abstractmethod\n"
"    def validate(self, value):\n"
"        pass"
msgstr ""
"from abc import ABC, abstractmethod\n"
"\n"
"class Validator(ABC):\n"
"\n"
"    def __set_name__(self, owner, name):\n"
"        self.private_name = '_' + name\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        return getattr(obj, self.private_name)\n"
"\n"
"    def __set__(self, obj, value):\n"
"        self.validate(value)\n"
"        setattr(obj, self.private_name, value)\n"
"\n"
"    @abstractmethod\n"
"    def validate(self, value):\n"
"        pass"

#: ../../howto/descriptor.rst:363
msgid ""
"Custom validators need to inherit from :class:`!Validator` and must supply a"
" :meth:`!validate` method to test various restrictions as needed."
msgstr ""
"自定义验证器必须继承自 :class:`!Validator` 并且必须提供 :meth:`!validate` 方法以根据需要测试各种约束。"

#: ../../howto/descriptor.rst:368
msgid "Custom validators"
msgstr "自定义验证器"

#: ../../howto/descriptor.rst:370
msgid "Here are three practical data validation utilities:"
msgstr "这是三个实用的数据验证工具："

#: ../../howto/descriptor.rst:372
msgid ""
":class:`!OneOf` verifies that a value is one of a restricted set of options."
msgstr ":class:`!OneOf` 验证值是指定的受约束选项集合中的一项。"

#: ../../howto/descriptor.rst:374
msgid ""
":class:`!Number` verifies that a value is either an :class:`int` or "
":class:`float`.  Optionally, it verifies that a value is between a given "
"minimum or maximum."
msgstr ""
":class:`!Number` 验证值是否为 :class:`int` 或 :class:`float`。 "
"作为可选项，它还能验证值在给定的最小值和最大值之间。"

#: ../../howto/descriptor.rst:378
msgid ""
":class:`!String` verifies that a value is a :class:`str`.  Optionally, it "
"validates a given minimum or maximum length.  It can validate a user-defined"
" `predicate <https://en.wikipedia.org/wiki/Predicate_(mathematical_logic)>`_"
" as well."
msgstr ""
":class:`!String` 验证值是否为 :class:`str`。 作为可选项，它还能验证给定的最小或最大长度。 它还能验证用户定义的 "
"`predicate <https://en.wikipedia.org/wiki/Predicate_(mathematical_logic)>`_。"

#: ../../howto/descriptor.rst:383
msgid ""
"class OneOf(Validator):\n"
"\n"
"    def __init__(self, *options):\n"
"        self.options = set(options)\n"
"\n"
"    def validate(self, value):\n"
"        if value not in self.options:\n"
"            raise ValueError(\n"
"                f'Expected {value!r} to be one of {self.options!r}'\n"
"            )\n"
"\n"
"class Number(Validator):\n"
"\n"
"    def __init__(self, minvalue=None, maxvalue=None):\n"
"        self.minvalue = minvalue\n"
"        self.maxvalue = maxvalue\n"
"\n"
"    def validate(self, value):\n"
"        if not isinstance(value, (int, float)):\n"
"            raise TypeError(f'Expected {value!r} to be an int or float')\n"
"        if self.minvalue is not None and value < self.minvalue:\n"
"            raise ValueError(\n"
"                f'Expected {value!r} to be at least {self.minvalue!r}'\n"
"            )\n"
"        if self.maxvalue is not None and value > self.maxvalue:\n"
"            raise ValueError(\n"
"                f'Expected {value!r} to be no more than {self.maxvalue!r}'\n"
"            )\n"
"\n"
"class String(Validator):\n"
"\n"
"    def __init__(self, minsize=None, maxsize=None, predicate=None):\n"
"        self.minsize = minsize\n"
"        self.maxsize = maxsize\n"
"        self.predicate = predicate\n"
"\n"
"    def validate(self, value):\n"
"        if not isinstance(value, str):\n"
"            raise TypeError(f'Expected {value!r} to be an str')\n"
"        if self.minsize is not None and len(value) < self.minsize:\n"
"            raise ValueError(\n"
"                f'Expected {value!r} to be no smaller than {self.minsize!r}'\n"
"            )\n"
"        if self.maxsize is not None and len(value) > self.maxsize:\n"
"            raise ValueError(\n"
"                f'Expected {value!r} to be no bigger than {self.maxsize!r}'\n"
"            )\n"
"        if self.predicate is not None and not self.predicate(value):\n"
"            raise ValueError(\n"
"                f'Expected {self.predicate} to be true for {value!r}'\n"
"            )"
msgstr ""
"class OneOf(Validator):\n"
"\n"
"    def __init__(self, *options):\n"
"        self.options = set(options)\n"
"\n"
"    def validate(self, value):\n"
"        if value not in self.options:\n"
"            raise ValueError(\n"
"                f'Expected {value!r} to be one of {self.options!r}'\n"
"            )\n"
"\n"
"class Number(Validator):\n"
"\n"
"    def __init__(self, minvalue=None, maxvalue=None):\n"
"        self.minvalue = minvalue\n"
"        self.maxvalue = maxvalue\n"
"\n"
"    def validate(self, value):\n"
"        if not isinstance(value, (int, float)):\n"
"            raise TypeError(f'Expected {value!r} to be an int or float')\n"
"        if self.minvalue is not None and value < self.minvalue:\n"
"            raise ValueError(\n"
"                f'Expected {value!r} to be at least {self.minvalue!r}'\n"
"            )\n"
"        if self.maxvalue is not None and value > self.maxvalue:\n"
"            raise ValueError(\n"
"                f'Expected {value!r} to be no more than {self.maxvalue!r}'\n"
"            )\n"
"\n"
"class String(Validator):\n"
"\n"
"    def __init__(self, minsize=None, maxsize=None, predicate=None):\n"
"        self.minsize = minsize\n"
"        self.maxsize = maxsize\n"
"        self.predicate = predicate\n"
"\n"
"    def validate(self, value):\n"
"        if not isinstance(value, str):\n"
"            raise TypeError(f'Expected {value!r} to be an str')\n"
"        if self.minsize is not None and len(value) < self.minsize:\n"
"            raise ValueError(\n"
"                f'Expected {value!r} to be no smaller than {self.minsize!r}'\n"
"            )\n"
"        if self.maxsize is not None and len(value) > self.maxsize:\n"
"            raise ValueError(\n"
"                f'Expected {value!r} to be no bigger than {self.maxsize!r}'\n"
"            )\n"
"        if self.predicate is not None and not self.predicate(value):\n"
"            raise ValueError(\n"
"                f'Expected {self.predicate} to be true for {value!r}'\n"
"            )"

#: ../../howto/descriptor.rst:439
msgid "Practical application"
msgstr "实际应用"

#: ../../howto/descriptor.rst:441
msgid "Here's how the data validators can be used in a real class:"
msgstr "这是在真实类中使用数据验证器的方法："

#: ../../howto/descriptor.rst:443
msgid ""
"class Component:\n"
"\n"
"    name = String(minsize=3, maxsize=10, predicate=str.isupper)\n"
"    kind = OneOf('wood', 'metal', 'plastic')\n"
"    quantity = Number(minvalue=0)\n"
"\n"
"    def __init__(self, name, kind, quantity):\n"
"        self.name = name\n"
"        self.kind = kind\n"
"        self.quantity = quantity"
msgstr ""
"class Component:\n"
"\n"
"    name = String(minsize=3, maxsize=10, predicate=str.isupper)\n"
"    kind = OneOf('wood', 'metal', 'plastic')\n"
"    quantity = Number(minvalue=0)\n"
"\n"
"    def __init__(self, name, kind, quantity):\n"
"        self.name = name\n"
"        self.kind = kind\n"
"        self.quantity = quantity"

#: ../../howto/descriptor.rst:456
msgid "The descriptors prevent invalid instances from being created:"
msgstr "描述器阻止无效实例的创建："

#: ../../howto/descriptor.rst:458
msgid ""
">>> Component('Widget', 'metal', 5)      # Blocked: 'Widget' is not all uppercase\n"
"Traceback (most recent call last):\n"
"    ...\n"
"ValueError: Expected <method 'isupper' of 'str' objects> to be true for 'Widget'\n"
"\n"
">>> Component('WIDGET', 'metle', 5)      # Blocked: 'metle' is misspelled\n"
"Traceback (most recent call last):\n"
"    ...\n"
"ValueError: Expected 'metle' to be one of {'metal', 'plastic', 'wood'}\n"
"\n"
">>> Component('WIDGET', 'metal', -5)     # Blocked: -5 is negative\n"
"Traceback (most recent call last):\n"
"    ...\n"
"ValueError: Expected -5 to be at least 0\n"
"\n"
">>> Component('WIDGET', 'metal', 'V')    # Blocked: 'V' isn't a number\n"
"Traceback (most recent call last):\n"
"    ...\n"
"TypeError: Expected 'V' to be an int or float\n"
"\n"
">>> c = Component('WIDGET', 'metal', 5)  # Allowed:  The inputs are valid"
msgstr ""
">>> Component('Widget', 'metal', 5)      # 阻止: 'Widget' 不是全大写\n"
"Traceback (most recent call last):\n"
"    ...\n"
"ValueError: Expected <method 'isupper' of 'str' objects> to be true for 'Widget'\n"
"\n"
">>> Component('WIDGET', 'metle', 5)      # 阻止: 'metle' 拼写错误\n"
"Traceback (most recent call last):\n"
"    ...\n"
"ValueError: Expected 'metle' to be one of {'metal', 'plastic', 'wood'}\n"
"\n"
">>> Component('WIDGET', 'metal', -5)     # 阻止: -5 为负数\n"
"Traceback (most recent call last):\n"
"    ...\n"
"ValueError: Expected -5 to be at least 0\n"
"\n"
">>> Component('WIDGET', 'metal', 'V')    # 阻止: 'V' 不是数字\n"
"Traceback (most recent call last):\n"
"    ...\n"
"TypeError: Expected 'V' to be an int or float\n"
"\n"
">>> c = Component('WIDGET', 'metal', 5)  # 允许: 输入有效"

#: ../../howto/descriptor.rst:484
msgid "Technical Tutorial"
msgstr "技术教程"

#: ../../howto/descriptor.rst:486
msgid ""
"What follows is a more technical tutorial for the mechanics and details of "
"how descriptors work."
msgstr "接下来是专业性更强的技术教程，以及描述器工作原理的详细信息。"

#: ../../howto/descriptor.rst:491
msgid "Abstract"
msgstr "摘要"

#: ../../howto/descriptor.rst:493
msgid ""
"Defines descriptors, summarizes the protocol, and shows how descriptors are "
"called.  Provides an example showing how object relational mappings work."
msgstr "定义描述器，总结协议，并说明如何调用描述器。提供一个展示对象关系映射如何工作的示例。"

#: ../../howto/descriptor.rst:496
msgid ""
"Learning about descriptors not only provides access to a larger toolset, it "
"creates a deeper understanding of how Python works."
msgstr "学习描述器不仅能提供接触到更多工具集的途径，还能更深地理解 Python 工作的原理。"

#: ../../howto/descriptor.rst:501
msgid "Definition and introduction"
msgstr "定义与介绍"

#: ../../howto/descriptor.rst:503
msgid ""
"In general, a descriptor is an attribute value that has one of the methods "
"in the descriptor protocol.  Those methods are :meth:`~object.__get__`, "
":meth:`~object.__set__`, and :meth:`~object.__delete__`.  If any of those "
"methods are defined for an attribute, it is said to be a :term:`descriptor`."
msgstr ""
"一般而言，描述器是具有描述器协议中的方法之一的属性值。 这些方法是 :meth:`~object.__get__`, "
":meth:`~object.__set__` 和 :meth:`~object.__delete__`。 "
"如果为某个属性定义了这些方法中的任何一个，它就被称为 :term:`descriptor`。"

#: ../../howto/descriptor.rst:508
msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary.  For instance, ``a.x`` has a lookup "
"chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``, and"
" continuing through the method resolution order of ``type(a)``. If the "
"looked-up value is an object defining one of the descriptor methods, then "
"Python may override the default behavior and invoke the descriptor method "
"instead. Where this occurs in the precedence chain depends on which "
"descriptor methods were defined."
msgstr ""
"属性访问的默认行为是从一个对象的字典中获取、设置或删除属性。对于实例来说，``a.x`` 的查找顺序会从 ``a.__dict__['x']`` "
"开始，然后是 ``type(a).__dict__['x']``，接下来依次查找 ``type(a)`` 的方法解析顺序（MRO）。 "
"如果找到的值是定义了某个描述器方法的对象，则 Python "
"可能会重写默认行为并转而唤起描述器方法。这具体发生在优先级链的哪个环节则要根据所定义的描述器方法及其被调用的方式来决定。"

#: ../../howto/descriptor.rst:517
msgid ""
"Descriptors are a powerful, general purpose protocol.  They are the "
"mechanism behind properties, methods, static methods, class methods, and "
":func:`super`.  They are used throughout Python itself.  Descriptors "
"simplify the underlying C code and offer a flexible set of new tools for "
"everyday Python programs."
msgstr ""
"描述器是一种强大的，通用的协议。 它们是属性、方法、静态方法、类方法和 :func:`super` 背后的机制。 它们在整个 Python 中都有使用。"
" 描述器简化了底层的 C 代码并为日常的 Python 程序提供了一套灵活的新工具。"

#: ../../howto/descriptor.rst:525
msgid "Descriptor protocol"
msgstr "描述器协议"

#: ../../howto/descriptor.rst:527
msgid "``descr.__get__(self, obj, type=None)``"
msgstr "``descr.__get__(self, obj, type=None)``"

#: ../../howto/descriptor.rst:529
msgid "``descr.__set__(self, obj, value)``"
msgstr "``descr.__set__(self, obj, value)``"

#: ../../howto/descriptor.rst:531
msgid "``descr.__delete__(self, obj)``"
msgstr "``descr.__delete__(self, obj)``"

#: ../../howto/descriptor.rst:533
msgid ""
"That is all there is to it.  Define any of these methods and an object is "
"considered a descriptor and can override default behavior upon being looked "
"up as an attribute."
msgstr "描述器的方法就这些。一个对象只要定义了以上方法中的任何一个，就被视为描述器，并在被作为属性时覆盖其默认行为。"

#: ../../howto/descriptor.rst:537
msgid ""
"If an object defines :meth:`~object.__set__` or :meth:`~object.__delete__`, "
"it is considered a data descriptor.  Descriptors that only define "
":meth:`~object.__get__` are called non-data descriptors (they are often used"
" for methods but other uses are possible)."
msgstr ""
"如果一个对象定义了 :meth:`~object.__set__` 或 :meth:`~object.__delete__`，它将被视为数据描述器。 "
"仅定义了 :meth:`~object.__get__` 的描述器称为非数据描述器（它们经常被用于方法但也可以有其他用途。"

#: ../../howto/descriptor.rst:542
msgid ""
"Data and non-data descriptors differ in how overrides are calculated with "
"respect to entries in an instance's dictionary.  If an instance's dictionary"
" has an entry with the same name as a data descriptor, the data descriptor "
"takes precedence.  If an instance's dictionary has an entry with the same "
"name as a non-data descriptor, the dictionary entry takes precedence."
msgstr ""
"数据和非数据描述器的不同之处在于，如何计算实例字典中条目的替代值。如果实例的字典具有与数据描述器同名的条目，则数据描述器优先。如果实例的字典具有与非数据描述器同名的条目，则该字典条目优先。"

#: ../../howto/descriptor.rst:548
msgid ""
"To make a read-only data descriptor, define both :meth:`~object.__get__` and"
" :meth:`~object.__set__` with the :meth:`~object.__set__` raising an "
":exc:`AttributeError` when called.  Defining the :meth:`~object.__set__` "
"method with an exception raising placeholder is enough to make it a data "
"descriptor."
msgstr ""
"为了使一个数据描述器只读，应同时定义 :meth:`~object.__get__` 和 :meth:`~object.__set__` 并在调用 "
":meth:`~object.__set__` 时引发 :exc:`AttributeError`。 用引发异常的占位符定义 "
":meth:`~object.__set__` 方法就足以使其成为一个数据描述器。"

#: ../../howto/descriptor.rst:555
msgid "Overview of descriptor invocation"
msgstr "描述器调用概述"

#: ../../howto/descriptor.rst:557
msgid ""
"A descriptor can be called directly with ``desc.__get__(obj)`` or "
"``desc.__get__(None, cls)``."
msgstr "描述器可以通过 ``d.__get__(obj)`` 或 ``desc.__get__(None, cls)`` 直接调用。"

#: ../../howto/descriptor.rst:560
msgid ""
"But it is more common for a descriptor to be invoked automatically from "
"attribute access."
msgstr "但更常见的是通过属性访问自动调用描述器。"

#: ../../howto/descriptor.rst:563
msgid ""
"The expression ``obj.x`` looks up the attribute ``x`` in the chain of "
"namespaces for ``obj``.  If the search finds a descriptor outside of the "
"instance :attr:`~object.__dict__`, its :meth:`~object.__get__` method is "
"invoked according to the precedence rules listed below."
msgstr ""
"表达式 ``obj.x`` 在 ``obj`` 的命名空间链中查找属性 ``x``。 如果搜索发现了一个实例 "
":attr:`~object.__dict__` 以外的描述器，将根据下面列出的优先级规则调用其 :meth:`~object.__get__` 方法。"

#: ../../howto/descriptor.rst:568
msgid ""
"The details of invocation depend on whether ``obj`` is an object, class, or "
"instance of super."
msgstr "调用的细节取决于 ``obj`` 是对象、类还是超类的实例。"

#: ../../howto/descriptor.rst:573
msgid "Invocation from an instance"
msgstr "通过实例调用"

#: ../../howto/descriptor.rst:575
msgid ""
"Instance lookup scans through a chain of namespaces giving data descriptors "
"the highest priority, followed by instance variables, then non-data "
"descriptors, then class variables, and lastly :meth:`~object.__getattr__` if"
" it is provided."
msgstr ""
"实例查找会扫描命名空间链并给予数据描述器最高的优先级，然后是实例变量，然后是非数据描述器，最后是 "
":meth:`~object.__getattr__`，如果有提供的话。"

#: ../../howto/descriptor.rst:580
msgid ""
"If a descriptor is found for ``a.x``, then it is invoked with: "
"``desc.__get__(a, type(a))``."
msgstr "如果 ``a.x`` 找到了一个描述器，那么将通过 ``desc.__get__(a, type(a))`` 调用它。"

#: ../../howto/descriptor.rst:583
msgid ""
"The logic for a dotted lookup is in :meth:`object.__getattribute__`.  Here "
"is a pure Python equivalent:"
msgstr "点运算符的查找逻辑在 :meth:`object.__getattribute__` 中。这里是一个等价的纯 Python 实现："

#: ../../howto/descriptor.rst:586
msgid ""
"def find_name_in_mro(cls, name, default):\n"
"    \"Emulate _PyType_Lookup() in Objects/typeobject.c\"\n"
"    for base in cls.__mro__:\n"
"        if name in vars(base):\n"
"            return vars(base)[name]\n"
"    return default\n"
"\n"
"def object_getattribute(obj, name):\n"
"    \"Emulate PyObject_GenericGetAttr() in Objects/object.c\"\n"
"    null = object()\n"
"    objtype = type(obj)\n"
"    cls_var = find_name_in_mro(objtype, name, null)\n"
"    descr_get = getattr(type(cls_var), '__get__', null)\n"
"    if descr_get is not null:\n"
"        if (hasattr(type(cls_var), '__set__')\n"
"            or hasattr(type(cls_var), '__delete__')):\n"
"            return descr_get(cls_var, obj, objtype)     # data descriptor\n"
"    if hasattr(obj, '__dict__') and name in vars(obj):\n"
"        return vars(obj)[name]                          # instance variable\n"
"    if descr_get is not null:\n"
"        return descr_get(cls_var, obj, objtype)         # non-data descriptor\n"
"    if cls_var is not null:\n"
"        return cls_var                                  # class variable\n"
"    raise AttributeError(name)"
msgstr ""
"def find_name_in_mro(cls, name, default):\n"
"    \"Emulate _PyType_Lookup() in Objects/typeobject.c\"\n"
"    for base in cls.__mro__:\n"
"        if name in vars(base):\n"
"            return vars(base)[name]\n"
"    return default\n"
"\n"
"def object_getattribute(obj, name):\n"
"    \"Emulate PyObject_GenericGetAttr() in Objects/object.c\"\n"
"    null = object()\n"
"    objtype = type(obj)\n"
"    cls_var = find_name_in_mro(objtype, name, null)\n"
"    descr_get = getattr(type(cls_var), '__get__', null)\n"
"    if descr_get is not null:\n"
"        if (hasattr(type(cls_var), '__set__')\n"
"            or hasattr(type(cls_var), '__delete__')):\n"
"            return descr_get(cls_var, obj, objtype)     # 数据描述器\n"
"    if hasattr(obj, '__dict__') and name in vars(obj):\n"
"        return vars(obj)[name]                          # 实例变量\n"
"    if descr_get is not null:\n"
"        return descr_get(cls_var, obj, objtype)         # 非数据描述器\n"
"    if cls_var is not null:\n"
"        return cls_var                                  # 类变量\n"
"    raise AttributeError(name)"

#: ../../howto/descriptor.rst:722
msgid ""
"Note, there is no :meth:`~object.__getattr__` hook in the "
":meth:`~object.__getattribute__` code.  That is why calling "
":meth:`~object.__getattribute__` directly or with "
"``super().__getattribute__`` will bypass :meth:`~object.__getattr__` "
"entirely."
msgstr ""
"注意，在 :meth:`~object.__getattribute__` 代码中没有 :meth:`~object.__getattr__` 钩子。 "
"这就是为什么直接调用 :meth:`~object.__getattribute__` 或用 ``super().__getattribute__`` "
"会彻底绕过 :meth:`~object.__getattr__`。"

#: ../../howto/descriptor.rst:726
msgid ""
"Instead, it is the dot operator and the :func:`getattr` function that are "
"responsible for invoking :meth:`~object.__getattr__` whenever "
":meth:`~object.__getattribute__` raises an :exc:`AttributeError`.  Their "
"logic is encapsulated in a helper function:"
msgstr ""
"相反，一旦 :meth:`~object.__getattribute__` 引发 :exc:`AttributeError` 则将由点运算符和 "
":func:`getattr` 函数来负责唤起 :meth:`~object.__getattr__`。 它们的逻辑封装在一个辅助函数中："

#: ../../howto/descriptor.rst:731
msgid ""
"def getattr_hook(obj, name):\n"
"    \"Emulate slot_tp_getattr_hook() in Objects/typeobject.c\"\n"
"    try:\n"
"        return obj.__getattribute__(name)\n"
"    except AttributeError:\n"
"        if not hasattr(type(obj), '__getattr__'):\n"
"            raise\n"
"    return type(obj).__getattr__(obj, name)             # __getattr__"
msgstr ""
"def getattr_hook(obj, name):\n"
"    \"Emulate slot_tp_getattr_hook() in Objects/typeobject.c\"\n"
"    try:\n"
"        return obj.__getattribute__(name)\n"
"    except AttributeError:\n"
"        if not hasattr(type(obj), '__getattr__'):\n"
"            raise\n"
"    return type(obj).__getattr__(obj, name)             # __getattr__"

#: ../../howto/descriptor.rst:776
msgid "Invocation from a class"
msgstr "通过类调用"

#: ../../howto/descriptor.rst:778
msgid ""
"The logic for a dotted lookup such as ``A.x`` is in "
":meth:`!type.__getattribute__`.  The steps are similar to those for "
":meth:`!object.__getattribute__` but the instance dictionary lookup is "
"replaced by a search through the class's :term:`method resolution order`."
msgstr ""
"像 ``A.x`` 这样的点操作符查找的逻辑在 :meth:`!type.__getattribute__` 中。 其步骤与 "
":meth:`!object.__getattribute__` 相似，但是实例字典查找被替换为搜索类的 :term:`method "
"resolution order`。"

#: ../../howto/descriptor.rst:783
msgid ""
"If a descriptor is found, it is invoked with ``desc.__get__(None, A)``."
msgstr "如果找到了一个描述器，那么将通过 ``desc.__get__(None, A)`` 调用它。"

#: ../../howto/descriptor.rst:785
msgid ""
"The full C implementation can be found in :c:func:`!type_getattro` and "
":c:func:`!_PyType_Lookup` in :source:`Objects/typeobject.c`."
msgstr ""
"完整的 C 实现可在 :source:`Objects/typeobject.c` 里的 :c:func:`!type_getattro` 和 "
":c:func:`!_PyType_Lookup` 中找到。"

#: ../../howto/descriptor.rst:790
msgid "Invocation from super"
msgstr "通过 super 调用"

#: ../../howto/descriptor.rst:792
msgid ""
"The logic for super's dotted lookup is in the "
":meth:`~object.__getattribute__` method for object returned by "
":func:`super`."
msgstr ""
"super 的点操作符查找的逻辑在 :func:`super` 所返回对象的 :meth:`~object.__getattribute__` 方法中。"

#: ../../howto/descriptor.rst:795
msgid ""
"A dotted lookup such as ``super(A, obj).m`` searches "
"``obj.__class__.__mro__`` for the base class ``B`` immediately following "
"``A`` and then returns ``B.__dict__['m'].__get__(obj, A)``.  If not a "
"descriptor, ``m`` is returned unchanged."
msgstr ""
"类似 ``super(A, obj).m`` 形式的点分查找将在 ``obj.__class__.__mro__`` 中搜索紧接在 ``A`` "
"之后的基类 ``B``，然后返回 ``B.__dict__['m'].__get__(obj, A)``。如果 ``m`` 不是描述器，则直接返回其值。"

#: ../../howto/descriptor.rst:800
msgid ""
"The full C implementation can be found in :c:func:`!super_getattro` in "
":source:`Objects/typeobject.c`.  A pure Python equivalent can be found in "
"`Guido's Tutorial "
"<https://www.python.org/download/releases/2.2.3/descrintro/#cooperation>`_."
msgstr ""
"完整的 C 实现可在 :source:`Objects/typeobject.c` 里的 :c:func:`!super_getattro` 中找到。 "
"纯 Python 的等价实现可在 `Guido 的教程 "
"<https://www.python.org/download/releases/2.2.3/descrintro/#cooperation>`_ "
"中找到。"

#: ../../howto/descriptor.rst:807
msgid "Summary of invocation logic"
msgstr "调用逻辑总结"

#: ../../howto/descriptor.rst:809
msgid ""
"The mechanism for descriptors is embedded in the "
":meth:`~object.__getattribute__` methods for :class:`object`, :class:`type`,"
" and :func:`super`."
msgstr ""
"描述器的机制嵌入在 :class:`object`, :class:`type` 和 :func:`super` 的 "
":meth:`~object.__getattribute__` 方法中。"

#: ../../howto/descriptor.rst:812
msgid "The important points to remember are:"
msgstr "要记住的重要点是："

#: ../../howto/descriptor.rst:814
msgid ""
"Descriptors are invoked by the :meth:`~object.__getattribute__` method."
msgstr "描述器将由 :meth:`~object.__getattribute__` 方法唤起。"

#: ../../howto/descriptor.rst:816
msgid ""
"Classes inherit this machinery from :class:`object`, :class:`type`, or "
":func:`super`."
msgstr "类从 :class:`object`，:class:`type` 或 :func:`super` 继承此机制。"

#: ../../howto/descriptor.rst:819
msgid ""
"Overriding :meth:`~object.__getattribute__` prevents automatic descriptor "
"calls because all the descriptor logic is in that method."
msgstr "重写 :meth:`~object.__getattribute__` 将阻止自动的描述器调用因为所有描述器逻辑都在该方法中。"

#: ../../howto/descriptor.rst:822
msgid ""
":meth:`!object.__getattribute__` and :meth:`!type.__getattribute__` make "
"different calls to :meth:`~object.__get__`.  The first includes the instance"
" and may include the class.  The second puts in ``None`` for the instance "
"and always includes the class."
msgstr ""
":meth:`!object.__getattribute__` 和 :meth:`!type.__getattribute__` 会用不同方式调用 "
":meth:`~object.__get__`。 第一个会包括实例并可能包括类 。第二个会将 ``None`` 作为实例并且总是包括类。"

#: ../../howto/descriptor.rst:827
msgid "Data descriptors always override instance dictionaries."
msgstr "数据描述器始终会覆盖实例字典。"

#: ../../howto/descriptor.rst:829
msgid "Non-data descriptors may be overridden by instance dictionaries."
msgstr "非数据描述器会被实例字典覆盖。"

#: ../../howto/descriptor.rst:833
msgid "Automatic name notification"
msgstr "自动名称通知"

#: ../../howto/descriptor.rst:835
msgid ""
"Sometimes it is desirable for a descriptor to know what class variable name "
"it was assigned to.  When a new class is created, the :class:`type` "
"metaclass scans the dictionary of the new class.  If any of the entries are "
"descriptors and if they define :meth:`~object.__set_name__`, that method is "
"called with two arguments.  The *owner* is the class where the descriptor is"
" used, and the *name* is the class variable the descriptor was assigned to."
msgstr ""
"有时描述器需要知道它被赋值到哪个变量名。 当一个新类被创建时，:class:`type` 元类将扫描新类的字典。 "
"如果其中有任何条目是描述器并且它们定义了 :meth:`~object.__set_name__`，则该方法被调用时将附带两个参数。 *owner* "
"是使用该描述器的类，而 *name* 是该描述器被赋值到的变量。"

#: ../../howto/descriptor.rst:842
msgid ""
"The implementation details are in :c:func:`!type_new` and "
":c:func:`!set_names` in :source:`Objects/typeobject.c`."
msgstr ""
"实现的细节在 :source:`Objects/typeobject.c` 里的 :c:func:`!type_new` 和 "
":c:func:`!set_names` 中。"

#: ../../howto/descriptor.rst:845
msgid ""
"Since the update logic is in :meth:`!type.__new__`, notifications only take "
"place at the time of class creation.  If descriptors are added to the class "
"afterwards, :meth:`~object.__set_name__` will need to be called manually."
msgstr ""
"由于更新逻辑是在 :meth:`!type.__new__` 中，因此通知仅在类创建时发出。 之后如果将描述器添加到类中，则需要手动调用 "
":meth:`~object.__set_name__`。"

#: ../../howto/descriptor.rst:851
msgid "ORM example"
msgstr "ORM （对象关系映射）示例"

#: ../../howto/descriptor.rst:853
msgid ""
"The following code is a simplified skeleton showing how data descriptors "
"could be used to implement an `object relational mapping "
"<https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping>`_."
msgstr ""
"以下代码展示了如何使用数据描述器来实现简单的 `对象关系映射 "
"<https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping>`_ 框架。"

#: ../../howto/descriptor.rst:857
msgid ""
"The essential idea is that the data is stored in an external database.  The "
"Python instances only hold keys to the database's tables.  Descriptors take "
"care of lookups or updates:"
msgstr "其核心思路是将数据存储在外部数据库中，Python 实例仅持有数据库表中对应的的键。描述器负责对值进行查找或更新："

#: ../../howto/descriptor.rst:861
msgid ""
"class Field:\n"
"\n"
"    def __set_name__(self, owner, name):\n"
"        self.fetch = f'SELECT {name} FROM {owner.table} WHERE {owner.key}=?;'\n"
"        self.store = f'UPDATE {owner.table} SET {name}=? WHERE {owner.key}=?;'\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        return conn.execute(self.fetch, [obj.key]).fetchone()[0]\n"
"\n"
"    def __set__(self, obj, value):\n"
"        conn.execute(self.store, [value, obj.key])\n"
"        conn.commit()"
msgstr ""
"class Field:\n"
"\n"
"    def __set_name__(self, owner, name):\n"
"        self.fetch = f'SELECT {name} FROM {owner.table} WHERE {owner.key}=?;'\n"
"        self.store = f'UPDATE {owner.table} SET {name}=? WHERE {owner.key}=?;'\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        return conn.execute(self.fetch, [obj.key]).fetchone()[0]\n"
"\n"
"    def __set__(self, obj, value):\n"
"        conn.execute(self.store, [value, obj.key])\n"
"        conn.commit()"

#: ../../howto/descriptor.rst:876
msgid ""
"We can use the :class:`!Field` class to define `models "
"<https://en.wikipedia.org/wiki/Database_model>`_ that describe the schema "
"for each table in a database:"
msgstr ""
"我们可以使用 :class:`!Field` 类来定义描述了数据库中每张表的结构的 `模型 "
"<https://en.wikipedia.org/wiki/Database_model>`_:"

#: ../../howto/descriptor.rst:880
msgid ""
"class Movie:\n"
"    table = 'Movies'                    # Table name\n"
"    key = 'title'                       # Primary key\n"
"    director = Field()\n"
"    year = Field()\n"
"\n"
"    def __init__(self, key):\n"
"        self.key = key\n"
"\n"
"class Song:\n"
"    table = 'Music'\n"
"    key = 'title'\n"
"    artist = Field()\n"
"    year = Field()\n"
"    genre = Field()\n"
"\n"
"    def __init__(self, key):\n"
"        self.key = key"
msgstr ""
"class Movie:\n"
"    table = 'Movies'                    # 表名\n"
"    key = 'title'                       # 主键\n"
"    director = Field()\n"
"    year = Field()\n"
"\n"
"    def __init__(self, key):\n"
"        self.key = key\n"
"\n"
"class Song:\n"
"    table = 'Music'\n"
"    key = 'title'\n"
"    artist = Field()\n"
"    year = Field()\n"
"    genre = Field()\n"
"\n"
"    def __init__(self, key):\n"
"        self.key = key"

#: ../../howto/descriptor.rst:901
msgid "To use the models, first connect to the database::"
msgstr "要使用模型，首先要连接到数据库："

#: ../../howto/descriptor.rst:903
msgid ""
">>> import sqlite3\n"
">>> conn = sqlite3.connect('entertainment.db')"
msgstr ""
">>> import sqlite3\n"
">>> conn = sqlite3.connect('entertainment.db')"

#: ../../howto/descriptor.rst:906
msgid ""
"An interactive session shows how data is retrieved from the database and how"
" it can be updated:"
msgstr "交互式会话显示了如何从数据库中检索数据及如何对其进行更新："

#: ../../howto/descriptor.rst:934
msgid ""
">>> Movie('Star Wars').director\n"
"'George Lucas'\n"
">>> jaws = Movie('Jaws')\n"
">>> f'Released in {jaws.year} by {jaws.director}'\n"
"'Released in 1975 by Steven Spielberg'\n"
"\n"
">>> Song('Country Roads').artist\n"
"'John Denver'\n"
"\n"
">>> Movie('Star Wars').director = 'J.J. Abrams'\n"
">>> Movie('Star Wars').director\n"
"'J.J. Abrams'"
msgstr ""
">>> Movie('Star Wars').director\n"
"'George Lucas'\n"
">>> jaws = Movie('Jaws')\n"
">>> f'Released in {jaws.year} by {jaws.director}'\n"
"'Released in 1975 by Steven Spielberg'\n"
"\n"
">>> Song('Country Roads').artist\n"
"'John Denver'\n"
"\n"
">>> Movie('Star Wars').director = 'J.J. Abrams'\n"
">>> Movie('Star Wars').director\n"
"'J.J. Abrams'"

#: ../../howto/descriptor.rst:955
msgid "Pure Python Equivalents"
msgstr "纯 Python 等价实现"

#: ../../howto/descriptor.rst:957
msgid ""
"The descriptor protocol is simple and offers exciting possibilities.  "
"Several use cases are so common that they have been prepackaged into built-"
"in tools. Properties, bound methods, static methods, class methods, and "
"\\_\\_slots\\_\\_ are all based on the descriptor protocol."
msgstr ""
"描述器协议很简单，但它提供了令人兴奋的可能性。有几个用例非常通用，以至于它们已预先打包到内置工具中。属性、绑定方法、静态方法、类方法和 "
"__slots__ 均基于描述器协议。"

#: ../../howto/descriptor.rst:964
msgid "Properties"
msgstr "属性"

#: ../../howto/descriptor.rst:966
msgid ""
"Calling :func:`property` is a succinct way of building a data descriptor "
"that triggers a function call upon access to an attribute.  Its signature "
"is::"
msgstr "调用 :func:`property` 是构建数据描述器的简洁方式，该数据描述器在访问属性时触发函数调用。它的签名是："

#: ../../howto/descriptor.rst:969
msgid "property(fget=None, fset=None, fdel=None, doc=None) -> property"
msgstr "property(fget=None, fset=None, fdel=None, doc=None) -> property"

#: ../../howto/descriptor.rst:971
msgid ""
"The documentation shows a typical use to define a managed attribute ``x``:"
msgstr "该文档显示了定义托管属性 ``x`` 的典型用法："

#: ../../howto/descriptor.rst:973
msgid ""
"class C:\n"
"    def getx(self): return self.__x\n"
"    def setx(self, value): self.__x = value\n"
"    def delx(self): del self.__x\n"
"    x = property(getx, setx, delx, \"I'm the 'x' property.\")"
msgstr ""
"class C:\n"
"    def getx(self): return self.__x\n"
"    def setx(self, value): self.__x = value\n"
"    def delx(self): del self.__x\n"
"    x = property(getx, setx, delx, \"I'm the 'x' property.\")"

#: ../../howto/descriptor.rst:995
msgid ""
"To see how :func:`property` is implemented in terms of the descriptor "
"protocol, here is a pure Python equivalent that implements most of the core "
"functionality:"
msgstr "要了解 :func:`property` 是如何按描述器协议的方式来实现的，以下是一个实现了大部分核心功能的纯 Python 等价实现："

#: ../../howto/descriptor.rst:998
msgid ""
"class Property:\n"
"    \"Emulate PyProperty_Type() in Objects/descrobject.c\"\n"
"\n"
"    def __init__(self, fget=None, fset=None, fdel=None, doc=None):\n"
"        self.fget = fget\n"
"        self.fset = fset\n"
"        self.fdel = fdel\n"
"        if doc is None and fget is not None:\n"
"            doc = fget.__doc__\n"
"        self.__doc__ = doc\n"
"\n"
"    def __set_name__(self, owner, name):\n"
"        self.__name__ = name\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        if obj is None:\n"
"            return self\n"
"        if self.fget is None:\n"
"            raise AttributeError\n"
"        return self.fget(obj)\n"
"\n"
"    def __set__(self, obj, value):\n"
"        if self.fset is None:\n"
"            raise AttributeError\n"
"        self.fset(obj, value)\n"
"\n"
"    def __delete__(self, obj):\n"
"        if self.fdel is None:\n"
"            raise AttributeError\n"
"        self.fdel(obj)\n"
"\n"
"    def getter(self, fget):\n"
"        return type(self)(fget, self.fset, self.fdel, self.__doc__)\n"
"\n"
"    def setter(self, fset):\n"
"        return type(self)(self.fget, fset, self.fdel, self.__doc__)\n"
"\n"
"    def deleter(self, fdel):\n"
"        return type(self)(self.fget, self.fset, fdel, self.__doc__)"
msgstr ""
"class Property:\n"
"    \"Emulate PyProperty_Type() in Objects/descrobject.c\"\n"
"\n"
"    def __init__(self, fget=None, fset=None, fdel=None, doc=None):\n"
"        self.fget = fget\n"
"        self.fset = fset\n"
"        self.fdel = fdel\n"
"        if doc is None and fget is not None:\n"
"            doc = fget.__doc__\n"
"        self.__doc__ = doc\n"
"\n"
"    def __set_name__(self, owner, name):\n"
"        self.__name__ = name\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        if obj is None:\n"
"            return self\n"
"        if self.fget is None:\n"
"            raise AttributeError\n"
"        return self.fget(obj)\n"
"\n"
"    def __set__(self, obj, value):\n"
"        if self.fset is None:\n"
"            raise AttributeError\n"
"        self.fset(obj, value)\n"
"\n"
"    def __delete__(self, obj):\n"
"        if self.fdel is None:\n"
"            raise AttributeError\n"
"        self.fdel(obj)\n"
"\n"
"    def getter(self, fget):\n"
"        return type(self)(fget, self.fset, self.fdel, self.__doc__)\n"
"\n"
"    def setter(self, fset):\n"
"        return type(self)(self.fget, fset, self.fdel, self.__doc__)\n"
"\n"
"    def deleter(self, fdel):\n"
"        return type(self)(self.fget, self.fset, fdel, self.__doc__)"

#: ../../howto/descriptor.rst:1122
msgid ""
"The :func:`property` builtin helps whenever a user interface has granted "
"attribute access and then subsequent changes require the intervention of a "
"method."
msgstr "这个内置的 :func:`property` 每当用户访问属性时生效，随后的变化需要一个方法的参与。"

#: ../../howto/descriptor.rst:1126
msgid ""
"For instance, a spreadsheet class may grant access to a cell value through "
"``Cell('b10').value``. Subsequent improvements to the program require the "
"cell to be recalculated on every access; however, the programmer does not "
"want to affect existing client code accessing the attribute directly.  The "
"solution is to wrap access to the value attribute in a property data "
"descriptor:"
msgstr ""
"例如，一个电子表格类可以通过 ``Cell('b10').value`` "
"授予对单元格值的访问权限。对程序的后续改进要求每次访问都要重新计算单元格；但是，程序员不希望影响直接访问该属性的现有客户端代码。解决方案是将对 "
"value 属性的访问包装在属性数据描述器中:"

#: ../../howto/descriptor.rst:1132
msgid ""
"class Cell:\n"
"    ...\n"
"\n"
"    @property\n"
"    def value(self):\n"
"        \"Recalculate the cell before returning value\"\n"
"        self.recalc()\n"
"        return self._value"
msgstr ""
"class Cell:\n"
"    ...\n"
"\n"
"    @property\n"
"    def value(self):\n"
"        \"Recalculate the cell before returning value\"\n"
"        self.recalc()\n"
"        return self._value"

#: ../../howto/descriptor.rst:1143
msgid ""
"Either the built-in :func:`property` or our :func:`!Property` equivalent "
"would work in this example."
msgstr "在这个例子中内置的 :func:`property` 或我们的 :func:`!Property` 等价实现都是可以的。"

#: ../../howto/descriptor.rst:1148
msgid "Functions and methods"
msgstr "函数和方法"

#: ../../howto/descriptor.rst:1150
msgid ""
"Python's object oriented features are built upon a function based "
"environment. Using non-data descriptors, the two are merged seamlessly."
msgstr "Python 的面向对象功能是在基于函数的环境构建的。通过使用非数据描述器，这两方面完成了无缝融合。"

#: ../../howto/descriptor.rst:1153
msgid ""
"Functions stored in class dictionaries get turned into methods when invoked."
" Methods only differ from regular functions in that the object instance is "
"prepended to the other arguments.  By convention, the instance is called "
"*self* but could be called *this* or any other variable name."
msgstr ""
"在调用时，存储在类词典中的函数将被转换为方法。方法与常规函数的不同之处仅在于对象实例被置于其他参数之前。方法与常规函数的不同之处仅在于第一个参数是为对象实例保留的。按照惯例，实例引用称为"
" *self* ，但也可以称为 *this* 或任何其他变量名称。"

#: ../../howto/descriptor.rst:1158
msgid ""
"Methods can be created manually with :class:`types.MethodType` which is "
"roughly equivalent to:"
msgstr "可以使用 :class:`types.MethodType` 手动创建方法，其行为基本等价于："

#: ../../howto/descriptor.rst:1161
msgid ""
"class MethodType:\n"
"    \"Emulate PyMethod_Type in Objects/classobject.c\"\n"
"\n"
"    def __init__(self, func, obj):\n"
"        self.__func__ = func\n"
"        self.__self__ = obj\n"
"\n"
"    def __call__(self, *args, **kwargs):\n"
"        func = self.__func__\n"
"        obj = self.__self__\n"
"        return func(obj, *args, **kwargs)\n"
"\n"
"    def __getattribute__(self, name):\n"
"        \"Emulate method_getset() in Objects/classobject.c\"\n"
"        if name == '__doc__':\n"
"            return self.__func__.__doc__\n"
"        return object.__getattribute__(self, name)\n"
"\n"
"    def __getattr__(self, name):\n"
"        \"Emulate method_getattro() in Objects/classobject.c\"\n"
"        return getattr(self.__func__, name)\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        \"Emulate method_descr_get() in Objects/classobject.c\"\n"
"        return self"
msgstr ""
"class MethodType:\n"
"    \"Emulate PyMethod_Type in Objects/classobject.c\"\n"
"\n"
"    def __init__(self, func, obj):\n"
"        self.__func__ = func\n"
"        self.__self__ = obj\n"
"\n"
"    def __call__(self, *args, **kwargs):\n"
"        func = self.__func__\n"
"        obj = self.__self__\n"
"        return func(obj, *args, **kwargs)\n"
"\n"
"    def __getattribute__(self, name):\n"
"        \"Emulate method_getset() in Objects/classobject.c\"\n"
"        if name == '__doc__':\n"
"            return self.__func__.__doc__\n"
"        return object.__getattribute__(self, name)\n"
"\n"
"    def __getattr__(self, name):\n"
"        \"Emulate method_getattro() in Objects/classobject.c\"\n"
"        return getattr(self.__func__, name)\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        \"Emulate method_descr_get() in Objects/classobject.c\"\n"
"        return self"

#: ../../howto/descriptor.rst:1189
msgid ""
"To support automatic creation of methods, functions include the "
":meth:`~object.__get__` method for binding methods during attribute access."
"  This means that functions are non-data descriptors that return bound "
"methods during dotted lookup from an instance.  Here's how it works:"
msgstr ""
"为支持方法的自动创建，函数会包括 :meth:`~object.__get__` 方法以便在属性访问期间绑定方法。 "
"这意味着函数就是在通过实例进行点号查找期间返回所绑定方法的非数据描述器。 其运作方式是这样的："

#: ../../howto/descriptor.rst:1194
msgid ""
"class Function:\n"
"    ...\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        \"Simulate func_descr_get() in Objects/funcobject.c\"\n"
"        if obj is None:\n"
"            return self\n"
"        return MethodType(self, obj)"
msgstr ""
"class Function:\n"
"    ...\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        \"Simulate func_descr_get() in Objects/funcobject.c\"\n"
"        if obj is None:\n"
"            return self\n"
"        return MethodType(self, obj)"

#: ../../howto/descriptor.rst:1205
msgid ""
"Running the following class in the interpreter shows how the function "
"descriptor works in practice:"
msgstr "在解释器中运行以下类，这显示了函数描述器的实际工作方式："

#: ../../howto/descriptor.rst:1208
msgid ""
"class D:\n"
"    def f(self):\n"
"         return self\n"
"\n"
"class D2:\n"
"    pass"
msgstr ""
"class D:\n"
"    def f(self):\n"
"         return self\n"
"\n"
"class D2:\n"
"    pass"

#: ../../howto/descriptor.rst:1226
msgid ""
"The function has a :term:`qualified name` attribute to support "
"introspection:"
msgstr "该函数具有 :term:`qualified name` 属性以支持自省："

#: ../../howto/descriptor.rst:1228
msgid ""
">>> D.f.__qualname__\n"
"'D.f'"
msgstr ""
">>> D.f.__qualname__\n"
"'D.f'"

#: ../../howto/descriptor.rst:1233
msgid ""
"Accessing the function through the class dictionary does not invoke "
":meth:`~object.__get__`.  Instead, it just returns the underlying function "
"object::"
msgstr "通过类字典访问函数不会唤起 :meth:`~object.__get__`。 相反，它只是返回下层的函数对象::"

#: ../../howto/descriptor.rst:1236
msgid ""
">>> D.__dict__['f']\n"
"<function D.f at 0x00C45070>"
msgstr ""
">>> D.__dict__['f']\n"
"<function D.f at 0x00C45070>"

#: ../../howto/descriptor.rst:1239
msgid ""
"Dotted access from a class calls :meth:`~object.__get__` which just returns "
"the underlying function unchanged::"
msgstr "通过类进行点号访问调用 :meth:`~object.__get__`，它将只原样返回下层的函数::"

#: ../../howto/descriptor.rst:1242
msgid ""
">>> D.f\n"
"<function D.f at 0x00C45070>"
msgstr ""
">>> D.f\n"
"<function D.f at 0x00C45070>"

#: ../../howto/descriptor.rst:1245
msgid ""
"The interesting behavior occurs during dotted access from an instance.  The "
"dotted lookup calls :meth:`~object.__get__` which returns a bound method "
"object::"
msgstr "有趣的行为发生在通过实例进行点号访问期间。 点号查找调用 :meth:`~object.__get__`，它将返回绑定的方法对象::"

#: ../../howto/descriptor.rst:1248
msgid ""
">>> d = D()\n"
">>> d.f\n"
"<bound method D.f of <__main__.D object at 0x00B18C90>>"
msgstr ""
">>> d = D()\n"
">>> d.f\n"
"<bound method D.f of <__main__.D object at 0x00B18C90>>"

#: ../../howto/descriptor.rst:1252
msgid ""
"Internally, the bound method stores the underlying function and the bound "
"instance::"
msgstr "绑定方法在内部存储了底层函数和绑定的实例："

#: ../../howto/descriptor.rst:1255
msgid ""
">>> d.f.__func__\n"
"<function D.f at 0x00C45070>\n"
"\n"
">>> d.f.__self__\n"
"<__main__.D object at 0x00B18C90>"
msgstr ""
">>> d.f.__func__\n"
"<function D.f at 0x00C45070>\n"
"\n"
">>> d.f.__self__\n"
"<__main__.D object at 0x00B18C90>"

#: ../../howto/descriptor.rst:1261
msgid ""
"If you have ever wondered where *self* comes from in regular methods or "
"where *cls* comes from in class methods, this is it!"
msgstr "如果你曾好奇常规方法中的 *self* 或类方法中的 *cls* 是从什么地方来的，就是这里了！"

#: ../../howto/descriptor.rst:1266
msgid "Kinds of methods"
msgstr "方法的种类"

#: ../../howto/descriptor.rst:1268
msgid ""
"Non-data descriptors provide a simple mechanism for variations on the usual "
"patterns of binding functions into methods."
msgstr "非数据描述器为把函数绑定为方法的通常模式提供了一种简单的机制。"

#: ../../howto/descriptor.rst:1271
msgid ""
"To recap, functions have a :meth:`~object.__get__` method so that they can "
"be converted to a method when accessed as attributes.  The non-data "
"descriptor transforms an ``obj.f(*args)`` call into ``f(obj, *args)``.  "
"Calling ``cls.f(*args)`` becomes ``f(*args)``."
msgstr ""
"总结一下，函数具有 :meth:`~object.__get__` 方法以便在其作为属性被访问时可被转换为方法。 非数据描述器会将 "
"``obj.f(*args)`` 调用转化为 ``f(obj, *args)``。 调用 ``cls.f(*args)`` 将变成 "
"``f(*args)``。"

#: ../../howto/descriptor.rst:1276
msgid "This chart summarizes the binding and its two most useful variants:"
msgstr "下表总结了绑定及其两个最有用的变体："

#: ../../howto/descriptor.rst:1279
msgid "Transformation"
msgstr "转换形式"

#: ../../howto/descriptor.rst:1279
msgid "Called from an object"
msgstr "通过对象调用"

#: ../../howto/descriptor.rst:1279
msgid "Called from a class"
msgstr "通过类调用"

#: ../../howto/descriptor.rst:1282
msgid "function"
msgstr "function -- 函数"

#: ../../howto/descriptor.rst:1282
msgid "f(obj, \\*args)"
msgstr "f(obj, \\*args)"

#: ../../howto/descriptor.rst:1282 ../../howto/descriptor.rst:1284
msgid "f(\\*args)"
msgstr "f(\\*args)"

#: ../../howto/descriptor.rst:1284
msgid "staticmethod"
msgstr "静态方法"

#: ../../howto/descriptor.rst:1286
msgid "classmethod"
msgstr "类方法"

#: ../../howto/descriptor.rst:1286
msgid "f(type(obj), \\*args)"
msgstr "f(type(obj), \\*args)"

#: ../../howto/descriptor.rst:1286
msgid "f(cls, \\*args)"
msgstr "f(cls, \\*args)"

#: ../../howto/descriptor.rst:1291
msgid "Static methods"
msgstr "静态方法"

#: ../../howto/descriptor.rst:1293
msgid ""
"Static methods return the underlying function without changes.  Calling "
"either ``c.f`` or ``C.f`` is the equivalent of a direct lookup into "
"``object.__getattribute__(c, \"f\")`` or ``object.__getattribute__(C, "
"\"f\")``. As a result, the function becomes identically accessible from "
"either an object or a class."
msgstr ""
"静态方法返回底层函数，不做任何更改。调用 ``c.f`` 或 ``C.f`` 等效于通过 ``object.__getattribute__(c, "
"\"f\")`` 或 ``object.__getattribute__(C, \"f\")`` 查找。这样该函数就可以从对象或类中进行相同的访问。"

#: ../../howto/descriptor.rst:1299
msgid ""
"Good candidates for static methods are methods that do not reference the "
"``self`` variable."
msgstr "适合作为静态方法的是那些不引用 ``self`` 变量的方法。"

#: ../../howto/descriptor.rst:1302
msgid ""
"For instance, a statistics package may include a container class for "
"experimental data.  The class provides normal methods for computing the "
"average, mean, median, and other descriptive statistics that depend on the "
"data. However, there may be useful functions which are conceptually related "
"but do not depend on the data.  For instance, ``erf(x)`` is handy conversion"
" routine that comes up in statistical work but does not directly depend on a"
" particular dataset. It can be called either from an object or the class:  "
"``s.erf(1.5) --> 0.9332`` or ``Sample.erf(1.5) --> 0.9332``."
msgstr ""
"举例来说，一个统计软件包可能包括存放实验性数据的容器类。 该类提供了用于计算平均数、均值、中位数以及其他描述性的统计数据的方法。 "
"不过，还可能存在在概念上相关但不依赖于这些数据的有用函数。 例如，``erf(x)`` 是在统计工作中的便捷转换例程但并不直接依赖于特定的数据集。 "
"它可以通过对象或者类来调用: ``s.erf(1.5) --> 0.9332`` 或者 ``Sample.erf(1.5) --> 0.9332``。"

#: ../../howto/descriptor.rst:1311
msgid ""
"Since static methods return the underlying function with no changes, the "
"example calls are unexciting:"
msgstr "由于静态方法返回的底层函数没有任何变化，因此示例调用也是意料之中："

#: ../../howto/descriptor.rst:1314
msgid ""
"class E:\n"
"    @staticmethod\n"
"    def f(x):\n"
"        return x * 10"
msgstr ""
"class E:\n"
"    @staticmethod\n"
"    def f(x):\n"
"        return x * 10"

#: ../../howto/descriptor.rst:1321
msgid ""
">>> E.f(3)\n"
"30\n"
">>> E().f(3)\n"
"30"
msgstr ""
">>> E.f(3)\n"
"30\n"
">>> E().f(3)\n"
"30"

#: ../../howto/descriptor.rst:1328
msgid ""
"Using the non-data descriptor protocol, a pure Python version of "
":func:`staticmethod` would look like this:"
msgstr "使用非数据描述器，纯 Python 版本的 :func:`staticmethod` 如下所示："

#: ../../howto/descriptor.rst:1331
msgid ""
"import functools\n"
"\n"
"class StaticMethod:\n"
"    \"Emulate PyStaticMethod_Type() in Objects/funcobject.c\"\n"
"\n"
"    def __init__(self, f):\n"
"        self.f = f\n"
"        functools.update_wrapper(self, f)\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        return self.f\n"
"\n"
"    def __call__(self, *args, **kwds):\n"
"        return self.f(*args, **kwds)\n"
"\n"
"    @property\n"
"    def __annotations__(self):\n"
"        return self.f.__annotations__"
msgstr ""

#: ../../howto/descriptor.rst:1352
msgid ""
"The :func:`functools.update_wrapper` call adds a ``__wrapped__`` attribute "
"that refers to the underlying function.  Also it carries forward the "
"attributes necessary to make the wrapper look like the wrapped function, "
"including :attr:`~function.__name__`, :attr:`~function.__qualname__`, and "
":attr:`~function.__doc__`."
msgstr ""

#: ../../howto/descriptor.rst:1421
msgid "Class methods"
msgstr "类方法"

#: ../../howto/descriptor.rst:1423
msgid ""
"Unlike static methods, class methods prepend the class reference to the "
"argument list before calling the function.  This format is the same for "
"whether the caller is an object or a class:"
msgstr "与静态方法不同，类方法在调用函数之前将类引用放在参数列表的最前。无论调用方是对象还是类，此格式相同："

#: ../../howto/descriptor.rst:1427
msgid ""
"class F:\n"
"    @classmethod\n"
"    def f(cls, x):\n"
"        return cls.__name__, x"
msgstr ""
"class F:\n"
"    @classmethod\n"
"    def f(cls, x):\n"
"        return cls.__name__, x"

#: ../../howto/descriptor.rst:1434
msgid ""
">>> F.f(3)\n"
"('F', 3)\n"
">>> F().f(3)\n"
"('F', 3)"
msgstr ""
">>> F.f(3)\n"
"('F', 3)\n"
">>> F().f(3)\n"
"('F', 3)"

#: ../../howto/descriptor.rst:1441
msgid ""
"This behavior is useful whenever the method only needs to have a class "
"reference and does not rely on data stored in a specific instance.  One use "
"for class methods is to create alternate class constructors.  For example, "
"the classmethod :func:`dict.fromkeys` creates a new dictionary from a list "
"of keys.  The pure Python equivalent is:"
msgstr ""
"当方法仅需要具有类引用并且确实依赖于存储在特定实例中的数据时，此行为就很有用。类方法的一种用途是创建备用类构造函数。例如，类方法  "
":func:`dict.fromkeys` 从键列表创建一个新字典。纯 Python 的等价实现是："

#: ../../howto/descriptor.rst:1447
msgid ""
"class Dict(dict):\n"
"    @classmethod\n"
"    def fromkeys(cls, iterable, value=None):\n"
"        \"Emulate dict_fromkeys() in Objects/dictobject.c\"\n"
"        d = cls()\n"
"        for key in iterable:\n"
"            d[key] = value\n"
"        return d"
msgstr ""
"class Dict(dict):\n"
"    @classmethod\n"
"    def fromkeys(cls, iterable, value=None):\n"
"        \"Emulate dict_fromkeys() in Objects/dictobject.c\"\n"
"        d = cls()\n"
"        for key in iterable:\n"
"            d[key] = value\n"
"        return d"

#: ../../howto/descriptor.rst:1458
msgid "Now a new dictionary of unique keys can be constructed like this:"
msgstr "现在可以这样构造一个新的唯一键字典："

#: ../../howto/descriptor.rst:1460
msgid ""
">>> d = Dict.fromkeys('abracadabra')\n"
">>> type(d) is Dict\n"
"True\n"
">>> d\n"
"{'a': None, 'b': None, 'r': None, 'c': None, 'd': None}"
msgstr ""
">>> d = Dict.fromkeys('abracadabra')\n"
">>> type(d) is Dict\n"
"True\n"
">>> d\n"
"{'a': None, 'b': None, 'r': None, 'c': None, 'd': None}"

#: ../../howto/descriptor.rst:1468
msgid ""
"Using the non-data descriptor protocol, a pure Python version of "
":func:`classmethod` would look like this:"
msgstr "使用非数据描述器协议，纯 Python 版本的 :func:`classmethod` 如下："

#: ../../howto/descriptor.rst:1471
msgid ""
"import functools\n"
"\n"
"class ClassMethod:\n"
"    \"Emulate PyClassMethod_Type() in Objects/funcobject.c\"\n"
"\n"
"    def __init__(self, f):\n"
"        self.f = f\n"
"        functools.update_wrapper(self, f)\n"
"\n"
"    def __get__(self, obj, cls=None):\n"
"        if cls is None:\n"
"            cls = type(obj)\n"
"        return MethodType(self.f, cls)"
msgstr ""
"import functools\n"
"\n"
"class ClassMethod:\n"
"    \"Emulate PyClassMethod_Type() in Objects/funcobject.c\"\n"
"\n"
"    def __init__(self, f):\n"
"        self.f = f\n"
"        functools.update_wrapper(self, f)\n"
"\n"
"    def __get__(self, obj, cls=None):\n"
"        if cls is None:\n"
"            cls = type(obj)\n"
"        return MethodType(self.f, cls)"

#: ../../howto/descriptor.rst:1533
msgid ""
"The :func:`functools.update_wrapper` call in ``ClassMethod`` adds a "
"``__wrapped__`` attribute that refers to the underlying function.  Also it "
"carries forward the attributes necessary to make the wrapper look like the "
"wrapped function: :attr:`~function.__name__`, "
":attr:`~function.__qualname__`, :attr:`~function.__doc__`, and "
":attr:`~function.__annotations__`."
msgstr ""
"``ClassMethod`` 中的 :func:`functools.update_wrapper` 调用增加了一个指向下层函数的 "
"``__wrapped__`` 属性。 它还会向前传递必要的属性以使此包装器看起来像是被包装的函数: "
":attr:`~function.__name__`, :attr:`~function.__qualname__`, "
":attr:`~function.__doc__` 以及 :attr:`~function.__annotations__`。"

#: ../../howto/descriptor.rst:1542
msgid "Member objects and __slots__"
msgstr "成员对象和 __slots__"

#: ../../howto/descriptor.rst:1544
msgid ""
"When a class defines ``__slots__``, it replaces instance dictionaries with a"
" fixed-length array of slot values.  From a user point of view that has "
"several effects:"
msgstr "当一个类定义了 ``__slots__``，它会用一个固定长度的 slot 值数组来替换实例字典。 从用户的视角看，效果是这样的："

#: ../../howto/descriptor.rst:1548
msgid ""
"1. Provides immediate detection of bugs due to misspelled attribute "
"assignments.  Only attribute names specified in ``__slots__`` are allowed:"
msgstr "1. 提供对由错误拼写的属性赋值导致的程序缺陷的即时检测。只允许在 ``__slots__`` 中指定的属性名称："

#: ../../howto/descriptor.rst:1551
msgid ""
"class Vehicle:\n"
"    __slots__ = ('id_number', 'make', 'model')"
msgstr ""
"class Vehicle:\n"
"    __slots__ = ('id_number', 'make', 'model')"

#: ../../howto/descriptor.rst:1556
msgid ""
">>> auto = Vehicle()\n"
">>> auto.id_nubmer = 'VYE483814LQEX'\n"
"Traceback (most recent call last):\n"
"    ...\n"
"AttributeError: 'Vehicle' object has no attribute 'id_nubmer'"
msgstr ""
">>> auto = Vehicle()\n"
">>> auto.id_nubmer = 'VYE483814LQEX'\n"
"Traceback (most recent call last):\n"
"    ...\n"
"AttributeError: 'Vehicle' object has no attribute 'id_nubmer'"

#: ../../howto/descriptor.rst:1564
msgid ""
"2. Helps create immutable objects where descriptors manage access to private"
" attributes stored in ``__slots__``:"
msgstr "2. 帮助创建由描述器来管理对保存在 ``__slots__`` 中的私有属性的访问的不可变对象："

#: ../../howto/descriptor.rst:1567
msgid ""
"class Immutable:\n"
"\n"
"    __slots__ = ('_dept', '_name')          # Replace the instance dictionary\n"
"\n"
"    def __init__(self, dept, name):\n"
"        self._dept = dept                   # Store to private attribute\n"
"        self._name = name                   # Store to private attribute\n"
"\n"
"    @property                               # Read-only descriptor\n"
"    def dept(self):\n"
"        return self._dept\n"
"\n"
"    @property\n"
"    def name(self):                         # Read-only descriptor\n"
"        return self._name"
msgstr ""
"class Immutable:\n"
"\n"
"    __slots__ = ('_dept', '_name')          # 替代实例字典\n"
"\n"
"    def __init__(self, dept, name):\n"
"        self._dept = dept                   # 保存到私有属性\n"
"        self._name = name                   # 保存到私有属性\n"
"\n"
"    @property                               # 只读描述器\n"
"    def dept(self):\n"
"        return self._dept\n"
"\n"
"    @property\n"
"    def name(self):                         # 只读描述器\n"
"        return self._name"

#: ../../howto/descriptor.rst:1585
msgid ""
">>> mark = Immutable('Botany', 'Mark Watney')\n"
">>> mark.dept\n"
"'Botany'\n"
">>> mark.dept = 'Space Pirate'\n"
"Traceback (most recent call last):\n"
"    ...\n"
"AttributeError: property 'dept' of 'Immutable' object has no setter\n"
">>> mark.location = 'Mars'\n"
"Traceback (most recent call last):\n"
"    ...\n"
"AttributeError: 'Immutable' object has no attribute 'location'"
msgstr ""
">>> mark = Immutable('Botany', 'Mark Watney')\n"
">>> mark.dept\n"
"'Botany'\n"
">>> mark.dept = 'Space Pirate'\n"
"Traceback (most recent call last):\n"
"    ...\n"
"AttributeError: property 'dept' of 'Immutable' object has no setter\n"
">>> mark.location = 'Mars'\n"
"Traceback (most recent call last):\n"
"    ...\n"
"AttributeError: 'Immutable' object has no attribute 'location'"

#: ../../howto/descriptor.rst:1599
msgid ""
"3. Saves memory.  On a 64-bit Linux build, an instance with two attributes "
"takes 48 bytes with ``__slots__`` and 152 bytes without.  This `flyweight "
"design pattern <https://en.wikipedia.org/wiki/Flyweight_pattern>`_ likely "
"only matters when a large number of instances are going to be created."
msgstr ""
"3. 节省内存。 在 64 位 Linux 版本上，带有两个属性的实例如果使用 ``__slots__`` 会占用 48 个字节，如果不使用则会占用 "
"152 个字节。 这种 `flyweight design pattern "
"<https://en.wikipedia.org/wiki/Flyweight_pattern>`_ 通常仅在要创建大量实例时才能显示效果。"

#: ../../howto/descriptor.rst:1604
msgid ""
"4. Improves speed.  Reading instance variables is 35% faster with "
"``__slots__`` (as measured with Python 3.10 on an Apple M1 processor)."
msgstr ""
"4. 提高速度。使用 ``__slots__`` 读取实例变量的速度提高了 35%（在 Apple M1 处理器上使用 Python 3.10 测量）。"

#: ../../howto/descriptor.rst:1607
msgid ""
"5. Blocks tools like :func:`functools.cached_property` which require an "
"instance dictionary to function correctly:"
msgstr "5. 阻止 :func:`functools.cached_property` 之类需要实例字典才能正常运作的工具："

#: ../../howto/descriptor.rst:1610
msgid ""
"from functools import cached_property\n"
"\n"
"class CP:\n"
"    __slots__ = ()                          # Eliminates the instance dict\n"
"\n"
"    @cached_property                        # Requires an instance dict\n"
"    def pi(self):\n"
"        return 4 * sum((-1.0)**n / (2.0*n + 1.0)\n"
"                       for n in reversed(range(100_000)))"
msgstr ""
"from functools import cached_property\n"
"\n"
"class CP:\n"
"    __slots__ = ()                          # 去除实例字典\n"
"\n"
"    @cached_property                        # 需要一个实例字典\n"
"    def pi(self):\n"
"        return 4 * sum((-1.0)**n / (2.0*n + 1.0)\n"
"                       for n in reversed(range(100_000)))"

#: ../../howto/descriptor.rst:1622
msgid ""
">>> CP().pi\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: No '__dict__' attribute on 'CP' instance to cache 'pi' property."
msgstr ""
">>> CP().pi\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: No '__dict__' attribute on 'CP' instance to cache 'pi' property."

#: ../../howto/descriptor.rst:1629
msgid ""
"It is not possible to create an exact drop-in pure Python version of "
"``__slots__`` because it requires direct access to C structures and control "
"over object memory allocation.  However, we can build a mostly faithful "
"simulation where the actual C structure for slots is emulated by a private "
"``_slotvalues`` list.  Reads and writes to that private structure are "
"managed by member descriptors:"
msgstr ""
"要创建一个一模一样的纯 Python 版的 ``__slots__`` 是不可能的，因为它需要直接访问 C 结构体并控制对象内存分配。 "
"但是，我们可以构建一个非常相似的模拟版，其中作为 slot 的实际 C 结构体由一个私有的 ``_slotvalues`` 列表来模拟。 "
"对该私有结构体的读写操作将由成员描述器来管理："

#: ../../howto/descriptor.rst:1636
msgid ""
"null = object()\n"
"\n"
"class Member:\n"
"\n"
"    def __init__(self, name, clsname, offset):\n"
"        'Emulate PyMemberDef in Include/structmember.h'\n"
"        # Also see descr_new() in Objects/descrobject.c\n"
"        self.name = name\n"
"        self.clsname = clsname\n"
"        self.offset = offset\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        'Emulate member_get() in Objects/descrobject.c'\n"
"        # Also see PyMember_GetOne() in Python/structmember.c\n"
"        if obj is None:\n"
"            return self\n"
"        value = obj._slotvalues[self.offset]\n"
"        if value is null:\n"
"            raise AttributeError(self.name)\n"
"        return value\n"
"\n"
"    def __set__(self, obj, value):\n"
"        'Emulate member_set() in Objects/descrobject.c'\n"
"        obj._slotvalues[self.offset] = value\n"
"\n"
"    def __delete__(self, obj):\n"
"        'Emulate member_delete() in Objects/descrobject.c'\n"
"        value = obj._slotvalues[self.offset]\n"
"        if value is null:\n"
"            raise AttributeError(self.name)\n"
"        obj._slotvalues[self.offset] = null\n"
"\n"
"    def __repr__(self):\n"
"        'Emulate member_repr() in Objects/descrobject.c'\n"
"        return f'<Member {self.name!r} of {self.clsname!r}>'"
msgstr ""
"null = object()\n"
"\n"
"class Member:\n"
"\n"
"    def __init__(self, name, clsname, offset):\n"
"        'Emulate PyMemberDef in Include/structmember.h'\n"
"        # 另请参阅 Objects/descrobject.c 中的 descr_new()\n"
"        self.name = name\n"
"        self.clsname = clsname\n"
"        self.offset = offset\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        'Emulate member_get() in Objects/descrobject.c'\n"
"        # 另请参阅 Python/structmember.c 中的 PyMember_GetOne()\n"
"        if obj is None:\n"
"            return self\n"
"        value = obj._slotvalues[self.offset]\n"
"        if value is null:\n"
"            raise AttributeError(self.name)\n"
"        return value\n"
"\n"
"    def __set__(self, obj, value):\n"
"        'Emulate member_set() in Objects/descrobject.c'\n"
"        obj._slotvalues[self.offset] = value\n"
"\n"
"    def __delete__(self, obj):\n"
"        'Emulate member_delete() in Objects/descrobject.c'\n"
"        value = obj._slotvalues[self.offset]\n"
"        if value is null:\n"
"            raise AttributeError(self.name)\n"
"        obj._slotvalues[self.offset] = null\n"
"\n"
"    def __repr__(self):\n"
"        'Emulate member_repr() in Objects/descrobject.c'\n"
"        return f'<Member {self.name!r} of {self.clsname!r}>'"

#: ../../howto/descriptor.rst:1674
msgid ""
"The :meth:`!type.__new__` method takes care of adding member objects to "
"class variables:"
msgstr ":meth:`!type.__new__` 方法负责将成员对象添加到类变量："

#: ../../howto/descriptor.rst:1677
msgid ""
"class Type(type):\n"
"    'Simulate how the type metaclass adds member objects for slots'\n"
"\n"
"    def __new__(mcls, clsname, bases, mapping, **kwargs):\n"
"        'Emulate type_new() in Objects/typeobject.c'\n"
"        # type_new() calls PyTypeReady() which calls add_methods()\n"
"        slot_names = mapping.get('slot_names', [])\n"
"        for offset, name in enumerate(slot_names):\n"
"            mapping[name] = Member(name, clsname, offset)\n"
"        return type.__new__(mcls, clsname, bases, mapping, **kwargs)"
msgstr ""
"class Type(type):\n"
"    'Simulate how the type metaclass adds member objects for slots'\n"
"\n"
"    def __new__(mcls, clsname, bases, mapping, **kwargs):\n"
"        'Emulate type_new() in Objects/typeobject.c'\n"
"        # type_new() 将调用 PyTypeReady()，后者将调用 add_methods()\n"
"        slot_names = mapping.get('slot_names', [])\n"
"        for offset, name in enumerate(slot_names):\n"
"            mapping[name] = Member(name, clsname, offset)\n"
"        return type.__new__(mcls, clsname, bases, mapping, **kwargs)"

#: ../../howto/descriptor.rst:1690
msgid ""
"The :meth:`object.__new__` method takes care of creating instances that have"
" slots instead of an instance dictionary.  Here is a rough simulation in "
"pure Python:"
msgstr ":meth:`object.__new__` 方法负责创建具有 slot 而非实例字典的实例。 以下是一个纯 Python 的粗略模拟版："

#: ../../howto/descriptor.rst:1694
msgid ""
"class Object:\n"
"    'Simulate how object.__new__() allocates memory for __slots__'\n"
"\n"
"    def __new__(cls, *args, **kwargs):\n"
"        'Emulate object_new() in Objects/typeobject.c'\n"
"        inst = super().__new__(cls)\n"
"        if hasattr(cls, 'slot_names'):\n"
"            empty_slots = [null] * len(cls.slot_names)\n"
"            object.__setattr__(inst, '_slotvalues', empty_slots)\n"
"        return inst\n"
"\n"
"    def __setattr__(self, name, value):\n"
"        'Emulate _PyObject_GenericSetAttrWithDict() Objects/object.c'\n"
"        cls = type(self)\n"
"        if hasattr(cls, 'slot_names') and name not in cls.slot_names:\n"
"            raise AttributeError(\n"
"                f'{cls.__name__!r} object has no attribute {name!r}'\n"
"            )\n"
"        super().__setattr__(name, value)\n"
"\n"
"    def __delattr__(self, name):\n"
"        'Emulate _PyObject_GenericSetAttrWithDict() Objects/object.c'\n"
"        cls = type(self)\n"
"        if hasattr(cls, 'slot_names') and name not in cls.slot_names:\n"
"            raise AttributeError(\n"
"                f'{cls.__name__!r} object has no attribute {name!r}'\n"
"            )\n"
"        super().__delattr__(name)"
msgstr ""
"class Object:\n"
"    'Simulate how object.__new__() allocates memory for __slots__'\n"
"\n"
"    def __new__(cls, *args, **kwargs):\n"
"        'Emulate object_new() in Objects/typeobject.c'\n"
"        inst = super().__new__(cls)\n"
"        if hasattr(cls, 'slot_names'):\n"
"            empty_slots = [null] * len(cls.slot_names)\n"
"            object.__setattr__(inst, '_slotvalues', empty_slots)\n"
"        return inst\n"
"\n"
"    def __setattr__(self, name, value):\n"
"        'Emulate _PyObject_GenericSetAttrWithDict() Objects/object.c'\n"
"        cls = type(self)\n"
"        if hasattr(cls, 'slot_names') and name not in cls.slot_names:\n"
"            raise AttributeError(\n"
"                f'{cls.__name__!r} object has no attribute {name!r}'\n"
"            )\n"
"        super().__setattr__(name, value)\n"
"\n"
"    def __delattr__(self, name):\n"
"        'Emulate _PyObject_GenericSetAttrWithDict() Objects/object.c'\n"
"        cls = type(self)\n"
"        if hasattr(cls, 'slot_names') and name not in cls.slot_names:\n"
"            raise AttributeError(\n"
"                f'{cls.__name__!r} object has no attribute {name!r}'\n"
"            )\n"
"        super().__delattr__(name)"

#: ../../howto/descriptor.rst:1725
msgid ""
"To use the simulation in a real class, just inherit from :class:`!Object` "
"and set the :term:`metaclass` to :class:`Type`:"
msgstr ""
"要在真实的类中使用此模拟，只需从 :class:`!Object` 继承并将 :term:`metaclass` 设为 :class:`Type`:"

#: ../../howto/descriptor.rst:1728
msgid ""
"class H(Object, metaclass=Type):\n"
"    'Instance variables stored in slots'\n"
"\n"
"    slot_names = ['x', 'y']\n"
"\n"
"    def __init__(self, x, y):\n"
"        self.x = x\n"
"        self.y = y"
msgstr ""
"class H(Object, metaclass=Type):\n"
"    'Instance variables stored in slots'\n"
"\n"
"    slot_names = ['x', 'y']\n"
"\n"
"    def __init__(self, x, y):\n"
"        self.x = x\n"
"        self.y = y"

#: ../../howto/descriptor.rst:1739
msgid ""
"At this point, the metaclass has loaded member objects for *x* and *y*::"
msgstr "这时，metaclass 已经为 *x* 和 *y* 加载了成员对象："

#: ../../howto/descriptor.rst:1741
msgid ""
">>> from pprint import pp\n"
">>> pp(dict(vars(H)))\n"
"{'__module__': '__main__',\n"
" '__doc__': 'Instance variables stored in slots',\n"
" 'slot_names': ['x', 'y'],\n"
" '__init__': <function H.__init__ at 0x7fb5d302f9d0>,\n"
" 'x': <Member 'x' of 'H'>,\n"
" 'y': <Member 'y' of 'H'>}"
msgstr ""
">>> from pprint import pp\n"
">>> pp(dict(vars(H)))\n"
"{'__module__': '__main__',\n"
" '__doc__': 'Instance variables stored in slots',\n"
" 'slot_names': ['x', 'y'],\n"
" '__init__': <function H.__init__ at 0x7fb5d302f9d0>,\n"
" 'x': <Member 'x' of 'H'>,\n"
" 'y': <Member 'y' of 'H'>}"

#: ../../howto/descriptor.rst:1760
msgid ""
"When instances are created, they have a ``slot_values`` list where the "
"attributes are stored:"
msgstr "当实例被创建时，它们将拥有一个用于存放属性的 ``slot_values`` 列表："

#: ../../howto/descriptor.rst:1763
msgid ""
">>> h = H(10, 20)\n"
">>> vars(h)\n"
"{'_slotvalues': [10, 20]}\n"
">>> h.x = 55\n"
">>> vars(h)\n"
"{'_slotvalues': [55, 20]}"
msgstr ""
">>> h = H(10, 20)\n"
">>> vars(h)\n"
"{'_slotvalues': [10, 20]}\n"
">>> h.x = 55\n"
">>> vars(h)\n"
"{'_slotvalues': [55, 20]}"

#: ../../howto/descriptor.rst:1772
msgid "Misspelled or unassigned attributes will raise an exception:"
msgstr "错误拼写或未赋值的属性将引发一个异常："

#: ../../howto/descriptor.rst:1774
msgid ""
">>> h.xz\n"
"Traceback (most recent call last):\n"
"    ...\n"
"AttributeError: 'H' object has no attribute 'xz'"
msgstr ""
">>> h.xz\n"
"Traceback (most recent call last):\n"
"    ...\n"
"AttributeError: 'H' object has no attribute 'xz'"
