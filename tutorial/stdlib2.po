# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 15:00+0000\n"
"PO-Revision-Date: 2025-07-18 19:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../tutorial/stdlib2.rst:5
msgid "Brief Tour of the Standard Library --- Part II"
msgstr "标准库简介 —— 第二部分"

#: ../../tutorial/stdlib2.rst:7
msgid ""
"This second tour covers more advanced modules that support professional "
"programming needs.  These modules rarely occur in small scripts."
msgstr "第二部分涵盖了专业编程所需要的更高级的模块。这些模块很少用在小脚本中。"

#: ../../tutorial/stdlib2.rst:14
msgid "Output Formatting"
msgstr "格式化输出"

#: ../../tutorial/stdlib2.rst:16
msgid ""
"The :mod:`reprlib` module provides a version of :func:`repr` customized for "
"abbreviated displays of large or deeply nested containers::"
msgstr ":mod:`reprlib` 模块提供了一个定制化版本的 :func:`repr` 函数，用于缩略显示大型或深层嵌套的容器对象::"

#: ../../tutorial/stdlib2.rst:19
msgid ""
">>> import reprlib\n"
">>> reprlib.repr(set('supercalifragilisticexpialidocious'))\n"
"\"{'a', 'c', 'd', 'e', 'f', 'g', ...}\""
msgstr ""
">>> import reprlib\n"
">>> reprlib.repr(set('supercalifragilisticexpialidocious'))\n"
"\"{'a', 'c', 'd', 'e', 'f', 'g', ...}\""

#: ../../tutorial/stdlib2.rst:23
msgid ""
"The :mod:`pprint` module offers more sophisticated control over printing "
"both built-in and user defined objects in a way that is readable by the "
"interpreter. When the result is longer than one line, the \"pretty printer\""
" adds line breaks and indentation to more clearly reveal data structure::"
msgstr ""
":mod:`pprint` "
"模块提供了更加复杂的打印控制，其输出的内置对象和用户自定义对象能够被解释器直接读取。当输出结果过长而需要折行时，“美化输出机制”会添加换行符和缩进，以更清楚地展示数据结构::"

#: ../../tutorial/stdlib2.rst:28
msgid ""
">>> import pprint\n"
">>> t = [[[['black', 'cyan'], 'white', ['green', 'red']], [['magenta',\n"
"...     'yellow'], 'blue']]]\n"
"...\n"
">>> pprint.pprint(t, width=30)\n"
"[[[['black', 'cyan'],\n"
"   'white',\n"
"   ['green', 'red']],\n"
"  [['magenta', 'yellow'],\n"
"   'blue']]]"
msgstr ""
">>> import pprint\n"
">>> t = [[[['black', 'cyan'], 'white', ['green', 'red']], [['magenta',\n"
"...     'yellow'], 'blue']]]\n"
"...\n"
">>> pprint.pprint(t, width=30)\n"
"[[[['black', 'cyan'],\n"
"   'white',\n"
"   ['green', 'red']],\n"
"  [['magenta', 'yellow'],\n"
"   'blue']]]"

#: ../../tutorial/stdlib2.rst:39
msgid ""
"The :mod:`textwrap` module formats paragraphs of text to fit a given screen "
"width::"
msgstr ":mod:`textwrap` 模块能够格式化文本段落，以适应给定的屏幕宽度::"

#: ../../tutorial/stdlib2.rst:42
msgid ""
">>> import textwrap\n"
">>> doc = \"\"\"The wrap() method is just like fill() except that it returns\n"
"... a list of strings instead of one big string with newlines to separate\n"
"... the wrapped lines.\"\"\"\n"
"...\n"
">>> print(textwrap.fill(doc, width=40))\n"
"The wrap() method is just like fill()\n"
"except that it returns a list of strings\n"
"instead of one big string with newlines\n"
"to separate the wrapped lines."
msgstr ""
">>> import textwrap\n"
">>> doc = \"\"\"The wrap() method is just like fill() except that it returns\n"
"... a list of strings instead of one big string with newlines to separate\n"
"... the wrapped lines.\"\"\"\n"
"...\n"
">>> print(textwrap.fill(doc, width=40))\n"
"The wrap() method is just like fill()\n"
"except that it returns a list of strings\n"
"instead of one big string with newlines\n"
"to separate the wrapped lines."

#: ../../tutorial/stdlib2.rst:53
msgid ""
"The :mod:`locale` module accesses a database of culture specific data "
"formats. The grouping attribute of locale's format function provides a "
"direct way of formatting numbers with group separators::"
msgstr ""
":mod:`locale` 模块处理与特定地域文化相关的数据格式。locale 模块的 format 函数包含一个 grouping "
"属性，可直接将数字格式化为带有组分隔符的样式::"

#: ../../tutorial/stdlib2.rst:57
msgid ""
">>> import locale\n"
">>> locale.setlocale(locale.LC_ALL, 'English_United States.1252')\n"
"'English_United States.1252'\n"
">>> conv = locale.localeconv()          # get a mapping of conventions\n"
">>> x = 1234567.8\n"
">>> locale.format_string(\"%d\", x, grouping=True)\n"
"'1,234,567'\n"
">>> locale.format_string(\"%s%.*f\", (conv['currency_symbol'],\n"
"...                      conv['frac_digits'], x), grouping=True)\n"
"'$1,234,567.80'"
msgstr ""
">>> import locale\n"
">>> locale.setlocale(locale.LC_ALL, 'English_United States.1252')\n"
"'English_United States.1252'\n"
">>> conv = locale.localeconv()          # 获取语言区域设置的映射\n"
">>> x = 1234567.8\n"
">>> locale.format_string(\"%d\", x, grouping=True)\n"
"'1,234,567'\n"
">>> locale.format_string(\"%s%.*f\", (conv['currency_symbol'],\n"
"...                      conv['frac_digits'], x), grouping=True)\n"
"'$1,234,567.80'"

#: ../../tutorial/stdlib2.rst:72
msgid "Templating"
msgstr "模板"

#: ../../tutorial/stdlib2.rst:74
msgid ""
"The :mod:`string` module includes a versatile :class:`~string.Template` "
"class with a simplified syntax suitable for editing by end-users.  This "
"allows users to customize their applications without having to alter the "
"application."
msgstr ""
":mod:`string` 模块包含一个通用的 :class:`~string.Template` "
"类，具有适用于最终用户的简化语法。它允许用户在不更改应用逻辑的情况下定制自己的应用。"

#: ../../tutorial/stdlib2.rst:78
msgid ""
"The format uses placeholder names formed by ``$`` with valid Python "
"identifiers (alphanumeric characters and underscores).  Surrounding the "
"placeholder with braces allows it to be followed by more alphanumeric "
"letters with no intervening spaces.  Writing ``$$`` creates a single escaped"
" ``$``::"
msgstr ""
"上述格式化操作是通过占位符实现的，占位符由 ``$`` 加上合法的 Python "
"标识符（只能包含字母、数字和下划线）构成。一旦使用花括号将占位符括起来，就可以在后面直接跟上更多的字母和数字而无需空格分割。``$$`` "
"将被转义成单个字符 ``$``::"

#: ../../tutorial/stdlib2.rst:83
msgid ""
">>> from string import Template\n"
">>> t = Template('${village}folk send $$10 to $cause.')\n"
">>> t.substitute(village='Nottingham', cause='the ditch fund')\n"
"'Nottinghamfolk send $10 to the ditch fund.'"
msgstr ""
">>> from string import Template\n"
">>> t = Template('${village}folk send $$10 to $cause.')\n"
">>> t.substitute(village='Nottingham', cause='the ditch fund')\n"
"'Nottinghamfolk send $10 to the ditch fund.'"

#: ../../tutorial/stdlib2.rst:88
msgid ""
"The :meth:`~string.Template.substitute` method raises a :exc:`KeyError` when"
" a placeholder is not supplied in a dictionary or a keyword argument.  For "
"mail-merge style applications, user supplied data may be incomplete and the "
":meth:`~string.Template.safe_substitute` method may be more appropriate --- "
"it will leave placeholders unchanged if data is missing::"
msgstr ""
"如果在字典或关键字参数中未提供某个占位符的值，那么 :meth:`~string.Template.substitute` 方法将抛出 "
":exc:`KeyError`\\ 。对于邮件合并类型的应用，用户提供的数据有可能是不完整的，此时使用 "
":meth:`~string.Template.safe_substitute` 方法更加合适 —— 如果数据缺失，它会直接将占位符原样保留。"

#: ../../tutorial/stdlib2.rst:94
msgid ""
">>> t = Template('Return the $item to $owner.')\n"
">>> d = dict(item='unladen swallow')\n"
">>> t.substitute(d)\n"
"Traceback (most recent call last):\n"
"  ...\n"
"KeyError: 'owner'\n"
">>> t.safe_substitute(d)\n"
"'Return the unladen swallow to $owner.'"
msgstr ""
">>> t = Template('Return the $item to $owner.')\n"
">>> d = dict(item='unladen swallow')\n"
">>> t.substitute(d)\n"
"Traceback (most recent call last):\n"
"  ...\n"
"KeyError: 'owner'\n"
">>> t.safe_substitute(d)\n"
"'Return the unladen swallow to $owner.'"

#: ../../tutorial/stdlib2.rst:103
msgid ""
"Template subclasses can specify a custom delimiter.  For example, a batch "
"renaming utility for a photo browser may elect to use percent signs for "
"placeholders such as the current date, image sequence number, or file "
"format::"
msgstr "Template 的子类可以自定义分隔符。例如，以下是某个照片浏览器的批量重命名功能，采用了百分号作为日期、照片序号和照片格式的占位符::"

#: ../../tutorial/stdlib2.rst:107
msgid ""
">>> import time, os.path\n"
">>> photofiles = ['img_1074.jpg', 'img_1076.jpg', 'img_1077.jpg']\n"
">>> class BatchRename(Template):\n"
"...     delimiter = '%'\n"
"...\n"
">>> fmt = input('Enter rename style (%d-date %n-seqnum %f-format):  ')\n"
"Enter rename style (%d-date %n-seqnum %f-format):  Ashley_%n%f\n"
"\n"
">>> t = BatchRename(fmt)\n"
">>> date = time.strftime('%d%b%y')\n"
">>> for i, filename in enumerate(photofiles):\n"
"...     base, ext = os.path.splitext(filename)\n"
"...     newname = t.substitute(d=date, n=i, f=ext)\n"
"...     print('{0} --> {1}'.format(filename, newname))\n"
"\n"
"img_1074.jpg --> Ashley_0.jpg\n"
"img_1076.jpg --> Ashley_1.jpg\n"
"img_1077.jpg --> Ashley_2.jpg"
msgstr ""
">>> import time, os.path\n"
">>> photofiles = ['img_1074.jpg', 'img_1076.jpg', 'img_1077.jpg']\n"
">>> class BatchRename(Template):\n"
"...     delimiter = '%'\n"
"...\n"
">>> fmt = input('Enter rename style (%d-date %n-seqnum %f-format):  ')\n"
"Enter rename style (%d-date %n-seqnum %f-format):  Ashley_%n%f\n"
"\n"
">>> t = BatchRename(fmt)\n"
">>> date = time.strftime('%d%b%y')\n"
">>> for i, filename in enumerate(photofiles):\n"
"...     base, ext = os.path.splitext(filename)\n"
"...     newname = t.substitute(d=date, n=i, f=ext)\n"
"...     print('{0} --> {1}'.format(filename, newname))\n"
"\n"
"img_1074.jpg --> Ashley_0.jpg\n"
"img_1076.jpg --> Ashley_1.jpg\n"
"img_1077.jpg --> Ashley_2.jpg"

#: ../../tutorial/stdlib2.rst:126
msgid ""
"Another application for templating is separating program logic from the "
"details of multiple output formats.  This makes it possible to substitute "
"custom templates for XML files, plain text reports, and HTML web reports."
msgstr ""
"模板的另一个应用是将程序逻辑与多样的格式化输出细节分离开来。这使得对 XML 文件、纯文本报表和 HTML 网络报表使用自定义模板成为可能。"

#: ../../tutorial/stdlib2.rst:134
msgid "Working with Binary Data Record Layouts"
msgstr "使用二进制数据记录格式"

#: ../../tutorial/stdlib2.rst:136
msgid ""
"The :mod:`struct` module provides :func:`~struct.pack` and "
":func:`~struct.unpack` functions for working with variable length binary "
"record formats.  The following example shows how to loop through header "
"information in a ZIP file without using the :mod:`zipfile` module.  Pack "
"codes ``\"H\"`` and ``\"I\"`` represent two and four byte unsigned numbers "
"respectively.  The ``\"<\"`` indicates that they are standard size and in "
"little-endian byte order::"
msgstr ""
":mod:`struct` 模块提供了 :func:`~struct.pack` 和 :func:`~struct.unpack` "
"函数，用于处理不定长度的二进制记录格式。下面的例子展示了在不使用 :mod:`zipfile` 模块的情况下，如何循环遍历一个 ZIP "
"文件的所有头信息。Pack 代码 ``\"H\"`` 和 ``\"I\"`` 分别代表两字节和四字节无符号整数。\\ ``\"<\"`` "
"代表它们是标准尺寸的小端字节序::"

#: ../../tutorial/stdlib2.rst:144
msgid ""
"import struct\n"
"\n"
"with open('myfile.zip', 'rb') as f:\n"
"    data = f.read()\n"
"\n"
"start = 0\n"
"for i in range(3):                      # show the first 3 file headers\n"
"    start += 14\n"
"    fields = struct.unpack('<IIIHH', data[start:start+16])\n"
"    crc32, comp_size, uncomp_size, filenamesize, extra_size = fields\n"
"\n"
"    start += 16\n"
"    filename = data[start:start+filenamesize]\n"
"    start += filenamesize\n"
"    extra = data[start:start+extra_size]\n"
"    print(filename, hex(crc32), comp_size, uncomp_size)\n"
"\n"
"    start += extra_size + comp_size     # skip to the next header"
msgstr ""
"import struct\n"
"\n"
"with open('myfile.zip', 'rb') as f:\n"
"    data = f.read()\n"
"\n"
"start = 0\n"
"for i in range(3):                      # 显示前 3 个文件标头\n"
"    start += 14\n"
"    fields = struct.unpack('<IIIHH', data[start:start+16])\n"
"    crc32, comp_size, uncomp_size, filenamesize, extra_size = fields\n"
"\n"
"    start += 16\n"
"    filename = data[start:start+filenamesize]\n"
"    start += filenamesize\n"
"    extra = data[start:start+extra_size]\n"
"    print(filename, hex(crc32), comp_size, uncomp_size)\n"
"\n"
"    start += extra_size + comp_size     # 跳过下一个标头"

#: ../../tutorial/stdlib2.rst:167
msgid "Multi-threading"
msgstr "多线程"

#: ../../tutorial/stdlib2.rst:169
msgid ""
"Threading is a technique for decoupling tasks which are not sequentially "
"dependent.  Threads can be used to improve the responsiveness of "
"applications that accept user input while other tasks run in the background."
"  A related use case is running I/O in parallel with computations in another"
" thread."
msgstr ""
"线程是一种对于非顺序依赖的多个任务进行解耦的技术。多线程可以提高应用的响应效率，当接收用户输入的同时，保持其他任务在后台运行。一个有关的应用场景是，将 "
"I/O 和计算运行在两个并行的线程中。"

#: ../../tutorial/stdlib2.rst:174
msgid ""
"The following code shows how the high level :mod:`threading` module can run "
"tasks in background while the main program continues to run::"
msgstr "以下代码展示了高阶的 :mod:`threading` 模块如何在后台运行任务，且不影响主程序的继续运行::"

#: ../../tutorial/stdlib2.rst:177
msgid ""
"import threading, zipfile\n"
"\n"
"class AsyncZip(threading.Thread):\n"
"    def __init__(self, infile, outfile):\n"
"        threading.Thread.__init__(self)\n"
"        self.infile = infile\n"
"        self.outfile = outfile\n"
"\n"
"    def run(self):\n"
"        f = zipfile.ZipFile(self.outfile, 'w', zipfile.ZIP_DEFLATED)\n"
"        f.write(self.infile)\n"
"        f.close()\n"
"        print('Finished background zip of:', self.infile)\n"
"\n"
"background = AsyncZip('mydata.txt', 'myarchive.zip')\n"
"background.start()\n"
"print('The main program continues to run in foreground.')\n"
"\n"
"background.join()    # Wait for the background task to finish\n"
"print('Main program waited until background was done.')"
msgstr ""
"import threading, zipfile\n"
"\n"
"class AsyncZip(threading.Thread):\n"
"    def __init__(self, infile, outfile):\n"
"        threading.Thread.__init__(self)\n"
"        self.infile = infile\n"
"        self.outfile = outfile\n"
"\n"
"    def run(self):\n"
"        f = zipfile.ZipFile(self.outfile, 'w', zipfile.ZIP_DEFLATED)\n"
"        f.write(self.infile)\n"
"        f.close()\n"
"        print('Finished background zip of:', self.infile)\n"
"\n"
"background = AsyncZip('mydata.txt', 'myarchive.zip')\n"
"background.start()\n"
"print('The main program continues to run in foreground.')\n"
"\n"
"background.join()    # 等待背景任务结束\n"
"print('Main program waited until background was done.')"

#: ../../tutorial/stdlib2.rst:198
msgid ""
"The principal challenge of multi-threaded applications is coordinating "
"threads that share data or other resources.  To that end, the threading "
"module provides a number of synchronization primitives including locks, "
"events, condition variables, and semaphores."
msgstr ""
"多线程应用面临的主要挑战是，相互协调的多个线程之间需要共享数据或其他资源。为此，threading "
"模块提供了多个同步操作原语，包括线程锁、事件、条件变量和信号量。"

#: ../../tutorial/stdlib2.rst:203
msgid ""
"While those tools are powerful, minor design errors can result in problems "
"that are difficult to reproduce.  So, the preferred approach to task "
"coordination is to concentrate all access to a resource in a single thread "
"and then use the :mod:`queue` module to feed that thread with requests from "
"other threads. Applications using :class:`~queue.Queue` objects for inter-"
"thread communication and coordination are easier to design, more readable, "
"and more reliable."
msgstr ""
"尽管这些工具非常强大，但微小的设计错误却可以导致一些难以复现的问题。因此，实现多任务协作的首选方法是将所有对资源的请求集中到一个线程中，然后使用 "
":mod:`queue` 模块向该线程供应来自其他线程的请求。 应用程序使用 :class:`~queue.Queue` "
"对象进行线程间通信和协调，更易于设计，更易读，更可靠。"

#: ../../tutorial/stdlib2.rst:214
msgid "Logging"
msgstr "日志记录"

#: ../../tutorial/stdlib2.rst:216
msgid ""
"The :mod:`logging` module offers a full featured and flexible logging "
"system. At its simplest, log messages are sent to a file or to "
"``sys.stderr``::"
msgstr ""
":mod:`logging` 模块提供功能齐全且灵活的日志记录系统。在最简单的情况下，日志消息被发送到文件或 ``sys.stderr``\\ ::"

#: ../../tutorial/stdlib2.rst:219
msgid ""
"import logging\n"
"logging.debug('Debugging information')\n"
"logging.info('Informational message')\n"
"logging.warning('Warning:config file %s not found', 'server.conf')\n"
"logging.error('Error occurred')\n"
"logging.critical('Critical error -- shutting down')"
msgstr ""
"import logging\n"
"logging.debug('Debugging information')\n"
"logging.info('Informational message')\n"
"logging.warning('Warning:config file %s not found', 'server.conf')\n"
"logging.error('Error occurred')\n"
"logging.critical('Critical error -- shutting down')"

#: ../../tutorial/stdlib2.rst:226
msgid "This produces the following output:"
msgstr "这会产生以下输出:"

#: ../../tutorial/stdlib2.rst:228
msgid ""
"WARNING:root:Warning:config file server.conf not found\n"
"ERROR:root:Error occurred\n"
"CRITICAL:root:Critical error -- shutting down"
msgstr ""
"WARNING:root:Warning:config file server.conf not found\n"
"ERROR:root:Error occurred\n"
"CRITICAL:root:Critical error -- shutting down"

#: ../../tutorial/stdlib2.rst:234
msgid ""
"By default, informational and debugging messages are suppressed and the "
"output is sent to standard error.  Other output options include routing "
"messages through email, datagrams, sockets, or to an HTTP Server.  New "
"filters can select different routing based on message priority: "
":const:`~logging.DEBUG`, :const:`~logging.INFO`, :const:`~logging.WARNING`, "
":const:`~logging.ERROR`, and :const:`~logging.CRITICAL`."
msgstr ""
"默认情况下，informational 和 debugging "
"消息被压制，输出会发送到标准错误流。其他输出选项包括将消息转发到电子邮件，数据报，套接字或 HTTP "
"服务器。新的过滤器可以根据消息优先级选择不同的路由方式：\\ :const:`~logging.DEBUG`\\ ，\\ "
":const:`~logging.INFO`\\ ，\\ :const:`~logging.WARNING`\\ ，\\ "
":const:`~logging.ERROR`\\ ，和 :const:`~logging.CRITICAL`\\ 。"

#: ../../tutorial/stdlib2.rst:241
msgid ""
"The logging system can be configured directly from Python or can be loaded "
"from a user editable configuration file for customized logging without "
"altering the application."
msgstr "日志系统可以直接从 Python 配置，也可以从用户配置文件加载，以便自定义日志记录而无需更改应用程序。"

#: ../../tutorial/stdlib2.rst:249
msgid "Weak References"
msgstr "弱引用"

#: ../../tutorial/stdlib2.rst:251
msgid ""
"Python does automatic memory management (reference counting for most objects"
" and :term:`garbage collection` to eliminate cycles).  The memory is freed "
"shortly after the last reference to it has been eliminated."
msgstr ""
"Python 会自动进行内存管理（对大多数对象进行引用计数并使用 :term:`garbage collection` 来清除循环引用）。 "
"当某个对象的最后一个引用被移除后不久就会释放其所占用的内存。"

#: ../../tutorial/stdlib2.rst:255
msgid ""
"This approach works fine for most applications but occasionally there is a "
"need to track objects only as long as they are being used by something else."
" Unfortunately, just tracking them creates a reference that makes them "
"permanent. The :mod:`weakref` module provides tools for tracking objects "
"without creating a reference.  When the object is no longer needed, it is "
"automatically removed from a weakref table and a callback is triggered for "
"weakref objects.  Typical applications include caching objects that are "
"expensive to create::"
msgstr ""
"此方式对大多数应用来说都适用，但偶尔也必须在对象持续被其他对象所使用时跟踪它们。 不幸的是，跟踪它们将创建一个会令其永久化的引用。 "
":mod:`weakref` 模块提供的工具可以不必创建引用就能跟踪对象。 "
"当对象不再需要时，它将自动从一个弱引用表中被移除，并为弱引用对象触发一个回调。 典型应用包括对创建开销较大的对象进行缓存::"

#: ../../tutorial/stdlib2.rst:263
msgid ""
">>> import weakref, gc\n"
">>> class A:\n"
"...     def __init__(self, value):\n"
"...         self.value = value\n"
"...     def __repr__(self):\n"
"...         return str(self.value)\n"
"...\n"
">>> a = A(10)                   # create a reference\n"
">>> d = weakref.WeakValueDictionary()\n"
">>> d['primary'] = a            # does not create a reference\n"
">>> d['primary']                # fetch the object if it is still alive\n"
"10\n"
">>> del a                       # remove the one reference\n"
">>> gc.collect()                # run garbage collection right away\n"
"0\n"
">>> d['primary']                # entry was automatically removed\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"    d['primary']                # entry was automatically removed\n"
"  File \"C:/python313/lib/weakref.py\", line 46, in __getitem__\n"
"    o = self.data[key]()\n"
"KeyError: 'primary'"
msgstr ""
">>> import weakref, gc\n"
">>> class A:\n"
"...     def __init__(self, value):\n"
"...         self.value = value\n"
"...     def __repr__(self):\n"
"...         return str(self.value)\n"
"...\n"
">>> a = A(10)                   # 创建一个引用\n"
">>> d = weakref.WeakValueDictionary()\n"
">>> d['primary'] = a            # 不创建引用\n"
">>> d['primary']                # 如果对象仍然存在则获取它\n"
"10\n"
">>> del a                       # 移除一个引用\n"
">>> gc.collect()                # 立即运行垃圾回收\n"
"0\n"
">>> d['primary']                # 条目会被自动移除\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"    d['primary']                # 条目会被自动移除\n"
"  File \"C:/python313/lib/weakref.py\", line 46, in __getitem__\n"
"    o = self.data[key]()\n"
"KeyError: 'primary'"

#: ../../tutorial/stdlib2.rst:290
msgid "Tools for Working with Lists"
msgstr "用于操作列表的工具"

#: ../../tutorial/stdlib2.rst:292
msgid ""
"Many data structure needs can be met with the built-in list type. However, "
"sometimes there is a need for alternative implementations with different "
"performance trade-offs."
msgstr "许多对于数据结构的需求可以通过内置列表类型来满足。 但是，有时也会需要具有不同效费比的替代实现。"

#: ../../tutorial/stdlib2.rst:296
msgid ""
"The :mod:`array` module provides an :class:`~array.array` object that is "
"like a list that stores only homogeneous data and stores it more compactly."
"  The following example shows an array of numbers stored as two byte "
"unsigned binary numbers (typecode ``\"H\"``) rather than the usual 16 bytes "
"per entry for regular lists of Python int objects::"
msgstr ""
":mod:`array` 模块提供了一种 :class:`~array.array` 对象，它类似于列表，但只能存储类型一致的数据且存储密度更高。 "
"下面的例子显示了一个由存储为双字节无符号整数的数字 (类型码 ``\"H\"``) 组成的元组，而不是常规 Python int "
"对象列表所采用的每个条目 16 字节::"

#: ../../tutorial/stdlib2.rst:302
msgid ""
">>> from array import array\n"
">>> a = array('H', [4000, 10, 700, 22222])\n"
">>> sum(a)\n"
"26932\n"
">>> a[1:3]\n"
"array('H', [10, 700])"
msgstr ""
">>> from array import array\n"
">>> a = array('H', [4000, 10, 700, 22222])\n"
">>> sum(a)\n"
"26932\n"
">>> a[1:3]\n"
"array('H', [10, 700])"

#: ../../tutorial/stdlib2.rst:309
msgid ""
"The :mod:`collections` module provides a :class:`~collections.deque` object "
"that is like a list with faster appends and pops from the left side but "
"slower lookups in the middle. These objects are well suited for implementing"
" queues and breadth first tree searches::"
msgstr ""
":mod:`collections` 模块提供了一种 :class:`~collections.deque` "
"对象，它类似于列表，但从左端添加和弹出的速度较快而在中间查找的速度较慢。 此种对象适用于实现队列和广度优先树搜索::"

#: ../../tutorial/stdlib2.rst:314
msgid ""
">>> from collections import deque\n"
">>> d = deque([\"task1\", \"task2\", \"task3\"])\n"
">>> d.append(\"task4\")\n"
">>> print(\"Handling\", d.popleft())\n"
"Handling task1"
msgstr ""
">>> from collections import deque\n"
">>> d = deque([\"task1\", \"task2\", \"task3\"])\n"
">>> d.append(\"task4\")\n"
">>> print(\"Handling\", d.popleft())\n"
"Handling task1"

#: ../../tutorial/stdlib2.rst:322
msgid ""
"unsearched = deque([starting_node])\n"
"def breadth_first_search(unsearched):\n"
"    node = unsearched.popleft()\n"
"    for m in gen_moves(node):\n"
"        if is_goal(m):\n"
"            return m\n"
"        unsearched.append(m)"
msgstr ""
"unsearched = deque([starting_node])\n"
"def breadth_first_search(unsearched):\n"
"    node = unsearched.popleft()\n"
"    for m in gen_moves(node):\n"
"        if is_goal(m):\n"
"            return m\n"
"        unsearched.append(m)"

#: ../../tutorial/stdlib2.rst:330
msgid ""
"In addition to alternative list implementations, the library also offers "
"other tools such as the :mod:`bisect` module with functions for manipulating"
" sorted lists::"
msgstr "在替代的列表实现以外，标准库也提供了其他工具，例如 :mod:`bisect` 模块具有用于操作有序列表的函数::"

#: ../../tutorial/stdlib2.rst:334
msgid ""
">>> import bisect\n"
">>> scores = [(100, 'perl'), (200, 'tcl'), (400, 'lua'), (500, 'python')]\n"
">>> bisect.insort(scores, (300, 'ruby'))\n"
">>> scores\n"
"[(100, 'perl'), (200, 'tcl'), (300, 'ruby'), (400, 'lua'), (500, 'python')]"
msgstr ""
">>> import bisect\n"
">>> scores = [(100, 'perl'), (200, 'tcl'), (400, 'lua'), (500, 'python')]\n"
">>> bisect.insort(scores, (300, 'ruby'))\n"
">>> scores\n"
"[(100, 'perl'), (200, 'tcl'), (300, 'ruby'), (400, 'lua'), (500, 'python')]"

#: ../../tutorial/stdlib2.rst:340
msgid ""
"The :mod:`heapq` module provides functions for implementing heaps based on "
"regular lists.  The lowest valued entry is always kept at position zero.  "
"This is useful for applications which repeatedly access the smallest element"
" but do not want to run a full list sort::"
msgstr ""
":mod:`heapq` 模块提供了基于常规列表来实现堆的函数。 最小值的条目总是保持在位置零。 "
"这对于需要重复访问最小元素而不希望运行完整列表排序的应用来说非常有用::"

#: ../../tutorial/stdlib2.rst:345
msgid ""
">>> from heapq import heapify, heappop, heappush\n"
">>> data = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]\n"
">>> heapify(data)                      # rearrange the list into heap order\n"
">>> heappush(data, -5)                 # add a new entry\n"
">>> [heappop(data) for i in range(3)]  # fetch the three smallest entries\n"
"[-5, 0, 1]"
msgstr ""
">>> from heapq import heapify, heappop, heappush\n"
">>> data = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]\n"
">>> heapify(data)                      # 将列表重新调整为堆顺序\n"
">>> heappush(data, -5)                 # 添加一个新条目\n"
">>> [heappop(data) for i in range(3)]  # 获取三个最小的条目\n"
"[-5, 0, 1]"

#: ../../tutorial/stdlib2.rst:356
msgid "Decimal Floating-Point Arithmetic"
msgstr "十进制浮点运算"

#: ../../tutorial/stdlib2.rst:358
msgid ""
"The :mod:`decimal` module offers a :class:`~decimal.Decimal` datatype for "
"decimal floating-point arithmetic.  Compared to the built-in :class:`float` "
"implementation of binary floating point, the class is especially helpful for"
msgstr ""
":mod:`decimal` 模块提供了一种 :class:`~decimal.Decimal` 数据类型用于十进制浮点运算。 相比内置的 "
":class:`float` 二进制浮点实现，该类特别适用于"

#: ../../tutorial/stdlib2.rst:362
msgid ""
"financial applications and other uses which require exact decimal "
"representation,"
msgstr "财务应用和其他需要精确十进制表示的用途，"

#: ../../tutorial/stdlib2.rst:364
msgid "control over precision,"
msgstr "控制精度，"

#: ../../tutorial/stdlib2.rst:365
msgid "control over rounding to meet legal or regulatory requirements,"
msgstr "控制四舍五入以满足法律或监管要求，"

#: ../../tutorial/stdlib2.rst:366
msgid "tracking of significant decimal places, or"
msgstr "跟踪有效小数位，或"

#: ../../tutorial/stdlib2.rst:367
msgid ""
"applications where the user expects the results to match calculations done "
"by hand."
msgstr "用户期望结果与手工完成的计算相匹配的应用程序。"

#: ../../tutorial/stdlib2.rst:370
msgid ""
"For example, calculating a 5% tax on a 70 cent phone charge gives different "
"results in decimal floating point and binary floating point. The difference "
"becomes significant if the results are rounded to the nearest cent::"
msgstr "例如，使用十进制浮点和二进制浮点数计算70美分手机和5％税的总费用，会产生的不同结果。如果结果四舍五入到最接近的分数差异会更大::"

#: ../../tutorial/stdlib2.rst:374
msgid ""
">>> from decimal import *\n"
">>> round(Decimal('0.70') * Decimal('1.05'), 2)\n"
"Decimal('0.74')\n"
">>> round(.70 * 1.05, 2)\n"
"0.73"
msgstr ""
">>> from decimal import *\n"
">>> round(Decimal('0.70') * Decimal('1.05'), 2)\n"
"Decimal('0.74')\n"
">>> round(.70 * 1.05, 2)\n"
"0.73"

#: ../../tutorial/stdlib2.rst:380
msgid ""
"The :class:`~decimal.Decimal` result keeps a trailing zero, automatically "
"inferring four place significance from multiplicands with two place "
"significance.  Decimal reproduces mathematics as done by hand and avoids "
"issues that can arise when binary floating point cannot exactly represent "
"decimal quantities."
msgstr ""
":class:`~decimal.Decimal` 表示的结果会保留尾部的零，并根据具有两个有效位的被乘数自动推出四个有效位。 Decimal "
"可以模拟手工运算来避免当二进制浮点数无法精确表示十进制数时会导致的问题。"

#: ../../tutorial/stdlib2.rst:386
msgid ""
"Exact representation enables the :class:`~decimal.Decimal` class to perform "
"modulo calculations and equality tests that are unsuitable for binary "
"floating point::"
msgstr "精确表示特性使得 :class:`~decimal.Decimal` 类能够执行对于二进制浮点数来说不适用的模运算和相等性检测::"

#: ../../tutorial/stdlib2.rst:390
msgid ""
">>> Decimal('1.00') % Decimal('.10')\n"
"Decimal('0.00')\n"
">>> 1.00 % 0.10\n"
"0.09999999999999995\n"
"\n"
">>> sum([Decimal('0.1')]*10) == Decimal('1.0')\n"
"True\n"
">>> 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 == 1.0\n"
"False"
msgstr ""
">>> Decimal('1.00') % Decimal('.10')\n"
"Decimal('0.00')\n"
">>> 1.00 % 0.10\n"
"0.09999999999999995\n"
"\n"
">>> sum([Decimal('0.1')]*10) == Decimal('1.0')\n"
"True\n"
">>> 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 == 1.0\n"
"False"

#: ../../tutorial/stdlib2.rst:400
msgid ""
"The :mod:`decimal` module provides arithmetic with as much precision as "
"needed::"
msgstr ":mod:`decimal` 模块提供了运算所需要的足够精度::"

#: ../../tutorial/stdlib2.rst:402
msgid ""
">>> getcontext().prec = 36\n"
">>> Decimal(1) / Decimal(7)\n"
"Decimal('0.142857142857142857142857142857142857')"
msgstr ""
">>> getcontext().prec = 36\n"
">>> Decimal(1) / Decimal(7)\n"
"Decimal('0.142857142857142857142857142857142857')"
