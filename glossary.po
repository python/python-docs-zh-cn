# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# Freesand Leo <yuqinju@163.com>, 2025
# 汇民 王 <whuim@qq.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 14:21+0000\n"
"PO-Revision-Date: 2025-07-18 18:48+0000\n"
"Last-Translator: 汇民 王 <whuim@qq.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../glossary.rst:5
msgid "Glossary"
msgstr "术语对照表"

#: ../../glossary.rst:10
msgid "``>>>``"
msgstr "``>>>``"

#: ../../glossary.rst:12
msgid ""
"The default Python prompt of the :term:`interactive` shell.  Often seen for "
"code examples which can be executed interactively in the interpreter."
msgstr ""
":term:`interactive` shell 中默认的 Python 提示符。 往往会显示于能以交互方式在解释器里执行的样例代码之前。"

#: ../../glossary.rst:15
msgid "``...``"
msgstr "``...``"

#: ../../glossary.rst:17
msgid "Can refer to:"
msgstr "具有以下含义："

#: ../../glossary.rst:19
msgid ""
"The default Python prompt of the :term:`interactive` shell when entering the"
" code for an indented code block, when within a pair of matching left and "
"right delimiters (parentheses, square brackets, curly braces or triple "
"quotes), or after specifying a decorator."
msgstr ""
":term:`interactive` shell 中输入特殊代码时默认的 Python "
"提示符，特殊代码包括缩进的代码块，左右成对分隔符（圆括号、方括号、花括号或三重引号等）之内，或是在指定一个装饰器之后。"

#: ../../glossary.rst:24
msgid "The :const:`Ellipsis` built-in constant."
msgstr ":const:`Ellipsis` 内置常量。"

#: ../../glossary.rst:25
msgid "abstract base class"
msgstr "abstract base class -- 抽象基类"

#: ../../glossary.rst:27
msgid ""
"Abstract base classes complement :term:`duck-typing` by providing a way to "
"define interfaces when other techniques like :func:`hasattr` would be clumsy"
" or subtly wrong (for example with :ref:`magic methods <special-lookup>`).  "
"ABCs introduce virtual subclasses, which are classes that don't inherit from"
" a class but are still recognized by :func:`isinstance` and "
":func:`issubclass`; see the :mod:`abc` module documentation.  Python comes "
"with many built-in ABCs for data structures (in the :mod:`collections.abc` "
"module), numbers (in the :mod:`numbers` module), streams (in the :mod:`io` "
"module), import finders and loaders (in the :mod:`importlib.abc` module).  "
"You can create your own ABCs with the :mod:`abc` module."
msgstr ""
"抽象基类简称 ABC，是对 :term:`duck-typing` 的补充，它提供了一种定义接口的新方式，相比之下其他技巧例如 "
":func:`hasattr` 显得过于笨拙或有微妙错误（例如使用 :ref:`魔术方法 <special-lookup>`）。ABC "
"引入了虚拟子类，这种类并非继承自其他类，但却仍能被 :func:`isinstance` 和 :func:`issubclass` 所认可；详见 "
":mod:`abc` 模块文档。Python 自带许多内置的 ABC 用于实现数据结构（在 :mod:`collections.abc` "
"模块中）、数字（在 :mod:`numbers` 模块中）、流（在 :mod:`io` 模块中）、导入查找器和加载器（在 "
":mod:`importlib.abc` 模块中）。你可以使用 :mod:`abc` 模块来创建自己的 ABC。"

#: ../../glossary.rst:38
msgid "annotate function"
msgstr "annotate function -- 标注函数"

#: ../../glossary.rst:40
msgid ""
"A function that can be called to retrieve the :term:`annotations "
"<annotation>` of an object. This function is accessible as the "
":attr:`~object.__annotate__` attribute of functions, classes, and modules. "
"Annotate functions are a subset of :term:`evaluate functions <evaluate "
"function>`."
msgstr ""
"一个可被调用以提取对象的 :term:`标注 <annotation>` 的函数。 此函数可作为函数、类和模块的 "
":attr:`~object.__annotate__` 属性来访问。 标注函数是 :term:`求值函数 <evaluate function>` "
"的一个子集。"

#: ../../glossary.rst:44
msgid "annotation"
msgstr "annotation -- 标注"

#: ../../glossary.rst:46
msgid ""
"A label associated with a variable, a class attribute or a function "
"parameter or return value, used by convention as a :term:`type hint`."
msgstr "关联到某个变量、类属性、函数形参或返回值的标签，被约定作为 :term:`类型注解 <type hint>` 来使用。"

#: ../../glossary.rst:50
msgid ""
"Annotations of local variables cannot be accessed at runtime, but "
"annotations of global variables, class attributes, and functions can be "
"retrieved by calling :func:`annotationlib.get_annotations` on modules, "
"classes, and functions, respectively."
msgstr ""
"局部变量的标注在运行时不可被访问，但全局变量、类属性和函数的标注可分别通过在模块、类和函数上调用 "
":func:`annotationlib.get_annotations` 来提取。"

#: ../../glossary.rst:55
msgid ""
"See :term:`variable annotation`, :term:`function annotation`, :pep:`484`, "
":pep:`526`, and :pep:`649`, which describe this functionality. Also see "
":ref:`annotations-howto` for best practices on working with annotations."
msgstr ""
"参见 :term:`variable annotation`, :term:`function annotation`, :pep:`484`, "
":pep:`526` 和 :pep:`649`，其中对此功能进行了描述。 另请参见 :ref:`annotations-howto` "
"了解使用标注的最佳实践。"

#: ../../glossary.rst:59
msgid "argument"
msgstr "argument -- 参数"

#: ../../glossary.rst:61
msgid ""
"A value passed to a :term:`function` (or :term:`method`) when calling the "
"function.  There are two kinds of argument:"
msgstr "在调用函数时传给 :term:`function` （或 :term:`method` ）的值。参数分为两种："

#: ../../glossary.rst:64
msgid ""
":dfn:`keyword argument`: an argument preceded by an identifier (e.g. "
"``name=``) in a function call or passed as a value in a dictionary preceded "
"by ``**``.  For example, ``3`` and ``5`` are both keyword arguments in the "
"following calls to :func:`complex`::"
msgstr ""
":dfn:`关键字参数`: 在函数调用中前面带有标识符（例如 ``name=``）或者作为包含在前面带有 ``**`` "
"的字典里的值传入。举例来说，``3`` 和 ``5`` 在以下对 :func:`complex` 的调用中均属于关键字参数::"

#: ../../glossary.rst:69
msgid ""
"complex(real=3, imag=5)\n"
"complex(**{'real': 3, 'imag': 5})"
msgstr ""
"complex(real=3, imag=5)\n"
"complex(**{'real': 3, 'imag': 5})"

#: ../../glossary.rst:72
msgid ""
":dfn:`positional argument`: an argument that is not a keyword argument. "
"Positional arguments can appear at the beginning of an argument list and/or "
"be passed as elements of an :term:`iterable` preceded by ``*``. For example,"
" ``3`` and ``5`` are both positional arguments in the following calls::"
msgstr ""
":dfn:`位置参数`: 不属于关键字参数的参数。位置参数可出现于参数列表的开头以及/或者作为前面带有 ``*`` 的 :term:`iterable`"
" 里的元素被传入。举例来说，``3`` 和 ``5`` 在以下调用中均属于位置参数::"

#: ../../glossary.rst:78
msgid ""
"complex(3, 5)\n"
"complex(*(3, 5))"
msgstr ""
"complex(3, 5)\n"
"complex(*(3, 5))"

#: ../../glossary.rst:81
msgid ""
"Arguments are assigned to the named local variables in a function body. See "
"the :ref:`calls` section for the rules governing this assignment. "
"Syntactically, any expression can be used to represent an argument; the "
"evaluated value is assigned to the local variable."
msgstr ""
"参数会被赋值给函数体中对应的局部变量。有关赋值规则参见 :ref:`calls` "
"一节。根据语法，任何表达式都可用来表示一个参数；最终算出的值会被赋给对应的局部变量。"

#: ../../glossary.rst:86
msgid ""
"See also the :term:`parameter` glossary entry, the FAQ question on :ref:`the"
" difference between arguments and parameters <faq-argument-vs-parameter>`, "
"and :pep:`362`."
msgstr ""
"另参见 :term:`parameter` 术语表条目，常见问题中 :ref:`参数与形参的区别 <faq-argument-vs-"
"parameter>` 以及 :pep:`362`。"

#: ../../glossary.rst:89
msgid "asynchronous context manager"
msgstr "asynchronous context manager -- 异步上下文管理器"

#: ../../glossary.rst:91
msgid ""
"An object which controls the environment seen in an :keyword:`async with` "
"statement by defining :meth:`~object.__aenter__` and "
":meth:`~object.__aexit__` methods.  Introduced by :pep:`492`."
msgstr ""
"此种对象通过定义 :meth:`~object.__aenter__` 和 :meth:`~object.__aexit__` 方法来对 "
":keyword:`async with` 语句中的环境进行控制。 由 :pep:`492` 引入。"

#: ../../glossary.rst:94
msgid "asynchronous generator"
msgstr "asynchronous generator -- 异步生成器"

#: ../../glossary.rst:96
msgid ""
"A function which returns an :term:`asynchronous generator iterator`.  It "
"looks like a coroutine function defined with :keyword:`async def` except "
"that it contains :keyword:`yield` expressions for producing a series of "
"values usable in an :keyword:`async for` loop."
msgstr ""
"返回值为 :term:`asynchronous generator iterator` 的函数。它与使用 :keyword:`async def` "
"定义的协程函数很相似，不同之处在于它包含 :keyword:`yield` 表达式以产生一系列可在 :keyword:`async for` "
"循环中使用的值。"

#: ../../glossary.rst:101
msgid ""
"Usually refers to an asynchronous generator function, but may refer to an "
"*asynchronous generator iterator* in some contexts.  In cases where the "
"intended meaning isn't clear, using the full terms avoids ambiguity."
msgstr "此术语通常是指异步生成器函数，但在某些情况下则可能是指 *异步生成器迭代器*。如果需要清楚表达具体含义，请使用全称以避免歧义。"

#: ../../glossary.rst:105
msgid ""
"An asynchronous generator function may contain :keyword:`await` expressions "
"as well as :keyword:`async for`, and :keyword:`async with` statements."
msgstr ""
"一个异步生成器函数可能包含 :keyword:`await` 表达式或者 :keyword:`async for` 以及 :keyword:`async"
" with` 语句。"

#: ../../glossary.rst:108
msgid "asynchronous generator iterator"
msgstr "asynchronous generator iterator -- 异步生成器迭代器"

#: ../../glossary.rst:110
msgid "An object created by a :term:`asynchronous generator` function."
msgstr ":term:`asynchronous generator` 函数所创建的对象。"

#: ../../glossary.rst:112
msgid ""
"This is an :term:`asynchronous iterator` which when called using the "
":meth:`~object.__anext__` method returns an awaitable object which will "
"execute the body of the asynchronous generator function until the next "
":keyword:`yield` expression."
msgstr ""
"此对象属于 :term:`asynchronous iterator`，当使用 :meth:`~object.__anext__` "
"方法调用时会返回一个可等待对象来执行异步生成器函数的函数体直到下一个 :keyword:`yield` 表达式。"

#: ../../glossary.rst:117
msgid ""
"Each :keyword:`yield` temporarily suspends processing, remembering the "
"execution state (including local variables and pending try-statements).  "
"When the *asynchronous generator iterator* effectively resumes with another "
"awaitable returned by :meth:`~object.__anext__`, it picks up where it left "
"off.  See :pep:`492` and :pep:`525`."
msgstr ""
"每个 :keyword:`yield` 会临时暂停处理过程，记住执行状态（包括局部变量和挂起的 try 语句）。 当 *异步生成器迭代器* 通过 "
":meth:`~object.__anext__` 所返回的另一个可等待对象有效地恢复时，它会从离开位置恢复处理过程。 参见 :pep:`492` 和 "
":pep:`525`。"

#: ../../glossary.rst:122
msgid "asynchronous iterable"
msgstr "asynchronous iterable -- 异步可迭代对象"

#: ../../glossary.rst:124
msgid ""
"An object, that can be used in an :keyword:`async for` statement. Must "
"return an :term:`asynchronous iterator` from its :meth:`~object.__aiter__` "
"method.  Introduced by :pep:`492`."
msgstr ""
"一个可以在 :keyword:`async for` 语句中使用的对象。 必须通过它的 :meth:`~object.__aiter__` 方法返回一个"
" :term:`asynchronous iterator`。 由 :pep:`492` 引入。"

#: ../../glossary.rst:127
msgid "asynchronous iterator"
msgstr "asynchronous iterator -- 异步迭代器"

#: ../../glossary.rst:129
msgid ""
"An object that implements the :meth:`~object.__aiter__` and "
":meth:`~object.__anext__` methods.  :meth:`~object.__anext__` must return an"
" :term:`awaitable` object. :keyword:`async for` resolves the awaitables "
"returned by an asynchronous iterator's :meth:`~object.__anext__` method "
"until it raises a :exc:`StopAsyncIteration` exception.  Introduced by "
":pep:`492`."
msgstr ""
"一个实现了 :meth:`~object.__aiter__` 和 :meth:`~object.__anext__` 方法的对象。 "
":meth:`~object.__anext__` 必须返回一个 :term:`awaitable` 对象。 :keyword:`async for` "
"会处理异步迭代器的 :meth:`~object.__anext__` 方法所返回的可等待对象直到其引发一个 "
":exc:`StopAsyncIteration` 异常。 由 :pep:`492` 引入。"

#: ../../glossary.rst:134
msgid "attached thread state"
msgstr "attached thread state -- 附加线程状态"

#: ../../glossary.rst:137
msgid "A :term:`thread state` that is active for the current OS thread."
msgstr "为当前 OS 线程激活的 :term:`thread state`。"

#: ../../glossary.rst:139
msgid ""
"When a :term:`thread state` is attached, the OS thread has access to the "
"full Python C API and can safely invoke the bytecode interpreter."
msgstr "当附加 :term:`thread state` 时，OS 线程将可访问完整 Python C API 并能安全地唤起字节码解释器。"

#: ../../glossary.rst:143
msgid ""
"Unless a function explicitly notes otherwise, attempting to call the C API "
"without an attached thread state will result in a fatal error or undefined "
"behavior.  A thread state can be attached and detached explicitly by the "
"user through the C API, or implicitly by the runtime, including during "
"blocking C calls and by the bytecode interpreter in between calls."
msgstr ""
"除非函数明确指出，否则尝试在没有附加线程状态的情况下调用C API将导致致命错误或未定义行为。线程状态可以由用户通过C "
"API显式地附加和分离，也可以由运行时隐式地附加和分离，包括在阻塞C调用期间和调用之间的字节码解释器。"

#: ../../glossary.rst:150
msgid ""
"On most builds of Python, having an attached thread state implies that the "
"caller holds the :term:`GIL` for the current interpreter, so only one OS "
"thread can have an attached thread state at a given moment. In :term:`free-"
"threaded <free threading>` builds of Python, threads can concurrently hold "
"an attached thread state, allowing for true parallelism of the bytecode "
"interpreter."
msgstr ""
"在大多数Python版本中，具有附加线程状态意味着调用者持有当前解释器的  "
":term:`GIL`，因此在给定时刻只有一个操作系统线程可以具有附加线程状态。在Python的 :term:`自由线程 <free "
"threading>` 版本中，线程可以并发地持有附加线程状态，从而允许字节码解释器的真正并行性。"

#: ../../glossary.rst:156
msgid "attribute"
msgstr "attribute -- 属性"

#: ../../glossary.rst:158
msgid ""
"A value associated with an object which is usually referenced by name using "
"dotted expressions. For example, if an object *o* has an attribute *a* it "
"would be referenced as *o.a*."
msgstr "关联到一个对象的值，通常使用点号表达式按名称来引用。 举例来说，如果对象 *o* 具有属性 *a* 则可以用 *o.a* 来引用它。"

#: ../../glossary.rst:163
msgid ""
"It is possible to give an object an attribute whose name is not an "
"identifier as defined by :ref:`identifiers`, for example using "
":func:`setattr`, if the object allows it. Such an attribute will not be "
"accessible using a dotted expression, and would instead need to be retrieved"
" with :func:`getattr`."
msgstr ""
"如果对象允许，将未被定义为 :ref:`identifiers` 的非标识名称用作一个对象的属性也是可以的，例如使用 :func:`setattr`。 "
"这样的属性将无法使用点号表达式来访问，而是必须通过 :func:`getattr` 来获取。"

#: ../../glossary.rst:168
msgid "awaitable"
msgstr "awaitable -- 可等待对象"

#: ../../glossary.rst:170
msgid ""
"An object that can be used in an :keyword:`await` expression.  Can be a "
":term:`coroutine` or an object with an :meth:`~object.__await__` method. See"
" also :pep:`492`."
msgstr ""
"一个可在 :keyword:`await` 表达式中使用的对象。 可以是 :term:`coroutine` 或是具有 "
":meth:`~object.__await__` 方法的对象。 参见 :pep:`492`。"

#: ../../glossary.rst:173
msgid "BDFL"
msgstr "BDFL"

#: ../../glossary.rst:175
msgid ""
"Benevolent Dictator For Life, a.k.a. `Guido van Rossum "
"<https://gvanrossum.github.io/>`_, Python's creator."
msgstr ""
"“终身仁慈独裁者”的英文缩写，即 `Guido van Rossum <https://gvanrossum.github.io/>`_，Python "
"的创造者。"

#: ../../glossary.rst:177
msgid "binary file"
msgstr "binary file -- 二进制文件"

#: ../../glossary.rst:179
msgid ""
"A :term:`file object` able to read and write :term:`bytes-like objects "
"<bytes-like object>`. Examples of binary files are files opened in binary "
"mode (``'rb'``, ``'wb'`` or ``'rb+'``), :data:`sys.stdin.buffer "
"<sys.stdin>`, :data:`sys.stdout.buffer <sys.stdout>`, and instances of "
":class:`io.BytesIO` and :class:`gzip.GzipFile`."
msgstr ""
":term:`file object` 能够读写 :term:`字节型对象 <bytes-like object>`。 二进制文件的例子包括以二进制模式"
" (``'rb'``, ``'wb'`` 或 ``'rb+'``) 打开的文件、:data:`sys.stdin.buffer "
"<sys.stdin>`、:data:`sys.stdout.buffer <sys.stdout>` 以及 :class:`io.BytesIO` 和"
" :class:`gzip.GzipFile` 的实例。"

#: ../../glossary.rst:186
msgid ""
"See also :term:`text file` for a file object able to read and write "
":class:`str` objects."
msgstr "另请参见 :term:`text file` 了解能够读写 :class:`str` 对象的文件对象。"

#: ../../glossary.rst:188
msgid "borrowed reference"
msgstr "borrowed reference -- 借入引用"

#: ../../glossary.rst:190
msgid ""
"In Python's C API, a borrowed reference is a reference to an object, where "
"the code using the object does not own the reference. It becomes a dangling "
"pointer if the object is destroyed. For example, a garbage collection can "
"remove the last :term:`strong reference` to the object and so destroy it."
msgstr ""
"在 Python 的 C API 中，借用引用是指一种对象引用，使用该对象的代码并不持有该引用。 如果对象被销毁则它就会变成一个悬空指针。 "
"例如，垃圾回收器可以移除对象的最后一个 :term:`strong reference` 来销毁它。"

#: ../../glossary.rst:196
msgid ""
"Calling :c:func:`Py_INCREF` on the :term:`borrowed reference` is recommended"
" to convert it to a :term:`strong reference` in-place, except when the "
"object cannot be destroyed before the last usage of the borrowed reference. "
"The :c:func:`Py_NewRef` function can be used to create a new :term:`strong "
"reference`."
msgstr ""
"推荐在 :term:`borrowed reference` 上调用 :c:func:`Py_INCREF` 以将其原地转换为 "
":term:`strong reference`，除非是当该对象无法在借入引用的最后一次使用之前被销毁。 :c:func:`Py_NewRef` "
"函数可以被用来创建一个新的 :term:`strong reference`。"

#: ../../glossary.rst:201
msgid "bytes-like object"
msgstr "bytes-like object -- 字节型对象"

#: ../../glossary.rst:203
msgid ""
"An object that supports the :ref:`bufferobjects` and can export a "
"C-:term:`contiguous` buffer. This includes all :class:`bytes`, "
":class:`bytearray`, and :class:`array.array` objects, as well as many common"
" :class:`memoryview` objects.  Bytes-like objects can be used for various "
"operations that work with binary data; these include compression, saving to "
"a binary file, and sending over a socket."
msgstr ""
"支持 :ref:`bufferobjects` 并且能导出 C-:term:`contiguous` 缓冲的对象。这包括所有 "
":class:`bytes`、:class:`bytearray` 和 :class:`array.array` 对象，以及许多普通 "
":class:`memoryview` 对象。 字节型对象可在多种二进制数据操作中使用；这些操作包括压缩、保存为二进制文件以及通过套接字发送等。"

#: ../../glossary.rst:210
msgid ""
"Some operations need the binary data to be mutable.  The documentation often"
" refers to these as \"read-write bytes-like objects\".  Example mutable "
"buffer objects include :class:`bytearray` and a :class:`memoryview` of a "
":class:`bytearray`. Other operations require the binary data to be stored in"
" immutable objects (\"read-only bytes-like objects\"); examples of these "
"include :class:`bytes` and a :class:`memoryview` of a :class:`bytes` object."
msgstr ""
"某些操作需要可变的二进制数据。这种对象在文档中常被称为“可读写字节类对象”。可变缓冲对象的例子包括 :class:`bytearray` 以及 "
":class:`bytearray` 的 :class:`memoryview`。其他操作要求二进制数据存放于不可变对象 "
"(\"只读字节类对象\")；这种对象的例子包括 :class:`bytes` 以及 :class:`bytes` 对象的 "
":class:`memoryview`。"

#: ../../glossary.rst:218
msgid "bytecode"
msgstr "bytecode -- 字节码"

#: ../../glossary.rst:220
msgid ""
"Python source code is compiled into bytecode, the internal representation of"
" a Python program in the CPython interpreter.  The bytecode is also cached "
"in ``.pyc`` files so that executing the same file is faster the second time "
"(recompilation from source to bytecode can be avoided).  This \"intermediate"
" language\" is said to run on a :term:`virtual machine` that executes the "
"machine code corresponding to each bytecode. Do note that bytecodes are not "
"expected to work between different Python virtual machines, nor to be stable"
" between Python releases."
msgstr ""
"Python 源代码会被编译为字节码，即 CPython 解释器中表示 Python 程序的内部代码。字节码还会缓存在 ``.pyc`` "
"文件中，这样第二次执行同一文件时速度更快（可以免去将源码重新编译为字节码）。这种 \"中间语言\" 运行在根据字节码执行相应机器码的 "
":term:`virtual machine` 之上。请注意不同 Python 虚拟机上的字节码不一定通用，也不一定能在不同 Python 版本上兼容。"

#: ../../glossary.rst:230
msgid ""
"A list of bytecode instructions can be found in the documentation for "
":ref:`the dis module <bytecodes>`."
msgstr "字节码指令列表可以在 :ref:`dis 模块 <bytecodes>` 的文档中查看。"

#: ../../glossary.rst:232
msgid "callable"
msgstr "callable -- 可调用对象"

#: ../../glossary.rst:234
msgid ""
"A callable is an object that can be called, possibly with a set of arguments"
" (see :term:`argument`), with the following syntax::"
msgstr "可调用对象就是可以执行调用运算的对象，并可能附带一组参数 (参见 :term:`argument`)，使用以下语法::"

#: ../../glossary.rst:237
msgid "callable(argument1, argument2, argumentN)"
msgstr "callable(argument1, argument2, argumentN)"

#: ../../glossary.rst:239
msgid ""
"A :term:`function`, and by extension a :term:`method`, is a callable. An "
"instance of a class that implements the :meth:`~object.__call__` method is "
"also a callable."
msgstr ""
":term:`function`，还可扩展到 :term:`method` 等，就属于可调用对象。 实现了 "
":meth:`~object.__call__` 方法的类的实例也属于可调用对象。"

#: ../../glossary.rst:242
msgid "callback"
msgstr "callback -- 回调"

#: ../../glossary.rst:244
msgid ""
"A subroutine function which is passed as an argument to be executed at some "
"point in the future."
msgstr "一个作为参数被传入以用以在未来的某个时刻被调用的子例程函数。"

#: ../../glossary.rst:246
msgid "class"
msgstr "class -- 类"

#: ../../glossary.rst:248
msgid ""
"A template for creating user-defined objects. Class definitions normally "
"contain method definitions which operate on instances of the class."
msgstr "用来创建用户定义对象的模板。类定义通常包含对该类的实例进行操作的方法定义。"

#: ../../glossary.rst:251
msgid "class variable"
msgstr "class variable -- 类变量"

#: ../../glossary.rst:253
msgid ""
"A variable defined in a class and intended to be modified only at class "
"level (i.e., not in an instance of the class)."
msgstr "在类中定义的变量，并且仅限在类的层级上修改 (而不是在类的实例中修改)。"

#: ../../glossary.rst:255
msgid "closure variable"
msgstr "closure variable -- 闭包变量"

#: ../../glossary.rst:257
msgid ""
"A :term:`free variable` referenced from a :term:`nested scope` that is "
"defined in an outer scope rather than being resolved at runtime from the "
"globals or builtin namespaces. May be explicitly defined with the "
":keyword:`nonlocal` keyword to allow write access, or implicitly defined if "
"the variable is only being read."
msgstr ""
"引用自 :term:`nested scope` 的 :term:`free "
"variable`，它是在外层作用域中定义而不是在运行时自全局或内置命名空间中取得。 可能使用 :keyword:`nonlocal` "
"关键字显式地定义以允许写入访问，或者如果变量仅供读取则只需隐式地定义。"

#: ../../glossary.rst:262
msgid ""
"For example, in the ``inner`` function in the following code, both ``x`` and"
" ``print`` are :term:`free variables <free variable>`, but only ``x`` is a "
"*closure variable*::"
msgstr ""
"例如，在以下代码的 ``inner`` 函数中，``x`` 和 ``print`` 均为 :term:`自由变量 <free "
"variable>`，但只有 ``x`` 属于 *闭包变量*::"

#: ../../glossary.rst:265
msgid ""
"def outer():\n"
"    x = 0\n"
"    def inner():\n"
"        nonlocal x\n"
"        x += 1\n"
"        print(x)\n"
"    return inner"
msgstr ""
"def outer():\n"
"    x = 0\n"
"    def inner():\n"
"        nonlocal x\n"
"        x += 1\n"
"        print(x)\n"
"    return inner"

#: ../../glossary.rst:273
msgid ""
"Due to the :attr:`codeobject.co_freevars` attribute (which, despite its "
"name, only includes the names of closure variables rather than listing all "
"referenced free variables), the more general :term:`free variable` term is "
"sometimes used even when the intended meaning is to refer specifically to "
"closure variables."
msgstr ""
"由于 :attr:`codeobject.co_freevars` "
"属性的存在（虽然名称如此，但其仅包括闭包变量名称而非列出所有被引用的自由变量），更一般化的术语 :term:`free variable` "
"有时在即便本意是专指闭包变量时也会被使用。"

#: ../../glossary.rst:277
msgid "complex number"
msgstr "complex number -- 复数"

#: ../../glossary.rst:279
msgid ""
"An extension of the familiar real number system in which all numbers are "
"expressed as a sum of a real part and an imaginary part.  Imaginary numbers "
"are real multiples of the imaginary unit (the square root of ``-1``), often "
"written ``i`` in mathematics or ``j`` in engineering.  Python has built-in "
"support for complex numbers, which are written with this latter notation; "
"the imaginary part is written with a ``j`` suffix, e.g., ``3+1j``.  To get "
"access to complex equivalents of the :mod:`math` module, use :mod:`cmath`.  "
"Use of complex numbers is a fairly advanced mathematical feature.  If you're"
" not aware of a need for them, it's almost certain you can safely ignore "
"them."
msgstr ""
"对普通实数系统的扩展，其中所有数字都被表示为一个实部和一个虚部的和。虚数是虚数单位（``-1`` 的平方根）的实倍数，通常在数学中写为 "
"``i``，在工程学中写为 ``j``。Python 内置了对复数的支持，采用工程学标记方式；虚部带有一个 ``j`` 后缀，例如 "
"``3+1j``。如果需要 :mod:`math` 模块内对象的对应复数版本，请使用 "
":mod:`cmath`，复数的使用是一个比较高级的数学特性。如果你感觉没有必要，忽略它们也几乎不会有任何问题。"

#: ../../glossary.rst:289
msgid "context"
msgstr "context -- 上下文"

#: ../../glossary.rst:291
msgid ""
"This term has different meanings depending on where and how it is used. Some"
" common meanings:"
msgstr "此术语根据其所在场合和使用方式的不同而具有不同的含义。 一些常见的含义为："

#: ../../glossary.rst:294
msgid ""
"The temporary state or environment established by a :term:`context manager` "
"via a :keyword:`with` statement."
msgstr "通过 :keyword:`with` 语句由一个 :term:`context manager` 所创建的临时环境或状态。"

#: ../../glossary.rst:296
msgid ""
"The collection of key­value bindings associated with a particular "
":class:`contextvars.Context` object and accessed via "
":class:`~contextvars.ContextVar` objects.  Also see :term:`context "
"variable`."
msgstr ""
"一组关联到特定 :class:`contextvars.Context` 对象并通过 :class:`~contextvars.ContextVar` "
"对象来访问的键值绑定。 另请参见 :term:`context variable`。"

#: ../../glossary.rst:300
msgid ""
"A :class:`contextvars.Context` object.  Also see :term:`current context`."
msgstr "一个 :class:`contextvars.Context` 对象。 另请参见 :term:`current context`。"

#: ../../glossary.rst:302
msgid "context management protocol"
msgstr "context management protocol -- 上下文管理协议"

#: ../../glossary.rst:304
msgid ""
"The :meth:`~object.__enter__` and :meth:`~object.__exit__` methods called by"
" the :keyword:`with` statement.  See :pep:`343`."
msgstr ""
":meth:`~object.__enter__` 和 :meth:`~object.__exit__` 方法将由 :keyword:`with` "
"语句来调用。 参见 :pep:`343`。"

#: ../../glossary.rst:306
msgid "context manager"
msgstr "context manager -- 上下文管理器"

#: ../../glossary.rst:308
msgid ""
"An object which implements the :term:`context management protocol` and "
"controls the environment seen in a :keyword:`with` statement.  See "
":pep:`343`."
msgstr ""
"一个实现了 :term:`context management protocol` 并负责控制某个 :keyword:`with` 语句内的环境的对象。"
" 参见 :pep:`343`。"

#: ../../glossary.rst:311
msgid "context variable"
msgstr "context variable -- 上下文变量"

#: ../../glossary.rst:313
msgid ""
"A variable whose value depends on which context is the :term:`current "
"context`.  Values are accessed via :class:`contextvars.ContextVar` objects."
"  Context variables are primarily used to isolate state between concurrent "
"asynchronous tasks."
msgstr ""
"一个具体值取决于哪个上下文是 :term:`current context` 的变量。 这些值是通过 "
":class:`contextvars.ContextVar` 对象来访问的。 上下文变量主要被用来隔离并发的异步任务之间的状态。"

#: ../../glossary.rst:317
msgid "contiguous"
msgstr "contiguous -- 连续"

#: ../../glossary.rst:321
msgid ""
"A buffer is considered contiguous exactly if it is either *C-contiguous* or "
"*Fortran contiguous*.  Zero-dimensional buffers are C and Fortran "
"contiguous.  In one-dimensional arrays, the items must be laid out in memory"
" next to each other, in order of increasing indexes starting from zero.  In "
"multidimensional C-contiguous arrays, the last index varies the fastest when"
" visiting items in order of memory address.  However, in Fortran contiguous "
"arrays, the first index varies the fastest."
msgstr ""
"一个缓冲如果是 *C 连续* 或 *Fortran 连续* 就会被认为是连续的。零维缓冲是 C 和 Fortran "
"连续的。在一维数组中，所有条目必须在内存中彼此相邻地排列，采用从零开始的递增索引顺序。在多维 "
"C-连续数组中，当按内存地址排列时用最后一个索引访问条目时速度最快。但是在 Fortran 连续数组中则是用第一个索引最快。"

#: ../../glossary.rst:329
msgid "coroutine"
msgstr "coroutine -- 协程"

#: ../../glossary.rst:331
msgid ""
"Coroutines are a more generalized form of subroutines. Subroutines are "
"entered at one point and exited at another point.  Coroutines can be "
"entered, exited, and resumed at many different points.  They can be "
"implemented with the :keyword:`async def` statement.  See also :pep:`492`."
msgstr ""
"协程是子例程的更一般形式。  子例程可以在某一点进入并在另一点退出。 协程则可以在许多不同的点上进入、退出和恢复。 它们可通过 "
":keyword:`async def` 语句来实现。 参见 :pep:`492`。"

#: ../../glossary.rst:336
msgid "coroutine function"
msgstr "coroutine function -- 协程函数"

#: ../../glossary.rst:338
msgid ""
"A function which returns a :term:`coroutine` object.  A coroutine function "
"may be defined with the :keyword:`async def` statement, and may contain "
":keyword:`await`, :keyword:`async for`, and :keyword:`async with` keywords."
"  These were introduced by :pep:`492`."
msgstr ""
"返回一个 :term:`coroutine` 对象的函数。协程函数可通过 :keyword:`async def` 语句来定义，并可能包含 "
":keyword:`await`、:keyword:`async for` 和 :keyword:`async with` 关键字。这些特性是由 "
":pep:`492` 引入的。"

#: ../../glossary.rst:343
msgid "CPython"
msgstr "CPython"

#: ../../glossary.rst:345
msgid ""
"The canonical implementation of the Python programming language, as "
"distributed on `python.org <https://www.python.org>`_.  The term \"CPython\""
" is used when necessary to distinguish this implementation from others such "
"as Jython or IronPython."
msgstr ""
"Python 编程语言的规范实现，在 `python.org <https://www.python.org>`_ 上发布。\"CPython\" "
"一词用于在必要时将此实现与其他实现例如 Jython 或 IronPython 相区别。"

#: ../../glossary.rst:349
msgid "current context"
msgstr "current context -- 当前上下文"

#: ../../glossary.rst:351
msgid ""
"The :term:`context` (:class:`contextvars.Context` object) that is currently "
"used by :class:`~contextvars.ContextVar` objects to access (get or set) the "
"values of :term:`context variables <context variable>`.  Each thread has its"
" own current context.  Frameworks for executing asynchronous tasks (see "
":mod:`asyncio`) associate each task with a context which becomes the current"
" context whenever the task starts or resumes execution."
msgstr ""
"在当前被 :class:`~contextvars.ContextVar` 对象用来访问 (获取或设置) :term:`上下文变量 <context "
"variable>` 的值的 :term:`context` (:class:`contextvars.Context` 对象)。 "
"每个线程都具有它自己的当前上下文。 用于执行异步任务 (参见 :mod:`asyncio`) "
"的框架会在每个任务开始或恢复执行时将任务关联到一个成为当前上下文的上下文。"

#: ../../glossary.rst:357
msgid "cyclic isolate"
msgstr "cyclic isolate -- 循环隔离"

#: ../../glossary.rst:359
msgid ""
"A subgroup of one or more objects that reference each other in a reference "
"cycle, but are not referenced by objects outside the group.  The goal of the"
" :term:`cyclic garbage collector <garbage collection>` is to identify these "
"groups and break the reference cycles so that the memory can be reclaimed."
msgstr ""
"某个引用循环中的子分组，其中包含的一个或多个对象会相互引用但不会被分组以外的对象所引用。 :term:`循环垃圾回收器 <garbage "
"collection>` 的目标是标识出这些分组并打断其引用循环以便回收相应的内存。"

#: ../../glossary.rst:363
msgid "decorator"
msgstr "decorator -- 装饰器"

#: ../../glossary.rst:365
msgid ""
"A function returning another function, usually applied as a function "
"transformation using the ``@wrapper`` syntax.  Common examples for "
"decorators are :func:`classmethod` and :func:`staticmethod`."
msgstr ""
"返回值为另一个函数的函数，通常使用 ``@wrapper`` 语法形式来进行函数变换。 装饰器的常见例子包括 :func:`classmethod` 和"
" :func:`staticmethod`。"

#: ../../glossary.rst:369
msgid ""
"The decorator syntax is merely syntactic sugar, the following two function "
"definitions are semantically equivalent::"
msgstr "装饰器语法只是一种语法糖，以下两个函数定义在语义上完全等价::"

#: ../../glossary.rst:372
msgid ""
"def f(arg):\n"
"    ...\n"
"f = staticmethod(f)\n"
"\n"
"@staticmethod\n"
"def f(arg):\n"
"    ..."
msgstr ""
"def f(arg):\n"
"    ...\n"
"f = staticmethod(f)\n"
"\n"
"@staticmethod\n"
"def f(arg):\n"
"    ..."

#: ../../glossary.rst:380
msgid ""
"The same concept exists for classes, but is less commonly used there.  See "
"the documentation for :ref:`function definitions <function>` and :ref:`class"
" definitions <class>` for more about decorators."
msgstr ""
"同样的概念也适用于类，但通常较少这样使用。有关装饰器的详情可参见 :ref:`函数定义 <function>` 和 :ref:`类定义 <class>`"
" 的文档。"

#: ../../glossary.rst:383
msgid "descriptor"
msgstr "descriptor -- 描述器"

#: ../../glossary.rst:385
msgid ""
"Any object which defines the methods :meth:`~object.__get__`, "
":meth:`~object.__set__`, or :meth:`~object.__delete__`. When a class "
"attribute is a descriptor, its special binding behavior is triggered upon "
"attribute lookup.  Normally, using *a.b* to get, set or delete an attribute "
"looks up the object named *b* in the class dictionary for *a*, but if *b* is"
" a descriptor, the respective descriptor method gets called.  Understanding "
"descriptors is a key to a deep understanding of Python because they are the "
"basis for many features including functions, methods, properties, class "
"methods, static methods, and reference to super classes."
msgstr ""
"任何定义了 :meth:`~object.__get__`, :meth:`~object.__set__` 或 "
":meth:`~object.__delete__` 方法的对象。 当一个类属性为描述器时，它的特殊绑定行为就会在属性查找时被触发。 通常情况下，使用 "
"*a.b* 来获取、设置或删除一个属性时会在 *a* 类的字典中查找名称为 *b* 的对象，但如果 *b* 是一个描述器，则会调用对应的描述器方法。 "
"理解描述器的概念是更深层次理解 Python 的关键，因为这是许多重要特性的基础，包括函数、方法、特征属性、类方法、静态方法以及对超类的引用等等。"

#: ../../glossary.rst:396
msgid ""
"For more information about descriptors' methods, see :ref:`descriptors` or "
"the :ref:`Descriptor How To Guide <descriptorhowto>`."
msgstr ""
"有关描述器的方法的更多信息，请参阅 :ref:`descriptors` 或 :ref:`描述器使用指南 <descriptorhowto>`。"

#: ../../glossary.rst:398
msgid "dictionary"
msgstr "dictionary -- 字典"

#: ../../glossary.rst:400
msgid ""
"An associative array, where arbitrary keys are mapped to values.  The keys "
"can be any object with :meth:`~object.__hash__` and :meth:`~object.__eq__` "
"methods. Called a hash in Perl."
msgstr ""
"一个关联数组，其中的任意键都映射到相应的值。 键可以是任何具有 :meth:`~object.__hash__` 和 "
":meth:`~object.__eq__` 方法的对象。 在 Perl 中称为 hash。"

#: ../../glossary.rst:404
msgid "dictionary comprehension"
msgstr "dictionary comprehension -- 字典推导式"

#: ../../glossary.rst:406
msgid ""
"A compact way to process all or part of the elements in an iterable and "
"return a dictionary with the results. ``results = {n: n ** 2 for n in "
"range(10)}`` generates a dictionary containing key ``n`` mapped to value ``n"
" ** 2``. See :ref:`comprehensions`."
msgstr ""
"处理一个可迭代对象中的所有或部分元素并返回结果字典的一种紧凑写法。 ``results = {n: n ** 2 for n in "
"range(10)}`` 将生成一个由键 ``n`` 到值 ``n ** 2`` 的映射构成的字典。 参见 :ref:`comprehensions`。"

#: ../../glossary.rst:410
msgid "dictionary view"
msgstr "dictionary view -- 字典视图"

#: ../../glossary.rst:412
msgid ""
"The objects returned from :meth:`dict.keys`, :meth:`dict.values`, and "
":meth:`dict.items` are called dictionary views. They provide a dynamic view "
"on the dictionary’s entries, which means that when the dictionary changes, "
"the view reflects these changes. To force the dictionary view to become a "
"full list use ``list(dictview)``.  See :ref:`dict-views`."
msgstr ""
"从 :meth:`dict.keys`, :meth:`dict.values` 和 :meth:`dict.items` "
"返回的对象被称为字典视图。它们提供了字典条目的一个动态视图，这意味着当字典改变时，视图也会相应改变。要将字典视图强制转换为真正的列表，可使用 "
"``list(dictview)``。参见 :ref:`dict-views`。"

#: ../../glossary.rst:418
msgid "docstring"
msgstr "docstring -- 文档字符串"

#: ../../glossary.rst:420
msgid ""
"A string literal which appears as the first expression in a class, function "
"or module.  While ignored when the suite is executed, it is recognized by "
"the compiler and put into the :attr:`~definition.__doc__` attribute of the "
"enclosing class, function or module.  Since it is available via "
"introspection, it is the canonical place for documentation of the object."
msgstr ""
"作为类、函数或模块之内的第一个表达式出现的字符串字面值。 它在代码块被执行时将被忽略，但会被编译器识别并放入所在类、函数或模块的 "
":attr:`~definition.__doc__` 属性中。 由于它可用于代码内省，因此是存放对象的文档的规范位置。"

#: ../../glossary.rst:426
msgid "duck-typing"
msgstr "duck-typing -- 鸭子类型"

#: ../../glossary.rst:428
msgid ""
"A programming style which does not look at an object's type to determine if "
"it has the right interface; instead, the method or attribute is simply "
"called or used (\"If it looks like a duck and quacks like a duck, it must be"
" a duck.\")  By emphasizing interfaces rather than specific types, well-"
"designed code improves its flexibility by allowing polymorphic substitution."
"  Duck-typing avoids tests using :func:`type` or :func:`isinstance`.  (Note,"
" however, that duck-typing can be complemented with :term:`abstract base "
"classes <abstract base class>`.)  Instead, it typically employs "
":func:`hasattr` tests or :term:`EAFP` programming."
msgstr ""
"指一种编程风格，它并不依靠查找对象类型来确定其是否具有正确的接口，而是直接调用或使用其方法或属性（“看起来像鸭子，叫起来也像鸭子，那么肯定就是鸭子。”）由于强调接口而非特定类型，设计良好的代码可通过允许多态替代来提升灵活性。鸭子类型避免使用"
" :func:`type` 或 :func:`isinstance` 检测。(但要注意鸭子类型可以使用 :term:`抽象基类 <abstract "
"base class>` 作为补充。)  而往往会采用 :func:`hasattr` 检测或是 :term:`EAFP` 编程。"

#: ../../glossary.rst:437
msgid "EAFP"
msgstr "EAFP"

#: ../../glossary.rst:439
msgid ""
"Easier to ask for forgiveness than permission.  This common Python coding "
"style assumes the existence of valid keys or attributes and catches "
"exceptions if the assumption proves false.  This clean and fast style is "
"characterized by the presence of many :keyword:`try` and :keyword:`except` "
"statements.  The technique contrasts with the :term:`LBYL` style common to "
"many other languages such as C."
msgstr ""
"“求原谅比求许可更容易”的英文缩写。这种 Python "
"常用代码编写风格会假定所需的键或属性存在，并在假定错误时捕获异常。这种简洁快速风格的特点就是大量运用 :keyword:`try` 和 "
":keyword:`except` 语句。于其相对的则是所谓 :term:`LBYL` 风格，常见于 C 等许多其他语言。"

#: ../../glossary.rst:445
msgid "evaluate function"
msgstr "evaluate function -- 求值函数"

#: ../../glossary.rst:447
msgid ""
"A function that can be called to evaluate a lazily evaluated attribute of an"
" object, such as the value of type aliases created with the :keyword:`type` "
"statement."
msgstr "一种可被调用来针对某个对象的惰性求值属性进行求值的函数，比如使用 :keyword:`type` 语句创建的类型别名的值。"

#: ../../glossary.rst:450
msgid "expression"
msgstr "expression -- 表达式"

#: ../../glossary.rst:452
msgid ""
"A piece of syntax which can be evaluated to some value.  In other words, an "
"expression is an accumulation of expression elements like literals, names, "
"attribute access, operators or function calls which all return a value.  In "
"contrast to many other languages, not all language constructs are "
"expressions.  There are also :term:`statement`\\s which cannot be used as "
"expressions, such as :keyword:`while`.  Assignments are also statements, not"
" expressions."
msgstr ""
"可以求出某个值的语法单元。 换句话说，一个表达式就是表达元素例如字面值、名称、属性访问、运算符或函数调用的汇总，它们最终都会返回一个值。 "
"与许多其他语言不同，并非所有语言构件都是表达式。 还存在不能被用作表达式的 :term:`statement`，例如 :keyword:`while`。"
" 赋值也是属于语句而非表达式。"

#: ../../glossary.rst:459
msgid "extension module"
msgstr "extension module -- 扩展模块"

#: ../../glossary.rst:461
msgid ""
"A module written in C or C++, using Python's C API to interact with the core"
" and with user code."
msgstr "以 C 或 C++ 编写的模块，使用 Python 的 C API 来与语言核心以及用户代码进行交互。"

#: ../../glossary.rst:463
msgid "f-string"
msgstr "f-string -- f-字符串"

#: ../../glossary.rst:465
msgid ""
"String literals prefixed with ``f`` or ``F`` are commonly called "
"\"f-strings\" which is short for :ref:`formatted string literals "
"<f-strings>`.  See also :pep:`498`."
msgstr ""
"带有 ``f`` 或 ``F`` 前缀的字符串字面值通常被称为 \"f-字符串\" 即 :ref:`格式化字符串字面值 <f-strings>` "
"的简写。 另请参阅 :pep:`498`。"

#: ../../glossary.rst:468
msgid "file object"
msgstr "file object -- 文件对象"

#: ../../glossary.rst:470
msgid ""
"An object exposing a file-oriented API (with methods such as :meth:`!read` "
"or :meth:`!write`) to an underlying resource.  Depending on the way it was "
"created, a file object can mediate access to a real on-disk file or to "
"another type of storage or communication device (for example standard "
"input/output, in-memory buffers, sockets, pipes, etc.).  File objects are "
"also called :dfn:`file-like objects` or :dfn:`streams`."
msgstr ""
"对外公开面向文件的 API（带有 :meth:`!read` 或 :meth:`!write` 等方法）以使用下层资源的对象。 "
"根据其创建方式的不同，文件对象可以处理对真实磁盘文件、其他类型的存储或通信设备的访问（例如标准输入/输出、内存缓冲区、套接字、管道等）。 "
"文件对象也被称为 :dfn:`文件型对象` 或 :dfn:`流`。"

#: ../../glossary.rst:478
msgid ""
"There are actually three categories of file objects: raw :term:`binary files"
" <binary file>`, buffered :term:`binary files <binary file>` and :term:`text"
" files <text file>`. Their interfaces are defined in the :mod:`io` module.  "
"The canonical way to create a file object is by using the :func:`open` "
"function."
msgstr ""
"实际上共有三种类别的文件对象: 原始 :term:`二进制文件 <binary file>`, 缓冲 :term:`二进制文件 <binary "
"file>` 以及 :term:`文本文件 <text file>`。它们的接口定义均在 :mod:`io` 模块中。 创建文件对象的规范方式是使用 "
":func:`open` 函数。"

#: ../../glossary.rst:483
msgid "file-like object"
msgstr "file-like object -- 文件型对象"

#: ../../glossary.rst:485
msgid "A synonym for :term:`file object`."
msgstr ":term:`file object` 的同义词。"

#: ../../glossary.rst:486
msgid "filesystem encoding and error handler"
msgstr "filesystem encoding and error handler  -- 文件系统编码格式与错误处理器"

#: ../../glossary.rst:488
msgid ""
"Encoding and error handler used by Python to decode bytes from the operating"
" system and encode Unicode to the operating system."
msgstr "Python 用来从操作系统解码字节串和向操作系统编码 Unicode 的编码格式与错误处理器。"

#: ../../glossary.rst:491
msgid ""
"The filesystem encoding must guarantee to successfully decode all bytes "
"below 128. If the file system encoding fails to provide this guarantee, API "
"functions can raise :exc:`UnicodeError`."
msgstr ""
"文件系统编码格式必须保证能成功解码长度在 128 以下的所有字节串。 如果文件系统编码格式无法提供此保证，则 API 函数可能会引发 "
":exc:`UnicodeError`。"

#: ../../glossary.rst:495
msgid ""
"The :func:`sys.getfilesystemencoding` and "
":func:`sys.getfilesystemencodeerrors` functions can be used to get the "
"filesystem encoding and error handler."
msgstr ""
":func:`sys.getfilesystemencoding` 和 :func:`sys.getfilesystemencodeerrors` "
"函数可被用来获取文件系统编码格式与错误处理器。"

#: ../../glossary.rst:499
msgid ""
"The :term:`filesystem encoding and error handler` are configured at Python "
"startup by the :c:func:`PyConfig_Read` function: see "
":c:member:`~PyConfig.filesystem_encoding` and "
":c:member:`~PyConfig.filesystem_errors` members of :c:type:`PyConfig`."
msgstr ""
":term:`filesystem encoding and error handler` 是在 Python 启动时通过 "
":c:func:`PyConfig_Read` 函数来配置的：请参阅 :c:type:`PyConfig` 的 "
":c:member:`~PyConfig.filesystem_encoding` 和 "
":c:member:`~PyConfig.filesystem_errors` 等成员。"

#: ../../glossary.rst:504
msgid "See also the :term:`locale encoding`."
msgstr "另请参见 :term:`locale encoding`。"

#: ../../glossary.rst:505
msgid "finder"
msgstr "finder -- 查找器"

#: ../../glossary.rst:507
msgid ""
"An object that tries to find the :term:`loader` for a module that is being "
"imported."
msgstr "一种会尝试查找被导入模块的 :term:`loader` 的对象。"

#: ../../glossary.rst:510
msgid ""
"There are two types of finder: :term:`meta path finders <meta path finder>` "
"for use with :data:`sys.meta_path`, and :term:`path entry finders <path "
"entry finder>` for use with :data:`sys.path_hooks`."
msgstr ""
"存在两种类型的查找器: :term:`元路径查找器 <meta path finder>` 配合 :data:`sys.meta_path` 使用，以及"
" :term:`路径条目查找器 <path entry finder>` 配合 :data:`sys.path_hooks` 使用。"

#: ../../glossary.rst:514
msgid ""
"See :ref:`finders-and-loaders` and :mod:`importlib` for much more detail."
msgstr "请参阅 :ref:`finders-and-loaders` 和 :mod:`importlib` 以了解更多细节。"

#: ../../glossary.rst:515
msgid "floor division"
msgstr "floor division -- 向下取整除法"

#: ../../glossary.rst:517
msgid ""
"Mathematical division that rounds down to nearest integer.  The floor "
"division operator is ``//``.  For example, the expression ``11 // 4`` "
"evaluates to ``2`` in contrast to the ``2.75`` returned by float true "
"division.  Note that ``(-11) // 4`` is ``-3`` because that is ``-2.75`` "
"rounded *downward*. See :pep:`238`."
msgstr ""
"向下舍入到最接近的整数的数学除法。向下取整除法的运算符是 ``//`` 。例如，表达式 ``11 // 4`` 的计算结果是 ``2`` "
"，而与之相反的是浮点数的真正除法返回 ``2.75`` 。注意 ``(-11) // 4`` 会返回 ``-3`` 因为这是 ``-2.75`` "
"*向下* 舍入得到的结果。见 :pep:`238` 。"

#: ../../glossary.rst:522
msgid "free threading"
msgstr "free threading -- 自由线程"

#: ../../glossary.rst:524
msgid ""
"A threading model where multiple threads can run Python bytecode "
"simultaneously within the same interpreter.  This is in contrast to the "
":term:`global interpreter lock` which allows only one thread to execute "
"Python bytecode at a time.  See :pep:`703`."
msgstr ""
"一种线程模型，在同一个解释器内部的多个线程可以同时运行 Python 字节码。 与此相对的是 :term:`global interpreter "
"lock`，在同一时刻只允许一个线程执行 Python 字节码。 参见 :pep:`703`。"

#: ../../glossary.rst:528
msgid "free variable"
msgstr "free variable -- 自由变量"

#: ../../glossary.rst:530
msgid ""
"Formally, as defined in the :ref:`language execution model <bind_names>`, a "
"free variable is any variable used in a namespace which is not a local "
"variable in that namespace. See :term:`closure variable` for an example. "
"Pragmatically, due to the name of the :attr:`codeobject.co_freevars` "
"attribute, the term is also sometimes used as a synonym for :term:`closure "
"variable`."
msgstr ""
"在正式场合下，如 :ref:`语言执行模型 <bind_names>` "
"所定义的，自由变量是指在某个命名空间中被使用的不属于该命名空间中的局部变量的任何变量。 参见 :term:`closure variable` "
"中的样例。 在实际应用中，由于 :attr:`codeobject.co_freevars` 属性被如此命名，该术语有时也被用作 "
":term:`closure variable` 的同义词。"

#: ../../glossary.rst:535
msgid "function"
msgstr "function -- 函数"

#: ../../glossary.rst:537
msgid ""
"A series of statements which returns some value to a caller. It can also be "
"passed zero or more :term:`arguments <argument>` which may be used in the "
"execution of the body. See also :term:`parameter`, :term:`method`, and the "
":ref:`function` section."
msgstr ""
"可以向调用者返回某个值的一组语句。还可以向其传入零个或多个 :term:`参数 <argument>` 并在函数体执行中被使用。另见 "
":term:`parameter`, :term:`method` 和 :ref:`function` 等节。"

#: ../../glossary.rst:541
msgid "function annotation"
msgstr "function annotation -- 函数标注"

#: ../../glossary.rst:543
msgid "An :term:`annotation` of a function parameter or return value."
msgstr "即针对函数形参或返回值的 :term:`annotation` 。"

#: ../../glossary.rst:545
msgid ""
"Function annotations are usually used for :term:`type hints <type hint>`: "
"for example, this function is expected to take two :class:`int` arguments "
"and is also expected to have an :class:`int` return value::"
msgstr ""
"函数标注通常用于 :term:`类型提示 <type hint>`：例如以下函数预期接受两个 :class:`int` 参数并预期返回一个 "
":class:`int` 值::"

#: ../../glossary.rst:550
msgid ""
"def sum_two_numbers(a: int, b: int) -> int:\n"
"   return a + b"
msgstr ""
"def sum_two_numbers(a: int, b: int) -> int:\n"
"   return a + b"

#: ../../glossary.rst:553
msgid "Function annotation syntax is explained in section :ref:`function`."
msgstr "函数标注语法的详解见 :ref:`function` 一节。"

#: ../../glossary.rst:555
msgid ""
"See :term:`variable annotation` and :pep:`484`, which describe this "
"functionality. Also see :ref:`annotations-howto` for best practices on "
"working with annotations."
msgstr ""
"参见 :term:`variable annotation` 和 :pep:`484`，其中描述了此功能。 另请参阅 "
":ref:`annotations-howto` 以了解使用标的最佳实践。"

#: ../../glossary.rst:559
msgid "__future__"
msgstr "__future__"

#: ../../glossary.rst:561
msgid ""
"A :ref:`future statement <future>`, ``from __future__ import <feature>``, "
"directs the compiler to compile the current module using syntax or semantics"
" that will become standard in a future release of Python. The "
":mod:`__future__` module documents the possible values of *feature*.  By "
"importing this module and evaluating its variables, you can see when a new "
"feature was first added to the language and when it will (or did) become the"
" default::"
msgstr ""
":ref:`future 语句 <future>`, ``from __future__ import <feature>`` 指示编译器使用将在未来的"
" Python 发布版中成为标准的语法和语义来编译当前模块。 :mod:`__future__` 模块文档记录了可能 的 *feature* 取值。 "
"通过导入此模块并对其变量求值，你可以看到每项新特性在何时被首次加入到该语言中以及它将（或已）在何时成为默认::"

#: ../../glossary.rst:569
msgid ""
">>> import __future__\n"
">>> __future__.division\n"
"_Feature((2, 2, 0, 'alpha', 2), (3, 0, 0, 'alpha', 0), 8192)"
msgstr ""
">>> import __future__\n"
">>> __future__.division\n"
"_Feature((2, 2, 0, 'alpha', 2), (3, 0, 0, 'alpha', 0), 8192)"

#: ../../glossary.rst:572
msgid "garbage collection"
msgstr "garbage collection -- 垃圾回收"

#: ../../glossary.rst:574
msgid ""
"The process of freeing memory when it is not used anymore.  Python performs "
"garbage collection via reference counting and a cyclic garbage collector "
"that is able to detect and break reference cycles.  The garbage collector "
"can be controlled using the :mod:`gc` module."
msgstr ""
"释放不再被使用的内存空间的过程。Python 是通过引用计数和一个能够检测和打破循环引用的循环垃圾回收器来执行垃圾回收的。可以使用 :mod:`gc` "
"模块来控制垃圾回收器。"

#: ../../glossary.rst:579 ../../glossary.rst:580
msgid "generator"
msgstr "generator -- 生成器"

#: ../../glossary.rst:582
msgid ""
"A function which returns a :term:`generator iterator`.  It looks like a "
"normal function except that it contains :keyword:`yield` expressions for "
"producing a series of values usable in a for-loop or that can be retrieved "
"one at a time with the :func:`next` function."
msgstr ""
"返回一个 :term:`generator iterator` 的函数。它看起来很像普通函数，不同点在于其包含 :keyword:`yield` "
"表达式以便产生一系列值供给 for-循环使用或是通过 :func:`next` 函数逐一获取。"

#: ../../glossary.rst:587
msgid ""
"Usually refers to a generator function, but may refer to a *generator "
"iterator* in some contexts.  In cases where the intended meaning isn't "
"clear, using the full terms avoids ambiguity."
msgstr "通常是指生成器函数，但在某些情况下也可能是指 *生成器迭代器*。如果需要清楚表达具体含义，请使用全称以避免歧义。"

#: ../../glossary.rst:590
msgid "generator iterator"
msgstr "generator iterator -- 生成器迭代器"

#: ../../glossary.rst:592
msgid "An object created by a :term:`generator` function."
msgstr ":term:`generator` 函数所创建的对象。"

#: ../../glossary.rst:594
msgid ""
"Each :keyword:`yield` temporarily suspends processing, remembering the "
"execution state (including local variables and pending try-statements).  "
"When the *generator iterator* resumes, it picks up where it left off (in "
"contrast to functions which start fresh on every invocation)."
msgstr ""
"每个 :keyword:`yield` 会临时暂停处理过程，记住执行状态（包括局部变量和挂起的 try 语句）。 当 *生成器迭代器* "
"恢复时，它会从离开位置继续执行（不同于每次被唤起时都从新开始的普通函数）。"

#: ../../glossary.rst:600 ../../glossary.rst:601
msgid "generator expression"
msgstr "generator expression -- 生成器表达式"

#: ../../glossary.rst:603
msgid ""
"An :term:`expression` that returns an :term:`iterator`.  It looks like a "
"normal expression followed by a :keyword:`!for` clause defining a loop "
"variable, range, and an optional :keyword:`!if` clause.  The combined "
"expression generates values for an enclosing function::"
msgstr ""
"返回一个 :term:`iterator` 的 :term:`expression`。 它看起来很像普通表达式后带有定义了一个循环变量、范围的 "
":keyword:`!for` 子句，以及一个可选的 :keyword:`!if` 子句。 以下复合表达式会为外层函数生成一系列值::"

#: ../../glossary.rst:608
msgid ""
">>> sum(i*i for i in range(10))         # sum of squares 0, 1, 4, ... 81\n"
"285"
msgstr ""
">>> sum(i*i for i in range(10))         # 平方值 0, 1, 4, ... 81 之和\n"
"285"

#: ../../glossary.rst:610
msgid "generic function"
msgstr "generic function -- 泛型函数"

#: ../../glossary.rst:612
msgid ""
"A function composed of multiple functions implementing the same operation "
"for different types. Which implementation should be used during a call is "
"determined by the dispatch algorithm."
msgstr "为不同的类型实现相同操作的多个函数所组成的函数。在调用时会由调度算法来确定应该使用哪个实现。"

#: ../../glossary.rst:616
msgid ""
"See also the :term:`single dispatch` glossary entry, the "
":func:`functools.singledispatch` decorator, and :pep:`443`."
msgstr ""
"另请参见 :term:`single dispatch` 术语表条目、:func:`functools.singledispatch` 装饰器以及 "
":pep:`443`。"

#: ../../glossary.rst:618
msgid "generic type"
msgstr "generic type -- 泛型"

#: ../../glossary.rst:620
msgid ""
"A :term:`type` that can be parameterized; typically a :ref:`container "
"class<sequence-types>` such as :class:`list` or :class:`dict`. Used for "
":term:`type hints <type hint>` and :term:`annotations <annotation>`."
msgstr ""
"可参数化的 :term:`type`；通常为 :class:`list` 或 :class:`dict` 这样的 :ref:`容器类 "
"<sequence-types>`。用于 :term:`类型提示 <type hint>` 和 :term:`注解 <annotation>`。"

#: ../../glossary.rst:625
msgid ""
"For more details, see :ref:`generic alias types<types-genericalias>`, "
":pep:`483`, :pep:`484`, :pep:`585`, and the :mod:`typing` module."
msgstr ""
"更多细节参见 :ref:`泛型别名类型 <types-genericalias>`、:pep:`483`、:pep:`484`、:pep:`585` 和"
" :mod:`typing` 模块。"

#: ../../glossary.rst:627
msgid "GIL"
msgstr "GIL"

#: ../../glossary.rst:629
msgid "See :term:`global interpreter lock`."
msgstr "参见 :term:`global interpreter lock`。"

#: ../../glossary.rst:630
msgid "global interpreter lock"
msgstr "global interpreter lock -- 全局解释器锁"

#: ../../glossary.rst:632
msgid ""
"The mechanism used by the :term:`CPython` interpreter to assure that only "
"one thread executes Python :term:`bytecode` at a time. This simplifies the "
"CPython implementation by making the object model (including critical built-"
"in types such as :class:`dict`) implicitly safe against concurrent access.  "
"Locking the entire interpreter makes it easier for the interpreter to be "
"multi-threaded, at the expense of much of the parallelism afforded by multi-"
"processor machines."
msgstr ""
":term:`CPython` 解释器所采用的一种机制，它确保同一时刻只有一个线程在执行 Python "
":term:`bytecode`。此机制通过设置对象模型（包括 :class:`dict` 等重要内置类型）针对并发访问的隐式安全简化了 CPython"
" 实现。给整个解释器加锁使得解释器多线程运行更方便，其代价则是牺牲了在多处理器上的并行性。"

#: ../../glossary.rst:641
msgid ""
"However, some extension modules, either standard or third-party, are "
"designed so as to release the GIL when doing computationally intensive tasks"
" such as compression or hashing.  Also, the GIL is always released when "
"doing I/O."
msgstr ""
"不过，某些标准库或第三方库的扩展模块被设计为在执行计算密集型任务如压缩或哈希时释放 GIL。 此外，在执行 I/O 操作时也总是会释放 GIL。"

#: ../../glossary.rst:646
msgid ""
"As of Python 3.13, the GIL can be disabled using the :option:`--disable-gil`"
" build configuration. After building Python with this option, code must be "
"run with :option:`-X gil=0 <-X>` or after setting the :envvar:`PYTHON_GIL=0 "
"<PYTHON_GIL>` environment variable. This feature enables improved "
"performance for multi-threaded applications and makes it easier to use "
"multi-core CPUs efficiently. For more details, see :pep:`703`."
msgstr ""
"在 Python 3.13 中，GIL 可以使用 :option:`--disable-gil` 构建配置选项来禁用。 在使用此选项构建 Python "
"之后，代码必须附带 :option:`-X gil=0 <-X>` 或在设置 :envvar:`PYTHON_GIL=0 <PYTHON_GIL>` "
"环境变量后运行。 此特性将为多线程应用程序启用性能提升并让高效率地使用多核 CPU 更加容易。 要了解详情，请参阅 :pep:`703`。"

#: ../../glossary.rst:653
msgid ""
"In prior versions of Python's C API, a function might declare that it "
"requires the GIL to be held in order to use it. This refers to having an "
":term:`attached thread state`."
msgstr ""
"在之前版本的 Python's C API 中，一个函数可能会声明它需要持有 GIL 才能够使用。 这被称为具有一个 :term:`attached "
"thread state`。"

#: ../../glossary.rst:656
msgid "hash-based pyc"
msgstr "hash-based pyc -- 基于哈希的 pyc"

#: ../../glossary.rst:658
msgid ""
"A bytecode cache file that uses the hash rather than the last-modified time "
"of the corresponding source file to determine its validity. See :ref:`pyc-"
"invalidation`."
msgstr "使用对应源文件的哈希值而非最后修改时间来确定其有效性的字节码缓存文件。 参见 :ref:`pyc-invalidation`。"

#: ../../glossary.rst:661
msgid "hashable"
msgstr "hashable -- 可哈希"

#: ../../glossary.rst:663
msgid ""
"An object is *hashable* if it has a hash value which never changes during "
"its lifetime (it needs a :meth:`~object.__hash__` method), and can be "
"compared to other objects (it needs an :meth:`~object.__eq__` method). "
"Hashable objects which compare equal must have the same hash value."
msgstr ""
"一个对象如果具有在其生命期内绝不改变的哈希值（它需要有 :meth:`~object.__hash__` 方法），并可以同其他对象进行比较（它需要有 "
":meth:`~object.__eq__` 方法）就被称为 *可哈希* 对象。 可哈希对象必须具有相同的哈希值比较结果才会相等。"

#: ../../glossary.rst:669
msgid ""
"Hashability makes an object usable as a dictionary key and a set member, "
"because these data structures use the hash value internally."
msgstr "可哈希性使得对象能够作为字典键或集合成员使用，因为这些数据结构要在内部使用哈希值。"

#: ../../glossary.rst:672
msgid ""
"Most of Python's immutable built-in objects are hashable; mutable containers"
" (such as lists or dictionaries) are not; immutable containers (such as "
"tuples and frozensets) are only hashable if their elements are hashable.  "
"Objects which are instances of user-defined classes are hashable by default."
"  They all compare unequal (except with themselves), and their hash value is"
" derived from their :func:`id`."
msgstr ""
"大多数 Python 中的不可变内置对象都是可哈希的；可变容器（例如列表或字典）都不可哈希；不可变容器（例如元组和 "
"frozenset）仅当它们的元素均为可哈希时才是可哈希的。 用户定义类的实例对象默认是可哈希的。 "
"它们在比较时一定不相同（除非是与自己比较），它们的哈希值的生成是基于它们的 :func:`id`。"

#: ../../glossary.rst:679
msgid "IDLE"
msgstr "IDLE"

#: ../../glossary.rst:681
msgid ""
"An Integrated Development and Learning Environment for Python. :ref:`idle` "
"is a basic editor and interpreter environment which ships with the standard "
"distribution of Python."
msgstr "Python 的集成开发与学习环境。 :ref:`idle` 是 Python 标准发行版附带的基本编辑器和解释器环境。"

#: ../../glossary.rst:684
msgid "immortal"
msgstr "immortal -- 永生对象"

#: ../../glossary.rst:686
msgid ""
"*Immortal objects* are a CPython implementation detail introduced in "
":pep:`683`."
msgstr "*永生对象* 是在 :pep:`683` 中引入的 CPython 实现细节。"

#: ../../glossary.rst:689
msgid ""
"If an object is immortal, its :term:`reference count` is never modified, and"
" therefore it is never deallocated while the interpreter is running. For "
"example, :const:`True` and :const:`None` are immortal in CPython."
msgstr ""
"如果对象属于永生对象，则它的 :term:`reference count` 永远不会被修改，因而它在解释器运行期间永远不会被取消分配。 "
"例如，:const:`True` 和 :const:`None` 在 CPython 中都属于永生对象。"

#: ../../glossary.rst:693
msgid ""
"Immortal objects can be identified via :func:`sys._is_immortal`, or via "
":c:func:`PyUnstable_IsImmortal` in the C API."
msgstr ""
"永生对象可通过 :func:`sys._is_immortal`，或通过 C API 中的 "
":c:func:`PyUnstable_IsImmortal` 来标识。"

#: ../../glossary.rst:695
msgid "immutable"
msgstr "immutable -- 不可变对象"

#: ../../glossary.rst:697
msgid ""
"An object with a fixed value.  Immutable objects include numbers, strings "
"and tuples.  Such an object cannot be altered.  A new object has to be "
"created if a different value has to be stored.  They play an important role "
"in places where a constant hash value is needed, for example as a key in a "
"dictionary."
msgstr ""
"具有固定值的对象。不可变对象包括数字、字符串和元组。这样的对象不能被改变。如果必须存储一个不同的值，则必须创建新的对象。它们在需要常量哈希值的地方起着重要作用，例如作为字典中的键。"

#: ../../glossary.rst:702
msgid "import path"
msgstr "import path -- 导入路径"

#: ../../glossary.rst:704
msgid ""
"A list of locations (or :term:`path entries <path entry>`) that are searched"
" by the :term:`path based finder` for modules to import. During import, this"
" list of locations usually comes from :data:`sys.path`, but for subpackages "
"it may also come from the parent package's ``__path__`` attribute."
msgstr ""
"由多个位置（或 :term:`路径条目 <path entry>`）组成的列表，会被模块的 :term:`path based finder` "
"用来查找导入目标。在导入时，此位置列表通常来自 :data:`sys.path`，但对次级包来说也可能来自上级包的 ``__path__`` 属性。"

#: ../../glossary.rst:709
msgid "importing"
msgstr "importing -- 导入"

#: ../../glossary.rst:711
msgid ""
"The process by which Python code in one module is made available to Python "
"code in another module."
msgstr "令一个模块中的 Python 代码能为另一个模块中的 Python 代码所使用的过程。"

#: ../../glossary.rst:713
msgid "importer"
msgstr "importer -- 导入器"

#: ../../glossary.rst:715
msgid ""
"An object that both finds and loads a module; both a :term:`finder` and "
":term:`loader` object."
msgstr "查找并加载模块的对象；此对象既属于 :term:`finder` 又属于 :term:`loader`。"

#: ../../glossary.rst:717
msgid "interactive"
msgstr "interactive -- 交互"

#: ../../glossary.rst:719
msgid ""
"Python has an interactive interpreter which means you can enter statements "
"and expressions at the interpreter prompt, immediately execute them and see "
"their results.  Just launch ``python`` with no arguments (possibly by "
"selecting it from your computer's main menu). It is a very powerful way to "
"test out new ideas or inspect modules and packages (remember ``help(x)``). "
"For more on interactive mode, see :ref:`tut-interac`."
msgstr ""
"Python 带有一个交互式解释器，这意味着你可以在解释器提示符后输入语句和表达式，立即执行并查看其结果。 只需不带参数地启动 ``python`` "
"命令（也可以在你的计算机主菜单中选择相应菜单项）。 在测试新想法或检验模块和包的时候这会非常方便（记住 ``help(x)`` 函数）。 "
"有关交互模式的详情，参见 :ref:`tut-interac`。"

#: ../../glossary.rst:726
msgid "interpreted"
msgstr "interpreted -- 解释型"

#: ../../glossary.rst:728
msgid ""
"Python is an interpreted language, as opposed to a compiled one, though the "
"distinction can be blurry because of the presence of the bytecode compiler."
"  This means that source files can be run directly without explicitly "
"creating an executable which is then run. Interpreted languages typically "
"have a shorter development/debug cycle than compiled ones, though their "
"programs generally also run more slowly.  See also :term:`interactive`."
msgstr ""
"Python "
"一是种解释型语言，与之相对的是编译型语言，虽然两者的区别由于字节码编译器的存在而会有所模糊。这意味着源文件可以直接运行而不必显式地创建可执行文件再运行。解释型语言通常具有比编译型语言更短的开发/调试周期，但是其程序往往运行得更慢。参见"
" :term:`interactive`。"

#: ../../glossary.rst:735
msgid "interpreter shutdown"
msgstr "interpreter shutdown -- 解释器关闭"

#: ../../glossary.rst:737
msgid ""
"When asked to shut down, the Python interpreter enters a special phase where"
" it gradually releases all allocated resources, such as modules and various "
"critical internal structures.  It also makes several calls to the "
":term:`garbage collector <garbage collection>`. This can trigger the "
"execution of code in user-defined destructors or weakref callbacks. Code "
"executed during the shutdown phase can encounter various exceptions as the "
"resources it relies on may not function anymore (common examples are library"
" modules or the warnings machinery)."
msgstr ""
"当被要求关闭时，Python 解释器将进入一个特殊运行阶段并逐步释放所有已分配资源，例如模块和各种关键内部结构等。它还会多次调用 "
":term:`垃圾回收器 <garbage "
"collection>`。这会触发用户定义析构器或弱引用回调中的代码执行。在关闭阶段执行的代码可能会遇到各种异常，因为其所依赖的资源已不再有效（常见的例子有库模块或警告机制等）。"

#: ../../glossary.rst:746
msgid ""
"The main reason for interpreter shutdown is that the ``__main__`` module or "
"the script being run has finished executing."
msgstr "解释器需要关闭的主要原因有 ``__main__`` 模块或所运行的脚本已完成执行。"

#: ../../glossary.rst:748
msgid "iterable"
msgstr "iterable -- 可迭代对象"

#: ../../glossary.rst:750
msgid ""
"An object capable of returning its members one at a time. Examples of "
"iterables include all sequence types (such as :class:`list`, :class:`str`, "
"and :class:`tuple`) and some non-sequence types like :class:`dict`, "
":term:`file objects <file object>`, and objects of any classes you define "
"with an :meth:`~object.__iter__` method or with a "
":meth:`~object.__getitem__` method that implements :term:`sequence` "
"semantics."
msgstr ""
"一种能够逐个返回其成员项的对象。 可迭代对象的例子包括所有序列类型（如 :class:`list`, :class:`str` 和 "
":class:`tuple` 等）以及某些非序列类型如 :class:`dict`, :term:`文件对象 <file object>` "
"以及任何定义了 :meth:`~object.__iter__` 方法或实现了 :term:`sequence` 语义的 "
":meth:`~object.__getitem__` 方法的自定义类的对象。"

#: ../../glossary.rst:758
msgid ""
"Iterables can be used in a :keyword:`for` loop and in many other places "
"where a sequence is needed (:func:`zip`, :func:`map`, ...).  When an "
"iterable object is passed as an argument to the built-in function "
":func:`iter`, it returns an iterator for the object.  This iterator is good "
"for one pass over the set of values.  When using iterables, it is usually "
"not necessary to call :func:`iter` or deal with iterator objects yourself.  "
"The :keyword:`for` statement does that automatically for you, creating a "
"temporary unnamed variable to hold the iterator for the duration of the "
"loop.  See also :term:`iterator`, :term:`sequence`, and :term:`generator`."
msgstr ""
"可迭代对象可被用于 :keyword:`for` 循环以及许多其他需要一个序列的地方 (:func:`zip`, :func:`map`, ...)。 "
"当一个可迭代对象作为参数被传给内置函数 :func:`iter` 时，它会返回该对象的迭代器。 这种迭代器适用于对值集合的一次性遍历。 "
"在使用可迭代对象时，你通常不需要调用 :func:`iter` 或者自己处理迭代器对象。 :keyword:`for` "
"语句会自动为你处理那些操作，创建一个临时的未命名变量用来在循环期间保存迭代器。 参见 :term:`iterator`, "
":term:`sequence` 和 :term:`generator`。"

#: ../../glossary.rst:768
msgid "iterator"
msgstr "iterator -- 迭代器"

#: ../../glossary.rst:770
msgid ""
"An object representing a stream of data.  Repeated calls to the iterator's "
":meth:`~iterator.__next__` method (or passing it to the built-in function "
":func:`next`) return successive items in the stream.  When no more data are "
"available a :exc:`StopIteration` exception is raised instead.  At this "
"point, the iterator object is exhausted and any further calls to its "
":meth:`!__next__` method just raise :exc:`StopIteration` again.  Iterators "
"are required to have an :meth:`~iterator.__iter__` method that returns the "
"iterator object itself so every iterator is also iterable and may be used in"
" most places where other iterables are accepted.  One notable exception is "
"code which attempts multiple iteration passes.  A container object (such as "
"a :class:`list`) produces a fresh new iterator each time you pass it to the "
":func:`iter` function or use it in a :keyword:`for` loop.  Attempting this "
"with an iterator will just return the same exhausted iterator object used in"
" the previous iteration pass, making it appear like an empty container."
msgstr ""
"用来表示一连串数据流的对象。 重复调用迭代器的 :meth:`~iterator.__next__` 方法 (或将其传给内置函数 "
":func:`next`) 将逐个返回流中的项。 当没有数据可用时则将引发 :exc:`StopIteration` 异常。 "
"到这时迭代器对象中的数据项已耗尽，继续调用其 :meth:`!__next__` 方法只会再次引发 :exc:`StopIteration`。 "
"迭代器必须具有 :meth:`~iterator.__iter__` "
"方法用来返回该迭代器对象自身，因此迭代器必定也是可迭代对象，可被用于其他可迭代对象适用的大部分场合。 一个显著的例外是那些会多次重复访问迭代项的代码。 "
"容器对象 (例如 :class:`list`) 在你每次将其传入 :func:`iter` 函数或是在 :keyword:`for` "
"循环中使用时都会产生一个新的迭代器。 如果在此情况下你尝试用迭代器则会返回在之前迭代过程中被耗尽的同一迭代器对象，使其看起来就像是一个空容器。"

#: ../../glossary.rst:785
msgid "More information can be found in :ref:`typeiter`."
msgstr "更多信息可查看 :ref:`typeiter`。"

#: ../../glossary.rst:789
msgid ""
"CPython does not consistently apply the requirement that an iterator define "
":meth:`~iterator.__iter__`. And also please note that the free-threading "
"CPython does not guarantee the thread-safety of iterator operations."
msgstr ""
"CPython 没有强制推行迭代器定义 :meth:`~iterator.__iter__` 的要求。 还要注意的是自由线程 CPython "
"并不保证迭代器操作的线程安全性。"

#: ../../glossary.rst:794
msgid "key function"
msgstr "key function -- 键函数"

#: ../../glossary.rst:796
msgid ""
"A key function or collation function is a callable that returns a value used"
" for sorting or ordering.  For example, :func:`locale.strxfrm` is used to "
"produce a sort key that is aware of locale specific sort conventions."
msgstr ""
"键函数或称整理函数，是能够返回用于排序或排位的值的可调用对象。例如，:func:`locale.strxfrm` "
"可用于生成一个符合特定区域排序约定的排序键。"

#: ../../glossary.rst:801
msgid ""
"A number of tools in Python accept key functions to control how elements are"
" ordered or grouped.  They include :func:`min`, :func:`max`, :func:`sorted`,"
" :meth:`list.sort`, :func:`heapq.merge`, :func:`heapq.nsmallest`, "
":func:`heapq.nlargest`, and :func:`itertools.groupby`."
msgstr ""
"Python 中有许多工具都允许用键函数来控制元素的排位或分组方式。其中包括 :func:`min`, :func:`max`, "
":func:`sorted`, :meth:`list.sort`, :func:`heapq.merge`, "
":func:`heapq.nsmallest`, :func:`heapq.nlargest` 以及 "
":func:`itertools.groupby`。"

#: ../../glossary.rst:807
msgid ""
"There are several ways to create a key function.  For example. the "
":meth:`str.lower` method can serve as a key function for case insensitive "
"sorts.  Alternatively, a key function can be built from a :keyword:`lambda` "
"expression such as ``lambda r: (r[0], r[2])``.  Also, "
":func:`operator.attrgetter`, :func:`operator.itemgetter`, and "
":func:`operator.methodcaller` are three key function constructors.  See the "
":ref:`Sorting HOW TO <sortinghowto>` for examples of how to create and use "
"key functions."
msgstr ""
"有多种方式可以创建一个键函数。 例如，:meth:`str.lower` 方法可以用作忽略大小写排序的键函数。 或者，键函数也可通过 "
":keyword:`lambda` 表达式来创建例如 ``lambda r: (r[0], r[2])``。 "
"此外，:func:`operator.attrgetter`, :func:`operator.itemgetter` 和 "
":func:`operator.methodcaller` 是键函数的三个构造器。 请查看 :ref:`排序指引 <sortinghowto>` "
"来获取创建和使用键函数的示例。"

#: ../../glossary.rst:814
msgid "keyword argument"
msgstr "keyword argument -- 关键字参数"

#: ../../glossary.rst:816 ../../glossary.rst:1131
msgid "See :term:`argument`."
msgstr "参见 :term:`argument`。"

#: ../../glossary.rst:817
msgid "lambda"
msgstr "lambda"

#: ../../glossary.rst:819
msgid ""
"An anonymous inline function consisting of a single :term:`expression` which"
" is evaluated when the function is called.  The syntax to create a lambda "
"function is ``lambda [parameters]: expression``"
msgstr ""
"由一个单独 :term:`expression` 构成的匿名内联函数，表达式会在调用时被求值。创建 lambda 函数的句法为 ``lambda "
"[parameters]: expression``"

#: ../../glossary.rst:822
msgid "LBYL"
msgstr "LBYL"

#: ../../glossary.rst:824
msgid ""
"Look before you leap.  This coding style explicitly tests for pre-conditions"
" before making calls or lookups.  This style contrasts with the :term:`EAFP`"
" approach and is characterized by the presence of many :keyword:`if` "
"statements."
msgstr ""
"“先查看后跳跃”的英文缩写。这种代码编写风格会在进行调用或查找之前显式地检查前提条件。此风格与 :term:`EAFP` 方式恰成对比，其特点是大量使用"
" :keyword:`if` 语句。"

#: ../../glossary.rst:829
msgid ""
"In a multi-threaded environment, the LBYL approach can risk introducing a "
"race condition between \"the looking\" and \"the leaping\".  For example, "
"the code, ``if key in mapping: return mapping[key]`` can fail if another "
"thread removes *key* from *mapping* after the test, but before the lookup. "
"This issue can be solved with locks or by using the EAFP approach."
msgstr ""
"在多线程环境中，LBYL 方式会导致“查看”和“跳跃”之间发生条件竞争风险。例如，以下代码 ``if key in mapping: return "
"mapping[key]`` 可能由于在检查操作之后其他线程从 *mapping* 中移除了 *key* 而出错。这种问题可通过加锁或使用 EAFP "
"方式来解决。"

#: ../../glossary.rst:834
msgid "lexical analyzer"
msgstr "lexical analyzer -- 词法分析器"

#: ../../glossary.rst:837
msgid "Formal name for the *tokenizer*; see :term:`token`."
msgstr "*分词器* 的正式名称；参见 :term:`token`。"

#: ../../glossary.rst:838
msgid "list"
msgstr "list -- 列表"

#: ../../glossary.rst:840
msgid ""
"A built-in Python :term:`sequence`.  Despite its name it is more akin to an "
"array in other languages than to a linked list since access to elements is "
"*O*\\ (1)."
msgstr ""
"一种 Python 内置 :term:`sequence`。 虽然名为列表，但它更类似于其他语言中的数组而非链表，因为访问元素的时间复杂度为 *O*\\"
" (1)。"

#: ../../glossary.rst:843
msgid "list comprehension"
msgstr "list comprehension -- 列表推导式"

#: ../../glossary.rst:845
msgid ""
"A compact way to process all or part of the elements in a sequence and "
"return a list with the results.  ``result = ['{:#04x}'.format(x) for x in "
"range(256) if x % 2 == 0]`` generates a list of strings containing even hex "
"numbers (0x..) in the range from 0 to 255. The :keyword:`if` clause is "
"optional.  If omitted, all elements in ``range(256)`` are processed."
msgstr ""
"处理一个序列中的所有或部分元素并返回结果列表的一种紧凑写法。``result = ['{:#04x}'.format(x) for x in "
"range(256) if x % 2 == 0]`` 将生成一个 0 到 255 范围内的十六进制偶数对应字符串（0x..）的列表。其中 "
":keyword:`if` 子句是可选的，如果省略则 ``range(256)`` 中的所有元素都会被处理。"

#: ../../glossary.rst:851
msgid "loader"
msgstr "loader -- 加载器"

#: ../../glossary.rst:853
msgid ""
"An object that loads a module. It must define the :meth:`!exec_module` and "
":meth:`!create_module` methods to implement the "
":class:`~importlib.abc.Loader` interface. A loader is typically returned by "
"a :term:`finder`. See also:"
msgstr ""
"负责加载模块的对象。 它必须定义 :meth:`!exec_module` 和 :meth:`!create_module` 方法以实现 "
":class:`~importlib.abc.Loader` 接口。 加载器通常由一个 :term:`finder` 返回。 另请参阅："

#: ../../glossary.rst:859
msgid ":ref:`finders-and-loaders`"
msgstr ":ref:`finders-and-loaders`"

#: ../../glossary.rst:860
msgid ":class:`importlib.abc.Loader`"
msgstr ":class:`importlib.abc.Loader`"

#: ../../glossary.rst:861
msgid ":pep:`302`"
msgstr ":pep:`302`"

#: ../../glossary.rst:862
msgid "locale encoding"
msgstr "locale encoding -- 语言区域编码格式"

#: ../../glossary.rst:864
msgid ""
"On Unix, it is the encoding of the LC_CTYPE locale. It can be set with "
":func:`locale.setlocale(locale.LC_CTYPE, new_locale) <locale.setlocale>`."
msgstr ""
"在 Unix 上，它是 LC_CTYPE 语言区域的编码格式。 它可以通过 "
":func:`locale.setlocale(locale.LC_CTYPE, new_locale) <locale.setlocale>` "
"来设置。"

#: ../../glossary.rst:867
msgid "On Windows, it is the ANSI code page (ex: ``\"cp1252\"``)."
msgstr "在 Windows 上，它是 ANSI 代码页 (如: ``\"cp1252\"``)。"

#: ../../glossary.rst:869
msgid "On Android and VxWorks, Python uses ``\"utf-8\"`` as the locale encoding."
msgstr "在 Android 和 VxWorks 上，Python 使用 ``\"utf-8\"`` 作为语言区域编码格式。"

#: ../../glossary.rst:871
msgid ":func:`locale.getencoding` can be used to get the locale encoding."
msgstr ":func:`locale.getencoding` 可被用来获取语言区域编码格式。"

#: ../../glossary.rst:873
msgid "See also the :term:`filesystem encoding and error handler`."
msgstr "另请参阅 :term:`filesystem encoding and error handler`。"

#: ../../glossary.rst:874
msgid "magic method"
msgstr "magic method -- 魔术方法"

#: ../../glossary.rst:878
msgid "An informal synonym for :term:`special method`."
msgstr ":term:`special method` 的非正式同义词 。"

#: ../../glossary.rst:879
msgid "mapping"
msgstr "mapping -- 映射"

#: ../../glossary.rst:881
msgid ""
"A container object that supports arbitrary key lookups and implements the "
"methods specified in the :class:`collections.abc.Mapping` or "
":class:`collections.abc.MutableMapping` :ref:`abstract base classes "
"<collections-abstract-base-classes>`.  Examples include :class:`dict`, "
":class:`collections.defaultdict`, :class:`collections.OrderedDict` and "
":class:`collections.Counter`."
msgstr ""
"一种支持任意键查找并实现了 :class:`collections.abc.Mapping` 或 "
":class:`collections.abc.MutableMapping` :ref:`抽象基类 <collections-abstract-"
"base-classes>` 所规定方法的容器对象。 此类对象的例子包括 :class:`dict`, "
":class:`collections.defaultdict`, :class:`collections.OrderedDict` 以及 "
":class:`collections.Counter`。"

#: ../../glossary.rst:887
msgid "meta path finder"
msgstr "meta path finder -- 元路径查找器"

#: ../../glossary.rst:889
msgid ""
"A :term:`finder` returned by a search of :data:`sys.meta_path`.  Meta path "
"finders are related to, but different from :term:`path entry finders <path "
"entry finder>`."
msgstr ""
":data:`sys.meta_path` 的搜索所返回的 :term:`finder`。元路径查找器与 :term:`path entry "
"finders <path entry finder>` 存在关联但并不相同。"

#: ../../glossary.rst:893
msgid ""
"See :class:`importlib.abc.MetaPathFinder` for the methods that meta path "
"finders implement."
msgstr "请查看 :class:`importlib.abc.MetaPathFinder` 了解元路径查找器所实现的方法。"

#: ../../glossary.rst:895
msgid "metaclass"
msgstr "metaclass -- 元类"

#: ../../glossary.rst:897
msgid ""
"The class of a class.  Class definitions create a class name, a class "
"dictionary, and a list of base classes.  The metaclass is responsible for "
"taking those three arguments and creating the class.  Most object oriented "
"programming languages provide a default implementation.  What makes Python "
"special is that it is possible to create custom metaclasses.  Most users "
"never need this tool, but when the need arises, metaclasses can provide "
"powerful, elegant solutions.  They have been used for logging attribute "
"access, adding thread-safety, tracking object creation, implementing "
"singletons, and many other tasks."
msgstr ""
"一种用于创建类的类。类定义包含类名、类字典和基类列表。元类负责接受上述三个参数并创建相应的类。大部分面向对象的编程语言都会提供一个默认实现。Python"
" "
"的特别之处在于可以创建自定义元类。大部分用户永远不需要这个工具，但当需要出现时，元类可提供强大而优雅的解决方案。它们已被用于记录属性访问日志、添加线程安全性、跟踪对象创建、实现单例，以及其他许多任务。"

#: ../../glossary.rst:907
msgid "More information can be found in :ref:`metaclasses`."
msgstr "更多详情参见 :ref:`metaclasses`。"

#: ../../glossary.rst:876 ../../glossary.rst:908 ../../glossary.rst:1281
msgid "method"
msgstr "method -- 方法"

#: ../../glossary.rst:910
msgid ""
"A function which is defined inside a class body.  If called as an attribute "
"of an instance of that class, the method will get the instance object as its"
" first :term:`argument` (which is usually called ``self``). See "
":term:`function` and :term:`nested scope`."
msgstr ""
"在类内部定义的函数。如果作为该类的实例的一个属性来调用，方法将会获取实例对象作为其第一个 :term:`argument` (通常命名为 "
"``self``)。参见 :term:`function` 和 :term:`nested scope`。"

#: ../../glossary.rst:914
msgid "method resolution order"
msgstr "method resolution order -- 方法解析顺序"

#: ../../glossary.rst:916
msgid ""
"Method Resolution Order is the order in which base classes are searched for "
"a member during lookup. See :ref:`python_2.3_mro` for details of the "
"algorithm used by the Python interpreter since the 2.3 release."
msgstr ""
"方法解析顺序就是在查找成员时搜索基类的顺序。 请参阅 :ref:`python_2.3_mro` 了解自 2.3 发布版起 Python "
"解释器所使用算法的详情。"

#: ../../glossary.rst:919
msgid "module"
msgstr "module -- 模块"

#: ../../glossary.rst:921
msgid ""
"An object that serves as an organizational unit of Python code.  Modules "
"have a namespace containing arbitrary Python objects.  Modules are loaded "
"into Python by the process of :term:`importing`."
msgstr ""
"此对象是 Python 代码的一种组织单位。各模块具有独立的命名空间，可包含任意 Python 对象。模块可通过 :term:`importing` "
"操作被加载到 Python 中。"

#: ../../glossary.rst:925
msgid "See also :term:`package`."
msgstr "另见 :term:`package`。"

#: ../../glossary.rst:926
msgid "module spec"
msgstr "module spec -- 模块规格"

#: ../../glossary.rst:928
msgid ""
"A namespace containing the import-related information used to load a module."
" An instance of :class:`importlib.machinery.ModuleSpec`."
msgstr ""
"一个命名空间，其中包含用于加载模块的相关导入信息。是 :class:`importlib.machinery.ModuleSpec` 的实例。"

#: ../../glossary.rst:931
msgid "See also :ref:`module-specs`."
msgstr "另请参阅 :ref:`module-specs`。"

#: ../../glossary.rst:932
msgid "MRO"
msgstr "MRO"

#: ../../glossary.rst:934
msgid "See :term:`method resolution order`."
msgstr "参见 :term:`method resolution order`。"

#: ../../glossary.rst:935
msgid "mutable"
msgstr "mutable -- 可变对象"

#: ../../glossary.rst:937
msgid ""
"Mutable objects can change their value but keep their :func:`id`.  See also "
":term:`immutable`."
msgstr "可变对象可以在其 :func:`id` 保持固定的情况下改变其取值。另请参见 :term:`immutable`。"

#: ../../glossary.rst:939
msgid "named tuple"
msgstr "named tuple -- 具名元组"

#: ../../glossary.rst:941
msgid ""
"The term \"named tuple\" applies to any type or class that inherits from "
"tuple and whose indexable elements are also accessible using named "
"attributes.  The type or class may have other features as well."
msgstr "术语“具名元组”可用于任何继承自元组，并且其中的可索引元素还能使用名称属性来访问的类型或类。 这样的类型或类还可能拥有其他特性。"

#: ../../glossary.rst:945
msgid ""
"Several built-in types are named tuples, including the values returned by "
":func:`time.localtime` and :func:`os.stat`.  Another example is "
":data:`sys.float_info`::"
msgstr ""
"有些内置类型属于具名元组，包括 :func:`time.localtime` 和 :func:`os.stat` 的返回值。 另一个例子是 "
":data:`sys.float_info`::"

#: ../../glossary.rst:949
msgid ""
">>> sys.float_info[1]                   # indexed access\n"
"1024\n"
">>> sys.float_info.max_exp              # named field access\n"
"1024\n"
">>> isinstance(sys.float_info, tuple)   # kind of tuple\n"
"True"
msgstr ""
">>> sys.float_info[1]                   # 索引访问\n"
"1024\n"
">>> sys.float_info.max_exp              # 命名字段访问\n"
"1024\n"
">>> isinstance(sys.float_info, tuple)   # 属于元组\n"
"True"

#: ../../glossary.rst:956
msgid ""
"Some named tuples are built-in types (such as the above examples). "
"Alternatively, a named tuple can be created from a regular class definition "
"that inherits from :class:`tuple` and that defines named fields.  Such a "
"class can be written by hand, or it can be created by inheriting "
":class:`typing.NamedTuple`, or with the factory function "
":func:`collections.namedtuple`.  The latter techniques also add some extra "
"methods that may not be found in hand-written or built-in named tuples."
msgstr ""
"有些具名元组是内置类型（比如上面的例子）。 此外，具名元组还可通过常规类定义从 :class:`tuple` 继承并定义指定名称的字段的方式来创建。 "
"这样的类可以手工编号，或者也可以通过继承 :class:`typing.NamedTuple`，或者使用工厂函数 "
":func:`collections.namedtuple` 来创建。 后一种方式还会添加一些手工编写或内置的具名元组所没有的额外方法。"

#: ../../glossary.rst:964
msgid "namespace"
msgstr "namespace -- 命名空间"

#: ../../glossary.rst:966
msgid ""
"The place where a variable is stored.  Namespaces are implemented as "
"dictionaries.  There are the local, global and built-in namespaces as well "
"as nested namespaces in objects (in methods).  Namespaces support modularity"
" by preventing naming conflicts.  For instance, the functions "
":func:`builtins.open <.open>` and :func:`os.open` are distinguished by their"
" namespaces.  Namespaces also aid readability and maintainability by making "
"it clear which module implements a function.  For instance, writing "
":func:`random.seed` or :func:`itertools.islice` makes it clear that those "
"functions are implemented by the :mod:`random` and :mod:`itertools` modules,"
" respectively."
msgstr ""
"命名空间是存放变量的场所。命名空间有局部、全局和内置的，还有对象中的嵌套命名空间（在方法之内）。命名空间通过防止命名冲突来支持模块化。例如，函数 "
":func:`builtins.open <.open>` 与 :func:`os.open` "
"可通过各自的命名空间来区分。命名空间还通过明确哪个模块实现那个函数来帮助提高可读性和可维护性。例如，:func:`random.seed` 或 "
":func:`itertools.islice` 这种写法明确了这些函数是由 :mod:`random` 与 :mod:`itertools` "
"模块分别实现的。"

#: ../../glossary.rst:976
msgid "namespace package"
msgstr "namespace package -- 命名空间包"

#: ../../glossary.rst:978
msgid ""
"A :term:`package` which serves only as a container for subpackages. "
"Namespace packages may have no physical representation, and specifically are"
" not like a :term:`regular package` because they have no ``__init__.py`` "
"file."
msgstr ""
"一种仅被用作子包的容器的 :term:`package`。 命名空间包可以没有实体表示物，具体而言就是不同于 :term:`regular "
"package` 因为它们没有 ``__init__.py`` 文件。"

#: ../../glossary.rst:983
msgid ""
"Namespace packages allow several individually installable packages to have a"
" common parent package. Otherwise, it is recommended to use a :term:`regular"
" package`."
msgstr "命名空间包允许几个可单独安装的包具有共同的父包。 在其他情况下，则推荐使用 :term:`regular package`。"

#: ../../glossary.rst:986
msgid ""
"For more information, see :pep:`420` and :ref:`reference-namespace-package`."
msgstr "要了解更多信息，请参阅 :pep:`420` 和 :ref:`reference-namespace-package`。"

#: ../../glossary.rst:988
msgid "See also :term:`module`."
msgstr "另可参见 :term:`module`。"

#: ../../glossary.rst:989
msgid "nested scope"
msgstr "nested scope -- 嵌套作用域"

#: ../../glossary.rst:991
msgid ""
"The ability to refer to a variable in an enclosing definition.  For "
"instance, a function defined inside another function can refer to variables "
"in the outer function.  Note that nested scopes by default work only for "
"reference and not for assignment.  Local variables both read and write in "
"the innermost scope.  Likewise, global variables read and write to the "
"global namespace.  The :keyword:`nonlocal` allows writing to outer scopes."
msgstr ""
"在一个定义范围内引用变量的能力。例如，在另一函数之内定义的函数可以引用前者的变量。请注意嵌套作用域默认只对引用有效而对赋值无效。局部变量的读写都受限于最内层作用域。类似的，全局变量的读写则作用于全局命名空间。通过"
" :keyword:`nonlocal` 关键字可允许写入外层作用域。"

#: ../../glossary.rst:998
msgid "new-style class"
msgstr "new-style class -- 新式类"

#: ../../glossary.rst:1000
msgid ""
"Old name for the flavor of classes now used for all class objects.  In "
"earlier Python versions, only new-style classes could use Python's newer, "
"versatile features like :attr:`~object.__slots__`, descriptors, properties, "
":meth:`~object.__getattribute__`, class methods, and static methods."
msgstr ""
"对目前已被应用于所有类对象的类形式的旧称谓。 在较早的 Python 版本中，只有新式类能够使用 Python 新增的更灵活我，如 "
":attr:`~object.__slots__`、描述器、特征属性、:meth:`~object.__getattribute__`、类方法和静态方法等。"

#: ../../glossary.rst:1005
msgid "object"
msgstr "object -- 对象"

#: ../../glossary.rst:1007
msgid ""
"Any data with state (attributes or value) and defined behavior (methods).  "
"Also the ultimate base class of any :term:`new-style class`."
msgstr ""
"任何具有状态（属性或值）以及预定义行为（方法）的数据。object 也是任何 :term:`new-style class` 的最顶层基类名。"

#: ../../glossary.rst:1010
msgid "optimized scope"
msgstr "optimized scope -- 已优化的作用域"

#: ../../glossary.rst:1012
msgid ""
"A scope where target local variable names are reliably known to the compiler"
" when the code is compiled, allowing optimization of read and write access "
"to these names. The local namespaces for functions, generators, coroutines, "
"comprehensions, and generator expressions are optimized in this fashion. "
"Note: most interpreter optimizations are applied to all scopes, only those "
"relying on a known set of local and nonlocal variable names are restricted "
"to optimized scopes."
msgstr ""
"当代码被编译时编译器已充分知晓目标局部变量名称的作用域，这允许对这些名称的读写进行优化。 "
"针对函数、生成器、协程、推导式和生成器表达式的局部命名空间都是这样的已优化作用域。 "
"注意：大部分解释器优化将应用于所有作用域，只有那些依赖于已知的局部和非局部变量名称集合的优化会仅限于已优化的作用域。"

#: ../../glossary.rst:1019
msgid "package"
msgstr "package -- 包"

#: ../../glossary.rst:1021
msgid ""
"A Python :term:`module` which can contain submodules or recursively, "
"subpackages.  Technically, a package is a Python module with a ``__path__`` "
"attribute."
msgstr ""
"一种可包含子模块或递归地包含子包的 Python :term:`module`。 从技术上说，包是具有 ``__path__`` 属性的 Python "
"模块。"

#: ../../glossary.rst:1025
msgid "See also :term:`regular package` and :term:`namespace package`."
msgstr "另参见 :term:`regular package` 和 :term:`namespace package`。"

#: ../../glossary.rst:1026
msgid "parameter"
msgstr "parameter -- 形参"

#: ../../glossary.rst:1028
msgid ""
"A named entity in a :term:`function` (or method) definition that specifies "
"an :term:`argument` (or in some cases, arguments) that the function can "
"accept.  There are five kinds of parameter:"
msgstr ""
":term:`function` （或方法）定义中的命名实体，它指定函数可以接受的一个 :term:`argument` "
"（或在某些情况下，多个实参）。有五种形参："

#: ../../glossary.rst:1032
msgid ""
":dfn:`positional-or-keyword`: specifies an argument that can be passed "
"either :term:`positionally <argument>` or as a :term:`keyword argument "
"<argument>`.  This is the default kind of parameter, for example *foo* and "
"*bar* in the following::"
msgstr ""
":dfn:`positional-or-keyword`：位置或关键字，指定一个可以作为 :term:`位置参数 <argument>` 传入也可以作为"
" :term:`关键字参数 <argument>` 传入的实参。这是默认的形参类型，例如下面的 *foo* 和 *bar*::"

#: ../../glossary.rst:1037
msgid "def func(foo, bar=None): ..."
msgstr "def func(foo, bar=None): ..."

#: ../../glossary.rst:1041
msgid ""
":dfn:`positional-only`: specifies an argument that can be supplied only by "
"position. Positional-only parameters can be defined by including a ``/`` "
"character in the parameter list of the function definition after them, for "
"example *posonly1* and *posonly2* in the following::"
msgstr ""
":dfn:`positional-only`：仅限位置，指定一个只能通过位置传入的参数。 仅限位置形参可通过在函数定义的形参列表中它们之后包含一个 "
"``/`` 字符来定义，例如下面的 *posonly1* 和 *posonly2*::"

#: ../../glossary.rst:1046
msgid "def func(posonly1, posonly2, /, positional_or_keyword): ..."
msgstr "def func(posonly1, posonly2, /, positional_or_keyword): ..."

#: ../../glossary.rst:1050
msgid ""
":dfn:`keyword-only`: specifies an argument that can be supplied only by "
"keyword.  Keyword-only parameters can be defined by including a single var-"
"positional parameter or bare ``*`` in the parameter list of the function "
"definition before them, for example *kw_only1* and *kw_only2* in the "
"following::"
msgstr ""
":dfn:`keyword-"
"only`：仅限关键字，指定一个只能通过关键字传入的参数。仅限关键字形参可通过在函数定义的形参列表中包含单个可变位置形参或者在多个可变位置形参之前放一个"
" ``*`` 来定义，例如下面的 *kw_only1* 和 *kw_only2*::"

#: ../../glossary.rst:1056
msgid "def func(arg, *, kw_only1, kw_only2): ..."
msgstr "def func(arg, *, kw_only1, kw_only2): ..."

#: ../../glossary.rst:1058
msgid ""
":dfn:`var-positional`: specifies that an arbitrary sequence of positional "
"arguments can be provided (in addition to any positional arguments already "
"accepted by other parameters).  Such a parameter can be defined by "
"prepending the parameter name with ``*``, for example *args* in the "
"following::"
msgstr ""
":dfn:`var-"
"positional`：可变位置，指定可以提供由一个任意数量的位置参数构成的序列（附加在其他形参已接受的位置参数之后）。这种形参可通过在形参名称前加缀 "
"``*`` 来定义，例如下面的 *args*::"

#: ../../glossary.rst:1064
msgid "def func(*args, **kwargs): ..."
msgstr "def func(*args, **kwargs): ..."

#: ../../glossary.rst:1066
msgid ""
":dfn:`var-keyword`: specifies that arbitrarily many keyword arguments can be"
" provided (in addition to any keyword arguments already accepted by other "
"parameters).  Such a parameter can be defined by prepending the parameter "
"name with ``**``, for example *kwargs* in the example above."
msgstr ""
":dfn:`var-"
"keyword`：可变关键字，指定可以提供任意数量的关键字参数（附加在其他形参已接受的关键字参数之后）。这种形参可通过在形参名称前加缀 ``**`` "
"来定义，例如上面的 *kwargs*。"

#: ../../glossary.rst:1072
msgid ""
"Parameters can specify both optional and required arguments, as well as "
"default values for some optional arguments."
msgstr "形参可以同时指定可选和必选参数，也可以为某些可选参数指定默认值。"

#: ../../glossary.rst:1075
msgid ""
"See also the :term:`argument` glossary entry, the FAQ question on :ref:`the "
"difference between arguments and parameters <faq-argument-vs-parameter>`, "
"the :class:`inspect.Parameter` class, the :ref:`function` section, and "
":pep:`362`."
msgstr ""
"另参见 :term:`argument` 术语表条目、:ref:`参数与形参的区别 <faq-argument-vs-parameter>` "
"中的常见问题、:class:`inspect.Parameter` 类、:ref:`function` 一节以及 :pep:`362`。"

#: ../../glossary.rst:1079
msgid "path entry"
msgstr "path entry -- 路径入口"

#: ../../glossary.rst:1081
msgid ""
"A single location on the :term:`import path` which the :term:`path based "
"finder` consults to find modules for importing."
msgstr ":term:`import path` 中的一个单独位置，会被 :term:`path based finder` 用来查找要导入的模块。"

#: ../../glossary.rst:1083
msgid "path entry finder"
msgstr "path entry finder -- 路径入口查找器"

#: ../../glossary.rst:1085
msgid ""
"A :term:`finder` returned by a callable on :data:`sys.path_hooks` (i.e. a "
":term:`path entry hook`) which knows how to locate modules given a "
":term:`path entry`."
msgstr ""
"任一可调用对象使用 :data:`sys.path_hooks` (即 :term:`path entry hook`) 返回的 "
":term:`finder`，此种对象能通过 :term:`path entry` 来定位模块。"

#: ../../glossary.rst:1089
msgid ""
"See :class:`importlib.abc.PathEntryFinder` for the methods that path entry "
"finders implement."
msgstr "请参看 :class:`importlib.abc.PathEntryFinder` 以了解路径入口查找器所实现的各个方法。"

#: ../../glossary.rst:1091
msgid "path entry hook"
msgstr "path entry hook -- 路径入口钩子"

#: ../../glossary.rst:1093
msgid ""
"A callable on the :data:`sys.path_hooks` list which returns a :term:`path "
"entry finder` if it knows how to find modules on a specific :term:`path "
"entry`."
msgstr ""
"一种可调用对象，它在知道如何查找特定 :term:`path entry` 中的模块的情况下能够使用 :data:`sys.path_hooks` "
"列表返回一个 :term:`path entry finder`。"

#: ../../glossary.rst:1096
msgid "path based finder"
msgstr "path based finder -- 基于路径的查找器"

#: ../../glossary.rst:1098
msgid ""
"One of the default :term:`meta path finders <meta path finder>` which "
"searches an :term:`import path` for modules."
msgstr ""
"默认的一种 :term:`元路径查找器 <meta path finder>`，可在一个 :term:`import path` 中查找模块。"

#: ../../glossary.rst:1100
msgid "path-like object"
msgstr "path-like object -- 路径类对象"

#: ../../glossary.rst:1102
msgid ""
"An object representing a file system path. A path-like object is either a "
":class:`str` or :class:`bytes` object representing a path, or an object "
"implementing the :class:`os.PathLike` protocol. An object that supports the "
":class:`os.PathLike` protocol can be converted to a :class:`str` or "
":class:`bytes` file system path by calling the :func:`os.fspath` function; "
":func:`os.fsdecode` and :func:`os.fsencode` can be used to guarantee a "
":class:`str` or :class:`bytes` result instead, respectively. Introduced by "
":pep:`519`."
msgstr ""
"代表一个文件系统路径的对象。路径类对象可以是一个表示路径的 :class:`str` 或者 :class:`bytes` 对象，还可以是一个实现了 "
":class:`os.PathLike` 协议的对象。一个支持 :class:`os.PathLike` 协议的对象可通过调用 "
":func:`os.fspath` 函数转换为 :class:`str` 或者 :class:`bytes` "
"类型的文件系统路径；:func:`os.fsdecode` 和 :func:`os.fsencode` 可被分别用来确保获得 :class:`str` "
"或 :class:`bytes` 类型的结果。此对象是由 :pep:`519` 引入的。"

#: ../../glossary.rst:1110
msgid "PEP"
msgstr "PEP"

#: ../../glossary.rst:1112
msgid ""
"Python Enhancement Proposal. A PEP is a design document providing "
"information to the Python community, or describing a new feature for Python "
"or its processes or environment. PEPs should provide a concise technical "
"specification and a rationale for proposed features."
msgstr ""
"“Python 增强提议”的英文缩写。一个 PEP 就是一份设计文档，用来向 Python 社区提供信息，或描述一个 Python "
"的新增特性及其进度或环境。PEP 应当提供精确的技术规格和所提议特性的原理说明。"

#: ../../glossary.rst:1118
msgid ""
"PEPs are intended to be the primary mechanisms for proposing major new "
"features, for collecting community input on an issue, and for documenting "
"the design decisions that have gone into Python. The PEP author is "
"responsible for building consensus within the community and documenting "
"dissenting opinions."
msgstr ""
"PEP 应被作为提出主要新特性建议、收集社区对特定问题反馈以及为必须加入 Python 的设计决策编写文档的首选机制。PEP "
"的作者有责任在社区内部建立共识，并应将不同意见也记入文档。"

#: ../../glossary.rst:1124
msgid "See :pep:`1`."
msgstr "参见 :pep:`1`。"

#: ../../glossary.rst:1125
msgid "portion"
msgstr "portion -- 部分"

#: ../../glossary.rst:1127
msgid ""
"A set of files in a single directory (possibly stored in a zip file) that "
"contribute to a namespace package, as defined in :pep:`420`."
msgstr "构成一个命名空间包的单个目录内文件集合（也可能存放于一个 zip 文件内），具体定义见 :pep:`420`。"

#: ../../glossary.rst:1129
msgid "positional argument"
msgstr "positional argument -- 位置参数"

#: ../../glossary.rst:1132
msgid "provisional API"
msgstr "provisional API -- 暂定 API"

#: ../../glossary.rst:1134
msgid ""
"A provisional API is one which has been deliberately excluded from the "
"standard library's backwards compatibility guarantees.  While major changes "
"to such interfaces are not expected, as long as they are marked provisional,"
" backwards incompatible changes (up to and including removal of the "
"interface) may occur if deemed necessary by core developers.  Such changes "
"will not be made gratuitously -- they will occur only if serious fundamental"
" flaws are uncovered that were missed prior to the inclusion of the API."
msgstr ""
"暂定 API "
"是指被有意排除在标准库的向后兼容性保证之外的应用编程接口。虽然此类接口通常不会再有重大改变，但只要其被标记为暂定，就可能在核心开发者确定有必要的情况下进行向后不兼容的更改（甚至包括移除该接口）。此种更改并不会随意进行"
" -- 仅在 API 被加入之前未考虑到的严重基础性缺陷被发现时才可能会这样做。"

#: ../../glossary.rst:1143
msgid ""
"Even for provisional APIs, backwards incompatible changes are seen as a "
"\"solution of last resort\" - every attempt will still be made to find a "
"backwards compatible resolution to any identified problems."
msgstr ""
"即便是对暂定 API 来说，向后不兼容的更改也会被视为“最后的解决方案” —— 任何问题被确认时都会尽可能先尝试找到一种向后兼容的解决方案。"

#: ../../glossary.rst:1147
msgid ""
"This process allows the standard library to continue to evolve over time, "
"without locking in problematic design errors for extended periods of time.  "
"See :pep:`411` for more details."
msgstr "这种处理过程允许标准库持续不断地演进，不至于被有问题的长期性设计缺陷所困。详情见 :pep:`411`。"

#: ../../glossary.rst:1150
msgid "provisional package"
msgstr "provisional package -- 暂定包"

#: ../../glossary.rst:1152
msgid "See :term:`provisional API`."
msgstr "参见 :term:`provisional API`。"

#: ../../glossary.rst:1153
msgid "Python 3000"
msgstr "Python 3000"

#: ../../glossary.rst:1155
msgid ""
"Nickname for the Python 3.x release line (coined long ago when the release "
"of version 3 was something in the distant future.)  This is also abbreviated"
" \"Py3k\"."
msgstr "Python 3.x 发布路线的昵称（这个名字在版本 3 的发布还遥遥无期的时候就已出现了）。有时也被缩写为“Py3k”。"

#: ../../glossary.rst:1158
msgid "Pythonic"
msgstr "Pythonic"

#: ../../glossary.rst:1160
msgid ""
"An idea or piece of code which closely follows the most common idioms of the"
" Python language, rather than implementing code using concepts common to "
"other languages.  For example, a common idiom in Python is to loop over all "
"elements of an iterable using a :keyword:`for` statement.  Many other "
"languages don't have this type of construct, so people unfamiliar with "
"Python sometimes use a numerical counter instead::"
msgstr ""
"指一个思路或一段代码紧密遵循了 Python 语言最常用的风格和理念，而不是使用其他语言中通用的概念来实现代码。例如，Python 的常用风格是使用 "
":keyword:`for` 语句循环来遍历一个可迭代对象中的所有元素。许多其他语言没有这样的结构，因此不熟悉 Python "
"的人有时会选择使用一个数字计数器::"

#: ../../glossary.rst:1167
msgid ""
"for i in range(len(food)):\n"
"    print(food[i])"
msgstr ""
"for i in range(len(food)):\n"
"    print(food[i])"

#: ../../glossary.rst:1170
msgid "As opposed to the cleaner, Pythonic method::"
msgstr "而相应的更简洁更 Pythonic 的方法是这样的::"

#: ../../glossary.rst:1172
msgid ""
"for piece in food:\n"
"    print(piece)"
msgstr ""
"for piece in food:\n"
"    print(piece)"

#: ../../glossary.rst:1174
msgid "qualified name"
msgstr "qualified name -- 限定名称"

#: ../../glossary.rst:1176
msgid ""
"A dotted name showing the \"path\" from a module's global scope to a class, "
"function or method defined in that module, as defined in :pep:`3155`.  For "
"top-level functions and classes, the qualified name is the same as the "
"object's name::"
msgstr ""
"一个以点号分隔的名称，显示从模块的全局作用域到该模块中定义的某个类、函数或方法的“路径”，相关定义见 "
":pep:`3155`。对于最高层级的函数和类，限定名称与对象名称一致::"

#: ../../glossary.rst:1181
msgid ""
">>> class C:\n"
"...     class D:\n"
"...         def meth(self):\n"
"...             pass\n"
"...\n"
">>> C.__qualname__\n"
"'C'\n"
">>> C.D.__qualname__\n"
"'C.D'\n"
">>> C.D.meth.__qualname__\n"
"'C.D.meth'"
msgstr ""
">>> class C:\n"
"...     class D:\n"
"...         def meth(self):\n"
"...             pass\n"
"...\n"
">>> C.__qualname__\n"
"'C'\n"
">>> C.D.__qualname__\n"
"'C.D'\n"
">>> C.D.meth.__qualname__\n"
"'C.D.meth'"

#: ../../glossary.rst:1193
msgid ""
"When used to refer to modules, the *fully qualified name* means the entire "
"dotted path to the module, including any parent packages, e.g. "
"``email.mime.text``::"
msgstr ""
"当被用于引用模块时，*完整限定名称* 意为标示该模块的以点号分隔的整个路径，其中包含其所有的父包，例如 ``email.mime.text``::"

#: ../../glossary.rst:1197
msgid ""
">>> import email.mime.text\n"
">>> email.mime.text.__name__\n"
"'email.mime.text'"
msgstr ""
">>> import email.mime.text\n"
">>> email.mime.text.__name__\n"
"'email.mime.text'"

#: ../../glossary.rst:1200
msgid "reference count"
msgstr "reference count -- 引用计数"

#: ../../glossary.rst:1202
msgid ""
"The number of references to an object.  When the reference count of an "
"object drops to zero, it is deallocated.  Some objects are :term:`immortal` "
"and have reference counts that are never modified, and therefore the objects"
" are never deallocated.  Reference counting is generally not visible to "
"Python code, but it is a key element of the :term:`CPython` implementation."
"  Programmers can call the :func:`sys.getrefcount` function to return the "
"reference count for a particular object."
msgstr ""
"指向某个对象的引用的数量。 当一个对象的引用计数降为零时，它就会被释放。 特殊的 :term:`immortal` "
"对象具有永远不会被修改的引用计数，因此这种对象永远不会被释放。 引用计数对 Python 代码来说通常是不可见的，但它是 :term:`CPython`"
" 实现的一个关键元素。 程序员可以调用 :func:`sys.getrefcount` 函数来返回特定对象的引用计数。"

#: ../../glossary.rst:1211
msgid ""
"In :term:`CPython`, reference counts are not considered to be stable or "
"well-defined values; the number of references to an object, and how that "
"number is affected by Python code, may be different between versions."
msgstr ""
"在 :term:`CPython` 中，引用计数并非稳定或明确定义的值；对象的引用数量以及该数量受 Python "
"代码影响的方式，可能会因版本不同而有所差异。"

#: ../../glossary.rst:1215
msgid "regular package"
msgstr "regular package -- 常规包"

#: ../../glossary.rst:1217
msgid ""
"A traditional :term:`package`, such as a directory containing an "
"``__init__.py`` file."
msgstr "传统型的 :term:`package`，例如包含有一个 ``__init__.py`` 文件的目录。"

#: ../../glossary.rst:1220
msgid "See also :term:`namespace package`."
msgstr "另参见 :term:`namespace package`。"

#: ../../glossary.rst:1221
msgid "REPL"
msgstr "REPL"

#: ../../glossary.rst:1223
msgid ""
"An acronym for the \"read–eval–print loop\", another name for the "
":term:`interactive` interpreter shell."
msgstr ""
"“读取-求值-打印循环”read-eval-print loop的缩写，:term:`interactive` 解释器 shell 的另一个名字。"

#: ../../glossary.rst:1225
msgid "__slots__"
msgstr "__slots__"

#: ../../glossary.rst:1227
msgid ""
"A declaration inside a class that saves memory by pre-declaring space for "
"instance attributes and eliminating instance dictionaries.  Though popular, "
"the technique is somewhat tricky to get right and is best reserved for rare "
"cases where there are large numbers of instances in a memory-critical "
"application."
msgstr ""
"一种写在类内部的声明，通过预先声明实例属性等对象并移除实例字典来节省内存。虽然这种技巧很流行，但想要用好却并不容易，最好是只保留在少数情况下采用，例如极耗内存的应用程序，并且其中包含大量实例。"

#: ../../glossary.rst:1232
msgid "sequence"
msgstr "sequence -- 序列"

#: ../../glossary.rst:1234
msgid ""
"An :term:`iterable` which supports efficient element access using integer "
"indices via the :meth:`~object.__getitem__` special method and defines a "
":meth:`~object.__len__` method that returns the length of the sequence. Some"
" built-in sequence types are :class:`list`, :class:`str`, :class:`tuple`, "
"and :class:`bytes`. Note that :class:`dict` also supports "
":meth:`~object.__getitem__` and :meth:`!__len__`, but is considered a "
"mapping rather than a sequence because the lookups use arbitrary "
":term:`hashable` keys rather than integers."
msgstr ""
"一种 :term:`iterable`，它支持通过 :meth:`~object.__getitem__` "
"特殊方法来使用整数索引进行高效的元素访问，并定义了一个返回序列长度的 :meth:`~object.__len__` 方法。 内置序列类型有 "
":class:`list`, :class:`str`, :class:`tuple` 和 :class:`bytes` 等。 请注意虽然 "
":class:`dict` 也支持 :meth:`~object.__getitem__` 和 "
":meth:`!__len__`，但它被归类为映射而非序列，因为它使用任意的 :term:`hashable` 键而不是整数来查找元素。"

#: ../../glossary.rst:1243
msgid ""
"The :class:`collections.abc.Sequence` abstract base class defines a much "
"richer interface that goes beyond just :meth:`~object.__getitem__` and "
":meth:`~object.__len__`, adding :meth:`!count`, :meth:`!index`, "
":meth:`~object.__contains__`, and :meth:`~object.__reversed__`. Types that "
"implement this expanded interface can be registered explicitly using "
":func:`~abc.ABCMeta.register`. For more documentation on sequence methods "
"generally, see :ref:`Common Sequence Operations <typesseq-common>`."
msgstr ""
":class:`collections.abc.Sequence` 抽象基类定义了一个更丰富的接口，它在 "
":meth:`~object.__getitem__` 和 :meth:`~object.__len__` 之外，还添加了 "
":meth:`!count`, :meth:`!index`, :meth:`~object.__contains__` 和 "
":meth:`~object.__reversed__`。 实现此扩展接口的类型可以使用 :func:`~abc.ABCMeta.register` "
"来显式地注册。 要获取有关通用序列方法的更多文档，请参阅 :ref:`通用序列操作 <typesseq-common>`。"

#: ../../glossary.rst:1252
msgid "set comprehension"
msgstr "set comprehension -- 集合推导式"

#: ../../glossary.rst:1254
msgid ""
"A compact way to process all or part of the elements in an iterable and "
"return a set with the results. ``results = {c for c in 'abracadabra' if c "
"not in 'abc'}`` generates the set of strings ``{'r', 'd'}``.  See "
":ref:`comprehensions`."
msgstr ""
"处理一个可迭代对象中的所有或部分元素并返回结果集合的一种紧凑写法。 ``results = {c for c in 'abracadabra' if c"
" not in 'abc'}`` 将生成字符串集合 ``{'r', 'd'}``。 参见 :ref:`comprehensions`。"

#: ../../glossary.rst:1258
msgid "single dispatch"
msgstr "single dispatch -- 单分派"

#: ../../glossary.rst:1260
msgid ""
"A form of :term:`generic function` dispatch where the implementation is "
"chosen based on the type of a single argument."
msgstr "一种 :term:`generic function` 分派形式，其实现是基于单个参数的类型来选择的。"

#: ../../glossary.rst:1262
msgid "slice"
msgstr "slice -- 切片"

#: ../../glossary.rst:1264
msgid ""
"An object usually containing a portion of a :term:`sequence`.  A slice is "
"created using the subscript notation, ``[]`` with colons between numbers "
"when several are given, such as in ``variable_name[1:3:5]``.  The bracket "
"(subscript) notation uses :class:`slice` objects internally."
msgstr ""
"通常只包含了特定 :term:`sequence` 的一部分的对象。切片是通过使用下标标记来创建的，在 ``[]`` 中给出几个以冒号分隔的数字，例如 "
"``variable_name[1:3:5]``。方括号（下标）标记在内部使用 :class:`slice` 对象。"

#: ../../glossary.rst:1268
msgid "soft deprecated"
msgstr "soft deprecated -- 软弃用"

#: ../../glossary.rst:1270
msgid ""
"A soft deprecated API should not be used in new code, but it is safe for "
"already existing code to use it. The API remains documented and tested, but "
"will not be enhanced further."
msgstr ""
"被软弃用的 API 不应在新编写的代码中使用，但在已有代码中使用仍是安全的。 这样的 API 将保留在文档中并被测试，但不会再获得进一步的功能增强。"

#: ../../glossary.rst:1274
msgid ""
"Soft deprecation, unlike normal deprecation, does not plan on removing the "
"API and will not emit warnings."
msgstr "与普通的弃用不同，软弃用没有 API 移除计划也不会发出弃用警告。"

#: ../../glossary.rst:1277
msgid ""
"See `PEP 387: Soft Deprecation <https://peps.python.org/pep-0387/#soft-"
"deprecation>`_."
msgstr ""
"参见 `PEP 387: Soft Deprecation <https://peps.python.org/pep-0387/#soft-"
"deprecation>`_。"

#: ../../glossary.rst:1279
msgid "special method"
msgstr "special method -- 特殊方法"

#: ../../glossary.rst:1283
msgid ""
"A method that is called implicitly by Python to execute a certain operation "
"on a type, such as addition.  Such methods have names starting and ending "
"with double underscores.  Special methods are documented in "
":ref:`specialnames`."
msgstr ""
"一种由 Python 隐式调用的方法，用来对某个类型执行特定操作例如相加等等。这种方法的名称的首尾都为双下划线。特殊方法的文档参见 "
":ref:`specialnames`。"

#: ../../glossary.rst:1287
msgid "standard library"
msgstr "standard library -- 标准库"

#: ../../glossary.rst:1289
msgid ""
"The collection of :term:`packages <package>`, :term:`modules <module>` and "
":term:`extension modules <extension module>` distributed as a part of the "
"official Python interpreter package.  The exact membership of the collection"
" may vary based on platform, available system libraries, or other criteria."
"  Documentation can be found at :ref:`library-index`."
msgstr ""
"作为官方 Python 解释器软件包的组成部分一同发布的 :term:`包 <package>`, :term:`模块 <module>` 和 "
":term:`扩展模块 <extension module>` 集合。 该集合成员的实际内容可能因系统平台、可用系统库或其他条件的不同而发生变化。 "
"相关文档可在 :ref:`library-index` 查看。"

#: ../../glossary.rst:1295
msgid ""
"See also :data:`sys.stdlib_module_names` for a list of all possible standard"
" library module names."
msgstr "另请参阅 :data:`sys.stdlib_module_names` 获取所有可用标准库模块名称的列表。"

#: ../../glossary.rst:1297
msgid "statement"
msgstr "statement -- 语句"

#: ../../glossary.rst:1299
msgid ""
"A statement is part of a suite (a \"block\" of code).  A statement is either"
" an :term:`expression` or one of several constructs with a keyword, such as "
":keyword:`if`, :keyword:`while` or :keyword:`for`."
msgstr ""
"语句是程序段（一个代码“块”）的组成单位。一条语句可以是一个 :term:`expression` 或某个带有关键字的结构，例如 "
":keyword:`if`、:keyword:`while` 或 :keyword:`for`。"

#: ../../glossary.rst:1302
msgid "static type checker"
msgstr "static type checker -- 静态类型检查器"

#: ../../glossary.rst:1304
msgid ""
"An external tool that reads Python code and analyzes it, looking for issues "
"such as incorrect types. See also :term:`type hints <type hint>` and the "
":mod:`typing` module."
msgstr ""
"读取 Python 代码并进行分析，以查找问题例如拼写错误的外部工具。 另请参阅 :term:`类型提示 <type hint>` 以及 "
":mod:`typing` 模块。"

#: ../../glossary.rst:1307
msgid "stdlib"
msgstr "stdlib -- 标准库"

#: ../../glossary.rst:1309
msgid "An abbreviation of :term:`standard library`."
msgstr ":term:`standard library` 的缩写。"

#: ../../glossary.rst:1310
msgid "strong reference"
msgstr "strong reference -- 强引用"

#: ../../glossary.rst:1312
msgid ""
"In Python's C API, a strong reference is a reference to an object which is "
"owned by the code holding the reference.  The strong reference is taken by "
"calling :c:func:`Py_INCREF` when the reference is created and released with "
":c:func:`Py_DECREF` when the reference is deleted."
msgstr ""
"在 Python 的 C API 中，强引用是指为持有引用的代码所拥有的对象的引用。 在创建引用时可通过调用 :c:func:`Py_INCREF` "
"来获取强引用而在删除引用时可通过 :c:func:`Py_DECREF` 来释放它。"

#: ../../glossary.rst:1318
msgid ""
"The :c:func:`Py_NewRef` function can be used to create a strong reference to"
" an object. Usually, the :c:func:`Py_DECREF` function must be called on the "
"strong reference before exiting the scope of the strong reference, to avoid "
"leaking one reference."
msgstr ""
":c:func:`Py_NewRef` 函数可被用于创建一个对象的强引用。 通常，必须在退出某个强引用的作用域时在该强引用上调用 "
":c:func:`Py_DECREF` 函数，以避免引用的泄漏。"

#: ../../glossary.rst:1323
msgid "See also :term:`borrowed reference`."
msgstr "另请参阅 :term:`borrowed reference`。"

#: ../../glossary.rst:1324
msgid "t-string"
msgstr "t-string -- t-字符串"

#: ../../glossary.rst:1326
msgid ""
"String literals prefixed with ``t`` or ``T`` are commonly called "
"\"t-strings\" which is short for :ref:`template string literals "
"<t-strings>`."
msgstr ""
"带有 ``t`` 或 ``T`` 前缀的字符串字面值通常被称为 \"t-字符串\" 即 :ref:`模板字符串字面值 <t-strings>` 的简写。"

#: ../../glossary.rst:1329
msgid "text encoding"
msgstr "text encoding -- 文本编码格式"

#: ../../glossary.rst:1331
msgid ""
"A string in Python is a sequence of Unicode code points (in range "
"``U+0000``--``U+10FFFF``). To store or transfer a string, it needs to be "
"serialized as a sequence of bytes."
msgstr ""
"在Python中，一个字符串是一串 Unicode 代码点（范围为 ``U+0000``--``U+10FFFF``）。 "
"为了存储或传输一个字符串，它需要被序列化为一串字节。"

#: ../../glossary.rst:1335
msgid ""
"Serializing a string into a sequence of bytes is known as \"encoding\", and "
"recreating the string from the sequence of bytes is known as \"decoding\"."
msgstr "将一个字符串序列化为一个字节序列被称为“编码”，而从字节序列中重新创建字符串被称为“解码”。"

#: ../../glossary.rst:1338
msgid ""
"There are a variety of different text serialization :ref:`codecs <standard-"
"encodings>`, which are collectively referred to as \"text encodings\"."
msgstr "有各种不同的文本序列化 :ref:`编码器 <standard-encodings>` ，它们被统称为 \"文本编码格式\"。"

#: ../../glossary.rst:1341
msgid "text file"
msgstr "text file -- 文本文件"

#: ../../glossary.rst:1343
msgid ""
"A :term:`file object` able to read and write :class:`str` objects. Often, a "
"text file actually accesses a byte-oriented datastream and handles the "
":term:`text encoding` automatically. Examples of text files are files opened"
" in text mode (``'r'`` or ``'w'``), :data:`sys.stdin`, :data:`sys.stdout`, "
"and instances of :class:`io.StringIO`."
msgstr ""
"一种能够读写 :class:`str` 对象的 :term:`file object`。通常一个文本文件实际是访问一个面向字节的数据流并自动处理 "
":term:`text encoding`。文本文件的例子包括以文本模式（``'r'`` 或 "
"``'w'``）打开的文件、:data:`sys.stdin`、:data:`sys.stdout` 以及 :class:`io.StringIO` "
"的实例。"

#: ../../glossary.rst:1350
msgid ""
"See also :term:`binary file` for a file object able to read and write "
":term:`bytes-like objects <bytes-like object>`."
msgstr ""
"另请参看 :term:`binary file` 了解能够读写 :term:`字节型对象 <bytes-like object>` 的文件对象。"

#: ../../glossary.rst:1352
msgid "thread state"
msgstr "thread state -- 线程状态"

#: ../../glossary.rst:1355
msgid ""
"The information used by the :term:`CPython` runtime to run in an OS thread. "
"For example, this includes the current exception, if any, and the state of "
"the bytecode interpreter."
msgstr ":term:`CPython` 运行时在一个 OS 线程中运行所使用的信息。 例如，这包括可能存在的当前异常，以及字节码解释器的状态等。"

#: ../../glossary.rst:1359
msgid ""
"Each thread state is bound to a single OS thread, but threads may have many "
"thread states available.  At most, one of them may be :term:`attached "
"<attached thread state>` at once."
msgstr ""
"每个线程状态将绑定到一个单独的 OS 线程，但线程可能具有许多可用的线程状态。 在最一般情况下，可能立即 :term:`附加 <attached "
"thread state>` 它们中的一个。"

#: ../../glossary.rst:1363
msgid ""
"An :term:`attached thread state` is required to call most of Python's C API,"
" unless a function explicitly documents otherwise. The bytecode interpreter "
"only runs under an attached thread state."
msgstr ""
"调用大多数 Python 的 C API 都需要有一个 :term:`attached thread "
"state`，除非一个函数文档显式地写明了不同情况。 字节码解释器只能运行在一个已附加线程状态下。"

#: ../../glossary.rst:1367
msgid ""
"Each thread state belongs to a single interpreter, but each interpreter may "
"have many thread states, including multiple for the same OS thread. Thread "
"states from multiple interpreters may be bound to the same thread, but only "
"one can be :term:`attached <attached thread state>` in that thread at any "
"given moment."
msgstr ""
"每个线程状态都归属于一个单独的解释器，但每个解释器可能有多个线程状态，包括同一个 OS 线程的多个线程状态。 "
"来自多个解释器的线程状态可能会绑定到相同的线程，但在任一给定时刻在一个线程中只能有一个线程状态可以被 :term:`附加 <attached "
"thread state>`。"

#: ../../glossary.rst:1373
msgid ""
"See :ref:`Thread State and the Global Interpreter Lock <threads>` for more "
"information."
msgstr "请参阅 :ref:`线程状态和全局解释器锁 <threads>` 了解详情。"

#: ../../glossary.rst:1375
msgid "token"
msgstr "token -- 词元"

#: ../../glossary.rst:1378
msgid ""
"A small unit of source code, generated by the :ref:`lexical analyzer "
"<lexical>` (also called the *tokenizer*). Names, numbers, strings, "
"operators, newlines and similar are represented by tokens."
msgstr ""
"一个源代码小单元，由 :ref:`词法分析器 <lexical>` (或称 *分词器*) 生成。 名称、数字、字符串、运算符、换行符等均由词元来表示。"

#: ../../glossary.rst:1383
msgid ""
"The :mod:`tokenize` module exposes Python's lexical analyzer. The "
":mod:`token` module contains information on the various types of tokens."
msgstr ":mod:`tokenize` 模块对外暴露了 Python 的词法分析器。 :mod:`token` 模块包含了有关各种词元类型的信息。"

#: ../../glossary.rst:1386
msgid "triple-quoted string"
msgstr "triple-quoted string -- 三引号字符串"

#: ../../glossary.rst:1388
msgid ""
"A string which is bound by three instances of either a quotation mark (\") "
"or an apostrophe (').  While they don't provide any functionality not "
"available with single-quoted strings, they are useful for a number of "
"reasons.  They allow you to include unescaped single and double quotes "
"within a string and they can span multiple lines without the use of the "
"continuation character, making them especially useful when writing "
"docstrings."
msgstr ""
"首尾各带三个连续双引号（\"）或者单引号（'）的字符串。它们在功能上与首尾各用一个引号标注的字符串没有什么不同，但是有多种用处。它们允许你在字符串内包含未经转义的单引号和双引号，并且可以跨越多行而无需使用连接符，在编写文档字符串时特别好用。"

#: ../../glossary.rst:1395
msgid "type"
msgstr "type -- 类型"

#: ../../glossary.rst:1397
msgid ""
"The type of a Python object determines what kind of object it is; every "
"object has a type.  An object's type is accessible as its "
":attr:`~object.__class__` attribute or can be retrieved with ``type(obj)``."
msgstr ""
"Python 对象的类型决定它属于什么种类；每个对象都具有特定的类型。 对象的类型可通过其 :attr:`~object.__class__` "
"属性来访问或是用 ``type(obj)`` 来获取。"

#: ../../glossary.rst:1401
msgid "type alias"
msgstr "type alias -- 类型别名"

#: ../../glossary.rst:1403
msgid "A synonym for a type, created by assigning the type to an identifier."
msgstr "一个类型的同义词，创建方式是把类型赋值给特定的标识符。"

#: ../../glossary.rst:1405
msgid ""
"Type aliases are useful for simplifying :term:`type hints <type hint>`. For "
"example::"
msgstr "类型别名的作用是简化 :term:`类型注解 <type hint>`。例如::"

#: ../../glossary.rst:1408
msgid ""
"def remove_gray_shades(\n"
"        colors: list[tuple[int, int, int]]) -> list[tuple[int, int, int]]:\n"
"    pass"
msgstr ""
"def remove_gray_shades(\n"
"        colors: list[tuple[int, int, int]]) -> list[tuple[int, int, int]]:\n"
"    pass"

#: ../../glossary.rst:1412
msgid "could be made more readable like this::"
msgstr "可以这样提高可读性::"

#: ../../glossary.rst:1414
msgid ""
"Color = tuple[int, int, int]\n"
"\n"
"def remove_gray_shades(colors: list[Color]) -> list[Color]:\n"
"    pass"
msgstr ""
"Color = tuple[int, int, int]\n"
"\n"
"def remove_gray_shades(colors: list[Color]) -> list[Color]:\n"
"    pass"

#: ../../glossary.rst:1419 ../../glossary.rst:1433
msgid "See :mod:`typing` and :pep:`484`, which describe this functionality."
msgstr "参见 :mod:`typing` 和 :pep:`484`，其中有对此功能的详细描述。"

#: ../../glossary.rst:1420
msgid "type hint"
msgstr "type hint -- 类型注解"

#: ../../glossary.rst:1422
msgid ""
"An :term:`annotation` that specifies the expected type for a variable, a "
"class attribute, or a function parameter or return value."
msgstr ":term:`annotation` 为变量、类属性、函数的形参或返回值指定预期的类型。"

#: ../../glossary.rst:1425
msgid ""
"Type hints are optional and are not enforced by Python but they are useful "
"to :term:`static type checkers <static type checker>`. They can also aid "
"IDEs with code completion and refactoring."
msgstr ""
"类型提示是可选的而不是 Python 的强制要求，但它们对 :term:`静态类型检查器 <static type checker>` 很有用处。 "
"它们还能协助 IDE 实现代码补全与重构。"

#: ../../glossary.rst:1429
msgid ""
"Type hints of global variables, class attributes, and functions, but not "
"local variables, can be accessed using :func:`typing.get_type_hints`."
msgstr "全局变量、类属性和函数的类型注解可以使用 :func:`typing.get_type_hints` 来访问，但局部变量则不可以。"

#: ../../glossary.rst:1434
msgid "universal newlines"
msgstr "universal newlines -- 通用换行"

#: ../../glossary.rst:1436
msgid ""
"A manner of interpreting text streams in which all of the following are "
"recognized as ending a line: the Unix end-of-line convention ``'\\n'``, the "
"Windows convention ``'\\r\\n'``, and the old Macintosh convention ``'\\r'``."
"  See :pep:`278` and :pep:`3116`, as well as :func:`bytes.splitlines` for an"
" additional use."
msgstr ""
"一种解读文本流的方式，将以下所有符号都识别为行结束标志：Unix 的行结束约定 ``'\\n'``、Windows 的约定 ``'\\r\\n'`` "
"以及旧版 Macintosh 的约定 ``'\\r'``。参见 :pep:`278` 和 :pep:`3116` 和 "
":func:`bytes.splitlines` 了解更多用法说明。"

#: ../../glossary.rst:1441
msgid "variable annotation"
msgstr "variable annotation -- 变量标注"

#: ../../glossary.rst:1443
msgid "An :term:`annotation` of a variable or a class attribute."
msgstr "对变量或类属性的 :term:`annotation`。"

#: ../../glossary.rst:1445
msgid ""
"When annotating a variable or a class attribute, assignment is optional::"
msgstr "在标注变量或类属性时，还可选择为其赋值::"

#: ../../glossary.rst:1447
msgid ""
"class C:\n"
"    field: 'annotation'"
msgstr ""
"class C:\n"
"    field: 'annotation'"

#: ../../glossary.rst:1450
msgid ""
"Variable annotations are usually used for :term:`type hints <type hint>`: "
"for example this variable is expected to take :class:`int` values::"
msgstr "变量标注通常被用作 :term:`类型提示 <type hint>`：例如以下变量预期接受 :class:`int` 类型的值::"

#: ../../glossary.rst:1454
msgid "count: int = 0"
msgstr "count: int = 0"

#: ../../glossary.rst:1456
msgid "Variable annotation syntax is explained in section :ref:`annassign`."
msgstr "变量标注语法的详细解释见 :ref:`annassign` 一节。"

#: ../../glossary.rst:1458
msgid ""
"See :term:`function annotation`, :pep:`484` and :pep:`526`, which describe "
"this functionality. Also see :ref:`annotations-howto` for best practices on "
"working with annotations."
msgstr ""
"参见 :term:`function annotation`, :pep:`484` 和 :pep:`526`，其中描述了此功能。 另请参阅 "
":ref:`annotations-howto` 以了解使用标注的最佳实践。"

#: ../../glossary.rst:1462
msgid "virtual environment"
msgstr "virtual environment -- 虚拟环境"

#: ../../glossary.rst:1464
msgid ""
"A cooperatively isolated runtime environment that allows Python users and "
"applications to install and upgrade Python distribution packages without "
"interfering with the behaviour of other Python applications running on the "
"same system."
msgstr ""
"一种采用协作式隔离的运行时环境，允许 Python 用户和应用程序在安装和升级 Python 分发包时不会干扰到同一系统上运行的其他 Python "
"应用程序的行为。"

#: ../../glossary.rst:1469
msgid "See also :mod:`venv`."
msgstr "另参见 :mod:`venv`。"

#: ../../glossary.rst:1470
msgid "virtual machine"
msgstr "virtual machine -- 虚拟机"

#: ../../glossary.rst:1472
msgid ""
"A computer defined entirely in software.  Python's virtual machine executes "
"the :term:`bytecode` emitted by the bytecode compiler."
msgstr "一台完全通过软件定义的计算机。Python 虚拟机可执行字节码编译器所生成的 :term:`bytecode`。"

#: ../../glossary.rst:1474
msgid "Zen of Python"
msgstr "Zen of Python -- Python 之禅"

#: ../../glossary.rst:1476
msgid ""
"Listing of Python design principles and philosophies that are helpful in "
"understanding and using the language.  The listing can be found by typing "
"\"``import this``\" at the interactive prompt."
msgstr "列出 Python 设计的原则与哲学，有助于理解与使用这种语言。查看其具体内容可在交互模式提示符中输入 \"``import this``\"。"

#: ../../glossary.rst:319
msgid "C-contiguous"
msgstr "C 连续"

#: ../../glossary.rst:319
msgid "Fortran contiguous"
msgstr "Fortran 连续"

#: ../../glossary.rst:876
msgid "magic"
msgstr "魔术"

#: ../../glossary.rst:1281
msgid "special"
msgstr "特殊"
