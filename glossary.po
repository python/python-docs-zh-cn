# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# ryohei <osakana.ryohei@gmail.com>, 2017
# Shengjing Zhu <zsj950618@gmail.com>, 2018
# Fred <fred.wei@foxmail.com>, 2018
# Freesand Leo <yuqinju@163.com>, 2018
# Junkai Shao <skaifun.dev@gmail.com>, 2018
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-10-27 09:37+0900\n"
"PO-Revision-Date: 2017-02-16 17:32+0000\n"
"Last-Translator: Junkai Shao <skaifun.dev@gmail.com>, 2018\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../glossary.rst:5
msgid "Glossary"
msgstr "术语表"

#: ../../glossary.rst:10
msgid "``>>>``"
msgstr "``>>>``"

#: ../../glossary.rst:12
msgid ""
"The default Python prompt of the interactive shell.  Often seen for code "
"examples which can be executed interactively in the interpreter."
msgstr "交互式终端中默认的 Python 提示符。往往会显示于能以交互方式在解释器里执行的样例代码之前。"

#: ../../glossary.rst:14
msgid "``...``"
msgstr "``...``"

#: ../../glossary.rst:16
msgid ""
"The default Python prompt of the interactive shell when entering code for an"
" indented code block, when within a pair of matching left and right "
"delimiters (parentheses, square brackets, curly braces or triple quotes), or"
" after specifying a decorator."
msgstr ""
"交互式终端中输入特殊代码行时默认的 Python 提示符，包括：缩进的代码块，成对的分隔符之内 (圆括号, 方括号, "
"花括号或三重引号)，或是指定一个装饰器之后。"

#: ../../glossary.rst:20
msgid "2to3"
msgstr "2to3"

#: ../../glossary.rst:22
msgid ""
"A tool that tries to convert Python 2.x code to Python 3.x code by handling "
"most of the incompatibilities which can be detected by parsing the source "
"and traversing the parse tree."
msgstr "一个将 Python 2.x 代码转换为 Python 3.x 代码的工具，能够处理大部分通过解析源码并遍历解析树可检测到的不兼容问题。"

#: ../../glossary.rst:26
msgid ""
"2to3 is available in the standard library as :mod:`lib2to3`; a standalone "
"entry point is provided as :file:`Tools/scripts/2to3`.  See "
":ref:`2to3-reference`."
msgstr ""
"2to3 包含在标准库中，模块名为 :mod:`lib2to3`；并提供一个独立入口点 :file:`Tools/scripts/2to3`。参见 "
":ref:`2to3-reference`."

#: ../../glossary.rst:29
msgid "abstract base class"
msgstr "abstract base class -- 抽象基类"

#: ../../glossary.rst:31
msgid ""
"Abstract base classes complement :term:`duck-typing` by providing a way to "
"define interfaces when other techniques like :func:`hasattr` would be clumsy"
" or subtly wrong (for example with :ref:`magic methods <special-lookup>`).  "
"ABCs introduce virtual subclasses, which are classes that don't inherit from"
" a class but are still recognized by :func:`isinstance` and "
":func:`issubclass`; see the :mod:`abc` module documentation.  Python comes "
"with many built-in ABCs for data structures (in the :mod:`collections.abc` "
"module), numbers (in the :mod:`numbers` module), streams (in the :mod:`io` "
"module), import finders and loaders (in the :mod:`importlib.abc` module).  "
"You can create your own ABCs with the :mod:`abc` module."
msgstr ""
"抽象基类简称 ABC，是对 :term:`duck-typing` 的补充，它提供了一种定义接口的新方式，相比之下其他技巧例如 "
":func:`hasattr` 显得过于笨拙或有微妙错误 (例如使用 :ref:`魔术方法 <special-lookup>`)。ABC "
"引入了虚拟子类，这种类并非继承自其他类，但却仍能被 :func:`isinstance` 和 :func:`issubclass` 所认可；详见 "
":mod:`abc` 模块文档。Python 自带许多内置的 ABC 用于实现数据结构 (在 :mod:`collections.abc` 模块中), "
"数字 (在 :mod:`numbers` 模块中), 流 (在 :mod:`io` 模块中), 导入查找器和加载器 (在 "
":mod:`importlib.abc` 模块中)。你可以使用 :mod:`abc` 模块来创建自己的 ABC。"

#: ../../glossary.rst:42
msgid "annotation"
msgstr "annotation -- 标注"

#: ../../glossary.rst:44
msgid ""
"A label associated with a variable, a class attribute or a function "
"parameter or return value, used by convention as a :term:`type hint`."
msgstr "关联到某个变量、类属性、函数形参或返回值的标签，被约定作为 :term:`type hint` 来使用。"

#: ../../glossary.rst:48
msgid ""
"Annotations of local variables cannot be accessed at runtime, but "
"annotations of global variables, class attributes, and functions are stored "
"in the :attr:`__annotations__` special attribute of modules, classes, and "
"functions, respectively."
msgstr ""
"局部变量的标注在运行时不可访问，但全局变量、类属性和函数的标注会分别存放模块、类和函数的 :attr:`__annotations__` 特殊属性中。"

#: ../../glossary.rst:54
msgid ""
"See :term:`variable annotation`, :term:`function annotation`, :pep:`484` and"
" :pep:`526`, which describe this functionality."
msgstr ""
"参见 :term:`variable annotation`, :term:`function annotation`, :pep:`484` 和 "
":pep:`526`, 对此功能均有介绍。"

#: ../../glossary.rst:56
msgid "argument"
msgstr "argument -- 参数"

#: ../../glossary.rst:58
msgid ""
"A value passed to a :term:`function` (or :term:`method`) when calling the "
"function.  There are two kinds of argument:"
msgstr "在调用函数时传给 :term:`function` (或 :term:`method`) 的值。参数分为两种:"

#: ../../glossary.rst:61
msgid ""
":dfn:`keyword argument`: an argument preceded by an identifier (e.g. "
"``name=``) in a function call or passed as a value in a dictionary preceded "
"by ``**``.  For example, ``3`` and ``5`` are both keyword arguments in the "
"following calls to :func:`complex`::"
msgstr ""
":dfn:`关键字参数`: 在函数调用中前面带有标识符 (例如 ``name=``) 或者作为包含在前面带有 ``**`` "
"的字典里的值传入。举例来说，``3`` 和 ``5`` 在以下对 :func:`complex` 的调用中均属于关键字参数::"

#: ../../glossary.rst:69
msgid ""
":dfn:`positional argument`: an argument that is not a keyword argument. "
"Positional arguments can appear at the beginning of an argument list and/or "
"be passed as elements of an :term:`iterable` preceded by ``*``. For example,"
" ``3`` and ``5`` are both positional arguments in the following calls::"
msgstr ""
":dfn:`位置参数`: 不属于关键字参数的参数。位置参数可出现于参数列表的开头以及/或者作为前面带有 ``*`` 的 :term:`iterable`"
" 里的元素被传入。举例来说，``3`` 和 ``5`` 在以下调用中均属于位置参数::"

#: ../../glossary.rst:78
msgid ""
"Arguments are assigned to the named local variables in a function body. See "
"the :ref:`calls` section for the rules governing this assignment. "
"Syntactically, any expression can be used to represent an argument; the "
"evaluated value is assigned to the local variable."
msgstr ""
"参数会被赋值给函数体中对应的局部变量。有关赋值规则参见 :ref:`calls` "
"一节。根据语法，任何表达式都可用来表示一个参数；最终算出的值会被赋给对应的局部变量。"

#: ../../glossary.rst:83
msgid ""
"See also the :term:`parameter` glossary entry, the FAQ question on :ref:`the"
" difference between arguments and parameters <faq-argument-vs-parameter>`, "
"and :pep:`362`."
msgstr ""
"另参见 :term:`parameter` 术语表条目，常见问题中 :ref:`参数与形参的区别 <faq-argument-vs-"
"parameter>` 以及 :pep:`362`。"

#: ../../glossary.rst:86
msgid "asynchronous context manager"
msgstr "asynchronous context manager -- 异步上下文管理器"

#: ../../glossary.rst:88
msgid ""
"An object which controls the environment seen in an :keyword:`async with` "
"statement by defining :meth:`__aenter__` and :meth:`__aexit__` methods.  "
"Introduced by :pep:`492`."
msgstr ""
"此种对象通过定义 :meth:`__aenter__` 和 :meth:`__aexit__` 方法来对 :keyword:`async with` "
"语句中的环境进行控制。由 :pep:`492` 引入。"

#: ../../glossary.rst:91
msgid "asynchronous generator"
msgstr "asynchronous generator -- 异步生成器"

#: ../../glossary.rst:93
msgid ""
"A function which returns an :term:`asynchronous generator iterator`.  It "
"looks like a coroutine function defined with :keyword:`async def` except "
"that it contains :keyword:`yield` expressions for producing a series of "
"values usable in an :keyword:`async for` loop."
msgstr ""
"返回值为 :term:`asynchronous generator iterator` 的函数。它与使用 :keyword:`async def` "
"定义的协程函数很相似，不同之处在于它包含 :keyword:`yield` 表达式以产生一系列可在 :keyword:`async for` "
"循环中使用的值。"

#: ../../glossary.rst:98
msgid ""
"Usually refers to a asynchronous generator function, but may refer to an "
"*asynchronous generator iterator* in some contexts.  In cases where the "
"intended meaning isn't clear, using the full terms avoids ambiguity."
msgstr "此术语通常是指异步生成器函数，但在某些情况下则可能是指 *异步生成器迭代器*。如果需要清楚表达具体含义，请使用全称以避免歧义。"

#: ../../glossary.rst:102
msgid ""
"An asynchronous generator function may contain :keyword:`await` expressions "
"as well as :keyword:`async for`, and :keyword:`async with` statements."
msgstr ""
"一个异步生成器函数可能包含 :keyword:`await` 表达式或者 :keyword:`async for` 以及 :keyword:`async"
" with` 语句。"

#: ../../glossary.rst:105
msgid "asynchronous generator iterator"
msgstr "asynchronous generator iterator -- 异步生成器迭代器"

#: ../../glossary.rst:107
msgid "An object created by a :term:`asynchronous generator` function."
msgstr ":term:`asynchronous generator` 函数所创建的对象。"

#: ../../glossary.rst:109
msgid ""
"This is an :term:`asynchronous iterator` which when called using the "
":meth:`__anext__` method returns an awaitable object which will execute that"
" the body of the asynchronous generator function until the next "
":keyword:`yield` expression."
msgstr ""
"此对象属于 :term:`asynchronous iterator`，当使用 :meth:`__anext__` "
"方法调用时会返回一个可等待对象来执行异步生成器函数的代码直至下一个 :keyword:`yield` 表达式。"

#: ../../glossary.rst:114
msgid ""
"Each :keyword:`yield` temporarily suspends processing, remembering the "
"location execution state (including local variables and pending try-"
"statements).  When the *asynchronous generator iterator* effectively resumes"
" with another awaitable returned by :meth:`__anext__`, it picks up where it "
"left off.  See :pep:`492` and :pep:`525`."
msgstr ""
"每个 :keyword:`yield` 会临时暂停处理，记住当前位置执行状态 (包括局部变量和挂起的 try 语句)。当该 *异步生成器迭代器* 与其他"
" :meth:`__anext__` 返回的可等待对象有效恢复时，它会从离开位置继续执行。参见 :pep:`492` 和 :pep:`525`。"

#: ../../glossary.rst:119
msgid "asynchronous iterable"
msgstr "asynchronous iterable -- 异步可迭代对象"

#: ../../glossary.rst:121
msgid ""
"An object, that can be used in an :keyword:`async for` statement. Must "
"return an :term:`asynchronous iterator` from its :meth:`__aiter__` method.  "
"Introduced by :pep:`492`."
msgstr ""
"可在 :keyword:`async for` 语句中被使用的对象。必须通过它的 :meth:`__aiter__` 方法返回一个 "
":term:`asynchronous iterator`。由 :pep:`492` 引入。"

#: ../../glossary.rst:124
msgid "asynchronous iterator"
msgstr "asynchronous iterator -- 异步迭代器"

#: ../../glossary.rst:126
msgid ""
"An object that implements the :meth:`__aiter__` and :meth:`__anext__` "
"methods.  ``__anext__`` must return an :term:`awaitable` object. "
":keyword:`async for` resolves the awaitables returned by an asynchronous "
"iterator's :meth:`__anext__` method until it raises a "
":exc:`StopAsyncIteration` exception.  Introduced by :pep:`492`."
msgstr ""
"实现了 :meth:`__aiter__` 和 :meth:`__anext__` 方法的对象。``__anext__`` 必须返回一个 "
":term:`awaitable` 对象。:keyword:`async for` 会处理异步迭代器的 :meth:`__anext__` "
"方法所返回的可等待对象，直到其引发一个 :exc:`StopAsyncIteration` 异常。由 :pep:`492` 引入。"

#: ../../glossary.rst:131
msgid "attribute"
msgstr "attribute -- 属性"

#: ../../glossary.rst:133
msgid ""
"A value associated with an object which is referenced by name using dotted "
"expressions.  For example, if an object *o* has an attribute *a* it would be"
" referenced as *o.a*."
msgstr "关联到一个对象的值，可以使用点号表达式通过其名称来引用。例如，如果一个对象 *o* 具有一个属性 *a*，就可以用 *o.a* 来引用它。"

#: ../../glossary.rst:136
msgid "awaitable"
msgstr "awaitable -- 可等待对象"

#: ../../glossary.rst:138
msgid ""
"An object that can be used in an :keyword:`await` expression.  Can be a "
":term:`coroutine` or an object with an :meth:`__await__` method. See also "
":pep:`492`."
msgstr ""
"能在 :keyword:`await` 表达式中使用的对象。可以是 :term:`coroutine` 或是具有 :meth:`__await__` "
"方法的对象。参见 :pep:`492`。"

#: ../../glossary.rst:141
msgid "BDFL"
msgstr "BDFL"

#: ../../glossary.rst:143
msgid ""
"Benevolent Dictator For Life, a.k.a. `Guido van Rossum "
"<https://gvanrossum.github.io/>`_, Python's creator."
msgstr ""
"“终身仁慈独裁者”的英文缩写，即 `Guido van Rossum <https://gvanrossum.github.io/>`_, Python"
" 的创造者。"

#: ../../glossary.rst:145
msgid "binary file"
msgstr "binary file -- 二进制文件"

#: ../../glossary.rst:147
msgid ""
"A :term:`file object` able to read and write :term:`bytes-like objects "
"<bytes-like object>`. Examples of binary files are files opened in binary "
"mode (``'rb'``, ``'wb'`` or ``'rb+'``), :data:`sys.stdin.buffer`, "
":data:`sys.stdout.buffer`, and instances of :class:`io.BytesIO` and "
":class:`gzip.GzipFile`."
msgstr ""
":term:`file object` 能够读写 :term:`类字节对象 <bytes-like object>`。二进制文件的例子包括以二进制模式 "
"(``'rb'``, ``'wb'`` or ``'rb+'``)打开的文件, :data:`sys.stdin.buffer`, "
":data:`sys.stdout.buffer` 以及 :class:`io.BytesIO` 和 :class:`gzip.GzipFile` "
"的实例。"

#: ../../glossary.rst:154
msgid ""
"See also :term:`text file` for a file object able to read and write "
":class:`str` objects."
msgstr "另请参见 :term:`text file` 了解能够读写 :class:`str` 对象的文件对象。"

#: ../../glossary.rst:156
msgid "bytes-like object"
msgstr "bytes-like object -- 字节类对象"

#: ../../glossary.rst:158
msgid ""
"An object that supports the :ref:`bufferobjects` and can export a "
"C-:term:`contiguous` buffer. This includes all :class:`bytes`, "
":class:`bytearray`, and :class:`array.array` objects, as well as many common"
" :class:`memoryview` objects.  Bytes-like objects can be used for various "
"operations that work with binary data; these include compression, saving to "
"a binary file, and sending over a socket."
msgstr ""
"支持 :ref:`bufferobjects` 并且能导出 C-:term:`contiguous` 缓冲的对象。这包括所有 "
":class:`bytes`, :class:`bytearray` 和 :class:`array.array` 对象，以及许多普通 "
":class:`memoryview` 对象。字节类对象可在多种二进制数据操作中使用；这些操作包括压缩、保存为二进制文件以及通过套接字发送等。"

#: ../../glossary.rst:165
msgid ""
"Some operations need the binary data to be mutable.  The documentation often"
" refers to these as \"read-write bytes-like objects\".  Example mutable "
"buffer objects include :class:`bytearray` and a :class:`memoryview` of a "
":class:`bytearray`. Other operations require the binary data to be stored in"
" immutable objects (\"read-only bytes-like objects\"); examples of these "
"include :class:`bytes` and a :class:`memoryview` of a :class:`bytes` object."
msgstr ""
"某些操作需要可变的二进制数据。这种对象在文档中常被称为 \"可读写字节类对象\"。可变缓冲对象的例子包括 :class:`bytearray` 以及 "
":class:`bytearray` 的 :class:`memoryview`。其他操作要求二进制数据存放于不可变对象 "
"(\"只读字节类对象\")；这种对象的例子包括 :class:`bytes` 以及 :class:`bytes` 对象的 "
":class:`memoryview`。"

#: ../../glossary.rst:173
msgid "bytecode"
msgstr "bytecode -- 字节码"

#: ../../glossary.rst:175
msgid ""
"Python source code is compiled into bytecode, the internal representation of"
" a Python program in the CPython interpreter.  The bytecode is also cached "
"in ``.pyc`` files so that executing the same file is faster the second time "
"(recompilation from source to bytecode can be avoided).  This \"intermediate"
" language\" is said to run on a :term:`virtual machine` that executes the "
"machine code corresponding to each bytecode. Do note that bytecodes are not "
"expected to work between different Python virtual machines, nor to be stable"
" between Python releases."
msgstr ""
"Python 源代码会被编译为字节码，即 CPython 解释器中表示 Python 程序的内部代码。字节码还会缓存在 ``.pyc`` "
"文件中，这样第二次执行同一文件时速度更快 (可以免去将源码重新编译为字节码)。这种 \"中间语言\" 运行在根据字节码执行相应机器码的 "
":term:`virtual machine` 之上。请注意不同 Python 虚拟机上的字节码不一定通用，也不一定能在不同 Python 版本上兼容。"

#: ../../glossary.rst:185
msgid ""
"A list of bytecode instructions can be found in the documentation for "
":ref:`the dis module <bytecodes>`."
msgstr "字节码指令列表可以在 :ref:`dis 模块 <bytecodes>` 的文档中查看。"

#: ../../glossary.rst:187
msgid "class"
msgstr "class -- 类"

#: ../../glossary.rst:189
msgid ""
"A template for creating user-defined objects. Class definitions normally "
"contain method definitions which operate on instances of the class."
msgstr "用来创建用户定义对象的模板。类定义通常包含对该类的实例进行操作的方法定义。"

#: ../../glossary.rst:192
msgid "class variable"
msgstr "class variable -- 类变量"

#: ../../glossary.rst:194
msgid ""
"A variable defined in a class and intended to be modified only at class "
"level (i.e., not in an instance of the class)."
msgstr "在类中定义的变量，并且仅限在类的层级上修改 (而不是在类的实例中修改)。"

#: ../../glossary.rst:196
msgid "coercion"
msgstr "coercion -- 强制类型转换"

#: ../../glossary.rst:198
msgid ""
"The implicit conversion of an instance of one type to another during an "
"operation which involves two arguments of the same type.  For example, "
"``int(3.15)`` converts the floating point number to the integer ``3``, but "
"in ``3+4.5``, each argument is of a different type (one int, one float), and"
" both must be converted to the same type before they can be added or it will"
" raise a :exc:`TypeError`.  Without coercion, all arguments of even "
"compatible types would have to be normalized to the same value by the "
"programmer, e.g., ``float(3)+4.5`` rather than just ``3+4.5``."
msgstr ""
"在包含两个相同类型参数的操作中，一种类型的实例隐式地转换为另一种类型。例如，``int(3.15)`` 是将原浮点数转换为整型数 ``3``，但在 "
"``3+4.5`` 中，参数的类型不一致 (一个是 int, 一个是 float)，两者必须转换为相同类型才能相加，否则将引发 "
":exc:`TypeError`。如果没有强制类型转换机制，程序员必须将所有可兼容参数归一化为相同类型，例如要写成 ``float(3)+4.5`` "
"而不是 ``3+4.5``。"

#: ../../glossary.rst:206
msgid "complex number"
msgstr "complex number -- 复数"

#: ../../glossary.rst:208
msgid ""
"An extension of the familiar real number system in which all numbers are "
"expressed as a sum of a real part and an imaginary part.  Imaginary numbers "
"are real multiples of the imaginary unit (the square root of ``-1``), often "
"written ``i`` in mathematics or ``j`` in engineering.  Python has built-in "
"support for complex numbers, which are written with this latter notation; "
"the imaginary part is written with a ``j`` suffix, e.g., ``3+1j``.  To get "
"access to complex equivalents of the :mod:`math` module, use :mod:`cmath`.  "
"Use of complex numbers is a fairly advanced mathematical feature.  If you're"
" not aware of a need for them, it's almost certain you can safely ignore "
"them."
msgstr ""
"对普通实数系统的扩展，其中所有数字都被表示为一个实部和一个虚部的和。虚数是虚数单位 (``-1`` 的平方根) 的实倍数，通常在数学中写为 "
"``i``，在工程学中写为 ``j``。Python 内置了对复数的支持，采用工程学标记方式；虚部带有一个 ``j`` 后缀，例如 "
"``3+1j``。如果需要 :mod:`math` 模块内对象的对应复数版本，请使用 "
":mod:`cmath`，复数的使用是一个比较高级的数学特性。如果你感觉没有必要，忽略它们也几乎不会有任何问题。"

#: ../../glossary.rst:218
msgid "context manager"
msgstr "context manager -- 上下文管理器"

#: ../../glossary.rst:220
msgid ""
"An object which controls the environment seen in a :keyword:`with` statement"
" by defining :meth:`__enter__` and :meth:`__exit__` methods. See :pep:`343`."
msgstr ""
"在 :keyword:`with` 语句中使用，通过定义 :meth:`__enter__` 和 :meth:`__exit__` "
"方法来控制环境状态的对象。参见 :pep:`343`。"

#: ../../glossary.rst:223
msgid "contiguous"
msgstr "contiguous -- 连续"

#: ../../glossary.rst:227
msgid ""
"A buffer is considered contiguous exactly if it is either *C-contiguous* or "
"*Fortran contiguous*.  Zero-dimensional buffers are C and Fortran "
"contiguous.  In one-dimensional arrays, the items must be laid out in memory"
" next to each other, in order of increasing indexes starting from zero.  In "
"multidimensional C-contiguous arrays, the last index varies the fastest when"
" visiting items in order of memory address.  However, in Fortran contiguous "
"arrays, the first index varies the fastest."
msgstr ""
"一个缓冲如果是 *C-连续* 或 *Fortran 连续* 就会被认为是连续的。零维缓冲是 C 和 Fortran "
"连续的。在一维数组中，所有条目必须在内存中彼此相邻地排列，采用从零开始的递增索引顺序。在多维 "
"C-连续数组中，当按内存地址排列时用最后一个索引访问条目时速度最快。但是在 Fortran 连续数组中则是用第一个索引最快。"

#: ../../glossary.rst:235
msgid "coroutine"
msgstr "coroutine -- 协程"

#: ../../glossary.rst:237
msgid ""
"Coroutines is a more generalized form of subroutines. Subroutines are "
"entered at one point and exited at another point.  Coroutines can be "
"entered, exited, and resumed at many different points.  They can be "
"implemented with the :keyword:`async def` statement.  See also :pep:`492`."
msgstr ""
"协程是子例程的更一般形式。子例程可以在某一点进入并在另一点退出。协程则可以在许多不同的点上进入、退出和恢复。它们可通过 :keyword:`async "
"def` 语句来实现。参见 :pep:`492`。"

#: ../../glossary.rst:242
msgid "coroutine function"
msgstr "coroutine function -- 协程函数"

#: ../../glossary.rst:244
msgid ""
"A function which returns a :term:`coroutine` object.  A coroutine function "
"may be defined with the :keyword:`async def` statement, and may contain "
":keyword:`await`, :keyword:`async for`, and :keyword:`async with` keywords."
"  These were introduced by :pep:`492`."
msgstr ""
"返回一个 :term:`coroutine` 对象的函数。协程函数可通过 :keyword:`async def` 语句来定义，并可能包含 "
":keyword:`await`, :keyword:`async for` 和 :keyword:`async with` 关键字。这些特性是由 "
":pep:`492` 引入的。"

#: ../../glossary.rst:249
msgid "CPython"
msgstr "CPython"

#: ../../glossary.rst:251
msgid ""
"The canonical implementation of the Python programming language, as "
"distributed on `python.org <https://www.python.org>`_.  The term \"CPython\""
" is used when necessary to distinguish this implementation from others such "
"as Jython or IronPython."
msgstr ""
"Python 编程语言的规范实现，在 `python.org <https://www.python.org>`_ 上发布。\"CPython\" "
"一词用于在必要时将此实现与其他实现例如 Jython 或 IronPython 相区别。"

#: ../../glossary.rst:255
msgid "decorator"
msgstr "decorator -- 装饰器"

#: ../../glossary.rst:257
msgid ""
"A function returning another function, usually applied as a function "
"transformation using the ``@wrapper`` syntax.  Common examples for "
"decorators are :func:`classmethod` and :func:`staticmethod`."
msgstr ""
"返回值为另一个函数的函数，通常使用 ``@wrapper`` 语法形式来进行函数变换。装饰器的常见例子包括 :func:`classmethod` 和 "
":func:`staticmethod`。"

#: ../../glossary.rst:261
msgid ""
"The decorator syntax is merely syntactic sugar, the following two function "
"definitions are semantically equivalent::"
msgstr "装饰器语法只是一种语法糖，以下两个函数定义在语义上完全等价::"

#: ../../glossary.rst:272
msgid ""
"The same concept exists for classes, but is less commonly used there.  See "
"the documentation for :ref:`function definitions <function>` and :ref:`class"
" definitions <class>` for more about decorators."
msgstr ""
"同的样概念也适用于类，但通常较少这样使用。有关装饰器的详情可参见 :ref:`函数定义 <function>` 和 :ref:`类定义 <class>`"
" 的文档。"

#: ../../glossary.rst:275
msgid "descriptor"
msgstr "descriptor -- 描述符"

#: ../../glossary.rst:277
msgid ""
"Any object which defines the methods :meth:`__get__`, :meth:`__set__`, or "
":meth:`__delete__`.  When a class attribute is a descriptor, its special "
"binding behavior is triggered upon attribute lookup.  Normally, using *a.b* "
"to get, set or delete an attribute looks up the object named *b* in the "
"class dictionary for *a*, but if *b* is a descriptor, the respective "
"descriptor method gets called.  Understanding descriptors is a key to a deep"
" understanding of Python because they are the basis for many features "
"including functions, methods, properties, class methods, static methods, and"
" reference to super classes."
msgstr ""
"任何定义了 :meth:`__get__`, :meth:`__set__` 或 :meth:`__delete__` "
"方法的对象。当一个类属性为描述符时，它的特殊绑定行为就会在属性查找时被触发。通常情况下，使用 *a.b* 来获取、设置或删除一个属性时会在 *a* "
"的类字典中查找名称为 *b* 的对象，但如果 *b* 是一个描述符，则会调用对应的描述符方法。理解描述符的概念是更深层次理解 Python "
"的关键，因为这是许多重要特性的基础，包括函数、方法、属性、类方法、静态方法以及对超类的引用等等。"

#: ../../glossary.rst:287
msgid ""
"For more information about descriptors' methods, see :ref:`descriptors`."
msgstr "有关描述符的方法的详情可参看 :ref:`descriptors`。"

#: ../../glossary.rst:288
msgid "dictionary"
msgstr "dictionary -- 字典"

#: ../../glossary.rst:290
msgid ""
"An associative array, where arbitrary keys are mapped to values.  The keys "
"can be any object with :meth:`__hash__` and :meth:`__eq__` methods. Called a"
" hash in Perl."
msgstr ""
"一个关联数组，其中的任意键都映射到相应的值。键可以是任何具有 :meth:`__hash__` 和 :meth:`__eq__` 方法的对象。在 "
"Perl 语言中称为 hash。"

#: ../../glossary.rst:293
msgid "dictionary view"
msgstr "dictionary view -- 字典视图"

#: ../../glossary.rst:295
msgid ""
"The objects returned from :meth:`dict.keys`, :meth:`dict.values`, and "
":meth:`dict.items` are called dictionary views. They provide a dynamic view "
"on the dictionary’s entries, which means that when the dictionary changes, "
"the view reflects these changes. To force the dictionary view to become a "
"full list use ``list(dictview)``.  See :ref:`dict-views`."
msgstr ""
"从 :meth:`dict.keys`, :meth:`dict.values` 和 :meth:`dict.items` "
"返回的对象被称为字典视图。它们提供了字典条目的一个动态视图，这意味着当字典改变时，视图也会相应改变。要将字典视图强制转换为真正的列表，可使用 "
"``list(dictview)``。参见 :ref:`dict-views`。"

#: ../../glossary.rst:301
msgid "docstring"
msgstr "docstring -- 文档字符串"

#: ../../glossary.rst:303
msgid ""
"A string literal which appears as the first expression in a class, function "
"or module.  While ignored when the suite is executed, it is recognized by "
"the compiler and put into the :attr:`__doc__` attribute of the enclosing "
"class, function or module.  Since it is available via introspection, it is "
"the canonical place for documentation of the object."
msgstr ""
"作为类、函数或模块之内的第一个表达式出现的字符串字面值。它在代码执行时会被忽略，但会被解释器识别并放入所在类、函数或模块的 "
":attr:`__doc__` 属性中。由于它可用于代码内省，因此是对象存放文档的规范位置。"

#: ../../glossary.rst:309
msgid "duck-typing"
msgstr "duck-typing -- 鸭子类型"

#: ../../glossary.rst:311
msgid ""
"A programming style which does not look at an object's type to determine if "
"it has the right interface; instead, the method or attribute is simply "
"called or used (\"If it looks like a duck and quacks like a duck, it must be"
" a duck.\")  By emphasizing interfaces rather than specific types, well-"
"designed code improves its flexibility by allowing polymorphic substitution."
"  Duck-typing avoids tests using :func:`type` or :func:`isinstance`.  (Note,"
" however, that duck-typing can be complemented with :term:`abstract base "
"classes <abstract base class>`.)  Instead, it typically employs "
":func:`hasattr` tests or :term:`EAFP` programming."
msgstr ""
"指一种编程风格，它并不依靠查找对象类型来确定其是否具有正确的接口，而是直接调用或使用其方法或属性 "
"(\"看起来像鸭子，叫起来也像鸭子，那么肯定就是鸭子。\")  由于强调接口而非特定类型，设计良好的代码可通过允许多态替代来提升灵活性。鸭子类型避免使用"
" :func:`type` 或 :func:`isinstance` 检测。(但要注意鸭子类型可以使用 :term:`抽象基类 <abstract "
"base class>` 作为补充。)  而往往会采用 :func:`hasattr` 检测或是 :term:`EAFP` 编程。"

#: ../../glossary.rst:320
msgid "EAFP"
msgstr "EAFP"

#: ../../glossary.rst:322
msgid ""
"Easier to ask for forgiveness than permission.  This common Python coding "
"style assumes the existence of valid keys or attributes and catches "
"exceptions if the assumption proves false.  This clean and fast style is "
"characterized by the presence of many :keyword:`try` and :keyword:`except` "
"statements.  The technique contrasts with the :term:`LBYL` style common to "
"many other languages such as C."
msgstr ""
"“求原谅比求许可更容易”的英文缩写。这种 Python 常用编码风格会假定所需的键或属性存在，并在假定错误时捕获异常。这种简洁快速风格的特定就是大量运用"
" :keyword:`try` 和 :keyword:`except` 语句。于其相对的则是所谓 :term:`LBYL` 风格，常见于 C "
"等许多其他语言。"

#: ../../glossary.rst:328
msgid "expression"
msgstr "expression -- 表达式"

#: ../../glossary.rst:330
msgid ""
"A piece of syntax which can be evaluated to some value.  In other words, an "
"expression is an accumulation of expression elements like literals, names, "
"attribute access, operators or function calls which all return a value.  In "
"contrast to many other languages, not all language constructs are "
"expressions.  There are also :term:`statement`\\s which cannot be used as "
"expressions, such as :keyword:`if`.  Assignments are also statements, not "
"expressions."
msgstr ""
"可以求出某个值的语法单元。换句话说，一个表达式就是表达元素例如字面值、名称、属性访问、运算符或函数调用的汇总，它们最终都会返回一个值。与许多其他语言不同，并非所有语言构件都是表达式。还存在不能用作表达式的"
" :term:`statement`，例如 :keyword:`if`。赋值也是语句而非表达式。"

#: ../../glossary.rst:337
msgid "extension module"
msgstr "extension module -- 扩展模块"

#: ../../glossary.rst:339
msgid ""
"A module written in C or C++, using Python's C API to interact with the core"
" and with user code."
msgstr "以 C 或 C++ 编写的模块，使用 Python 的 C API 来与语言核心以及用户代码进行交互。"

#: ../../glossary.rst:341
msgid "f-string"
msgstr "f-string -- f-字符串"

#: ../../glossary.rst:343
msgid ""
"String literals prefixed with ``'f'`` or ``'F'`` are commonly called "
"\"f-strings\" which is short for :ref:`formatted string literals "
"<f-strings>`.  See also :pep:`498`."
msgstr ""
"带有 ``'f'`` 或 ``'F'`` 前缀的字符串字面值通常被称为 \"f-字符串\" 即 :ref:`格式化字符串字面值 <f-strings>`"
" 的简写。参见 :pep:`498`。"

#: ../../glossary.rst:346
msgid "file object"
msgstr "file object -- 文件对象"

#: ../../glossary.rst:348
msgid ""
"An object exposing a file-oriented API (with methods such as :meth:`read()` "
"or :meth:`write()`) to an underlying resource.  Depending on the way it was "
"created, a file object can mediate access to a real on-disk file or to "
"another type of storage or communication device (for example standard "
"input/output, in-memory buffers, sockets, pipes, etc.).  File objects are "
"also called :dfn:`file-like objects` or :dfn:`streams`."
msgstr ""
"对外提供面向文件 API 以使用下层资源的对象 (带有 :meth:`read()` 或 :meth:`write()` "
"这样的方法)。根据其创建方式的不同，文件对象可以处理对真实磁盘文件，对其他类型存储，或是对通讯设备的访问 "
"(例如标准输入/输出、内存缓冲区、套接字、管道等等)。文件对象也被称为 :dfn:`文件类对象` 或 :dfn:`流`。"

#: ../../glossary.rst:356
msgid ""
"There are actually three categories of file objects: raw :term:`binary files"
" <binary file>`, buffered :term:`binary files <binary file>` and :term:`text"
" files <text file>`. Their interfaces are defined in the :mod:`io` module.  "
"The canonical way to create a file object is by using the :func:`open` "
"function."
msgstr ""
"实际上共有三种类别的文件对象: 原始 :term:`二进制文件 <binary file>`, 缓冲 :term:`二进制文件 <binary "
"file>` 以及 :term:`文本文件 <text file>`。它们的接口定义均在 :mod:`io` 模块中。创建文件对象的规范方式是使用 "
":func:`open` 函数。"

#: ../../glossary.rst:361
msgid "file-like object"
msgstr "file-like object -- 文件类对象"

#: ../../glossary.rst:363
msgid "A synonym for :term:`file object`."
msgstr ":term:`file object` 的同义词。"

#: ../../glossary.rst:364
msgid "finder"
msgstr "finder -- 查找器"

#: ../../glossary.rst:366
msgid ""
"An object that tries to find the :term:`loader` for a module that is being "
"imported."
msgstr ""

#: ../../glossary.rst:369
msgid ""
"Since Python 3.3, there are two types of finder: :term:`meta path finders "
"<meta path finder>` for use with :data:`sys.meta_path`, and :term:`path "
"entry finders <path entry finder>` for use with :data:`sys.path_hooks`."
msgstr ""

#: ../../glossary.rst:373
msgid "See :pep:`302`, :pep:`420` and :pep:`451` for much more detail."
msgstr ""

#: ../../glossary.rst:374
msgid "floor division"
msgstr "floor division -- 向下取整除法"

#: ../../glossary.rst:376
msgid ""
"Mathematical division that rounds down to nearest integer.  The floor "
"division operator is ``//``.  For example, the expression ``11 // 4`` "
"evaluates to ``2`` in contrast to the ``2.75`` returned by float true "
"division.  Note that ``(-11) // 4`` is ``-3`` because that is ``-2.75`` "
"rounded *downward*. See :pep:`238`."
msgstr ""
"向下舍入到最接近的整数的数学除法。向下取整除法的运算符是 ``//`` 。例如，表达式 ``11 // 4`` 的计算结果是 ``2`` ，而与之相反的是浮点数的真正除法返回 ``2.75`` 。注意 ``(-11) // 4`` 返回 ``-3``是因为\n"
"结果``-2.75`` *向下* 舍入得到的。见 :pep:`238` 。"

#: ../../glossary.rst:381
msgid "function"
msgstr "function -- 函数"

#: ../../glossary.rst:383
msgid ""
"A series of statements which returns some value to a caller. It can also be "
"passed zero or more :term:`arguments <argument>` which may be used in the "
"execution of the body. See also :term:`parameter`, :term:`method`, and the "
":ref:`function` section."
msgstr ""

#: ../../glossary.rst:387
msgid "function annotation"
msgstr "function annotation -- 函数标注"

#: ../../glossary.rst:389
msgid "An :term:`annotation` of a function parameter or return value."
msgstr ""

#: ../../glossary.rst:391
msgid ""
"Function annotations are usually used for :term:`type hints <type hint>`: "
"for example this function is expected to take two :class:`int` arguments and"
" is also expected to have an :class:`int` return value::"
msgstr ""

#: ../../glossary.rst:399
msgid "Function annotation syntax is explained in section :ref:`function`."
msgstr ""

#: ../../glossary.rst:401
msgid ""
"See :term:`variable annotation` and :pep:`484`, which describe this "
"functionality."
msgstr ""

#: ../../glossary.rst:403
msgid "__future__"
msgstr "__future__"

#: ../../glossary.rst:405
msgid ""
"A pseudo-module which programmers can use to enable new language features "
"which are not compatible with the current interpreter."
msgstr ""

#: ../../glossary.rst:408
msgid ""
"By importing the :mod:`__future__` module and evaluating its variables, you "
"can see when a new feature was first added to the language and when it "
"becomes the default::"
msgstr ""

#: ../../glossary.rst:415
msgid "garbage collection"
msgstr "garbage collection -- 垃圾回收"

#: ../../glossary.rst:417
msgid ""
"The process of freeing memory when it is not used anymore.  Python performs "
"garbage collection via reference counting and a cyclic garbage collector "
"that is able to detect and break reference cycles.  The garbage collector "
"can be controlled using the :mod:`gc` module."
msgstr ""

#: ../../glossary.rst:423
msgid "generator"
msgstr "generator -- 生成器"

#: ../../glossary.rst:425
msgid ""
"A function which returns a :term:`generator iterator`.  It looks like a "
"normal function except that it contains :keyword:`yield` expressions for "
"producing a series of values usable in a for-loop or that can be retrieved "
"one at a time with the :func:`next` function."
msgstr ""

#: ../../glossary.rst:430
msgid ""
"Usually refers to a generator function, but may refer to a *generator "
"iterator* in some contexts.  In cases where the intended meaning isn't "
"clear, using the full terms avoids ambiguity."
msgstr ""

#: ../../glossary.rst:433
msgid "generator iterator"
msgstr "generator iterator -- 生成器迭代器"

#: ../../glossary.rst:435
msgid "An object created by a :term:`generator` function."
msgstr ""

#: ../../glossary.rst:437
msgid ""
"Each :keyword:`yield` temporarily suspends processing, remembering the "
"location execution state (including local variables and pending try-"
"statements).  When the *generator iterator* resumes, it picks up where it "
"left off (in contrast to functions which start fresh on every invocation)."
msgstr ""

#: ../../glossary.rst:444
msgid "generator expression"
msgstr "generator expression -- 生成器表达式"

#: ../../glossary.rst:446
msgid ""
"An expression that returns an iterator.  It looks like a normal expression "
"followed by a :keyword:`for` expression defining a loop variable, range, and"
" an optional :keyword:`if` expression.  The combined expression generates "
"values for an enclosing function::"
msgstr ""

#: ../../glossary.rst:453
msgid "generic function"
msgstr "generic function -- 泛型函数"

#: ../../glossary.rst:455
msgid ""
"A function composed of multiple functions implementing the same operation "
"for different types. Which implementation should be used during a call is "
"determined by the dispatch algorithm."
msgstr ""

#: ../../glossary.rst:459
msgid ""
"See also the :term:`single dispatch` glossary entry, the "
":func:`functools.singledispatch` decorator, and :pep:`443`."
msgstr ""

#: ../../glossary.rst:462
msgid "GIL"
msgstr "GIL"

#: ../../glossary.rst:464
msgid "See :term:`global interpreter lock`."
msgstr ""

#: ../../glossary.rst:465
msgid "global interpreter lock"
msgstr "全局解释器锁"

#: ../../glossary.rst:467
msgid ""
"The mechanism used by the :term:`CPython` interpreter to assure that only "
"one thread executes Python :term:`bytecode` at a time. This simplifies the "
"CPython implementation by making the object model (including critical built-"
"in types such as :class:`dict`) implicitly safe against concurrent access.  "
"Locking the entire interpreter makes it easier for the interpreter to be "
"multi-threaded, at the expense of much of the parallelism afforded by multi-"
"processor machines."
msgstr ""

#: ../../glossary.rst:476
msgid ""
"However, some extension modules, either standard or third-party, are "
"designed so as to release the GIL when doing computationally-intensive tasks"
" such as compression or hashing.  Also, the GIL is always released when "
"doing I/O."
msgstr ""

#: ../../glossary.rst:481
msgid ""
"Past efforts to create a \"free-threaded\" interpreter (one which locks "
"shared data at a much finer granularity) have not been successful because "
"performance suffered in the common single-processor case. It is believed "
"that overcoming this performance issue would make the implementation much "
"more complicated and therefore costlier to maintain."
msgstr ""

#: ../../glossary.rst:487
msgid "hash-based pyc"
msgstr "hash-based pyc -- 基于哈希的 pyc"

#: ../../glossary.rst:489
msgid ""
"A bytecode cache file that uses the hash rather than the last-modified time "
"of the corresponding source file to determine its validity. See :ref:`pyc-"
"invalidation`."
msgstr ""

#: ../../glossary.rst:492
msgid "hashable"
msgstr "hashable -- 可哈希"

#: ../../glossary.rst:494
msgid ""
"An object is *hashable* if it has a hash value which never changes during "
"its lifetime (it needs a :meth:`__hash__` method), and can be compared to "
"other objects (it needs an :meth:`__eq__` method).  Hashable objects which "
"compare equal must have the same hash value."
msgstr ""

#: ../../glossary.rst:499
msgid ""
"Hashability makes an object usable as a dictionary key and a set member, "
"because these data structures use the hash value internally."
msgstr ""

#: ../../glossary.rst:502
msgid ""
"All of Python's immutable built-in objects are hashable; mutable containers "
"(such as lists or dictionaries) are not.  Objects which are instances of "
"user-defined classes are hashable by default.  They all compare unequal "
"(except with themselves), and their hash value is derived from their "
":func:`id`."
msgstr ""

#: ../../glossary.rst:507
msgid "IDLE"
msgstr "IDLE"

#: ../../glossary.rst:509
msgid ""
"An Integrated Development Environment for Python.  IDLE is a basic editor "
"and interpreter environment which ships with the standard distribution of "
"Python."
msgstr ""

#: ../../glossary.rst:512
msgid "immutable"
msgstr "immutable -- 不可变"

#: ../../glossary.rst:514
msgid ""
"An object with a fixed value.  Immutable objects include numbers, strings "
"and tuples.  Such an object cannot be altered.  A new object has to be "
"created if a different value has to be stored.  They play an important role "
"in places where a constant hash value is needed, for example as a key in a "
"dictionary."
msgstr ""

#: ../../glossary.rst:519
msgid "import path"
msgstr "import path -- 导入路径"

#: ../../glossary.rst:521
msgid ""
"A list of locations (or :term:`path entries <path entry>`) that are searched"
" by the :term:`path based finder` for modules to import. During import, this"
" list of locations usually comes from :data:`sys.path`, but for subpackages "
"it may also come from the parent package's ``__path__`` attribute."
msgstr ""

#: ../../glossary.rst:526
msgid "importing"
msgstr "importing -- 导入"

#: ../../glossary.rst:528
msgid ""
"The process by which Python code in one module is made available to Python "
"code in another module."
msgstr ""

#: ../../glossary.rst:530
msgid "importer"
msgstr "importer -- 导入器"

#: ../../glossary.rst:532
msgid ""
"An object that both finds and loads a module; both a :term:`finder` and "
":term:`loader` object."
msgstr ""

#: ../../glossary.rst:534
msgid "interactive"
msgstr "interactive -- 交互"

#: ../../glossary.rst:536
msgid ""
"Python has an interactive interpreter which means you can enter statements "
"and expressions at the interpreter prompt, immediately execute them and see "
"their results.  Just launch ``python`` with no arguments (possibly by "
"selecting it from your computer's main menu). It is a very powerful way to "
"test out new ideas or inspect modules and packages (remember ``help(x)``)."
msgstr ""

#: ../../glossary.rst:542
msgid "interpreted"
msgstr "interpreted -- 解释"

#: ../../glossary.rst:544
msgid ""
"Python is an interpreted language, as opposed to a compiled one, though the "
"distinction can be blurry because of the presence of the bytecode compiler."
"  This means that source files can be run directly without explicitly "
"creating an executable which is then run. Interpreted languages typically "
"have a shorter development/debug cycle than compiled ones, though their "
"programs generally also run more slowly.  See also :term:`interactive`."
msgstr ""

#: ../../glossary.rst:551
msgid "interpreter shutdown"
msgstr ""

#: ../../glossary.rst:553
msgid ""
"When asked to shut down, the Python interpreter enters a special phase where"
" it gradually releases all allocated resources, such as modules and various "
"critical internal structures.  It also makes several calls to the "
":term:`garbage collector <garbage collection>`. This can trigger the "
"execution of code in user-defined destructors or weakref callbacks. Code "
"executed during the shutdown phase can encounter various exceptions as the "
"resources it relies on may not function anymore (common examples are library"
" modules or the warnings machinery)."
msgstr ""

#: ../../glossary.rst:562
msgid ""
"The main reason for interpreter shutdown is that the ``__main__`` module or "
"the script being run has finished executing."
msgstr ""

#: ../../glossary.rst:564
msgid "iterable"
msgstr "iterable -- 可迭代对象"

#: ../../glossary.rst:566
msgid ""
"An object capable of returning its members one at a time. Examples of "
"iterables include all sequence types (such as :class:`list`, :class:`str`, "
"and :class:`tuple`) and some non-sequence types like :class:`dict`, "
":term:`file objects <file object>`, and objects of any classes you define "
"with an :meth:`__iter__` method or with a :meth:`__getitem__` method that "
"implements :term:`Sequence` semantics."
msgstr ""

#: ../../glossary.rst:573
msgid ""
"Iterables can be used in a :keyword:`for` loop and in many other places "
"where a sequence is needed (:func:`zip`, :func:`map`, ...).  When an "
"iterable object is passed as an argument to the built-in function "
":func:`iter`, it returns an iterator for the object.  This iterator is good "
"for one pass over the set of values.  When using iterables, it is usually "
"not necessary to call :func:`iter` or deal with iterator objects yourself.  "
"The ``for`` statement does that automatically for you, creating a temporary "
"unnamed variable to hold the iterator for the duration of the loop.  See "
"also :term:`iterator`, :term:`sequence`, and :term:`generator`."
msgstr ""

#: ../../glossary.rst:583
msgid "iterator"
msgstr "iterator -- 迭代器"

#: ../../glossary.rst:585
msgid ""
"An object representing a stream of data.  Repeated calls to the iterator's "
":meth:`~iterator.__next__` method (or passing it to the built-in function "
":func:`next`) return successive items in the stream.  When no more data are "
"available a :exc:`StopIteration` exception is raised instead.  At this "
"point, the iterator object is exhausted and any further calls to its "
":meth:`__next__` method just raise :exc:`StopIteration` again.  Iterators "
"are required to have an :meth:`__iter__` method that returns the iterator "
"object itself so every iterator is also iterable and may be used in most "
"places where other iterables are accepted.  One notable exception is code "
"which attempts multiple iteration passes.  A container object (such as a "
":class:`list`) produces a fresh new iterator each time you pass it to the "
":func:`iter` function or use it in a :keyword:`for` loop.  Attempting this "
"with an iterator will just return the same exhausted iterator object used in"
" the previous iteration pass, making it appear like an empty container."
msgstr ""

#: ../../glossary.rst:600
msgid "More information can be found in :ref:`typeiter`."
msgstr ""

#: ../../glossary.rst:601
msgid "key function"
msgstr "key function -- 键函数"

#: ../../glossary.rst:603
msgid ""
"A key function or collation function is a callable that returns a value used"
" for sorting or ordering.  For example, :func:`locale.strxfrm` is used to "
"produce a sort key that is aware of locale specific sort conventions."
msgstr ""

#: ../../glossary.rst:608
msgid ""
"A number of tools in Python accept key functions to control how elements are"
" ordered or grouped.  They include :func:`min`, :func:`max`, :func:`sorted`,"
" :meth:`list.sort`, :func:`heapq.merge`, :func:`heapq.nsmallest`, "
":func:`heapq.nlargest`, and :func:`itertools.groupby`."
msgstr ""

#: ../../glossary.rst:614
msgid ""
"There are several ways to create a key function.  For example. the "
":meth:`str.lower` method can serve as a key function for case insensitive "
"sorts.  Alternatively, a key function can be built from a :keyword:`lambda` "
"expression such as ``lambda r: (r[0], r[2])``.  Also, the :mod:`operator` "
"module provides three key function constructors: "
":func:`~operator.attrgetter`, :func:`~operator.itemgetter`, and "
":func:`~operator.methodcaller`.  See the :ref:`Sorting HOW TO "
"<sortinghowto>` for examples of how to create and use key functions."
msgstr ""

#: ../../glossary.rst:622
msgid "keyword argument"
msgstr "keyword argument -- 关键字参数"

#: ../../glossary.rst:624 ../../glossary.rst:883
msgid "See :term:`argument`."
msgstr ""

#: ../../glossary.rst:625
msgid "lambda"
msgstr "lambda"

#: ../../glossary.rst:627
msgid ""
"An anonymous inline function consisting of a single :term:`expression` which"
" is evaluated when the function is called.  The syntax to create a lambda "
"function is ``lambda [parameters]: expression``"
msgstr ""

#: ../../glossary.rst:630
msgid "LBYL"
msgstr "LBYL"

#: ../../glossary.rst:632
msgid ""
"Look before you leap.  This coding style explicitly tests for pre-conditions"
" before making calls or lookups.  This style contrasts with the :term:`EAFP`"
" approach and is characterized by the presence of many :keyword:`if` "
"statements."
msgstr ""

#: ../../glossary.rst:637
msgid ""
"In a multi-threaded environment, the LBYL approach can risk introducing a "
"race condition between \"the looking\" and \"the leaping\".  For example, "
"the code, ``if key in mapping: return mapping[key]`` can fail if another "
"thread removes *key* from *mapping* after the test, but before the lookup. "
"This issue can be solved with locks or by using the EAFP approach."
msgstr ""

#: ../../glossary.rst:642
msgid "list"
msgstr "list -- 列表"

#: ../../glossary.rst:644
msgid ""
"A built-in Python :term:`sequence`.  Despite its name it is more akin to an "
"array in other languages than to a linked list since access to elements is "
"O(1)."
msgstr ""

#: ../../glossary.rst:647
msgid "list comprehension"
msgstr "list comprehension -- 列表推导式"

#: ../../glossary.rst:649
msgid ""
"A compact way to process all or part of the elements in a sequence and "
"return a list with the results.  ``result = ['{:#04x}'.format(x) for x in "
"range(256) if x % 2 == 0]`` generates a list of strings containing even hex "
"numbers (0x..) in the range from 0 to 255. The :keyword:`if` clause is "
"optional.  If omitted, all elements in ``range(256)`` are processed."
msgstr ""

#: ../../glossary.rst:655
msgid "loader"
msgstr "loader -- 加载器"

#: ../../glossary.rst:657
msgid ""
"An object that loads a module. It must define a method named "
":meth:`load_module`. A loader is typically returned by a :term:`finder`. See"
" :pep:`302` for details and :class:`importlib.abc.Loader` for an "
":term:`abstract base class`."
msgstr ""

#: ../../glossary.rst:661
msgid "mapping"
msgstr "mapping -- 映射"

#: ../../glossary.rst:663
msgid ""
"A container object that supports arbitrary key lookups and implements the "
"methods specified in the :class:`~collections.abc.Mapping` or "
":class:`~collections.abc.MutableMapping` :ref:`abstract base classes "
"<collections-abstract-base-classes>`.  Examples include :class:`dict`, "
":class:`collections.defaultdict`, :class:`collections.OrderedDict` and "
":class:`collections.Counter`."
msgstr ""

#: ../../glossary.rst:669
msgid "meta path finder"
msgstr "meta path finder -- 元路径查找器"

#: ../../glossary.rst:671
msgid ""
"A :term:`finder` returned by a search of :data:`sys.meta_path`.  Meta path "
"finders are related to, but different from :term:`path entry finders <path "
"entry finder>`."
msgstr ""

#: ../../glossary.rst:675
msgid ""
"See :class:`importlib.abc.MetaPathFinder` for the methods that meta path "
"finders implement."
msgstr ""

#: ../../glossary.rst:677
msgid "metaclass"
msgstr "metaclass -- 元类"

#: ../../glossary.rst:679
msgid ""
"The class of a class.  Class definitions create a class name, a class "
"dictionary, and a list of base classes.  The metaclass is responsible for "
"taking those three arguments and creating the class.  Most object oriented "
"programming languages provide a default implementation.  What makes Python "
"special is that it is possible to create custom metaclasses.  Most users "
"never need this tool, but when the need arises, metaclasses can provide "
"powerful, elegant solutions.  They have been used for logging attribute "
"access, adding thread-safety, tracking object creation, implementing "
"singletons, and many other tasks."
msgstr ""

#: ../../glossary.rst:689
msgid "More information can be found in :ref:`metaclasses`."
msgstr ""

#: ../../glossary.rst:690
msgid "method"
msgstr "method -- 方法"

#: ../../glossary.rst:692
msgid ""
"A function which is defined inside a class body.  If called as an attribute "
"of an instance of that class, the method will get the instance object as its"
" first :term:`argument` (which is usually called ``self``). See "
":term:`function` and :term:`nested scope`."
msgstr ""

#: ../../glossary.rst:696
msgid "method resolution order"
msgstr "method resolution order -- 方法解析顺序"

#: ../../glossary.rst:698
msgid ""
"Method Resolution Order is the order in which base classes are searched for "
"a member during lookup. See `The Python 2.3 Method Resolution Order "
"<https://www.python.org/download/releases/2.3/mro/>`_ for details of the "
"algorithm used by the Python interpreter since the 2.3 release."
msgstr ""

#: ../../glossary.rst:702
msgid "module"
msgstr "module -- 模块"

#: ../../glossary.rst:704
msgid ""
"An object that serves as an organizational unit of Python code.  Modules "
"have a namespace containing arbitrary Python objects.  Modules are loaded "
"into Python by the process of :term:`importing`."
msgstr ""

#: ../../glossary.rst:708
msgid "See also :term:`package`."
msgstr ""

#: ../../glossary.rst:709
msgid "module spec"
msgstr "module spec -- 模块规格"

#: ../../glossary.rst:711
msgid ""
"A namespace containing the import-related information used to load a module."
" An instance of :class:`importlib.machinery.ModuleSpec`."
msgstr ""

#: ../../glossary.rst:713
msgid "MRO"
msgstr "MRO"

#: ../../glossary.rst:715
msgid "See :term:`method resolution order`."
msgstr ""

#: ../../glossary.rst:716
msgid "mutable"
msgstr "mutable -- 可变"

#: ../../glossary.rst:718
msgid ""
"Mutable objects can change their value but keep their :func:`id`.  See also "
":term:`immutable`."
msgstr ""

#: ../../glossary.rst:720
msgid "named tuple"
msgstr "named tuple -- 具名元组"

#: ../../glossary.rst:722
msgid ""
"Any tuple-like class whose indexable elements are also accessible using "
"named attributes (for example, :func:`time.localtime` returns a tuple-like "
"object where the *year* is accessible either with an index such as ``t[0]`` "
"or with a named attribute like ``t.tm_year``)."
msgstr ""

#: ../../glossary.rst:727
msgid ""
"A named tuple can be a built-in type such as :class:`time.struct_time`, or "
"it can be created with a regular class definition.  A full featured named "
"tuple can also be created with the factory function "
":func:`collections.namedtuple`.  The latter approach automatically provides "
"extra features such as a self-documenting representation like "
"``Employee(name='jones', title='programmer')``."
msgstr ""

#: ../../glossary.rst:733
msgid "namespace"
msgstr "namespace -- 命名空间"

#: ../../glossary.rst:735
msgid ""
"The place where a variable is stored.  Namespaces are implemented as "
"dictionaries.  There are the local, global and built-in namespaces as well "
"as nested namespaces in objects (in methods).  Namespaces support modularity"
" by preventing naming conflicts.  For instance, the functions "
":func:`builtins.open <.open>` and :func:`os.open` are distinguished by their"
" namespaces.  Namespaces also aid readability and maintainability by making "
"it clear which module implements a function.  For instance, writing "
":func:`random.seed` or :func:`itertools.islice` makes it clear that those "
"functions are implemented by the :mod:`random` and :mod:`itertools` modules,"
" respectively."
msgstr ""

#: ../../glossary.rst:745
msgid "namespace package"
msgstr "namespace package -- 命名空间包"

#: ../../glossary.rst:747
msgid ""
"A :pep:`420` :term:`package` which serves only as a container for "
"subpackages.  Namespace packages may have no physical representation, and "
"specifically are not like a :term:`regular package` because they have no "
"``__init__.py`` file."
msgstr ""

#: ../../glossary.rst:752
msgid "See also :term:`module`."
msgstr ""

#: ../../glossary.rst:753
msgid "nested scope"
msgstr "nested scope -- 嵌套作用域"

#: ../../glossary.rst:755
msgid ""
"The ability to refer to a variable in an enclosing definition.  For "
"instance, a function defined inside another function can refer to variables "
"in the outer function.  Note that nested scopes by default work only for "
"reference and not for assignment.  Local variables both read and write in "
"the innermost scope.  Likewise, global variables read and write to the "
"global namespace.  The :keyword:`nonlocal` allows writing to outer scopes."
msgstr ""

#: ../../glossary.rst:762
msgid "new-style class"
msgstr "new-style class -- 新式类"

#: ../../glossary.rst:764
msgid ""
"Old name for the flavor of classes now used for all class objects.  In "
"earlier Python versions, only new-style classes could use Python's newer, "
"versatile features like :attr:`~object.__slots__`, descriptors, properties, "
":meth:`__getattribute__`, class methods, and static methods."
msgstr ""

#: ../../glossary.rst:768
msgid "object"
msgstr "object -- 对象"

#: ../../glossary.rst:770
msgid ""
"Any data with state (attributes or value) and defined behavior (methods).  "
"Also the ultimate base class of any :term:`new-style class`."
msgstr ""

#: ../../glossary.rst:773
msgid "package"
msgstr "package -- 包"

#: ../../glossary.rst:775
msgid ""
"A Python :term:`module` which can contain submodules or recursively, "
"subpackages.  Technically, a package is a Python module with an ``__path__``"
" attribute."
msgstr ""

#: ../../glossary.rst:779
msgid "See also :term:`regular package` and :term:`namespace package`."
msgstr ""

#: ../../glossary.rst:780
msgid "parameter"
msgstr "parameter -- 形参"

#: ../../glossary.rst:782
msgid ""
"A named entity in a :term:`function` (or method) definition that specifies "
"an :term:`argument` (or in some cases, arguments) that the function can "
"accept.  There are five kinds of parameter:"
msgstr ""

#: ../../glossary.rst:786
msgid ""
":dfn:`positional-or-keyword`: specifies an argument that can be passed "
"either :term:`positionally <argument>` or as a :term:`keyword argument "
"<argument>`.  This is the default kind of parameter, for example *foo* and "
"*bar* in the following::"
msgstr ""

#: ../../glossary.rst:795
msgid ""
":dfn:`positional-only`: specifies an argument that can be supplied only by "
"position.  Python has no syntax for defining positional-only parameters.  "
"However, some built-in functions have positional-only parameters (e.g. "
":func:`abs`)."
msgstr ""

#: ../../glossary.rst:802
msgid ""
":dfn:`keyword-only`: specifies an argument that can be supplied only by "
"keyword.  Keyword-only parameters can be defined by including a single var-"
"positional parameter or bare ``*`` in the parameter list of the function "
"definition before them, for example *kw_only1* and *kw_only2* in the "
"following::"
msgstr ""

#: ../../glossary.rst:810
msgid ""
":dfn:`var-positional`: specifies that an arbitrary sequence of positional "
"arguments can be provided (in addition to any positional arguments already "
"accepted by other parameters).  Such a parameter can be defined by "
"prepending the parameter name with ``*``, for example *args* in the "
"following::"
msgstr ""

#: ../../glossary.rst:818
msgid ""
":dfn:`var-keyword`: specifies that arbitrarily many keyword arguments can be"
" provided (in addition to any keyword arguments already accepted by other "
"parameters).  Such a parameter can be defined by prepending the parameter "
"name with ``**``, for example *kwargs* in the example above."
msgstr ""

#: ../../glossary.rst:824
msgid ""
"Parameters can specify both optional and required arguments, as well as "
"default values for some optional arguments."
msgstr ""

#: ../../glossary.rst:827
msgid ""
"See also the :term:`argument` glossary entry, the FAQ question on :ref:`the "
"difference between arguments and parameters <faq-argument-vs-parameter>`, "
"the :class:`inspect.Parameter` class, the :ref:`function` section, and "
":pep:`362`."
msgstr ""

#: ../../glossary.rst:831
msgid "path entry"
msgstr "path entry -- 路径入口"

#: ../../glossary.rst:833
msgid ""
"A single location on the :term:`import path` which the :term:`path based "
"finder` consults to find modules for importing."
msgstr ""

#: ../../glossary.rst:835
msgid "path entry finder"
msgstr "path entry finder -- 路径入口查找器"

#: ../../glossary.rst:837
msgid ""
"A :term:`finder` returned by a callable on :data:`sys.path_hooks` (i.e. a "
":term:`path entry hook`) which knows how to locate modules given a "
":term:`path entry`."
msgstr ""

#: ../../glossary.rst:841
msgid ""
"See :class:`importlib.abc.PathEntryFinder` for the methods that path entry "
"finders implement."
msgstr ""

#: ../../glossary.rst:843
msgid "path entry hook"
msgstr "path entry hook -- 路径入口钩子"

#: ../../glossary.rst:845
msgid ""
"A callable on the :data:`sys.path_hook` list which returns a :term:`path "
"entry finder` if it knows how to find modules on a specific :term:`path "
"entry`."
msgstr ""

#: ../../glossary.rst:848
msgid "path based finder"
msgstr "path based finder -- 基于路径的查找器"

#: ../../glossary.rst:850
msgid ""
"One of the default :term:`meta path finders <meta path finder>` which "
"searches an :term:`import path` for modules."
msgstr ""

#: ../../glossary.rst:852
msgid "path-like object"
msgstr "path-like object -- 类路径对象"

#: ../../glossary.rst:854
msgid ""
"An object representing a file system path. A path-like object is either a "
":class:`str` or :class:`bytes` object representing a path, or an object "
"implementing the :class:`os.PathLike` protocol. An object that supports the "
":class:`os.PathLike` protocol can be converted to a :class:`str` or "
":class:`bytes` file system path by calling the :func:`os.fspath` function; "
":func:`os.fsdecode` and :func:`os.fsencode` can be used to guarantee a "
":class:`str` or :class:`bytes` result instead, respectively. Introduced by "
":pep:`519`."
msgstr ""

#: ../../glossary.rst:862
msgid "PEP"
msgstr "PEP"

#: ../../glossary.rst:864
msgid ""
"Python Enhancement Proposal. A PEP is a design document providing "
"information to the Python community, or describing a new feature for Python "
"or its processes or environment. PEPs should provide a concise technical "
"specification and a rationale for proposed features."
msgstr ""

#: ../../glossary.rst:870
msgid ""
"PEPs are intended to be the primary mechanisms for proposing major new "
"features, for collecting community input on an issue, and for documenting "
"the design decisions that have gone into Python. The PEP author is "
"responsible for building consensus within the community and documenting "
"dissenting opinions."
msgstr ""

#: ../../glossary.rst:876
msgid "See :pep:`1`."
msgstr ""

#: ../../glossary.rst:877
msgid "portion"
msgstr "portion -- 部分"

#: ../../glossary.rst:879
msgid ""
"A set of files in a single directory (possibly stored in a zip file) that "
"contribute to a namespace package, as defined in :pep:`420`."
msgstr ""

#: ../../glossary.rst:881
msgid "positional argument"
msgstr "positional argument -- 位置参数"

#: ../../glossary.rst:884
msgid "provisional API"
msgstr "provisional API -- 暂定 API"

#: ../../glossary.rst:886
msgid ""
"A provisional API is one which has been deliberately excluded from the "
"standard library's backwards compatibility guarantees.  While major changes "
"to such interfaces are not expected, as long as they are marked provisional,"
" backwards incompatible changes (up to and including removal of the "
"interface) may occur if deemed necessary by core developers.  Such changes "
"will not be made gratuitously -- they will occur only if serious fundamental"
" flaws are uncovered that were missed prior to the inclusion of the API."
msgstr ""

#: ../../glossary.rst:895
msgid ""
"Even for provisional APIs, backwards incompatible changes are seen as a "
"\"solution of last resort\" - every attempt will still be made to find a "
"backwards compatible resolution to any identified problems."
msgstr ""

#: ../../glossary.rst:899
msgid ""
"This process allows the standard library to continue to evolve over time, "
"without locking in problematic design errors for extended periods of time.  "
"See :pep:`411` for more details."
msgstr ""

#: ../../glossary.rst:902
msgid "provisional package"
msgstr "provisional package -- 暂定包"

#: ../../glossary.rst:904
msgid "See :term:`provisional API`."
msgstr ""

#: ../../glossary.rst:905
msgid "Python 3000"
msgstr "Python 3000"

#: ../../glossary.rst:907
msgid ""
"Nickname for the Python 3.x release line (coined long ago when the release "
"of version 3 was something in the distant future.)  This is also abbreviated"
" \"Py3k\"."
msgstr ""

#: ../../glossary.rst:910
msgid "Pythonic"
msgstr "Pythonic"

#: ../../glossary.rst:912
msgid ""
"An idea or piece of code which closely follows the most common idioms of the"
" Python language, rather than implementing code using concepts common to "
"other languages.  For example, a common idiom in Python is to loop over all "
"elements of an iterable using a :keyword:`for` statement.  Many other "
"languages don't have this type of construct, so people unfamiliar with "
"Python sometimes use a numerical counter instead::"
msgstr ""

#: ../../glossary.rst:922
msgid "As opposed to the cleaner, Pythonic method::"
msgstr ""

#: ../../glossary.rst:926
msgid "qualified name"
msgstr "qualified name -- 限定名称"

#: ../../glossary.rst:928
msgid ""
"A dotted name showing the \"path\" from a module's global scope to a class, "
"function or method defined in that module, as defined in :pep:`3155`.  For "
"top-level functions and classes, the qualified name is the same as the "
"object's name::"
msgstr ""

#: ../../glossary.rst:945
msgid ""
"When used to refer to modules, the *fully qualified name* means the entire "
"dotted path to the module, including any parent packages, e.g. "
"``email.mime.text``::"
msgstr ""

#: ../../glossary.rst:952
msgid "reference count"
msgstr "reference count -- 引用计数"

#: ../../glossary.rst:954
msgid ""
"The number of references to an object.  When the reference count of an "
"object drops to zero, it is deallocated.  Reference counting is generally "
"not visible to Python code, but it is a key element of the :term:`CPython` "
"implementation.  The :mod:`sys` module defines a :func:`~sys.getrefcount` "
"function that programmers can call to return the reference count for a "
"particular object."
msgstr ""

#: ../../glossary.rst:960
msgid "regular package"
msgstr "regular package -- 正规包"

#: ../../glossary.rst:962
msgid ""
"A traditional :term:`package`, such as a directory containing an "
"``__init__.py`` file."
msgstr ""

#: ../../glossary.rst:965
msgid "See also :term:`namespace package`."
msgstr ""

#: ../../glossary.rst:966
msgid "__slots__"
msgstr "__slots__"

#: ../../glossary.rst:968
msgid ""
"A declaration inside a class that saves memory by pre-declaring space for "
"instance attributes and eliminating instance dictionaries.  Though popular, "
"the technique is somewhat tricky to get right and is best reserved for rare "
"cases where there are large numbers of instances in a memory-critical "
"application."
msgstr ""

#: ../../glossary.rst:973
msgid "sequence"
msgstr "sequence -- 序列"

#: ../../glossary.rst:975
msgid ""
"An :term:`iterable` which supports efficient element access using integer "
"indices via the :meth:`__getitem__` special method and defines a "
":meth:`__len__` method that returns the length of the sequence. Some built-"
"in sequence types are :class:`list`, :class:`str`, :class:`tuple`, and "
":class:`bytes`. Note that :class:`dict` also supports :meth:`__getitem__` "
"and :meth:`__len__`, but is considered a mapping rather than a sequence "
"because the lookups use arbitrary :term:`immutable` keys rather than "
"integers."
msgstr ""

#: ../../glossary.rst:984
msgid ""
"The :class:`collections.abc.Sequence` abstract base class defines a much "
"richer interface that goes beyond just :meth:`__getitem__` and "
":meth:`__len__`, adding :meth:`count`, :meth:`index`, :meth:`__contains__`, "
"and :meth:`__reversed__`. Types that implement this expanded interface can "
"be registered explicitly using :func:`~abc.register`."
msgstr ""

#: ../../glossary.rst:991
msgid "single dispatch"
msgstr "single dispatch -- 单分派"

#: ../../glossary.rst:993
msgid ""
"A form of :term:`generic function` dispatch where the implementation is "
"chosen based on the type of a single argument."
msgstr ""

#: ../../glossary.rst:995
msgid "slice"
msgstr "slice -- 切片"

#: ../../glossary.rst:997
msgid ""
"An object usually containing a portion of a :term:`sequence`.  A slice is "
"created using the subscript notation, ``[]`` with colons between numbers "
"when several are given, such as in ``variable_name[1:3:5]``.  The bracket "
"(subscript) notation uses :class:`slice` objects internally."
msgstr ""

#: ../../glossary.rst:1001
msgid "special method"
msgstr "special method -- 特殊方法"

#: ../../glossary.rst:1003
msgid ""
"A method that is called implicitly by Python to execute a certain operation "
"on a type, such as addition.  Such methods have names starting and ending "
"with double underscores.  Special methods are documented in "
":ref:`specialnames`."
msgstr ""

#: ../../glossary.rst:1007
msgid "statement"
msgstr "statement -- 语句"

#: ../../glossary.rst:1009
msgid ""
"A statement is part of a suite (a \"block\" of code).  A statement is either"
" an :term:`expression` or one of several constructs with a keyword, such as "
":keyword:`if`, :keyword:`while` or :keyword:`for`."
msgstr ""

#: ../../glossary.rst:1012
msgid "struct sequence"
msgstr "struct sequence -- 结构序列"

#: ../../glossary.rst:1014
msgid ""
"A tuple with named elements. Struct sequences expose an interface similar to"
" :term:`named tuple` in that elements can be accessed either by index or as "
"an attribute. However, they do not have any of the named tuple methods like "
":meth:`~collections.somenamedtuple._make` or "
":meth:`~collections.somenamedtuple._asdict`. Examples of struct sequences "
"include :data:`sys.float_info` and the return value of :func:`os.stat`."
msgstr ""

#: ../../glossary.rst:1020
msgid "text encoding"
msgstr "text encoding -- 文本编码"

#: ../../glossary.rst:1022
msgid "A codec which encodes Unicode strings to bytes."
msgstr ""

#: ../../glossary.rst:1023
msgid "text file"
msgstr "text file -- 文本文件"

#: ../../glossary.rst:1025
msgid ""
"A :term:`file object` able to read and write :class:`str` objects. Often, a "
"text file actually accesses a byte-oriented datastream and handles the "
":term:`text encoding` automatically. Examples of text files are files opened"
" in text mode (``'r'`` or ``'w'``), :data:`sys.stdin`, :data:`sys.stdout`, "
"and instances of :class:`io.StringIO`."
msgstr ""

#: ../../glossary.rst:1032
msgid ""
"See also :term:`binary file` for a file object able to read and write :term"
":`bytes-like objects <bytes-like object>`."
msgstr ""

#: ../../glossary.rst:1034
msgid "triple-quoted string"
msgstr "triple-quoted string -- 三引号字符串"

#: ../../glossary.rst:1036
msgid ""
"A string which is bound by three instances of either a quotation mark (\") "
"or an apostrophe (').  While they don't provide any functionality not "
"available with single-quoted strings, they are useful for a number of "
"reasons.  They allow you to include unescaped single and double quotes "
"within a string and they can span multiple lines without the use of the "
"continuation character, making them especially useful when writing "
"docstrings."
msgstr ""

#: ../../glossary.rst:1043
msgid "type"
msgstr "type -- 类型"

#: ../../glossary.rst:1045
msgid ""
"The type of a Python object determines what kind of object it is; every "
"object has a type.  An object's type is accessible as its "
":attr:`~instance.__class__` attribute or can be retrieved with "
"``type(obj)``."
msgstr ""

#: ../../glossary.rst:1049
msgid "type alias"
msgstr "type alias -- 类型别名"

#: ../../glossary.rst:1051
msgid "A synonym for a type, created by assigning the type to an identifier."
msgstr ""

#: ../../glossary.rst:1053
msgid ""
"Type aliases are useful for simplifying :term:`type hints <type hint>`. For "
"example::"
msgstr ""

#: ../../glossary.rst:1062
msgid "could be made more readable like this::"
msgstr ""

#: ../../glossary.rst:1071 ../../glossary.rst:1085
msgid "See :mod:`typing` and :pep:`484`, which describe this functionality."
msgstr ""

#: ../../glossary.rst:1072
msgid "type hint"
msgstr "type hint -- 类型提示"

#: ../../glossary.rst:1074
msgid ""
"An :term:`annotation` that specifies the expected type for a variable, a "
"class attribute, or a function parameter or return value."
msgstr ""

#: ../../glossary.rst:1077
msgid ""
"Type hints are optional and are not enforced by Python but they are useful "
"to static type analysis tools, and aid IDEs with code completion and "
"refactoring."
msgstr ""

#: ../../glossary.rst:1081
msgid ""
"Type hints of global variables, class attributes, and functions, but not "
"local variables, can be accessed using :func:`typing.get_type_hints`."
msgstr ""

#: ../../glossary.rst:1086
msgid "universal newlines"
msgstr "universal newlines -- 通用换行"

#: ../../glossary.rst:1088
msgid ""
"A manner of interpreting text streams in which all of the following are "
"recognized as ending a line: the Unix end-of-line convention ``'\\n'``, the "
"Windows convention ``'\\r\\n'``, and the old Macintosh convention ``'\\r'``."
"  See :pep:`278` and :pep:`3116`, as well as :func:`bytes.splitlines` for an"
" additional use."
msgstr ""

#: ../../glossary.rst:1093
msgid "variable annotation"
msgstr "variable annotation -- 变量标注"

#: ../../glossary.rst:1095
msgid "An :term:`annotation` of a variable or a class attribute."
msgstr ""

#: ../../glossary.rst:1097
msgid ""
"When annotating a variable or a class attribute, assignment is optional::"
msgstr ""

#: ../../glossary.rst:1102
msgid ""
"Variable annotations are usually used for :term:`type hints <type hint>`: "
"for example this variable is expected to take :class:`int` values::"
msgstr ""

#: ../../glossary.rst:1108
msgid "Variable annotation syntax is explained in section :ref:`annassign`."
msgstr ""

#: ../../glossary.rst:1110
msgid ""
"See :term:`function annotation`, :pep:`484` and :pep:`526`, which describe "
"this functionality."
msgstr ""

#: ../../glossary.rst:1112
msgid "virtual environment"
msgstr "virtual environment -- 虚拟环境"

#: ../../glossary.rst:1114
msgid ""
"A cooperatively isolated runtime environment that allows Python users and "
"applications to install and upgrade Python distribution packages without "
"interfering with the behaviour of other Python applications running on the "
"same system."
msgstr ""

#: ../../glossary.rst:1119
msgid "See also :mod:`venv`."
msgstr ""

#: ../../glossary.rst:1120
msgid "virtual machine"
msgstr "virtual machine -- 虚拟机"

#: ../../glossary.rst:1122
msgid ""
"A computer defined entirely in software.  Python's virtual machine executes "
"the :term:`bytecode` emitted by the bytecode compiler."
msgstr "一台完全通过软件定义的计算机。Python 虚拟机可执行字节码编译器所生成的 :term:`bytecode`。"

#: ../../glossary.rst:1124
msgid "Zen of Python"
msgstr "Zen of Python -- Python 之禅"

#: ../../glossary.rst:1126
msgid ""
"Listing of Python design principles and philosophies that are helpful in "
"understanding and using the language.  The listing can be found by typing "
"\"``import this``\" at the interactive prompt."
msgstr "列出 Python 设计的原则与哲学，有助于理解与使用这种语言。查看其具体内容可在交互模式提示符中输入 \"``import this``\"。"
