# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Nyuan Zhang, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 16:48+0000\n"
"PO-Revision-Date: 2025-07-18 20:04+0000\n"
"Last-Translator: Nyuan Zhang, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../distutils/examples.rst:5
msgid "Distutils Examples"
msgstr "Distutils 示例"

#: ../../distutils/_setuptools_disclaimer.rst:3
msgid ""
"This document is being retained solely until the ``setuptools`` "
"documentation at https://setuptools.readthedocs.io/en/latest/setuptools.html"
" independently covers all of the relevant information currently included "
"here."
msgstr ""
"这篇文档是历史遗留文档，在 https://setuptools.readthedocs.io/en/latest/setuptools.html 上的"
" ``setuptools`` 文档独立涵盖此处包含的所有相关信息之后，将不再单独作为正式文档保留。"

#: ../../distutils/examples.rst:9
msgid ""
"This chapter provides a number of basic examples to help get started with "
"distutils.  Additional information about using distutils can be found in the"
" Distutils Cookbook."
msgstr ""
"本章节提供几个基础示例，来帮助用户入门 distutils。关于使用 distutils 的额外信息可以参考 Distutils Cookbook。"

#: ../../distutils/examples.rst:16
msgid ""
"`Distutils Cookbook <https://wiki.python.org/moin/Distutils/Cookbook>`_"
msgstr ""
"`Distutils Cookbook <https://wiki.python.org/moin/Distutils/Cookbook>`_"

#: ../../distutils/examples.rst:17
msgid ""
"Collection of recipes showing how to achieve more control over distutils."
msgstr "一套展示如何更好地控制和使用 distutils 的方法。"

#: ../../distutils/examples.rst:23
msgid "Pure Python distribution (by module)"
msgstr "纯 Python 分发（通过 module）"

#: ../../distutils/examples.rst:25
msgid ""
"If you're just distributing a couple of modules, especially if they don't "
"live in a particular package, you can specify them individually using the "
"``py_modules`` option in the setup script."
msgstr "如果你要分发一组模块，特别是它们不在特定的包中，你可以在配置脚本中使用 ``py_modules`` 选项单独指定它们。"

#: ../../distutils/examples.rst:29
msgid ""
"In the simplest case, you'll have two files to worry about: a setup script "
"and the single module you're distributing, :file:`foo.py` in this example::"
msgstr "最简单的情况下，你只用关心两个文件：一个配置脚本，和单个你要分发的模块，这个示例中的 :file:`foo.py`: ："

#: ../../distutils/examples.rst:36
msgid ""
"(In all diagrams in this section, *<root>* will refer to the distribution "
"root directory.)  A minimal setup script to describe this situation would "
"be::"
msgstr "（在本章节的所有图中，*<root>* 表示分发根目录。）这种情况下的一个最小配置脚本是："

#: ../../distutils/examples.rst:45
msgid ""
"Note that the name of the distribution is specified independently with the "
"``name`` option, and there's no rule that says it has to be the same as the "
"name of the sole module in the distribution (although that's probably a good"
" convention to follow).  However, the distribution name is used to generate "
"filenames, so you should stick to letters, digits, underscores, and hyphens."
msgstr ""
"注意分发的包名用 ``name`` "
"选项单独指定，没有规定它必须和包中单独的模块同名（虽然这也是个可以遵循的好习惯）。然而，分发名用来生成文件名，所以你应该坚持用字母、数字、下划线和连词号。"

#: ../../distutils/examples.rst:51
msgid ""
"Since ``py_modules`` is a list, you can of course specify multiple modules, "
"eg. if you're distributing modules :mod:`foo` and :mod:`bar`, your setup "
"might look like this::"
msgstr ""
"因为 ``py_modules`` 是个列表，你当然可以指定多个模块，比如，如果你要分发模块 :mod:`foo` 和 "
":mod:`bar`，你的配置可能是这样："

#: ../../distutils/examples.rst:60
msgid "and the setup script might be  ::"
msgstr "并且配置脚本是："

#: ../../distutils/examples.rst:68
msgid ""
"You can put module source files into another directory, but if you have "
"enough modules to do that, it's probably easier to specify modules by "
"package rather than listing them individually."
msgstr "你可以把模块源文件放进另一个目录，但是如果你有足够的模块，也许用包指定模块更简单，而不是单独列出它们。"

#: ../../distutils/examples.rst:76
msgid "Pure Python distribution (by package)"
msgstr "纯 Python 分发（通过 包）"

#: ../../distutils/examples.rst:78
msgid ""
"If you have more than a couple of modules to distribute, especially if they "
"are in multiple packages, it's probably easier to specify whole packages "
"rather than individual modules.  This works even if your modules are not in "
"a package; you can just tell the Distutils to process modules from the root "
"package, and that works the same as any other package (except that you don't"
" have to have an :file:`__init__.py` file)."
msgstr ""
"如果你有超过一组模块要分发，特别是它们在不同的包中，也许指定整个包更简单，而不是指定单独的模块。这样即使你的模块不在一个包中也有效；你可以直接令 "
"Distutils 来从根包来处理模块，并且这样对任何其他包也有效（除非你不需要 :file:`__init__.py` 文件）。"

#: ../../distutils/examples.rst:85
msgid "The setup script from the last example could also be written as  ::"
msgstr "上一个示例的配置脚本也可以写成："

#: ../../distutils/examples.rst:93
msgid "(The empty string stands for the root package.)"
msgstr "（空字符串表示根包。）"

#: ../../distutils/examples.rst:95
msgid ""
"If those two files are moved into a subdirectory, but remain in the root "
"package, e.g.::"
msgstr "如果两个文件移动到子目录，但是依然在根包中，如："

#: ../../distutils/examples.rst:103
msgid ""
"then you would still specify the root package, but you have to tell the "
"Distutils where source files in the root package live::"
msgstr "那么你依然需要指定根包，但是你还需要告诉 Distutils 根包中的源文件在哪："

#: ../../distutils/examples.rst:113
msgid ""
"More typically, though, you will want to distribute multiple modules in the "
"same package (or in sub-packages).  For example, if the :mod:`foo`  and "
":mod:`bar` modules belong in package :mod:`foobar`, one way to layout your "
"source tree is ::"
msgstr ""
"更一般地，你要分发多个在同一个包（或者子包）中的模块。举个例子，假设 :mod:`foo` 和 :mod:`bar` 模块属于 "
":mod:`foobar` 包，排布源文件树的一种方式是："

#: ../../distutils/examples.rst:125
msgid ""
"This is in fact the default layout expected by the Distutils, and the one "
"that requires the least work to describe in your setup script::"
msgstr "这其实是 Distutils 默认的排布，也是你的配置脚本中需要的工作量最小的。"

#: ../../distutils/examples.rst:134
msgid ""
"If you want to put modules in directories not named for their package, then "
"you need to use the ``package_dir`` option again.  For example, if the "
":file:`src` directory holds modules in the :mod:`foobar` package::"
msgstr ""
"如果你要把模块放到没有按照它们的包名命名的目录里，那你需要再次使用 ``package_dir`` 选项。比如，如果 :file:`src` 目录包含包"
" :mod:`foobar` 中的模块："

#: ../../distutils/examples.rst:145
msgid "an appropriate setup script would be  ::"
msgstr "一个合适的配置脚本可以是："

#: ../../distutils/examples.rst:154
msgid ""
"Or, you might put modules from your main package right in the distribution "
"root::"
msgstr "或者，你可以把主包中的模块直接放到分发根目录："

#: ../../distutils/examples.rst:163
msgid "in which case your setup script would be  ::"
msgstr "这样你的配置文件是："

#: ../../distutils/examples.rst:172
msgid "(The empty string also stands for the current directory.)"
msgstr "（空字符串同样表示当前目录。）"

#: ../../distutils/examples.rst:174
msgid ""
"If you have sub-packages, they must be explicitly listed in ``packages``, "
"but any entries in ``package_dir`` automatically extend to sub-packages. (In"
" other words, the Distutils does *not* scan your source tree, trying to "
"figure out which directories correspond to Python packages by looking for "
":file:`__init__.py` files.)  Thus, if the default layout grows a sub-"
"package::"
msgstr ""
"如果你有子包，则它们必须显式列在 ``packages`` 中，但是 ``package_dir`` "
"中的任何条目会自动扩展到子包。（也就是说，Distutils *不会* 扫描你的源码树，而是尝试通过查找 :file:`__init__.py` "
"文件，来弄清哪些目录与 Python 包关联。）这样，如果默认排布产生一个子包："

#: ../../distutils/examples.rst:190
msgid "then the corresponding setup script would be  ::"
msgstr "则相应的配置脚本是："

#: ../../distutils/examples.rst:202
msgid "Single extension module"
msgstr "单个扩展模块"

#: ../../distutils/examples.rst:204
msgid ""
"Extension modules are specified using the ``ext_modules`` option. "
"``package_dir`` has no effect on where extension source files are found; it "
"only affects the source for pure Python modules.  The simplest  case, a "
"single extension module in a single C source file, is::"
msgstr ""
"扩展模块用 ``ext_modules`` 选项指定。``package_dir`` 对在哪寻找扩展源文件无效；它只对纯 Python "
"模块的源文件有效。最简单的，一个用单个C源文件写的单扩展模块是："

#: ../../distutils/examples.rst:213
msgid ""
"If the :mod:`foo` extension belongs in the root package, the setup script "
"for this could be  ::"
msgstr "如果 :mod:`foo` 扩展属于根包，则配置脚本可以是："

#: ../../distutils/examples.rst:223
msgid ""
"If the extension actually belongs in a package, say :mod:`foopkg`, then"
msgstr "如果扩展在包中，比如 :mod:`foopkg`，那么"

#: ../../distutils/examples.rst:225
msgid ""
"With exactly the same source tree layout, this extension can be put in the "
":mod:`foopkg` package simply by changing the name of the extension::"
msgstr "使用完全相同的源文件树排布，通过改变扩展的名字，这个扩展很容易放入 :mod:`foopkg` 包中："

#: ../../distutils/examples.rst:236
msgid "Checking a package"
msgstr "检查一个包"

#: ../../distutils/examples.rst:238
msgid ""
"The ``check`` command allows you to verify if your package meta-data meet "
"the minimum requirements to build a distribution."
msgstr "``check`` 命令允许你校验你的包的元数据是否满足生成分发的最低要求。"

#: ../../distutils/examples.rst:241
msgid ""
"To run it, just call it using your :file:`setup.py` script. If something is "
"missing, ``check`` will display a warning."
msgstr "直接使用你的 :file:`setup.py` 脚本来运行它。如果缺了一些东西，``check`` 会显示警告。"

#: ../../distutils/examples.rst:244
msgid "Let's take an example with a simple script::"
msgstr "我们来用单个脚本举例："

#: ../../distutils/examples.rst:250
msgid "Running the ``check`` command will display some warnings:"
msgstr "运行 ``check`` 命令会显示一些警告："

#: ../../distutils/examples.rst:261
msgid ""
"If you use the reStructuredText syntax in the ``long_description`` field and"
" `docutils`_  is installed you can check if the syntax is fine with the "
"``check`` command, using the ``restructuredtext`` option."
msgstr ""
"如果你在 ``long_description`` 域中使用 reStructuredText 语法，并且安装了 `docutils`_ ，你可以用 "
"``check`` 命令，和 ``restructuredtext`` 选项检查语法是否正确。"

#: ../../distutils/examples.rst:265
msgid "For example, if the :file:`setup.py` script is changed like this::"
msgstr "比如，如果 :file:`setup.py` 脚本改成："

#: ../../distutils/examples.rst:280
msgid ""
"Where the long description is broken, ``check`` will be able to detect it by"
" using the :mod:`docutils` parser:"
msgstr "长描述中有问题的地方，通过使用 :mod:`docutils` 解析器，``check`` 能进行删除："

#: ../../distutils/examples.rst:291
msgid "Reading the metadata"
msgstr "读取元数据"

#: ../../distutils/examples.rst:293
msgid ""
"The :func:`distutils.core.setup` function provides a command-line interface "
"that allows you to query the metadata fields of a project through the "
"``setup.py`` script of a given project:"
msgstr ""
":func:`distutils.core.setup` 函数提供一个通过项目的 ``setup.py``  脚本，来查询项目的元数据的域的命令行接口："

#: ../../distutils/examples.rst:302
msgid ""
"This call reads the ``name`` metadata by running the "
":func:`distutils.core.setup`  function. Although, when a source or binary "
"distribution is created with Distutils, the metadata fields are written in a"
" static file called :file:`PKG-INFO`. When a Distutils-based project is "
"installed in Python, the :file:`PKG-INFO` file is copied alongside the "
"modules and packages of the distribution under :file:`NAME-VERSION-"
"pyX.X.egg-info`, where ``NAME`` is the name of the project, ``VERSION`` its "
"version as defined in the Metadata, and ``pyX.X`` the major and minor "
"version of Python like ``2.7`` or ``3.2``."
msgstr ""
"这个调用通过运行 :func:`distutils.core.setup` 函数读取 ``name`` 元数据。然而，当源文件或者二进制分发用 "
"Distutils 创建时，元数据域写入一个名为 :file:`PKG-INFO` 的静态文件。当一个基于Distutils的项目安装在 Python "
"中时，:file:`PKG-INFO` 文件随着分发的模块和包一起复制到 :file:`NAME-VERSION-pyX.X.egg-info` "
"中，其中 ``NAME`` 是项目的名字，``VERSION`` 是元数据中定义的版本， ``pyX.X`` 则是 Python 的大版本和小版本，如 "
"``2.7`` 或者 ``3.2``。"

#: ../../distutils/examples.rst:312
msgid ""
"You can read back this static file, by using the "
":class:`distutils.dist.DistributionMetadata` class and its "
":func:`read_pkg_file` method::"
msgstr ""
"你可以读回静态文件，使用 :class:`distutils.dist.DistributionMetadata` 类和它的 "
":func:`read_pkg_file` 方法："

#: ../../distutils/examples.rst:326
msgid ""
"Notice that the class can also be instantiated with a metadata file path to "
"loads its values::"
msgstr "注意类也可以用元数据文件载入值来实例化："
