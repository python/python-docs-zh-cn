# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 18:10+0000\n"
"PO-Revision-Date: 2025-07-18 20:08+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../distutils/apiref.rst:5
msgid "API Reference"
msgstr "API参考引用"

#: ../../distutils/apiref.rst:11
msgid "`New and changed setup.py arguments in setuptools`_"
msgstr "`New and changed setup.py arguments in setuptools`_"

#: ../../distutils/apiref.rst:10
msgid ""
"The ``setuptools`` project adds new capabilities to the ``setup`` function "
"and other APIs, makes the API consistent across different Python versions, "
"and is hence recommended over using ``distutils`` directly."
msgstr ""
"``setuptools`` 项目为 ``setup`` 函数和其他 API 添加了新的功能，使得 API 在不同 Python "
"版本间保持一致，因此推荐以它来取代直接使用 ``distutils``。"

#: ../../distutils/_setuptools_disclaimer.rst:3
msgid ""
"This document is being retained solely until the ``setuptools`` "
"documentation at https://setuptools.readthedocs.io/en/latest/setuptools.html"
" independently covers all of the relevant information currently included "
"here."
msgstr ""
"这篇文档是历史遗留文档，在 https://setuptools.readthedocs.io/en/latest/setuptools.html 上的"
" ``setuptools`` 文档独立涵盖此处包含的所有相关信息之后，将不再单独作为正式文档保留。"

#: ../../distutils/apiref.rst:19
msgid ":mod:`distutils.core` --- Core Distutils functionality"
msgstr ":mod:`distutils.core` --- 分发包功能的核心"

#: ../../distutils/apiref.rst:25
msgid ""
"The :mod:`distutils.core` module is the only module that needs to be "
"installed to use the Distutils. It provides the :func:`setup` (which is "
"called from the setup script). Indirectly provides the  "
":class:`distutils.dist.Distribution` and :class:`distutils.cmd.Command` "
"class."
msgstr ""
"The :mod:`distutils.core` 是为了使用 Distutils 工具唯一要安装的模块。它提供函数 :func:`setup` "
"（该函数被 setup 脚本调用）。间接提供了类  :class:`distutils.dist.Distribution` 和 "
":class:`distutils.cmd.Command`."

#: ../../distutils/apiref.rst:33
msgid ""
"The basic do-everything function that does most everything you could ever "
"ask for from a Distutils method."
msgstr "基本的包办一切的函数，它完成了您可以从Distutils方法中请求的大部分事情。"

#: ../../distutils/apiref.rst:36
msgid ""
"The setup function takes a large number of arguments. These are laid out in "
"the following table."
msgstr "setup函数接受大量参数。这些都列在下表中。"

#: ../../distutils/apiref.rst:42 ../../distutils/apiref.rst:185
msgid "argument name"
msgstr "参数名称"

#: ../../distutils/apiref.rst:42 ../../distutils/apiref.rst:143
#: ../../distutils/apiref.rst:185
msgid "value"
msgstr "value"

#: ../../distutils/apiref.rst:42 ../../distutils/apiref.rst:185
msgid "type"
msgstr "type"

#: ../../distutils/apiref.rst:44 ../../distutils/apiref.rst:187
msgid "*name*"
msgstr "*name*"

#: ../../distutils/apiref.rst:44
msgid "The name of the package"
msgstr "包的名字"

#: ../../distutils/apiref.rst:44 ../../distutils/apiref.rst:46
#: ../../distutils/apiref.rst:50 ../../distutils/apiref.rst:53
#: ../../distutils/apiref.rst:56 ../../distutils/apiref.rst:58
#: ../../distutils/apiref.rst:61 ../../distutils/apiref.rst:68
#: ../../distutils/apiref.rst:72 ../../distutils/apiref.rst:75
#: ../../distutils/apiref.rst:96 ../../distutils/apiref.rst:106
#: ../../distutils/apiref.rst:187 ../../distutils/apiref.rst:278
msgid "a string"
msgstr "字符串"

#: ../../distutils/apiref.rst:46
msgid "*version*"
msgstr "*version*"

#: ../../distutils/apiref.rst:46
msgid "The version number of the package; see :mod:`distutils.version`"
msgstr "包的版本号；参见 :mod:`distutils.version`"

#: ../../distutils/apiref.rst:50
msgid "*description*"
msgstr "*description*"

#: ../../distutils/apiref.rst:50
msgid "A single line describing the package"
msgstr "单行的包的描述"

#: ../../distutils/apiref.rst:53
msgid "*long_description*"
msgstr "*long_description*"

#: ../../distutils/apiref.rst:53
msgid "Longer description of the package"
msgstr "更长的包描述"

#: ../../distutils/apiref.rst:56
msgid "*author*"
msgstr "*author*"

#: ../../distutils/apiref.rst:56
msgid "The name of the package author"
msgstr "包的作者"

#: ../../distutils/apiref.rst:58
msgid "*author_email*"
msgstr "*author_email*"

#: ../../distutils/apiref.rst:58
msgid "The email address of the package author"
msgstr "包的作者的电子邮件"

#: ../../distutils/apiref.rst:61
msgid "*maintainer*"
msgstr "*maintainer*"

#: ../../distutils/apiref.rst:61
msgid ""
"The name of the current maintainer, if different from the author. Note that "
"if the maintainer is provided, distutils will use it as the author in "
":file:`PKG-INFO`"
msgstr ""
"当前维护者的名字，如果与作者不同的话。 请注意，如果提供了维护者，distutils 将使用它作为 :file:`PKG-INFO` 中的作者。"

#: ../../distutils/apiref.rst:68
msgid "*maintainer_email*"
msgstr "*maintainer_email*"

#: ../../distutils/apiref.rst:68
msgid ""
"The email address of the current maintainer, if different from the author"
msgstr "当前维护者的电子邮件地址（如果与作者不同）"

#: ../../distutils/apiref.rst:72
msgid "*url*"
msgstr "*url*"

#: ../../distutils/apiref.rst:72
msgid "A URL for the package (homepage)"
msgstr "包的URL（主页）"

#: ../../distutils/apiref.rst:75
msgid "*download_url*"
msgstr "*download_url*"

#: ../../distutils/apiref.rst:75
msgid "A URL to download the package"
msgstr "包的下载地址"

#: ../../distutils/apiref.rst:77
msgid "*packages*"
msgstr "*packages*"

#: ../../distutils/apiref.rst:77
msgid "A list of Python packages that distutils will manipulate"
msgstr "distutils将操作的Python软件包的列表"

#: ../../distutils/apiref.rst:77 ../../distutils/apiref.rst:80
#: ../../distutils/apiref.rst:83 ../../distutils/apiref.rst:100
#: ../../distutils/apiref.rst:193 ../../distutils/apiref.rst:207
#: ../../distutils/apiref.rst:223 ../../distutils/apiref.rst:226
#: ../../distutils/apiref.rst:230 ../../distutils/apiref.rst:234
#: ../../distutils/apiref.rst:240 ../../distutils/apiref.rst:247
#: ../../distutils/apiref.rst:258 ../../distutils/apiref.rst:267
#: ../../distutils/apiref.rst:275
msgid "a list of strings"
msgstr "字符串列表"

#: ../../distutils/apiref.rst:80
msgid "*py_modules*"
msgstr "*py_modules*"

#: ../../distutils/apiref.rst:80
msgid "A list of Python modules that distutils will manipulate"
msgstr "distutils 会操作的 Python 模块列表"

#: ../../distutils/apiref.rst:83
msgid "*scripts*"
msgstr "*scripts*"

#: ../../distutils/apiref.rst:83
msgid "A list of standalone script files to be built and installed"
msgstr "要构建和安装的独立脚本文件的列表"

#: ../../distutils/apiref.rst:87
msgid "*ext_modules*"
msgstr "*ext_modules*"

#: ../../distutils/apiref.rst:87
msgid "A list of Python extensions to be built"
msgstr "要构建的 Python 扩展的列表"

#: ../../distutils/apiref.rst:87
msgid "a list of instances of :class:`distutils.core.Extension`"
msgstr "类 :class:`distutils.core.Extension` 的实例的列表"

#: ../../distutils/apiref.rst:90
msgid "*classifiers*"
msgstr "*classifiers*"

#: ../../distutils/apiref.rst:90
msgid "A list of categories for the package"
msgstr "包的类别列表"

#: ../../distutils/apiref.rst:90
msgid ""
"a list of strings; valid classifiers are listed on `PyPI "
"<https://pypi.org/classifiers>`_."
msgstr "一个字符串列表；可用的分类器已在 `PyPI <https://pypi.org/classifiers>`_ 上列出。"

#: ../../distutils/apiref.rst:93
msgid "*distclass*"
msgstr "*distclass*"

#: ../../distutils/apiref.rst:93
msgid "the :class:`Distribution` class to use"
msgstr "要使用的类 :class:`Distribution` 类"

#: ../../distutils/apiref.rst:93
msgid "a subclass of :class:`distutils.core.Distribution`"
msgstr ":class:`distutils.core.Distribution` 的子类"

#: ../../distutils/apiref.rst:96
msgid "*script_name*"
msgstr "*script_name*"

#: ../../distutils/apiref.rst:96
msgid "The name of the setup.py script - defaults to ``sys.argv[0]``"
msgstr "setup.py 脚本名称 —— 默认为 ``sys.argv[0]``"

#: ../../distutils/apiref.rst:100
msgid "*script_args*"
msgstr "*script_args*"

#: ../../distutils/apiref.rst:100
msgid "Arguments to supply to the setup script"
msgstr "提供给安装脚本的参数"

#: ../../distutils/apiref.rst:103
msgid "*options*"
msgstr "*options*"

#: ../../distutils/apiref.rst:103
msgid "default options for the setup script"
msgstr "安装脚本的默认选项"

#: ../../distutils/apiref.rst:103 ../../distutils/apiref.rst:113
#: ../../distutils/apiref.rst:119
msgid "a dictionary"
msgstr "字典"

#: ../../distutils/apiref.rst:106
msgid "*license*"
msgstr "*license*"

#: ../../distutils/apiref.rst:106
msgid "The license for the package"
msgstr "包的许可证"

#: ../../distutils/apiref.rst:108
msgid "*keywords*"
msgstr "*keywords*"

#: ../../distutils/apiref.rst:108
msgid "Descriptive meta-data, see :pep:`314`"
msgstr "描述性的元数据，参见 :pep:`314`"

#: ../../distutils/apiref.rst:108 ../../distutils/apiref.rst:111
msgid "a list of strings or a comma-separated string"
msgstr "字符串列表或逗号分隔的字符串"

#: ../../distutils/apiref.rst:111
msgid "*platforms*"
msgstr "*platforms*"

#: ../../distutils/apiref.rst:113
msgid "*cmdclass*"
msgstr "*cmdclass*"

#: ../../distutils/apiref.rst:113
msgid "A mapping of command names to :class:`Command` subclasses"
msgstr "一个从命令名称到 :class:`Command` 子类的映射"

#: ../../distutils/apiref.rst:116
msgid "*data_files*"
msgstr "*data_files*"

#: ../../distutils/apiref.rst:116
msgid "A list of data files to install"
msgstr "要安装的数据文件列表"

#: ../../distutils/apiref.rst:116
msgid "a list"
msgstr "列表"

#: ../../distutils/apiref.rst:119
msgid "*package_dir*"
msgstr "*package_dir*"

#: ../../distutils/apiref.rst:119
msgid "A mapping of package to directory names"
msgstr "包到目录名的映射"

#: ../../distutils/apiref.rst:127
msgid ""
"Run a setup script in a somewhat controlled environment, and return  the "
":class:`distutils.dist.Distribution` instance that drives things.   This is "
"useful if you need to find out the distribution meta-data  (passed as "
"keyword args from *script* to :func:`setup`), or  the contents of the config"
" files or command-line."
msgstr ""
"在某种程度上受控制的环境中运行一个安装脚本，并返回驱动程序的 :class:`distutils.dist.Distribution` 实例。 "
"如果你需要查找分发元数据 (作为关键字 args 从 *script* 传递到 :func:`setup`)，或者配置文件或命令行的内容，这将非常有用。"

#: ../../distutils/apiref.rst:133
msgid ""
"*script_name* is a file that will be read and run with :func:`exec`.  "
"``sys.argv[0]`` will be replaced with *script* for the duration of the call."
"  *script_args* is a list of strings; if supplied, ``sys.argv[1:]`` will be "
"replaced by *script_args* for the duration  of the call."
msgstr ""
"*script_name* 是一个将使用 :func:`exec` 读取和运行的文件。在调用期间，``sys.argv[0]`` 将被替换为 "
"*script*。 *script_args* 是一个字符串列表；如果提供了 ``sys.argv[1:]``，则在调用期间将被 "
"*script_args* 替换。"

#: ../../distutils/apiref.rst:138
msgid ""
"*stop_after* tells :func:`setup` when to stop processing; possible  values:"
msgstr "*stop_after* 告诉 :func:`setup` 何时停止处理；可能的值有："

#: ../../distutils/apiref.rst:143 ../../distutils/apiref.rst:562
#: ../../distutils/apiref.rst:1606
msgid "description"
msgstr "description"

#: ../../distutils/apiref.rst:145
msgid "*init*"
msgstr "*init*"

#: ../../distutils/apiref.rst:145
msgid ""
"Stop after the :class:`Distribution` instance has been created  and "
"populated with the keyword arguments to :func:`setup`"
msgstr ""
"Зупиніться після того, як екземпляр :class:`Distribution` буде створено та "
"заповнено ключовими аргументами для :func:`setup`"

#: ../../distutils/apiref.rst:149
msgid "*config*"
msgstr "*config*"

#: ../../distutils/apiref.rst:149
msgid ""
"Stop after config files have been parsed (and their data stored in the "
":class:`Distribution` instance)"
msgstr ""
"Зупинити після аналізу конфігураційних файлів (і їх даних, збережених в "
"екземплярі :class:`Distribution`)"

#: ../../distutils/apiref.rst:153
msgid "*commandline*"
msgstr "*commandline*"

#: ../../distutils/apiref.rst:153
msgid ""
"Stop after the command-line (``sys.argv[1:]`` or  *script_args*) have been "
"parsed (and the data stored in the :class:`Distribution` instance.)"
msgstr ""
"Зупиніться після аналізу командного рядка (``sys.argv[1:]`` або "
"*script_args*) (і даних, збережених в екземплярі :class:`Distribution`)."

#: ../../distutils/apiref.rst:158
msgid "*run*"
msgstr "*run*"

#: ../../distutils/apiref.rst:158
msgid ""
"Stop after all commands have been run (the same as  if :func:`setup` had "
"been called in the usual way). This is the default value."
msgstr ""
"Зупиніться після виконання всіх команд (так само, якби :func:`setup` було "
"викликано звичайним способом). Це значення за умовчанням."

#: ../../distutils/apiref.rst:164
msgid ""
"In addition, the :mod:`distutils.core` module exposed a number of  classes "
"that live elsewhere."
msgstr ""
"Крім того, модуль :mod:`distutils.core` відкрив низку класів, які живуть в "
"інших місцях."

#: ../../distutils/apiref.rst:167
msgid ""
":class:`~distutils.extension.Extension` from :mod:`distutils.extension`"
msgstr ""
"来自 :mod:`distutils.extension` 的 :class:`~distutils.extension.Extension`"

#: ../../distutils/apiref.rst:169
msgid ":class:`~distutils.cmd.Command` from :mod:`distutils.cmd`"
msgstr "来自 :mod:`distutils.cmd` 的 :class:`~distutils.cmd.Command`"

#: ../../distutils/apiref.rst:171
msgid ":class:`~distutils.dist.Distribution` from :mod:`distutils.dist`"
msgstr ":class:`~distutils.dist.Distribution` з :mod:`distutils.dist`"

#: ../../distutils/apiref.rst:173
msgid ""
"A short description of each of these follows, but see the relevant module "
"for the full reference."
msgstr ""
"Нижче наведено короткий опис кожного з них, але повну довідку див. у "
"відповідному модулі."

#: ../../distutils/apiref.rst:179
msgid ""
"The Extension class describes a single C or C++ extension module in a setup "
"script. It accepts the following keyword arguments in its constructor:"
msgstr ""
"Клас Extension описує один модуль розширення C або C++ у сценарії "
"налаштування. Він приймає такі ключові аргументи у своєму конструкторі:"

#: ../../distutils/apiref.rst:187
msgid ""
"the full name of the extension, including any packages --- ie. *not* a "
"filename or pathname, but Python dotted name"
msgstr ""
"повна назва розширення, включаючи будь-які пакети --- тобто. *не* ім’я файлу"
" чи шлях, а ім’я Python із крапками"

#: ../../distutils/apiref.rst:193
msgid "*sources*"
msgstr "*sources*"

#: ../../distutils/apiref.rst:193
msgid ""
"list of source filenames, relative to the distribution root (where the setup"
" script lives), in Unix form (slash-separated) for portability. Source files"
" may be C, C++, SWIG (.i), platform-specific resource files, or whatever "
"else is recognized by the :command:`build_ext` command as source for a "
"Python extension."
msgstr ""
"список імен вихідних файлів відносно кореня розповсюдження (де знаходиться "
"сценарій встановлення), у формі Unix (розділені скісною рискою) для "
"переносимості. Вихідними файлами можуть бути C, C++, SWIG (.i), файли "
"ресурсів для певної платформи або будь-які інші файли, які розпізнаються "
"командою :command:`build_ext` як джерело для розширення Python."

#: ../../distutils/apiref.rst:207
msgid "*include_dirs*"
msgstr "*include_dirs*"

#: ../../distutils/apiref.rst:207
msgid ""
"list of directories to search for C/C++ header files (in Unix form for "
"portability)"
msgstr ""
"список каталогів для пошуку файлів заголовків C/C++ (у формі Unix для "
"переносимості)"

#: ../../distutils/apiref.rst:211
msgid "*define_macros*"
msgstr "*define_macros*"

#: ../../distutils/apiref.rst:211
msgid ""
"list of macros to define; each macro is defined using a 2-tuple ``(name, "
"value)``, where *value* is either the string to define it to or ``None`` to "
"define it without a particular value (equivalent of ``#define FOO`` in "
"source or :option:`!-DFOO` on Unix C compiler command line)"
msgstr ""
"список макросів для визначення; кожен макрос визначається за допомогою "
"2-кортежу ``(ім’я, значення)``, де *value* є або рядком для його визначення,"
" або ``None``, щоб визначити його без певного значення (еквівалент ``# "
"визначте FOO`` у джерелі або :option:`!-DFOO` в командному рядку компілятора"
" Unix C)"

#: ../../distutils/apiref.rst:211
msgid "a list of tuples"
msgstr "元组列表"

#: ../../distutils/apiref.rst:223
msgid "*undef_macros*"
msgstr "*undef_macros*"

#: ../../distutils/apiref.rst:223
msgid "list of macros to undefine explicitly"
msgstr "要明确取消定义的宏列表"

#: ../../distutils/apiref.rst:226
msgid "*library_dirs*"
msgstr "*library_dirs*"

#: ../../distutils/apiref.rst:226
msgid "list of directories to search for C/C++ libraries at link time"
msgstr "список каталогів для пошуку бібліотек C/C++ під час підключення"

#: ../../distutils/apiref.rst:230
msgid "*libraries*"
msgstr "*libraries*"

#: ../../distutils/apiref.rst:230
msgid "list of library names (not filenames or paths) to link against"
msgstr "要链接的库名列表（不是文件名或路径）"

#: ../../distutils/apiref.rst:234
msgid "*runtime_library_dirs*"
msgstr "*runtime_library_dirs*"

#: ../../distutils/apiref.rst:234
msgid ""
"list of directories to search for C/C++ libraries at run time (for shared "
"extensions, this is when the extension is loaded)"
msgstr ""
"список каталогів для пошуку бібліотек C/C++ під час виконання (для спільних "
"розширень це час завантаження розширення)"

#: ../../distutils/apiref.rst:240
msgid "*extra_objects*"
msgstr "*extra_objects*"

#: ../../distutils/apiref.rst:240
msgid ""
"list of extra files to link with (eg. object files not implied by 'sources',"
" static library that must be explicitly specified, binary resource files, "
"etc.)"
msgstr ""
"список додаткових файлів, з якими можна зв’язатися (наприклад, об’єктні "
"файли, які не передбачаються \"джерелами\", статична бібліотека, яку "
"необхідно вказати явно, двійкові файли ресурсів тощо)"

#: ../../distutils/apiref.rst:247
msgid "*extra_compile_args*"
msgstr "*extra_compile_args*"

#: ../../distutils/apiref.rst:247
msgid ""
"any extra platform- and compiler-specific information to use when compiling "
"the source files in 'sources'. For platforms and compilers where a command "
"line makes sense, this is typically a list of command-line arguments, but "
"for other platforms it could be anything."
msgstr ""
"будь-яка додаткова інформація про платформу та компілятор для використання "
"під час компіляції вихідних файлів у \"джерелах\". Для платформ і "
"компіляторів, де командний рядок має сенс, це зазвичай список аргументів "
"командного рядка, але для інших платформ це може бути будь-що."

#: ../../distutils/apiref.rst:258
msgid "*extra_link_args*"
msgstr "*extra_link_args*"

#: ../../distutils/apiref.rst:258
msgid ""
"any extra platform- and compiler-specific information to use when linking "
"object files together to create the extension (or to create a new static "
"Python interpreter). Similar interpretation as for 'extra_compile_args'."
msgstr ""
"будь-яка додаткова інформація про платформу та компілятор, яку можна "
"використовувати під час зв’язування об’єктних файлів разом для створення "
"розширення (або для створення нового статичного інтерпретатора Python). "
"Інтерпретація подібна до 'extra_compile_args'."

#: ../../distutils/apiref.rst:267
msgid "*export_symbols*"
msgstr "*export_symbols*"

#: ../../distutils/apiref.rst:267
msgid ""
"list of symbols to be exported from a shared extension. Not used on all "
"platforms, and not generally necessary for Python extensions, which "
"typically export exactly one symbol: ``init`` + extension_name."
msgstr ""
"список символів, які потрібно експортувати зі спільного розширення. Не "
"використовується на всіх платформах і не є загалом необхідним для розширень "
"Python, які зазвичай експортують лише один символ: ``init`` + "
"extension_name."

#: ../../distutils/apiref.rst:275
msgid "*depends*"
msgstr "*depends*"

#: ../../distutils/apiref.rst:275
msgid "list of files that the extension depends on"
msgstr "扩展名依赖的文件列表"

#: ../../distutils/apiref.rst:278
msgid "*language*"
msgstr "*language*"

#: ../../distutils/apiref.rst:278
msgid ""
"extension language (i.e. ``'c'``, ``'c++'``, ``'objc'``). Will be detected "
"from the source extensions if not provided."
msgstr ""
"мова розширення (тобто ``'c'``, ``'c++'``, ``'objc'``). Буде виявлено з "
"вихідних розширень, якщо їх не надано."

#: ../../distutils/apiref.rst:284
msgid "*optional*"
msgstr "*optional*"

#: ../../distutils/apiref.rst:284
msgid ""
"specifies that a build failure in the extension should not abort the build "
"process, but simply skip the extension."
msgstr "指定扩展中的构建失败不应中止构建过程，而只是跳过扩展。"

#: ../../distutils/apiref.rst:284
msgid "a boolean"
msgstr "布尔"

#: ../../distutils/apiref.rst:292
msgid ""
"On Unix, C extensions are no longer linked to libpython except on Android "
"and Cygwin."
msgstr ""
"В Unix розширення C більше не пов’язані з libpython, за винятком Android і "
"Cygwin."

#: ../../distutils/apiref.rst:298
msgid ""
"A :class:`Distribution` describes how to build, install and package up a "
"Python software package."
msgstr ""
":class:`Distribution` описує, як створити, встановити та запакувати "
"програмний пакет Python."

#: ../../distutils/apiref.rst:301
msgid ""
"See the :func:`setup` function for a list of keyword arguments accepted  by "
"the Distribution constructor. :func:`setup` creates a Distribution instance."
msgstr ""
"Перегляньте функцію :func:`setup`, щоб переглянути список ключових "
"аргументів, які приймає конструктор розподілу. :func:`setup` створює "
"екземпляр Distribution."

#: ../../distutils/apiref.rst:304
msgid ""
":class:`~distutils.core.Distribution` now warns if ``classifiers``, "
"``keywords`` and ``platforms`` fields are not specified as a list or a "
"string."
msgstr ""
":class:`~distutils.core.Distribution` тепер попереджає, якщо поля "
"``класифікатори``, ``ключові слова`` та ``платформи`` не вказані як список "
"або рядок."

#: ../../distutils/apiref.rst:311
msgid ""
"A :class:`Command` class (or rather, an instance of one of its subclasses) "
"implement a single distutils command."
msgstr ""
"Клас :class:`Command` (точніше, екземпляр одного з його підкласів) реалізує "
"одну команду distutils."

#: ../../distutils/apiref.rst:316
msgid ":mod:`distutils.ccompiler` --- CCompiler base class"
msgstr ":mod:`distutils.ccompiler` --- CCompiler基类"

#: ../../distutils/apiref.rst:322
msgid ""
"This module provides the abstract base class for the :class:`CCompiler` "
"classes.  A :class:`CCompiler` instance can be used for all the compile  and"
" link steps needed to build a single project. Methods are provided to  set "
"options for the compiler --- macro definitions, include directories,  link "
"path, libraries and the like."
msgstr ""
"Цей модуль надає абстрактний базовий клас для класів :class:`CCompiler`. "
"Екземпляр :class:`CCompiler` можна використовувати для всіх кроків "
"компіляції та зв’язування, необхідних для створення одного проекту. "
"Надаються методи для встановлення опцій для компілятора --- визначень "
"макросів, включення каталогів, шляхів посилань, бібліотек тощо."

#: ../../distutils/apiref.rst:328
msgid "This module provides the following functions."
msgstr "Цей модуль забезпечує такі функції."

#: ../../distutils/apiref.rst:333
msgid ""
"Generate linker options for searching library directories and linking with "
"specific libraries.  *libraries* and *library_dirs* are, respectively, lists"
" of library names (not filenames!) and search directories.  Returns a list "
"of command-line options suitable for use with some compiler (depending on "
"the two format strings passed in)."
msgstr ""
"Створення параметрів компонувальника для пошуку каталогів бібліотек і "
"зв’язування з певними бібліотеками. *libraries* і *library_dirs* — це, "
"відповідно, списки імен бібліотек (а не імен файлів!) і каталогів пошуку. "
"Повертає список параметрів командного рядка, придатних для використання з "
"деяким компілятором (залежно від двох переданих рядків формату)."

#: ../../distutils/apiref.rst:342
msgid ""
"Generate C pre-processor options (:option:`!-D`, :option:`!-U`, "
":option:`!-I`) as used by at least two types of compilers: the typical Unix "
"compiler and Visual C++. *macros* is the usual thing, a list of 1- or "
"2-tuples, where ``(name,)`` means undefine (:option:`!-U`) macro *name*, and"
" ``(name, value)`` means define (:option:`!-D`) macro *name* to *value*.  "
"*include_dirs* is just a list of directory names to be added to the header "
"file search path (:option:`!-I`). Returns a list of command-line options "
"suitable for either Unix compilers or Visual C++."
msgstr ""
"Згенеруйте параметри попереднього процесора C (:option:`!-D`, :option:`!-U`,"
" :option:`!-I`), які використовуються принаймні двома типами компіляторів: "
"типовим компілятором Unix і Visual C++. *макроси* — це звичайна річ, список "
"1- або 2-кортежів, де ``(name,)`` означає undefine (:option:`!-U`) макрос "
"*name*, а ``(name, значення)`` означає визначення (:option:`!-D`) *назви* "
"макросу на *значення*. *include_dirs* — це лише список імен каталогів, які "
"потрібно додати до шляху пошуку файлу заголовка (:option:`!-I`). Повертає "
"список параметрів командного рядка, придатних для компіляторів Unix або "
"Visual C++."

#: ../../distutils/apiref.rst:354
msgid "Determine the default compiler to use for the given platform."
msgstr "Визначте компілятор за замовчуванням для даної платформи."

#: ../../distutils/apiref.rst:356
msgid ""
"*osname* should be one of the standard Python OS names (i.e. the ones "
"returned by ``os.name``) and *platform* the common value returned by "
"``sys.platform`` for the platform in question."
msgstr ""
"*osname* має бути одним із стандартних імен ОС Python (тобто тих, які "
"повертає ``os.name``), а *platform* — загальне значення, яке повертає "
"``sys.platform`` для відповідної платформи."

#: ../../distutils/apiref.rst:360
msgid ""
"The default values are ``os.name`` and ``sys.platform`` in case the "
"parameters are not given."
msgstr ""
"Значеннями за замовчуванням є ``os.name`` і ``sys.platform``, якщо параметри"
" не вказано."

#: ../../distutils/apiref.rst:366
msgid ""
"Factory function to generate an instance of some CCompiler subclass for the "
"supplied platform/compiler combination. *plat* defaults to ``os.name`` (eg. "
"``'posix'``, ``'nt'``), and *compiler*  defaults to the default compiler for"
" that platform. Currently only ``'posix'`` and ``'nt'`` are supported, and "
"the default compilers are \"traditional Unix interface\" "
"(:class:`UnixCCompiler` class) and Visual C++ (:class:`MSVCCompiler` class)."
"  Note that it's perfectly possible to ask for a Unix compiler object under "
"Windows, and a Microsoft compiler object under Unix---if you supply a value "
"for *compiler*, *plat* is ignored."
msgstr ""
"Фабрична функція для створення екземпляра деякого підкласу CCompiler для "
"наданої комбінації платформа/компілятор. *plat* за замовчуванням має "
"``os.name`` (наприклад, ``'posix'``, ``'nt'``), а *compiler* за "
"замовчуванням використовує компілятор за замовчуванням для цієї платформи. "
"Наразі підтримуються лише ``'posix'`` і ``'nt'``, а компіляторами за "
"замовчуванням є \"традиційний інтерфейс Unix\" (:class:`UnixCCompiler` клас)"
" і Visual C++ (:class:`MSVCCompiler` клас ). Зауважте, що цілком можливо "
"запросити об’єкт компілятора Unix під Windows і об’єкт компілятора Microsoft"
" під Unix --- якщо ви вказуєте значення для *compiler*, *plat* ігнорується."

#: ../../distutils/apiref.rst:382
msgid ""
"Print list of available compilers (used by the :option:`!--help-compiler` "
"options to :command:`build`, :command:`build_ext`, :command:`build_clib`)."
msgstr ""
"Надрукувати список доступних компіляторів (використовується параметрами "
":option:`!--help-compiler` для :command:`build`, :command:`build_ext`, "
":command:`build_clib`)."

#: ../../distutils/apiref.rst:388
msgid ""
"The abstract base class :class:`CCompiler` defines the interface that  must "
"be implemented by real compiler classes.  The class also has  some utility "
"methods used by several compiler classes."
msgstr ""
"Абстрактний базовий клас :class:`CCompiler` визначає інтерфейс, який має "
"бути реалізований реальними класами компілятора. Клас також має деякі "
"корисні методи, які використовуються кількома класами компілятора."

#: ../../distutils/apiref.rst:392
msgid ""
"The basic idea behind a compiler abstraction class is that each instance can"
" be used for all the compile/link steps in building a single project.  Thus,"
" attributes common to all of those compile and link steps --- include "
"directories, macros to define, libraries to link against, etc. --- are "
"attributes of the compiler instance.  To allow for variability in how "
"individual files are treated, most of those attributes may be varied on a "
"per-compilation or per-link basis."
msgstr ""
"Основна ідея класу абстракції компілятора полягає в тому, що кожен екземпляр"
" можна використовувати для всіх етапів компіляції/зв’язування в створенні "
"одного проекту. Таким чином, атрибути, загальні для всіх цих етапів "
"компіляції та зв’язування --- включають каталоги, макроси для визначення, "
"бібліотеки для зв’язування тощо --- є атрибутами примірника компілятора. Щоб"
" уможливити варіативність у тому, як обробляються окремі файли, більшість із"
" цих атрибутів можна змінювати для кожної компіляції чи кожного посилання."

#: ../../distutils/apiref.rst:400
msgid ""
"The constructor for each subclass creates an instance of the Compiler "
"object. Flags are *verbose* (show verbose output), *dry_run* (don't actually"
" execute the steps) and *force* (rebuild everything, regardless of "
"dependencies). All of these flags default to ``0`` (off). Note that you "
"probably don't want to instantiate :class:`CCompiler` or one of its "
"subclasses directly - use the :func:`distutils.CCompiler.new_compiler` "
"factory function instead."
msgstr ""
"Конструктор для кожного підкласу створює екземпляр об’єкта Compiler. "
"Прапори: *verbose* (показати докладний вихід), *dry_run* (фактично не "
"виконувати кроки) і *force* (перебудувати все, незалежно від залежностей). "
"Усі ці прапорці за замовчуванням мають значення ``0`` (вимкнено). Зауважте, "
"що ви, мабуть, не бажаєте створювати екземпляр :class:`CCompiler` або один "
"із його підкласів напряму - використовуйте натомість фабричну функцію "
":func:`distutils.CCompiler.new_compiler`."

#: ../../distutils/apiref.rst:407
msgid ""
"The following methods allow you to manually alter compiler options for  the "
"instance of the Compiler class."
msgstr ""
"Наступні методи дозволяють вручну змінювати параметри компілятора для "
"екземпляра класу Compiler."

#: ../../distutils/apiref.rst:413
msgid ""
"Add *dir* to the list of directories that will be searched for header files."
" The compiler is instructed to search directories in the order in which they"
" are supplied by successive calls to :meth:`add_include_dir`."
msgstr ""
"Додайте *dir* до списку каталогів, у яких здійснюватиметься пошук файлів "
"заголовків. Компілятор отримує вказівку шукати каталоги в тому порядку, в "
"якому вони надаються послідовними викликами :meth:`add_include_dir`."

#: ../../distutils/apiref.rst:420
msgid ""
"Set the list of directories that will be searched to *dirs* (a list of "
"strings). Overrides any preceding calls to :meth:`add_include_dir`; "
"subsequent calls to :meth:`add_include_dir` add to the list passed to "
":meth:`set_include_dirs`. This does not affect any list of standard include "
"directories that the compiler may search by default."
msgstr ""
"Встановіть список каталогів, у яких здійснюватиметься пошук, як *dirs* "
"(список рядків). Перевизначає будь-які попередні виклики "
":meth:`add_include_dir`; наступні виклики :meth:`add_include_dir` додають до"
" списку, переданого :meth:`set_include_dirs`. Це не впливає на список "
"каталогів стандартного включення, які компілятор може шукати за "
"замовчуванням."

#: ../../distutils/apiref.rst:429
msgid ""
"Add *libname* to the list of libraries that will be included in all links "
"driven by this compiler object.  Note that *libname* should \\*not\\* be the"
" name of a file containing a library, but the name of the library itself: "
"the actual filename will be inferred by the linker, the compiler, or the "
"compiler class (depending on the platform)."
msgstr ""
"Додайте *libname* до списку бібліотек, які будуть включені в усі посилання, "
"керовані цим об’єктом компілятора. Зауважте, що *libname* має \\*не\\* бути "
"назвою файлу, що містить бібліотеку, а назвою самої бібліотеки: фактичне "
"ім’я файлу буде визначено компонувальником, компілятором або класом "
"компілятора (залежно від платформа)."

#: ../../distutils/apiref.rst:435
msgid ""
"The linker will be instructed to link against libraries in the order they "
"were supplied to :meth:`add_library` and/or :meth:`set_libraries`.  It is "
"perfectly valid to duplicate library names; the linker will be instructed to"
" link against libraries as many times as they are mentioned."
msgstr ""
"Пов’язувач отримає вказівку зв’язувати бібліотеки в тому порядку, в якому "
"вони були надані в :meth:`add_library` та/або :meth:`set_libraries`. Цілком "
"допустимо дублювати імена бібліотек; компонувальник отримає вказівку "
"створити зв’язок із бібліотеками стільки разів, скільки вони згадуються."

#: ../../distutils/apiref.rst:443
msgid ""
"Set the list of libraries to be included in all links driven by this "
"compiler object to *libnames* (a list of strings).  This does not affect any"
" standard system libraries that the linker may include by default."
msgstr ""
"Встановіть список бібліотек, які будуть включені в усі посилання, керовані "
"цим об’єктом компілятора, як *libnames* (список рядків). Це не впливає на "
"стандартні системні бібліотеки, які компонувальник може включати за "
"замовчуванням."

#: ../../distutils/apiref.rst:450
msgid ""
"Add *dir* to the list of directories that will be searched for libraries "
"specified to :meth:`add_library` and :meth:`set_libraries`.  The linker will"
" be instructed to search for libraries in the order they are supplied to "
":meth:`add_library_dir` and/or :meth:`set_library_dirs`."
msgstr ""
"Додайте *dir* до списку каталогів, у яких здійснюватиметься пошук бібліотек,"
" указаних у :meth:`add_library` і :meth:`set_libraries`. Пов’язувач отримає "
"вказівку шукати бібліотеки в тому порядку, в якому вони надані в "
":meth:`add_library_dir` та/або :meth:`set_library_dirs`."

#: ../../distutils/apiref.rst:458
msgid ""
"Set the list of library search directories to *dirs* (a list of strings).  "
"This does not affect any standard library search path that the linker may "
"search by default."
msgstr ""
"Встановіть список каталогів пошуку бібліотек на *dirs* (список рядків). Це "
"не впливає на будь-який стандартний шлях пошуку бібліотеки, який "
"компонувальник може шукати за замовчуванням."

#: ../../distutils/apiref.rst:465
msgid ""
"Add *dir* to the list of directories that will be searched for shared "
"libraries at runtime."
msgstr ""
"Додайте *dir* до списку каталогів, у яких здійснюватиметься пошук спільних "
"бібліотек під час виконання."

#: ../../distutils/apiref.rst:471
msgid ""
"Set the list of directories to search for shared libraries at runtime to "
"*dirs* (a list of strings).  This does not affect any standard search path "
"that the runtime linker may search by default."
msgstr ""
"Встановіть список каталогів для пошуку спільних бібліотек під час виконання "
"на *dirs* (список рядків). Це не впливає на будь-який стандартний шлях "
"пошуку, який компонувальник під час виконання може шукати за замовчуванням."

#: ../../distutils/apiref.rst:478
msgid ""
"Define a preprocessor macro for all compilations driven by this compiler "
"object. The optional parameter *value* should be a string; if it is not "
"supplied, then the macro will be defined without an explicit value and the "
"exact outcome depends on the compiler used."
msgstr ""
"Визначте макрос препроцесора для всіх компіляцій, керованих цим об’єктом "
"компілятора. Додатковий параметр *value* має бути рядком; якщо він не "
"наданий, то макрос буде визначено без явного значення, і точний результат "
"залежить від використовуваного компілятора."

#: ../../distutils/apiref.rst:488
msgid ""
"Undefine a preprocessor macro for all compilations driven by this compiler "
"object.  If the same macro is defined by :meth:`define_macro` and undefined "
"by :meth:`undefine_macro` the last call takes precedence (including multiple"
" redefinitions or undefinitions).  If the macro is redefined/undefined on a "
"per-compilation basis (ie. in the call to :meth:`compile`), then that takes "
"precedence."
msgstr ""
"Скасуйте визначення макросу препроцесора для всіх компіляцій, керованих цим "
"об’єктом компілятора. Якщо той самий макрос визначено :meth:`define_macro` і"
" не визначено :meth:`undefine_macro`, останній виклик має перевагу (включно "
"з кількома перевизначеннями або невизначеннями). Якщо макрос "
"перевизначено/не визначено на основі кожної компіляції (тобто під час "
"виклику :meth:`compile`), то він має перевагу."

#: ../../distutils/apiref.rst:498
msgid ""
"Add *object* to the list of object files (or analogues, such as explicitly "
"named library files or the output of \"resource compilers\") to be included "
"in every link driven by this compiler object."
msgstr ""
"Додайте *об’єкт* до списку об’єктних файлів (або аналогів, таких як "
"бібліотечні файли з явною назвою або вихідні дані \"компіляторів "
"ресурсів\"), які будуть включені в кожне посилання, кероване цим об’єктом "
"компілятора."

#: ../../distutils/apiref.rst:505
msgid ""
"Set the list of object files (or analogues) to be included in every link to "
"*objects*.  This does not affect any standard object files that the linker "
"may include by default (such as system libraries)."
msgstr ""
"Встановіть список об’єктних файлів (або аналогів), які будуть включені до "
"кожного посилання на *об’єкти*. Це не впливає на будь-які стандартні "
"об’єктні файли, які компонувальник може включати за замовчуванням "
"(наприклад, системні бібліотеки)."

#: ../../distutils/apiref.rst:509
msgid ""
"The following methods implement methods for autodetection of compiler  "
"options, providing some functionality similar to GNU :program:`autoconf`."
msgstr ""
"Наступні методи реалізують методи для автоматичного визначення параметрів "
"компілятора, надаючи деякі функції, подібні до GNU :program:`autoconf`."

#: ../../distutils/apiref.rst:515
msgid ""
"Detect the language of a given file, or list of files. Uses the  instance "
"attributes :attr:`language_map` (a dictionary), and  :attr:`language_order` "
"(a list) to do the job."
msgstr ""
"Визначити мову певного файлу або списку файлів. Використовує атрибути "
"екземпляра :attr:`language_map` (словник) і :attr:`language_order` (список) "
"для виконання завдання."

#: ../../distutils/apiref.rst:522
msgid ""
"Search the specified list of directories for a static or shared library file"
" *lib* and return the full path to that file.  If *debug* is true, look for "
"a debugging version (if that makes sense on the current platform).  Return "
"``None`` if *lib* wasn't found in any of the specified directories."
msgstr ""
"Знайдіть у вказаному списку каталогів файл статичної або спільної бібліотеки"
" *lib* і поверніть повний шлях до цього файлу. Якщо *debug* має значення "
"true, знайдіть версію для налагодження (якщо це має сенс на поточній "
"платформі). Повертає ``None``, якщо *lib* не знайдено в жодному з указаних "
"каталогів."

#: ../../distutils/apiref.rst:530
msgid ""
"Return a boolean indicating whether *funcname* is supported on the current "
"platform.  The optional arguments can be used to augment the compilation "
"environment by providing additional include files and paths and libraries "
"and paths."
msgstr ""
"Повертає логічне значення, яке вказує, чи підтримується *funcname* на "
"поточній платформі. Необов’язкові аргументи можна використовувати для "
"розширення середовища компіляції шляхом надання додаткових файлів і шляхів, "
"а також бібліотек і шляхів."

#: ../../distutils/apiref.rst:538
msgid ""
"Return the compiler option to add *dir* to the list of directories searched "
"for libraries."
msgstr ""
"Повернути опцію компілятора, щоб додати *dir* до списку каталогів, у яких "
"шукаються бібліотеки."

#: ../../distutils/apiref.rst:544
msgid ""
"Return the compiler option to add *lib* to the list of libraries linked into"
" the shared library or executable."
msgstr ""
"Поверніть опцію компілятора, щоб додати *lib* до списку бібліотек, "
"пов’язаних із спільною бібліотекою або виконуваним файлом."

#: ../../distutils/apiref.rst:550
msgid ""
"Return the compiler option to add *dir* to the list of directories searched "
"for runtime libraries."
msgstr ""
"Поверніть опцію компілятора, щоб додати *dir* до списку каталогів, у яких "
"шукаються бібліотеки середовища виконання."

#: ../../distutils/apiref.rst:556
msgid ""
"Define the executables (and options for them) that will be run to perform "
"the various stages of compilation.  The exact set of executables that may be"
" specified here depends on the compiler class (via the 'executables' class "
"attribute), but most will have:"
msgstr ""
"Визначте виконувані файли (і параметри для них), які будуть запущені для "
"виконання різних етапів компіляції. Точний набір виконуваних файлів, який "
"можна вказати тут, залежить від класу компілятора (через атрибут класу "
"'executables'), але більшість матиме:"

#: ../../distutils/apiref.rst:562
msgid "attribute"
msgstr "attribute -- 属性"

#: ../../distutils/apiref.rst:564
msgid "*compiler*"
msgstr "*compiler*"

#: ../../distutils/apiref.rst:564
msgid "the C/C++ compiler"
msgstr "C/C++ 编译器"

#: ../../distutils/apiref.rst:566
msgid "*linker_so*"
msgstr "*linker_so*"

#: ../../distutils/apiref.rst:566
msgid "linker used to create shared objects and libraries"
msgstr "用于创建共享对象和库的链接器"

#: ../../distutils/apiref.rst:569
msgid "*linker_exe*"
msgstr "*linker_exe*"

#: ../../distutils/apiref.rst:569
msgid "linker used to create binary executables"
msgstr "用于创建二进制可执行文件的链接器"

#: ../../distutils/apiref.rst:571
msgid "*archiver*"
msgstr "*archiver*"

#: ../../distutils/apiref.rst:571
msgid "static library creator"
msgstr "静态库创建者"

#: ../../distutils/apiref.rst:574
msgid ""
"On platforms with a command-line (Unix, DOS/Windows), each of these is a "
"string that will be split into executable name and (optional) list of "
"arguments. (Splitting the string is done similarly to how Unix shells "
"operate: words are delimited by spaces, but quotes and backslashes can "
"override this.  See :func:`distutils.util.split_quoted`.)"
msgstr ""
"На платформах із командним рядком (Unix, DOS/Windows) кожен із них є рядком,"
" який буде розділено на ім’я виконуваного файлу та (необов’язковий) список "
"аргументів. (Поділ рядка виконується подібно до того, як працюють оболонки "
"Unix: слова розділені пробілами, але лапки та зворотні косі риски можуть "
"замінити це. Див. :func:`distutils.util.split_quoted`.)"

#: ../../distutils/apiref.rst:580
msgid "The following methods invoke stages in the build process."
msgstr "Наступні методи викликають етапи процесу побудови."

#: ../../distutils/apiref.rst:585
msgid ""
"Compile one or more source files. Generates object files (e.g.  transforms a"
" :file:`.c` file to a :file:`.o` file.)"
msgstr ""
"Скомпілюйте один або кілька вихідних файлів. Створює об’єктні файли "
"(наприклад, перетворює файл :file:`.c` на файл :file:`.o`.)"

#: ../../distutils/apiref.rst:588
msgid ""
"*sources* must be a list of filenames, most likely C/C++ files, but in "
"reality anything that can be handled by a particular compiler and compiler "
"class (eg. :class:`MSVCCompiler` can handle resource files in *sources*).  "
"Return a list of object filenames, one per source filename in *sources*.  "
"Depending on the implementation, not all source files will necessarily be "
"compiled, but all corresponding object filenames will be returned."
msgstr ""
"*джерела* мають бути списком імен файлів, швидше за все файлів C/C++, але "
"насправді все, що може оброблятися певним компілятором і класом компілятора "
"(наприклад, :class:`MSVCCompiler` може обробляти файли ресурсів у "
"*джерелах*) . Повертає список імен файлів об’єктів, по одному на ім’я "
"вихідного файлу в *джерелах*. Залежно від реалізації, не всі вихідні файли "
"обов’язково будуть скомпільовані, але будуть повернуті всі відповідні імена "
"файлів об’єктів."

#: ../../distutils/apiref.rst:595
msgid ""
"If *output_dir* is given, object files will be put under it, while retaining"
" their original path component.  That is, :file:`foo/bar.c` normally "
"compiles to :file:`foo/bar.o` (for a Unix implementation); if *output_dir* "
"is *build*, then it would compile to :file:`build/foo/bar.o`."
msgstr ""
"Якщо задано *output_dir*, об’єктні файли буде розміщено під ним, зберігаючи "
"при цьому їхній початковий компонент шляху. Тобто :file:`foo/bar.c` зазвичай"
" компілюється до :file:`foo/bar.o` (для реалізації Unix); якщо *output_dir* "
"є *build*, тоді він скомпілюється до :file:`build/foo/bar.o`."

#: ../../distutils/apiref.rst:600
msgid ""
"*macros*, if given, must be a list of macro definitions.  A macro definition"
" is either a ``(name, value)`` 2-tuple or a ``(name,)`` 1-tuple. The former "
"defines a macro; if the value is ``None``, the macro is defined without an "
"explicit value.  The 1-tuple case undefines a macro.  Later "
"definitions/redefinitions/undefinitions take precedence."
msgstr ""
"*макроси*, якщо вказано, мають бути списком визначень макросів. Визначення "
"макросу – це 2-кортеж ``(ім’я, значення)\" або 1-кортеж ``(ім’я,)``. Перший "
"визначає макрос; якщо значенням є ``None``, макрос визначено без явного "
"значення. Випадок 1-кортежу не визначає макрос. Пізніші "
"визначення/перевизначення/невизначення мають пріоритет."

#: ../../distutils/apiref.rst:606
msgid ""
"*include_dirs*, if given, must be a list of strings, the directories to add "
"to the default include file search path for this compilation only."
msgstr ""
"*include_dirs*, якщо задано, має бути списком рядків, каталогів, які "
"потрібно додати до шляху пошуку файлів за замовчуванням лише для цієї "
"компіляції."

#: ../../distutils/apiref.rst:609
msgid ""
"*debug* is a boolean; if true, the compiler will be instructed to output "
"debug symbols in (or alongside) the object file(s)."
msgstr ""
"*debug* є логічним; якщо істина, компілятор отримає вказівку вивести символи"
" налагодження в (або поруч) з об’єктним файлом(ами)."

#: ../../distutils/apiref.rst:612
msgid ""
"*extra_preargs* and *extra_postargs* are implementation-dependent. On "
"platforms that have the notion of a command-line (e.g. Unix, DOS/Windows), "
"they are most likely lists of strings: extra command-line arguments to "
"prepend/append to the compiler command line.  On other platforms, consult "
"the implementation class documentation.  In any event, they are intended as "
"an escape hatch for those occasions when the abstract compiler framework "
"doesn't cut the mustard."
msgstr ""
"*extra_preargs* і *extra_postargs* залежать від реалізації. На платформах, "
"які мають поняття командного рядка (наприклад, Unix, DOS/Windows), це, "
"швидше за все, списки рядків: додаткові аргументи командного рядка для "
"додавання перед/до командного рядка компілятора. На інших платформах "
"зверніться до документації класу реалізації. У будь-якому випадку, вони "
"призначені як аварійний люк у тих випадках, коли структура абстрактного "
"компілятора не вирішує проблеми."

#: ../../distutils/apiref.rst:619
msgid ""
"*depends*, if given, is a list of filenames that all targets depend on.  If "
"a source file is older than any file in depends, then the source file will "
"be recompiled.  This supports dependency tracking, but only at a coarse "
"granularity."
msgstr ""
"*depends*, якщо вказано, це список імен файлів, від яких залежать усі цілі. "
"Якщо вихідний файл старіший за будь-який файл у залежностях, вихідний файл "
"буде перекомпільовано. Це підтримує відстеження залежностей, але лише з "
"грубою деталізацією."

#: ../../distutils/apiref.rst:624
msgid "Raises :exc:`CompileError` on failure."
msgstr "Викликає :exc:`CompileError` у разі помилки."

#: ../../distutils/apiref.rst:629
msgid ""
"Link a bunch of stuff together to create a static library file. The \"bunch "
"of stuff\" consists of the list of object files supplied as *objects*, the "
"extra object files supplied to :meth:`add_link_object` and/or "
":meth:`set_link_objects`, the libraries supplied to :meth:`add_library` "
"and/or :meth:`set_libraries`, and the libraries supplied as *libraries* (if "
"any)."
msgstr ""
"Зв’яжіть купу матеріалів разом, щоб створити файл статичної бібліотеки. "
"\"Кучка речей\" складається зі списку об’єктних файлів, наданих як "
"*objects*, додаткових об’єктних файлів, наданих у :meth:`add_link_object` "
"та/або :meth:`set_link_objects`, бібліотек, наданих у :meth:`add_library` "
"та/або :meth:`set_libraries`, а також бібліотеки, що надаються як "
"*бібліотеки* (якщо такі є)."

#: ../../distutils/apiref.rst:635
msgid ""
"*output_libname* should be a library name, not a filename; the filename will"
" be inferred from the library name.  *output_dir* is the directory where the"
" library file will be put."
msgstr ""
"*output_libname* має бути назвою бібліотеки, а не назвою файлу; ім'я файлу "
"буде виведено з назви бібліотеки. *output_dir* - це каталог, куди буде "
"розміщено файл бібліотеки."

#: ../../distutils/apiref.rst:641
msgid ""
"*debug* is a boolean; if true, debugging information will be included in the"
" library (note that on most platforms, it is the compile step where this "
"matters: the *debug* flag is included here just for consistency)."
msgstr ""
"*debug* є логічним; якщо true, інформація про налагодження буде включена в "
"бібліотеку (зауважте, що на більшості платформ це має значення на етапі "
"компіляції: прапор *debug* включено тут лише для узгодженості)."

#: ../../distutils/apiref.rst:645 ../../distutils/apiref.rst:687
msgid ""
"*target_lang* is the target language for which the given objects are being "
"compiled. This allows specific linkage time treatment of certain languages."
msgstr ""
"*target_lang* — цільова мова, для якої компілюються ці об’єкти. Це дозволяє "
"обробку певних мов у певний час зв’язування."

#: ../../distutils/apiref.rst:648
msgid "Raises :exc:`LibError` on failure."
msgstr "Викликає :exc:`LibError` у разі помилки."

#: ../../distutils/apiref.rst:653
msgid ""
"Link a bunch of stuff together to create an executable or shared library "
"file."
msgstr ""
"Пов’яжіть купу матеріалів разом, щоб створити виконуваний файл або файл "
"спільної бібліотеки."

#: ../../distutils/apiref.rst:655
msgid ""
"The \"bunch of stuff\" consists of the list of object files supplied as "
"*objects*. *output_filename* should be a filename.  If *output_dir* is "
"supplied, *output_filename* is relative to it (i.e. *output_filename* can "
"provide directory components if needed)."
msgstr ""
"\"Кучка речей\" складається зі списку об'єктних файлів, які надаються як "
"*об'єкти*. *вихідна_назва_файлу* має бути назвою файлу. Якщо вказано "
"*output_dir*, *output_filename* є відносно нього (тобто *output_filename* "
"може надати компоненти каталогу, якщо це необхідно)."

#: ../../distutils/apiref.rst:660
msgid ""
"*libraries* is a list of libraries to link against.  These are library "
"names, not filenames, since they're translated into filenames in a platform-"
"specific way (eg. *foo* becomes :file:`libfoo.a` on Unix and :file:`foo.lib`"
" on DOS/Windows).  However, they can include a directory component, which "
"means the linker will look in that specific directory rather than searching "
"all the normal locations."
msgstr ""
"*libraries* — це список бібліотек, з якими можна посилатися. Це назви "
"бібліотек, а не назви файлів, оскільки вони перекладаються на назви файлів "
"залежно від платформи (наприклад, *foo* стає :file:`libfoo.a` в Unix і "
":file:`foo.lib` в DOS/ вікна). Однак вони можуть містити компонент каталогу,"
" що означає, що компонувальник шукатиме в цьому конкретному каталозі, а не "
"шукатиме у всіх звичайних місцях."

#: ../../distutils/apiref.rst:667
msgid ""
"*library_dirs*, if supplied, should be a list of directories to search for "
"libraries that were specified as bare library names (ie. no directory "
"component).  These are on top of the system default and those supplied to "
":meth:`add_library_dir` and/or :meth:`set_library_dirs`.  "
"*runtime_library_dirs* is a list of directories that will be embedded into "
"the shared library and used to search for other shared libraries that "
"\\*it\\* depends on at run-time.  (This may only be relevant on Unix.)"
msgstr ""
"*library_dirs*, якщо надається, має бути списком каталогів для пошуку "
"бібліотек, які були вказані як голі імена бібліотек (тобто без компонента "
"каталогу). Вони є поверх системних стандартних і тих, що надаються до "
":meth:`add_library_dir` та/або :meth:`set_library_dirs`. "
"*runtime_library_dirs* — це список каталогів, які будуть вбудовані в спільну"
" бібліотеку та використовуватимуться для пошуку інших спільних бібліотек, "
"від яких \\*вона\\* залежить під час виконання. (Це може бути актуальним "
"лише для Unix.)"

#: ../../distutils/apiref.rst:675
msgid ""
"*export_symbols* is a list of symbols that the shared library will export. "
"(This appears to be relevant only on Windows.)"
msgstr ""
"*export_symbols* — це список символів, які буде експортовано спільною "
"бібліотекою. (Здається, це стосується лише Windows.)"

#: ../../distutils/apiref.rst:678
msgid ""
"*debug* is as for :meth:`compile` and :meth:`create_static_lib`,  with the "
"slight distinction that it actually matters on most platforms (as opposed to"
" :meth:`create_static_lib`, which includes a *debug* flag mostly for form's "
"sake)."
msgstr ""
"*debug* — це те саме, що стосується :meth:`compile` і "
":meth:`create_static_lib`, з тією невеликою різницею, що це насправді має "
"значення на більшості платформ (на відміну від :meth:`create_static_lib`, "
"який переважно містить прапорець *debug* заради форми)."

#: ../../distutils/apiref.rst:683
msgid ""
"*extra_preargs* and *extra_postargs* are as for :meth:`compile`  (except of "
"course that they supply command-line arguments for the particular linker "
"being used)."
msgstr ""
"*extra_preargs* і *extra_postargs* схожі на :meth:`compile` (звісно, за "
"винятком того, що вони надають аргументи командного рядка для конкретного "
"використовуваного компонувальника)."

#: ../../distutils/apiref.rst:690
msgid "Raises :exc:`LinkError` on failure."
msgstr "Викликає :exc:`LinkError` у разі помилки."

#: ../../distutils/apiref.rst:695
msgid ""
"Link an executable.  *output_progname* is the name of the file executable, "
"while *objects* are a list of object filenames to link in. Other arguments  "
"are as for the :meth:`link` method."
msgstr ""
"Посилання на виконуваний файл. *output_progname* — це ім’я виконуваного "
"файлу, тоді як *objects* — це список імен файлів об’єктів для посилань. Інші"
" аргументи такі ж, як і для методу :meth:`link`."

#: ../../distutils/apiref.rst:702
msgid ""
"Link a shared library. *output_libname* is the name of the output  library, "
"while *objects* is a list of object filenames to link in.  Other arguments "
"are as for the :meth:`link` method."
msgstr ""
"Пов’язати спільну бібліотеку. *output_libname* — це ім’я вихідної "
"бібліотеки, тоді як *objects* — це список імен файлів об’єктів для посилань."
" Інші аргументи такі ж, як і для методу :meth:`link`."

#: ../../distutils/apiref.rst:709
msgid ""
"Link a shared object. *output_filename* is the name of the shared object "
"that will be created, while *objects* is a list of object filenames  to link"
" in. Other arguments are as for the :meth:`link` method."
msgstr ""
"Пов’язати спільний об’єкт. *output_filename* — це ім’я спільного об’єкта, "
"який буде створено, тоді як *objects* — це список імен файлів об’єктів для "
"посилань. Інші аргументи такі ж, як і для методу :meth:`link`."

#: ../../distutils/apiref.rst:716
msgid ""
"Preprocess a single C/C++ source file, named in *source*. Output will be "
"written to file named *output_file*, or *stdout* if *output_file* not "
"supplied. *macros* is a list of macro definitions as for :meth:`compile`, "
"which will augment the macros set with :meth:`define_macro` and "
":meth:`undefine_macro`. *include_dirs* is a list of directory names that "
"will be added to the  default list, in the same way as "
":meth:`add_include_dir`."
msgstr ""
"Попередньо обробіть один вихідний файл C/C++, названий у *source*. Вихідні "
"дані буде записано у файл з назвою *output_file* або *stdout*, якщо "
"*output_file* не надано. *макроси* — це список визначень макросів, як для "
":meth:`compile`, який доповнює набір макросів за допомогою "
":meth:`define_macro` і :meth:`undefine_macro`. *include_dirs* — це список "
"імен каталогів, які буде додано до списку за замовчуванням так само, як "
":meth:`add_include_dir`."

#: ../../distutils/apiref.rst:723
msgid "Raises :exc:`PreprocessError` on failure."
msgstr "Викликає :exc:`PreprocessError` у разі помилки."

#: ../../distutils/apiref.rst:725
msgid ""
"The following utility methods are defined by the :class:`CCompiler` class, "
"for use by the various concrete subclasses."
msgstr ""
"Наступні службові методи визначені класом :class:`CCompiler` для "
"використання різними конкретними підкласами."

#: ../../distutils/apiref.rst:731
msgid ""
"Returns the filename of the executable for the given *basename*.  Typically "
"for non-Windows platforms this is the same as the basename,  while Windows "
"will get a :file:`.exe` added."
msgstr ""
"Повертає назву виконуваного файлу для заданого *базового імені*. Зазвичай "
"для платформ, відмінних від Windows, це те саме, що й базове ім’я, у той час"
" як Windows додаватиме :file:`.exe`."

#: ../../distutils/apiref.rst:738
msgid ""
"Returns the filename for the given library name on the current platform. On "
"Unix a library with *lib_type* of ``'static'`` will typically  be of the "
"form :file:`liblibname.a`, while a *lib_type* of ``'dynamic'``  will be of "
"the form :file:`liblibname.so`."
msgstr ""
"Повертає назву файлу для заданої назви бібліотеки на поточній платформі. В "
"Unix бібліотека з *lib_type* ``'static'`` зазвичай матиме форму "
":file:`liblibname.a`, тоді як *lib_type* ``'dynamic'`` матиме форму: "
"файл:`liblibname.so`."

#: ../../distutils/apiref.rst:746
msgid ""
"Returns the name of the object files for the given source files. "
"*source_filenames* should be a list of filenames."
msgstr ""
"Повертає назву об’єктних файлів для заданих вихідних файлів. "
"*source_filenames* має бути списком імен файлів."

#: ../../distutils/apiref.rst:752
msgid ""
"Returns the name of a shared object file for the given file name *basename*."
msgstr "Повертає назву файлу спільного об’єкта для заданого імені *basename*."

#: ../../distutils/apiref.rst:757
msgid ""
"Invokes :func:`distutils.util.execute`. This method invokes a  Python "
"function *func* with the given arguments *args*, after  logging and taking "
"into account the *dry_run* flag."
msgstr ""
"Викликає :func:`distutils.util.execute`. Цей метод викликає функцію Python "
"*func* із заданими аргументами *args* після реєстрації та з урахуванням "
"прапора *dry_run*."

#: ../../distutils/apiref.rst:764
msgid ""
"Invokes :func:`distutils.util.spawn`. This invokes an external  process to "
"run the given command."
msgstr ""
"Викликає :func:`distutils.util.spawn`. Це викликає зовнішній процес для "
"виконання даної команди."

#: ../../distutils/apiref.rst:770
msgid ""
"Invokes :func:`distutils.dir_util.mkpath`. This creates a directory  and any"
" missing ancestor directories."
msgstr ""
"Викликає :func:`distutils.dir_util.mkpath`. Це створює каталог і будь-які "
"відсутні каталоги предків."

#: ../../distutils/apiref.rst:776
msgid ""
"Invokes :meth:`distutils.file_util.move_file`. Renames *src* to  *dst*."
msgstr ""
"Викликає :meth:`distutils.file_util.move_file`. Перейменовує *src* на *dst*."

#: ../../distutils/apiref.rst:781
msgid "Write a message using :func:`distutils.log.debug`."
msgstr "Напишіть повідомлення за допомогою :func:`distutils.log.debug`."

#: ../../distutils/apiref.rst:786
msgid "Write a warning message *msg* to standard error."
msgstr "Напишіть попередження *msg* до стандартної помилки."

#: ../../distutils/apiref.rst:791
msgid ""
"If the *debug* flag is set on this :class:`CCompiler` instance, print  *msg*"
" to standard output, otherwise do nothing."
msgstr ""
"Якщо на цьому екземплярі :class:`CCompiler` встановлено прапор *debug*, "
"виведіть *msg* у стандартний вихід, інакше нічого не робіть."

#: ../../distutils/apiref.rst:803
msgid ":mod:`distutils.unixccompiler` --- Unix C Compiler"
msgstr ":mod:`distutils.unixccompiler` --- Компілятор Unix C"

#: ../../distutils/apiref.rst:809
msgid ""
"This module provides the :class:`UnixCCompiler` class, a subclass of "
":class:`CCompiler` that handles the typical Unix-style command-line  C "
"compiler:"
msgstr ""
"Цей модуль надає клас :class:`UnixCCompiler`, підклас :class:`CCompiler`, "
"який обробляє типовий компілятор командного рядка C у стилі Unix:"

#: ../../distutils/apiref.rst:812
msgid "macros defined with :option:`!-Dname[=value]`"
msgstr "通过 :option:`!-Dname[=value]` 定义的宏"

#: ../../distutils/apiref.rst:814
msgid "macros undefined with :option:`!-Uname`"
msgstr "通过 :option:`!-Uname` 取消定义的宏"

#: ../../distutils/apiref.rst:816
msgid "include search directories specified with :option:`!-Idir`"
msgstr "包括通过 :option:`!-Idir` 指定的搜索目录"

#: ../../distutils/apiref.rst:818
msgid "libraries specified with :option:`!-llib`"
msgstr "通过 :option:`!-llib` 指定的库"

#: ../../distutils/apiref.rst:820
msgid "library search directories specified with :option:`!-Ldir`"
msgstr "通过 :option:`!-Ldir` 指定的库搜索目录"

#: ../../distutils/apiref.rst:822
msgid ""
"compile handled by :program:`cc` (or similar) executable with :option:`!-c` "
"option: compiles :file:`.c` to :file:`.o`"
msgstr ""
"компілюється за допомогою :program:`cc` (або подібного) виконуваного файлу з"
" опцією :option:`!-c`: компілює :file:`.c` до :file:`.o`"

#: ../../distutils/apiref.rst:825
msgid ""
"link static library handled by :program:`ar` command (possibly with "
":program:`ranlib`)"
msgstr ""
"зв’язати статичну бібліотеку, яка обробляється командою :program:`ar` "
"(можливо, за допомогою :program:`ranlib`)"

#: ../../distutils/apiref.rst:828
msgid "link shared library handled by :program:`cc` :option:`!-shared`"
msgstr ""
"посилання на спільну бібліотеку обробляється :program:`cc` "
":option:`!-shared`"

#: ../../distutils/apiref.rst:832
msgid ":mod:`distutils.msvccompiler` --- Microsoft Compiler"
msgstr ":mod:`distutils.msvccompiler` --- Компілятор Microsoft"

#: ../../distutils/apiref.rst:839
msgid ""
"This module provides :class:`MSVCCompiler`, an implementation of the "
"abstract :class:`CCompiler` class for Microsoft Visual Studio. Typically, "
"extension modules need to be compiled with the same compiler that was used "
"to compile Python. For Python 2.3 and earlier, the compiler was Visual "
"Studio 6. For Python 2.4 and 2.5, the compiler is Visual Studio .NET 2003."
msgstr ""
"Цей модуль забезпечує :class:`MSVCCompiler`, реалізацію абстрактного "
":class:`CCompiler` класу для Microsoft Visual Studio. Як правило, модулі "
"розширення потрібно скомпілювати за допомогою того самого компілятора, який "
"використовувався для компіляції Python. Для Python 2.3 і раніших версій "
"компілятором була Visual Studio 6. Для Python 2.4 і 2.5 компілятором була "
"Visual Studio .NET 2003."

#: ../../distutils/apiref.rst:845
msgid ""
":class:`MSVCCompiler` will normally choose the right compiler, linker etc. "
"on its own. To override this choice, the environment variables "
"*DISTUTILS_USE_SDK* and *MSSdk* must be both set. *MSSdk* indicates that the"
" current environment has been setup by the SDK's ``SetEnv.Cmd`` script, or "
"that the environment variables had been registered when the SDK was "
"installed; *DISTUTILS_USE_SDK* indicates that the distutils user has made an"
" explicit choice to override the compiler selection by "
":class:`MSVCCompiler`."
msgstr ""
":class:`MSVCCompiler` зазвичай самостійно вибере правильний компілятор, "
"компонувальник тощо. Щоб перевизначити цей вибір, потрібно встановити обидві"
" змінні середовища *DISTUTILS_USE_SDK* і *MSSdk*. *MSSdk* вказує на те, що "
"поточне середовище було налаштовано за допомогою сценарію ``SetEnv.Cmd`` SDK"
" або що змінні середовища були зареєстровані під час встановлення SDK; "
"*DISTUTILS_USE_SDK* вказує, що користувач distutils зробив явний вибір "
"перевизначити вибір компілятора за допомогою :class:`MSVCCompiler`."

#: ../../distutils/apiref.rst:855
msgid ":mod:`distutils.bcppcompiler` --- Borland Compiler"
msgstr ":mod:`distutils.bcppcompiler` --- Компілятор Borland"

#: ../../distutils/apiref.rst:860
msgid ""
"This module provides :class:`BorlandCCompiler`, a subclass of the abstract "
":class:`CCompiler` class for the Borland C++ compiler."
msgstr ""
"Цей модуль надає :class:`BorlandCCompiler`, підклас абстрактного "
":class:`CCompiler` класу для компілятора Borland C++."

#: ../../distutils/apiref.rst:865
msgid ":mod:`distutils.cygwincompiler` --- Cygwin Compiler"
msgstr ":mod:`distutils.cygwincompiler` --- компілятор Cygwin"

#: ../../distutils/apiref.rst:870
msgid ""
"This module provides the :class:`CygwinCCompiler` class, a subclass of "
":class:`UnixCCompiler` that handles the Cygwin port of the GNU C compiler to"
" Windows.  It also contains the Mingw32CCompiler class which handles the "
"mingw32 port of GCC (same as cygwin in no-cygwin mode)."
msgstr ""
"Цей модуль надає клас :class:`CygwinCCompiler`, підклас "
":class:`UnixCCompiler`, який обробляє порт Cygwin компілятора GNU C для "
"Windows. Він також містить клас Mingw32CCompiler, який обробляє порт mingw32"
" GCC (те саме, що cygwin у режимі без cygwin)."

#: ../../distutils/apiref.rst:877
msgid ":mod:`distutils.archive_util` ---  Archiving utilities"
msgstr ":mod:`distutils.archive_util` --- Утиліти архівування"

#: ../../distutils/apiref.rst:883
msgid ""
"This module provides a few functions for creating archive files, such as "
"tarballs or zipfiles."
msgstr ""
"Цей модуль надає кілька функцій для створення архівних файлів, таких як tar-"
"файли або zip-файли."

#: ../../distutils/apiref.rst:889
msgid ""
"Create an archive file (eg. ``zip`` or ``tar``).  *base_name*  is the name "
"of the file to create, minus any format-specific extension;  *format* is the"
" archive format: one of ``zip``, ``tar``, ``gztar``, ``bztar``, ``xztar``, "
"or ``ztar``. *root_dir* is a directory that will be the root directory of "
"the archive; ie. we typically ``chdir`` into *root_dir* before  creating the"
" archive.  *base_dir* is the directory where we start  archiving from; ie. "
"*base_dir* will be the common prefix of all files and directories in the "
"archive.  *root_dir* and *base_dir* both default to the current directory. "
"Returns the name of the archive file."
msgstr ""
"Створіть архівний файл (наприклад, ``zip`` або ``tar``). *base_name* — це "
"ім’я файлу, який потрібно створити, за вирахуванням розширення, що залежить "
"від формату; *format* — це формат архіву: один із ``zip``, ``tar``, "
"``gztar``, ``bztar``, ``xztar`` або ``ztar``. *root_dir* – це каталог, який "
"буде кореневим каталогом архіву; тобто. ми зазвичай ``chdir`` в *root_dir* "
"перед створенням архіву. *base_dir* - це каталог, з якого ми починаємо "
"архівування; тобто. *base_dir* буде загальним префіксом для всіх файлів і "
"каталогів в архіві. *root_dir* і *base_dir* за замовчуванням є поточним "
"каталогом. Повертає назву архівного файлу."

#: ../../distutils/apiref.rst:899
msgid "Added support for the ``xztar`` format."
msgstr "添加了对 ``xztar`` 格式的支持"

#: ../../distutils/apiref.rst:905
msgid ""
"'Create an (optional compressed) archive as a tar file from all files in and"
" under *base_dir*. *compress* must be ``'gzip'`` (the default), ``'bzip2'``,"
" ``'xz'``, ``'compress'``, or ``None``.  For the ``'compress'`` method the "
"compression utility named by :program:`compress` must be on the default "
"program search path, so this is probably Unix-specific.  The output tar file"
" will be named :file:`base_dir.tar`, possibly plus the appropriate "
"compression extension (``.gz``, ``.bz2``, ``.xz`` or ``.Z``).  Return the "
"output filename."
msgstr ""
"\"Створіть (необов’язково стиснутий) архів як файл tar з усіх файлів у "
"*base_dir* та під ним. *compress* має бути ``'gzip'`` (за замовчуванням), "
"``'bzip2'``, ``'xz'``, ``'compress'`` або ``None``. Для методу "
"``'стиснення''`` утиліта стиснення, названа :program:`compress`, має бути на"
" шляху пошуку програми за замовчуванням, тому це, ймовірно, специфічно для "
"Unix. Вихідний файл tar матиме назву :file:`base_dir.tar`, можливо, з "
"додаванням відповідного розширення стиснення (``.gz``, ``.bz2``, ``.xz`` або"
" ``.Z`` ). Повернути назву вихідного файлу."

#: ../../distutils/apiref.rst:914
msgid "Added support for the ``xz`` compression."
msgstr "Додано підтримку стиснення ``xz``."

#: ../../distutils/apiref.rst:920
msgid ""
"Create a zip file from all files in and under *base_dir*.  The output zip "
"file will be named *base_name* + :file:`.zip`.  Uses either the  "
":mod:`zipfile` Python module (if available) or the InfoZIP :file:`zip`  "
"utility (if installed and found on the default search path).  If neither  "
"tool is available, raises :exc:`DistutilsExecError`.   Returns the name of "
"the output zip file."
msgstr ""
"Створіть файл zip з усіх файлів у *base_dir* і під ним. Вихідний zip-файл "
"матиме назву *base_name* + :file:`.zip`. Використовує або модуль "
":mod:`zipfile` Python (якщо доступний), або утиліту InfoZIP :file:`zip` "
"(якщо встановлено та знайдено на шляху пошуку за умовчанням). Якщо жоден "
"інструмент недоступний, викликає :exc:`DistutilsExecError`. Повертає назву "
"вихідного zip-файлу."

#: ../../distutils/apiref.rst:928
msgid ":mod:`distutils.dep_util` --- Dependency checking"
msgstr ":mod:`distutils.dep_util` --- Перевірка залежностей"

#: ../../distutils/apiref.rst:934
msgid ""
"This module provides functions for performing simple, timestamp-based "
"dependency of files and groups of files; also, functions based entirely  on "
"such timestamp dependency analysis."
msgstr ""
"Цей модуль надає функції для виконання простої залежності файлів і груп "
"файлів на основі часових позначок; також функції, повністю засновані на "
"такому аналізі залежностей часових позначок."

#: ../../distutils/apiref.rst:941
msgid ""
"Return true if *source* exists and is more recently modified than *target*, "
"or if *source* exists and *target* doesn't. Return false if both exist and "
"*target* is the same age or newer  than *source*. Raise "
":exc:`DistutilsFileError` if *source* does not exist."
msgstr ""
"Повертає істину, якщо *джерело* існує та змінено нещодавно, ніж *ціль*, або "
"якщо *джерело* існує, а *ціль* ні. Повертає false, якщо обидва існують і "
"*ціль* має той самий вік або новіший, ніж *джерело*. Викликати "
":exc:`DistutilsFileError`, якщо *джерело* не існує."

#: ../../distutils/apiref.rst:949
msgid ""
"Walk two filename lists in parallel, testing if each source is newer than "
"its corresponding target.  Return a pair of lists (*sources*, *targets*) "
"where source is newer than target, according to the semantics of "
":func:`newer`."
msgstr ""
"Перегляньте два списки імен файлів паралельно, перевіряючи, чи кожне джерело"
" є новішим за відповідну ціль. Повертає пару списків (*джерела*, *цілі*), де"
" джерело є новішим за ціль, відповідно до семантики :func:`newer`."

#: ../../distutils/apiref.rst:958
msgid ""
"Return true if *target* is out-of-date with respect to any file listed in "
"*sources*.  In other words, if *target* exists and is newer than every file "
"in *sources*, return false; otherwise return true. *missing* controls what "
"we do when a source file is missing; the default (``'error'``) is to blow up"
" with an :exc:`OSError` from  inside :func:`os.stat`; if it is ``'ignore'``,"
" we silently drop any missing source files; if it is ``'newer'``, any "
"missing source files make us assume that *target* is out-of-date (this is "
"handy in \"dry-run\" mode: it'll make you pretend to carry out commands that"
" wouldn't work because inputs are missing, but that doesn't matter because "
"you're not actually going to run the commands)."
msgstr ""
"Повертає true, якщо *target* застарів щодо будь-якого файлу, зазначеного в "
"*джерелах*. Іншими словами, якщо *target* існує і є новішим за всі файли в "
"*sources*, поверніть false; інакше повертає true. *missing* контролює те, що"
" ми робимо, коли вихідний файл відсутній; за замовчуванням (``'помилка'``) "
"вибухає з :exc:`OSError` зсередини :func:`os.stat`; якщо це ``'ignore''``, "
"ми мовчки видаляємо всі відсутні джерельні файли; якщо він ``'новіший'``, "
"будь-які відсутні вихідні файли змушують нас вважати, що *target* застарів "
"(це зручно в режимі \"сухого запуску\": це змусить вас вдавати, що ви "
"виконуєте команди це не спрацює, оскільки вхідні дані відсутні, але це не "
"має значення, оскільки ви насправді не збираєтеся виконувати команди)."

#: ../../distutils/apiref.rst:971
msgid ":mod:`distutils.dir_util` --- Directory tree operations"
msgstr ":mod:`distutils.dir_util` --- Операції з деревом каталогів"

#: ../../distutils/apiref.rst:977
msgid ""
"This module provides functions for operating on directories and trees of "
"directories."
msgstr ""
"Цей модуль надає функції для роботи з каталогами та деревами каталогів."

#: ../../distutils/apiref.rst:983
msgid ""
"Create a directory and any missing ancestor directories.  If the directory "
"already exists (or if *name* is the empty string, which means the current "
"directory, which of course exists), then do nothing.  Raise "
":exc:`DistutilsFileError` if unable to create some directory along the way "
"(eg. some sub-path exists, but is a file rather than a directory).  If "
"*verbose* is true, print a one-line summary of each mkdir to stdout.  Return"
" the list of directories actually created."
msgstr ""
"Створіть каталог і будь-які відсутні каталоги предків. Якщо каталог уже "
"існує (або якщо *name* є порожнім рядком, що означає поточний каталог, який,"
" звичайно, існує), тоді нічого не робити. Викликати "
":exc:`DistutilsFileError`, якщо неможливо створити певний каталог "
"(наприклад, якийсь підшлях існує, але це файл, а не каталог). Якщо *verbose*"
" має значення true, вивести однорядковий підсумок кожного mkdir у "
"стандартний вихід. Повертає список фактично створених каталогів."

#: ../../distutils/apiref.rst:994
msgid ""
"Create all the empty directories under *base_dir* needed to put *files* "
"there. *base_dir* is just the name of a directory which doesn't necessarily "
"exist yet; *files* is a list of filenames to be interpreted relative to "
"*base_dir*. *base_dir* + the directory portion of every file in *files* will"
" be created if it doesn't already exist.  *mode*, *verbose* and *dry_run* "
"flags  are as for :func:`mkpath`."
msgstr ""
"Створіть усі порожні каталоги в *base_dir*, необхідні для розміщення туди "
"*файлів*. *base_dir* — це просто назва каталогу, який ще не обов’язково "
"існує; *files* — це список імен файлів, які слід інтерпретувати відносно "
"*base_dir*. *base_dir* + частина каталогу кожного файлу в *files* буде "
"створена, якщо вона ще не існує. Прапори *mode*, *verbose* і *dry_run* такі "
"ж, як і для :func:`mkpath`."

#: ../../distutils/apiref.rst:1004
msgid ""
"Copy an entire directory tree *src* to a new location *dst*.  Both *src* and"
" *dst* must be directory names.  If *src* is not a directory, raise "
":exc:`DistutilsFileError`.  If *dst* does  not exist, it is created with "
":func:`mkpath`.  The end result of the  copy is that every file in *src* is "
"copied to *dst*, and  directories under *src* are recursively copied to "
"*dst*. Return the list of files that were copied or might have been copied, "
"using their output name. The return value is unaffected by *update* or "
"*dry_run*: it is simply the list of all files under *src*, with the names "
"changed to be under *dst*."
msgstr ""
"Скопіюйте все дерево каталогів *src* до нового розташування *dst*. І *src*, "
"і *dst* мають бути іменами каталогів. Якщо *src* не є каталогом, викликайте "
":exc:`DistutilsFileError`. Якщо *dst* не існує, він створюється за допомогою"
" :func:`mkpath`. Кінцевим результатом копіювання є те, що кожен файл у *src*"
" копіюється в *dst*, а каталоги в *src* рекурсивно копіюються в *dst*. "
"Повертає список файлів, які були скопійовані або могли бути скопійовані, "
"використовуючи їхні вихідні назви. На повернене значення не впливають "
"*update* або *dry_run*: це просто список усіх файлів у *src*, імена яких "
"змінено на *dst*."

#: ../../distutils/apiref.rst:1014
msgid ""
"*preserve_mode* and *preserve_times* are the same as for "
":func:`distutils.file_util.copy_file`; note that they only apply to regular "
"files, not to directories.  If *preserve_symlinks* is true, symlinks will be"
" copied as symlinks (on platforms that support them!); otherwise (the "
"default), the destination of the symlink will be copied.  *update* and "
"*verbose* are the same as for :func:`copy_file`."
msgstr ""
"*preserve_mode* і *preserve_times* такі самі, як і для "
":func:`distutils.file_util.copy_file`; зауважте, що вони застосовуються лише"
" до звичайних файлів, а не до каталогів. Якщо *preserve_symlinks* має "
"значення true, символічні посилання буде скопійовано як символічні посилання"
" (на платформах, які їх підтримують!); інакше (за замовчуванням) місце "
"призначення символічного посилання буде скопійовано. *update* і *verbose* "
"такі самі, як і для :func:`copy_file`."

#: ../../distutils/apiref.rst:1022
msgid ""
"Files in *src* that begin with :file:`.nfs` are skipped (more information on"
" these files is available in answer D2 of the `NFS FAQ page "
"<http://nfs.sourceforge.net/#section_d>`_)."
msgstr ""

#: ../../distutils/apiref.rst:1026
msgid "NFS files are ignored."
msgstr "NFS Dateien werden ignoriert."

#: ../../distutils/apiref.rst:1031
msgid ""
"Recursively remove *directory* and all files and directories underneath it. "
"Any errors are ignored (apart from being reported to ``sys.stdout`` if "
"*verbose* is true)."
msgstr ""
"Рекурсивно видаліть *каталог* і всі файли та каталоги під ним. Будь-які "
"помилки ігноруються (крім повідомлень у ``sys.stdout``, якщо *verbose* має "
"значення true)."

#: ../../distutils/apiref.rst:1037
msgid ":mod:`distutils.file_util` --- Single file operations"
msgstr ":mod:`distutils.file_util` --- Операції з одним файлом"

#: ../../distutils/apiref.rst:1043
msgid ""
"This module contains some utility functions for operating on individual "
"files."
msgstr ""
"Цей модуль містить деякі службові функції для роботи з окремими файлами."

#: ../../distutils/apiref.rst:1048
msgid ""
"Copy file *src* to *dst*. If *dst* is a directory, then *src* is copied "
"there with the same name; otherwise, it must be a filename. (If the file "
"exists, it will be ruthlessly clobbered.) If *preserve_mode* is true (the "
"default), the file's mode (type and permission bits, or whatever is "
"analogous on the current platform) is copied. If *preserve_times* is true "
"(the default), the last-modified and last-access times are copied as well. "
"If *update* is true, *src* will only be copied if *dst* does not exist, or "
"if *dst* does exist but is older than *src*."
msgstr ""
"Скопіюйте файл *src* в *dst*. Якщо *dst* є каталогом, то *src* копіюється "
"туди з таким же ім’ям; інакше це має бути ім'я файлу. (Якщо файл існує, його"
" буде безжально знищено.) Якщо *preserve_mode* має значення true (за "
"замовчуванням), режим файлу (тип і біти дозволу або щось аналогічне на "
"поточній платформі) копіюється. Якщо *preserve_times* має значення true (за "
"замовчуванням), час останньої зміни та останнього доступу також копіюється. "
"Якщо *update* має значення true, *src* буде скопійовано, лише якщо *dst* не "
"існує, або якщо *dst* існує, але він старіший за *src*."

#: ../../distutils/apiref.rst:1057
msgid ""
"*link* allows you to make hard links (using :func:`os.link`) or symbolic "
"links (using :func:`os.symlink`) instead of copying: set it to ``'hard'`` or"
" ``'sym'``; if it is ``None`` (the default), files are copied. Don't set "
"*link* on systems that don't support it: :func:`copy_file` doesn't check if "
"hard or symbolic linking is available.  It uses :func:`_copy_file_contents` "
"to copy file contents."
msgstr ""
"*link* дозволяє створювати жорсткі посилання (за допомогою :func:`os.link`) "
"або символічні посилання (за допомогою :func:`os.symlink`) замість "
"копіювання: установіть значення ``'hard'`` або ``'сим'``; якщо значення "
"``None`` (за замовчуванням), файли копіюються. Не встановлюйте *посилання* "
"на системах, які його не підтримують: :func:`copy_file` не перевіряє "
"наявність жорсткого чи символічного зв’язування. Він використовує "
":func:`_copy_file_contents` для копіювання вмісту файлу."

#: ../../distutils/apiref.rst:1064
msgid ""
"Return a tuple ``(dest_name, copied)``: *dest_name* is the actual  name of "
"the output file, and *copied* is true if the file was copied  (or would have"
" been copied, if *dry_run* true)."
msgstr ""
"Повертає кортеж ``(dest_name, copied)``: *dest_name* є фактичною назвою "
"вихідного файлу, а *copied* має значення true, якщо файл було скопійовано "
"(або було б скопійовано, якщо *dry_run* true)."

#: ../../distutils/apiref.rst:1078
msgid ""
"Move file *src* to *dst*. If *dst* is a directory, the file will be moved "
"into it with the same name; otherwise, *src* is just renamed to *dst*.  "
"Returns the new full name of the file."
msgstr ""
"Перемістити файл *src* до *dst*. Якщо *dst* є каталогом, файл буде "
"переміщено до нього з таким же ім'ям; інакше *src* просто перейменовується "
"на *dst*. Повертає нову повну назву файлу."

#: ../../distutils/apiref.rst:1084
msgid ""
"Handles cross-device moves on Unix using :func:`copy_file`.  What about "
"other systems?"
msgstr ""
"Обробляє переміщення між пристроями в Unix за допомогою :func:`copy_file`. А"
" як щодо інших систем?"

#: ../../distutils/apiref.rst:1090
msgid ""
"Create a file called *filename* and write *contents* (a sequence of strings "
"without line terminators) to it."
msgstr ""
"Створіть файл під назвою *filename* і запишіть у нього *contents* "
"(послідовність рядків без символів закінчення рядків)."

#: ../../distutils/apiref.rst:1095
msgid ":mod:`distutils.util` --- Miscellaneous other utility functions"
msgstr ":mod:`distutils.util` --- Інші інші службові функції"

#: ../../distutils/apiref.rst:1101
msgid ""
"This module contains other assorted bits and pieces that don't fit into  any"
" other utility module."
msgstr ""
"Цей модуль містить інші різні частини, які не підходять до жодного іншого "
"службового модуля."

#: ../../distutils/apiref.rst:1107
msgid ""
"Return a string that identifies the current platform.  This is used mainly "
"to distinguish platform-specific build directories and platform-specific "
"built distributions.  Typically includes the OS name and version and the "
"architecture (as supplied by 'os.uname()'), although the exact information "
"included depends on the OS; e.g., on Linux, the kernel version isn't "
"particularly important."
msgstr ""
"Повертає рядок, що ідентифікує поточну платформу. Це використовується в "
"основному для того, щоб розрізнити каталоги збірок для певної платформи та "
"побудовані дистрибутиви для конкретної платформи. Зазвичай включає назву та "
"версію ОС та архітектуру (як надає 'os.uname()'), хоча точна включена "
"інформація залежить від ОС; наприклад, у Linux версія ядра не особливо "
"важлива."

#: ../../distutils/apiref.rst:1114
msgid "Examples of returned values:"
msgstr "返回值的示例："

#: ../../distutils/apiref.rst:1116
msgid "``linux-i586``"
msgstr "``linux-i586``"

#: ../../distutils/apiref.rst:1117
msgid "``linux-alpha``"
msgstr "``linux-alpha``"

#: ../../distutils/apiref.rst:1118
msgid "``solaris-2.6-sun4u``"
msgstr "``solaris-2.6-sun4u``"

#: ../../distutils/apiref.rst:1120
msgid "For non-POSIX platforms, currently just returns ``sys.platform``."
msgstr ""
"Для платформ, відмінних від POSIX, наразі повертає лише ``sys.platform``."

#: ../../distutils/apiref.rst:1122
msgid ""
"For macOS systems the OS version reflects the minimal version on which "
"binaries will run (that is, the value of ``MACOSX_DEPLOYMENT_TARGET`` during"
" the build of Python), not the OS version of the current system."
msgstr ""
"Для систем macOS версія ОС відображає мінімальну версію, на якій "
"запускатимуться двійкові файли (тобто значення ``MACOSX_DEPLOYMENT_TARGET`` "
"під час збирання Python), а не версію ОС поточної системи."

#: ../../distutils/apiref.rst:1126
msgid ""
"For universal binary builds on macOS the architecture value reflects the "
"universal binary status instead of the architecture of the current "
"processor. For 32-bit universal binaries the architecture is ``fat``, for "
"64-bit universal binaries the architecture is ``fat64``, and for 4-way "
"universal binaries the architecture is ``universal``. Starting from Python "
"2.7 and Python 3.2 the architecture ``fat3`` is used for a 3-way universal "
"build (ppc, i386, x86_64) and ``intel`` is used for a universal build with "
"the i386 and x86_64 architectures"
msgstr ""
"Для універсальних двійкових збірок на macOS значення архітектури відображає "
"статус універсального двійкового файлу замість архітектури поточного "
"процесора. Для 32-розрядних універсальних двійкових файлів архітектура "
"``fat``, для 64-розрядних універсальних двійкових файлів архітектура "
"``fat64``, а для 4-сторонніх універсальних двійкових файлів архітектура "
"``universal``. Починаючи з Python 2.7 і Python 3.2, архітектура ``fat3`` "
"використовується для тристоронньої універсальної збірки (ppc, i386, x86_64),"
" а ``intel`` використовується для універсальної збірки з архітектурами i386 "
"і x86_64"

#: ../../distutils/apiref.rst:1135
msgid "Examples of returned values on macOS:"
msgstr "macOS 上的返回值示例:"

#: ../../distutils/apiref.rst:1137
msgid "``macosx-10.3-ppc``"
msgstr "``macosx-10.3-ppc``"

#: ../../distutils/apiref.rst:1139
msgid "``macosx-10.3-fat``"
msgstr "``macosx-10.3-fat``"

#: ../../distutils/apiref.rst:1141
msgid "``macosx-10.5-universal``"
msgstr "``macosx-10.5-universal``"

#: ../../distutils/apiref.rst:1143
msgid "``macosx-10.6-intel``"
msgstr "``macosx-10.6-intel``"

#: ../../distutils/apiref.rst:1145
msgid ""
"For AIX, Python 3.9 and later return a string starting with \"aix\", "
"followed by additional fields (separated by ``'-'``) that represent the "
"combined values of AIX Version, Release and Technology Level (first field), "
"Build Date (second field), and bit-size (third field). Python 3.8 and "
"earlier returned only a single additional field with the AIX Version and "
"Release."
msgstr ""
"Для AIX Python 3.9 і пізніших версій повертає рядок, що починається з "
"\"aix\", за яким ідуть додаткові поля (розділені \"-\"), які представляють "
"об’єднані значення версії AIX, випуску та рівня технології (перше поле), "
"Build Дата (друге поле) і бітовий розмір (третє поле). Python 3.8 і "
"попередні версії повертали лише одне додаткове поле з версією та випуском "
"AIX."

#: ../../distutils/apiref.rst:1151
msgid "Examples of returned values on AIX:"
msgstr "Приклади повернених значень в AIX:"

#: ../../distutils/apiref.rst:1153
msgid ""
"``aix-5307-0747-32`` # 32-bit build on AIX ``oslevel -s``: 5300-07-00-0000"
msgstr ""
"``aix-5307-0747-32`` # 32-розрядна збірка на AIX ``oslevel -s``: "
"5300-07-00-0000"

#: ../../distutils/apiref.rst:1155
msgid ""
"``aix-7105-1731-64`` # 64-bit build on AIX ``oslevel -s``: 7100-05-01-1731"
msgstr ""
"``aix-7105-1731-64`` # 64-розрядна збірка на AIX ``oslevel -s``: "
"7100-05-01-1731"

#: ../../distutils/apiref.rst:1157
msgid "``aix-7.2``          # Legacy form reported in Python 3.8 and earlier"
msgstr "``aix-7.2`` # Застаріла форма, представлена в Python 3.8 і раніше"

#: ../../distutils/apiref.rst:1159
msgid ""
"The AIX platform string format now also includes the technology level, build"
" date, and ABI bit-size."
msgstr ""
"Формат рядка платформи AIX тепер також включає рівень технології, дату "
"збірки та бітовий розмір ABI."

#: ../../distutils/apiref.rst:1166
msgid ""
"Return 'pathname' as a name that will work on the native filesystem, i.e. "
"split it on '/' and put it back together again using the current directory "
"separator. Needed because filenames in the setup script are always supplied "
"in Unix style, and have to be converted to the local convention before we "
"can actually use them in the filesystem.  Raises :exc:`ValueError` on non-"
"Unix-ish systems if *pathname* either  starts or ends with a slash."
msgstr ""
"Поверніть \"pathname\" як ім’я, яке працюватиме у рідній файловій системі, "
"тобто розділіть його на \"/\" і знову об’єднайте, використовуючи поточний "
"роздільник каталогів. Необхідно, тому що імена файлів у сценарії "
"встановлення завжди надаються у стилі Unix і мають бути перетворені "
"відповідно до локальної угоди, перш ніж ми зможемо фактично використовувати "
"їх у файловій системі. Викликає :exc:`ValueError` на системах, що не "
"підтримують Unix, якщо *шлях* починається або закінчується скісною рискою."

#: ../../distutils/apiref.rst:1176
msgid ""
"Return *pathname* with *new_root* prepended.  If *pathname* is relative, "
"this is equivalent to ``os.path.join(new_root,pathname)`` Otherwise, it "
"requires making *pathname* relative and then joining the two, which is "
"tricky on DOS/Windows."
msgstr ""
"Повернути *pathname* з *new_root* перед початком. Якщо *pathname* є "
"відносним, це еквівалентно ``os.path.join(new_root,pathname)``. В іншому "
"випадку потрібно зробити *pathname* відносним, а потім об’єднати два, що "
"складно в DOS/Windows."

#: ../../distutils/apiref.rst:1183
msgid ""
"Ensure that 'os.environ' has all the environment variables we guarantee that"
" users can use in config files, command-line options, etc.  Currently this "
"includes:"
msgstr ""
"Переконайтеся, що \"os.environ\" містить усі змінні середовища, які ми "
"гарантуємо, що користувачі можуть використовувати у файлах конфігурації, "
"параметрах командного рядка тощо. Наразі це включає:"

#: ../../distutils/apiref.rst:1187
msgid ":envvar:`HOME` - user's home directory (Unix only)"
msgstr ":envvar:`HOME` - домашній каталог користувача (тільки для Unix)"

#: ../../distutils/apiref.rst:1188
msgid ""
":envvar:`PLAT` - description of the current platform, including hardware and"
" OS (see :func:`get_platform`)"
msgstr ""
":envvar:`PLAT` - опис поточної платформи, включаючи обладнання та ОС (див. "
":func:`get_platform`)"

#: ../../distutils/apiref.rst:1194
msgid ""
"Perform shell/Perl-style variable substitution on *s*.  Every occurrence of "
"``$`` followed by a name is considered a variable, and variable is "
"substituted by the value found in the *local_vars* dictionary, or in "
"``os.environ`` if it's not in *local_vars*. *os.environ* is first "
"checked/augmented to guarantee that it contains certain values: see "
":func:`check_environ`.  Raise :exc:`ValueError` for any variables not found "
"in either *local_vars* or ``os.environ``."
msgstr ""
"Виконайте підстановку змінної у стилі shell/Perl на *s*. Кожне входження "
"``$``, після якого йде ім’я, вважається змінною, а змінна замінюється "
"значенням, знайденим у словнику *local_vars* або в ``os.environ``, якщо його"
" немає в *local_vars*. *os.environ* спочатку перевіряється/доповнюється, щоб"
" гарантувати, що він містить певні значення: див. :func:`check_environ`. "
"Викликати :exc:`ValueError` для будь-яких змінних, не знайдених ні в "
"*local_vars*, ні в ``os.environ``."

#: ../../distutils/apiref.rst:1201
msgid ""
"Note that this is not a full-fledged string interpolation function. A valid "
"``$variable`` can consist only of upper and lower case letters, numbers and "
"an underscore. No { } or ( ) style quoting is available."
msgstr ""
"これは完全な文字列挿入関数ではないことに注意してください。 ``$variable`` の名前には大小英字、数字、アンダーバーだけを含むことができます。"
" { } や ( ) を使った引用形式は利用できません。"

#: ../../distutils/apiref.rst:1208
msgid ""
"Split a string up according to Unix shell-like rules for quotes and "
"backslashes. In short: words are delimited by spaces, as long as those "
"spaces are not escaped by a backslash, or inside a quoted string. Single and"
" double quotes are equivalent, and the quote characters can be backslash-"
"escaped.  The backslash is stripped from any two-character escape sequence, "
"leaving only the escaped character.  The quote characters are stripped from "
"any quoted string.  Returns a list of words."
msgstr ""
"Розділіть рядок відповідно до правил оболонки Unix для лапок і зворотних "
"косих риск. Коротше кажучи: слова розділені пробілами, якщо ці пробіли не "
"виділені зворотною скісною рискою або всередині рядка в лапках. Одинарні та "
"подвійні лапки еквівалентні, а символи лапок можна екранувати зворотною "
"скісною рискою. Зворотний слеш видаляється з будь-якої послідовності "
"екранування з двох символів, залишаючи лише екранований символ. Символи "
"лапок видаляються з будь-якого рядка в лапках. Повертає список слів."

#: ../../distutils/apiref.rst:1221
msgid ""
"Perform some action that affects the outside world (for instance, writing to"
" the filesystem).  Such actions are special because they are disabled by the"
" *dry_run* flag.  This method takes  care of all that bureaucracy for you; "
"all you have to do is supply the function to call and an argument tuple for "
"it (to embody the \"external action\" being performed), and an optional "
"message to print."
msgstr ""
"Виконайте певну дію, яка впливає на зовнішній світ (наприклад, запис у "
"файлову систему). Такі дії є особливими, тому що вони вимкнені прапором "
"*dry_run*. Цей метод подбає про всю цю бюрократію за вас; все, що вам "
"потрібно зробити, це надати функцію для виклику та кортеж аргументів для неї"
" (щоб втілити \"зовнішню дію\", що виконується), і додаткове повідомлення "
"для друку."

#: ../../distutils/apiref.rst:1230
msgid "Convert a string representation of truth to true (1) or false (0)."
msgstr ""
"Перетворення рядкового представлення правди в істину (1) або хибність (0)."

#: ../../distutils/apiref.rst:1232
msgid ""
"True values are ``y``, ``yes``, ``t``, ``true``, ``on``  and ``1``; false "
"values are ``n``, ``no``, ``f``, ``false``,  ``off`` and ``0``.  Raises "
":exc:`ValueError` if *val*  is anything else."
msgstr ""
"Справжніми значеннями є ``y``, ``yes``, ``t``, ``true``, ``on`` і ``1``; "
"помилковими значеннями є ``n``, ``no``, ``f``, ``false``, ``off`` і ``0``. "
"Викликає :exc:`ValueError`, якщо *val* є чимось іншим."

#: ../../distutils/apiref.rst:1239
msgid ""
"Byte-compile a collection of Python source files to :file:`.pyc` files in a "
":file:`__pycache__` subdirectory (see :pep:`3147` and :pep:`488`). "
"*py_files* is a list of files to compile; any files that don't end in "
":file:`.py` are silently skipped.  *optimize* must be one of the following:"
msgstr ""
"Байтова компіляція колекції вихідних файлів Python у файли :file:`.pyc` у "
"підкаталозі :file:`__pycache__` (див. :pep:`3147` і :pep:`488`). *py_files* "
"— список файлів для компіляції; будь-які файли, які не закінчуються на "
":file:`.py` мовчки пропускаються. *optimize* має бути одним із таких:"

#: ../../distutils/apiref.rst:1244
msgid "``0`` - don't optimize"
msgstr "``0`` - не оптимізувати"

#: ../../distutils/apiref.rst:1245
msgid "``1`` - normal optimization (like ``python -O``)"
msgstr "``1`` - звичайна оптимізація (наприклад, ``python -O``)"

#: ../../distutils/apiref.rst:1246
msgid "``2`` - extra optimization (like ``python -OO``)"
msgstr "``2`` - додаткова оптимізація (наприклад, ``python -OO``)"

#: ../../distutils/apiref.rst:1248
msgid "If *force* is true, all files are recompiled regardless of timestamps."
msgstr ""
"Якщо *force* має значення true, усі файли перекомпільовуються незалежно від "
"позначок часу."

#: ../../distutils/apiref.rst:1250
msgid ""
"The source filename encoded in each :term:`bytecode` file defaults to the "
"filenames listed in *py_files*; you can modify these with *prefix* and "
"*basedir*. *prefix* is a string that will be stripped off of each source "
"filename, and *base_dir* is a directory name that will be prepended (after "
"*prefix* is stripped).  You can supply either or both (or neither) of "
"*prefix* and *base_dir*, as you wish."
msgstr ""
"Ім’я вихідного файлу, закодоване в кожному файлі :term:`bytecode`, за "
"замовчуванням відповідає назвам файлів, указаним у *py_files*; ви можете "
"змінити їх за допомогою *prefix* і *basedir*. *префікс* — це рядок, який "
"буде видалено з імені кожного вихідного файлу, а *base_dir* — це ім’я "
"каталогу, яке буде додано перед (після видалення *префікса*). Ви можете "
"вказати один або обидва (або жоден) з *prefix* і *base_dir*, як хочете."

#: ../../distutils/apiref.rst:1257
msgid ""
"If *dry_run* is true, doesn't actually do anything that would affect the "
"filesystem."
msgstr ""
"Якщо *dry_run* має значення true, фактично не робить нічого, що могло б "
"вплинути на файлову систему."

#: ../../distutils/apiref.rst:1260
msgid ""
"Byte-compilation is either done directly in this interpreter process with "
"the standard :mod:`py_compile` module, or indirectly by writing a temporary "
"script and executing it.  Normally, you should let :func:`byte_compile` "
"figure out to use direct compilation or not (see the source for details).  "
"The *direct* flag is used by the script generated in indirect mode; unless "
"you know what you're doing, leave it set to ``None``."
msgstr ""
"Компіляція байтів виконується або безпосередньо в цьому процесі "
"інтерпретатора за допомогою стандартного модуля :mod:`py_compile`, або "
"опосередковано шляхом написання тимчасового сценарію та його виконання. "
"Зазвичай ви повинні дозволити :func:`byte_compile` визначити, "
"використовувати пряму компіляцію чи ні (дивіться джерело для деталей). "
"Прапор *прямий* використовується сценарієм, згенерованим у непрямому режимі;"
" Якщо ви не знаєте, що робите, залиште значення ``None``."

#: ../../distutils/apiref.rst:1267
msgid ""
"Create ``.pyc`` files with an :func:`import magic tag <imp.get_tag>` in "
"their name, in a :file:`__pycache__` subdirectory instead of files without "
"tag in the current directory."
msgstr ""
"Створюйте файли ``.pyc`` із :func:`магічним тегом імпорту <imp.get_tag>` у "
"своєму імені в підкаталозі :file:`__pycache__` замість файлів без тегу в "
"поточному каталозі."

#: ../../distutils/apiref.rst:1272
msgid "Create ``.pyc`` files according to :pep:`488`."
msgstr "Створіть файли ``.pyc`` відповідно до :pep:`488`."

#: ../../distutils/apiref.rst:1278
msgid ""
"Return a version of *header* escaped for inclusion in an :rfc:`822` header, "
"by ensuring there are 8 spaces space after each newline. Note that it does "
"no other modification of the string."
msgstr ""
"Повертає екрановану версію *заголовка* для включення в заголовок :rfc:`822`,"
" переконавшись, що після кожного нового рядка є 8 пробілів. Зауважте, що він"
" не виконує інших модифікацій рядка."

#: ../../distutils/apiref.rst:1288
msgid ":mod:`distutils.dist` --- The Distribution class"
msgstr ":mod:`distutils.dist` --- Клас розподілу"

#: ../../distutils/apiref.rst:1295
msgid ""
"This module provides the :class:`~distutils.core.Distribution` class, which "
"represents the module distribution being built/installed/distributed."
msgstr ""
"Цей модуль надає клас :class:`~distutils.core.Distribution`, який "
"представляє дистрибутив модуля, який "
"створюється/встановлюється/розповсюджується."

#: ../../distutils/apiref.rst:1300
msgid ":mod:`distutils.extension` --- The Extension class"
msgstr ":mod:`distutils.extension` --- Клас розширення"

#: ../../distutils/apiref.rst:1307
msgid ""
"This module provides the :class:`Extension` class, used to describe C/C++ "
"extension modules in setup scripts."
msgstr ""
"Цей модуль надає клас :class:`Extension`, який використовується для опису "
"модулів розширення C/C++ у сценаріях налаштування."

#: ../../distutils/apiref.rst:1315
msgid ":mod:`distutils.debug` --- Distutils debug mode"
msgstr ":mod:`distutils.debug` --- Режим налагодження Distutils"

#: ../../distutils/apiref.rst:1321
msgid "This module provides the DEBUG flag."
msgstr "本模块提供DEBUG标识。"

#: ../../distutils/apiref.rst:1325
msgid ":mod:`distutils.errors` --- Distutils exceptions"
msgstr ":mod:`distutils.errors` --- винятки Distutils"

#: ../../distutils/apiref.rst:1331
msgid ""
"Provides exceptions used by the Distutils modules.  Note that Distutils "
"modules may raise standard exceptions; in particular, SystemExit is usually "
"raised for errors that are obviously the end-user's fault (eg. bad command-"
"line arguments)."
msgstr ""
"Надає винятки, які використовуються модулями Distutils. Зауважте, що модулі "
"Distutils можуть викликати стандартні винятки; зокрема, SystemExit зазвичай "
"викликається для помилок, які, очевидно, є помилкою кінцевого користувача "
"(наприклад, неправильні аргументи командного рядка)."

#: ../../distutils/apiref.rst:1335
msgid ""
"This module is safe to use in ``from ... import *`` mode; it only exports "
"symbols whose names start with ``Distutils`` and end with ``Error``."
msgstr ""
"Цей модуль безпечно використовувати в режимі ``from ... import *``; він "
"експортує лише символи, імена яких починаються з ``Distutils`` і "
"закінчуються ``Error``."

#: ../../distutils/apiref.rst:1340
msgid ""
":mod:`distutils.fancy_getopt` --- Wrapper around the standard getopt module"
msgstr ""
":mod:`distutils.fancy_getopt` --- Обгортка навколо стандартного модуля "
"getopt"

#: ../../distutils/apiref.rst:1346
msgid ""
"This module provides a wrapper around the standard :mod:`getopt`  module "
"that provides the following additional features:"
msgstr ""
"Цей модуль надає оболонку стандартного модуля :mod:`getopt`, яка надає "
"наступні додаткові функції:"

#: ../../distutils/apiref.rst:1349
msgid "short and long options are tied together"
msgstr "короткі і довгі варіанти зв'язуються разом"

#: ../../distutils/apiref.rst:1351
msgid ""
"options have help strings, so :func:`fancy_getopt` could potentially  create"
" a complete usage summary"
msgstr ""
"параметри мають рядки довідки, тому :func:`fancy_getopt` потенційно може "
"створити повний підсумок використання"

#: ../../distutils/apiref.rst:1354
msgid "options set attributes of a passed-in object"
msgstr "параметри встановлюють атрибути переданого об'єкта"

#: ../../distutils/apiref.rst:1356
msgid ""
"boolean options can have \"negative aliases\" --- eg. if :option:`!--quiet` "
"is the \"negative alias\" of :option:`!--verbose`, then :option:`!--quiet` "
"on the command line sets *verbose* to false."
msgstr ""
"логічні параметри можуть мати \"негативні псевдоніми\" --- наприклад. якщо "
":option:`!--quiet` є \"негативним псевдонімом\" :option:`!--verbose`, тоді "
":option:`!--quiet` у командному рядку встановлює для *verbose* значення "
"false."

#: ../../distutils/apiref.rst:1362
msgid ""
"Wrapper function. *options* is a list of ``(long_option, short_option, "
"help_string)`` 3-tuples as described in the constructor for "
":class:`FancyGetopt`. *negative_opt* should be a dictionary mapping option "
"names to option names, both the key and value should be in the *options* "
"list. *object* is an object which will be used to store values (see the "
":meth:`getopt` method of the :class:`FancyGetopt` class). *args* is the "
"argument list. Will use ``sys.argv[1:]`` if you  pass ``None`` as *args*."
msgstr ""
"Функція обгортки. *options* — це список ``(long_option, short_option, "
"help_string)`` 3-кортежів, як описано в конструкторі для "
":class:`FancyGetopt`. *negative_opt* має бути словником, який зіставляє "
"назви параметрів з назвами параметрів, і ключ, і значення мають бути в "
"списку *параметрів*. *object* — це об’єкт, який використовуватиметься для "
"зберігання значень (дивіться метод :meth:`getopt` класу "
":class:`FancyGetopt`). *args* — список аргументів. Використовуватиме "
"``sys.argv[1:]``, якщо ви передасте ``None`` як *args*."

#: ../../distutils/apiref.rst:1373
msgid "Wraps *text* to less than *width* wide."
msgstr "Переносить *текст* на ширину менше *ширини*."

#: ../../distutils/apiref.rst:1378
msgid ""
"The option_table is a list of 3-tuples: ``(long_option, short_option, "
"help_string)``"
msgstr ""
"Таблиця_опцій — це список із трьох кортежів: ``(long_option, short_option, "
"help_string)``"

#: ../../distutils/apiref.rst:1381
msgid ""
"If an option takes an argument, its *long_option* should have ``'='`` "
"appended; *short_option* should just be a single character, no ``':'`` in "
"any case. *short_option* should be ``None`` if a *long_option*  doesn't have"
" a corresponding *short_option*. All option tuples must have long options."
msgstr ""
"Якщо параметр приймає аргумент, до його *long_option* має бути додано "
"``'='``; *short_option* має бути лише одним символом, ні в якому разі не "
"``':''``. *short_option* має бути ``None``, якщо *long_option* не має "
"відповідного *short_option*. Усі кортежі параметрів повинні мати довгі "
"параметри."

#: ../../distutils/apiref.rst:1386
msgid "The :class:`FancyGetopt` class provides the following methods:"
msgstr "Клас :class:`FancyGetopt` надає такі методи:"

#: ../../distutils/apiref.rst:1391
msgid "Parse command-line options in args. Store as attributes on *object*."
msgstr ""
"Розібрати параметри командного рядка в args. Зберігати як атрибути на "
"*об’єкті*."

#: ../../distutils/apiref.rst:1393
msgid ""
"If *args* is ``None`` or not supplied, uses ``sys.argv[1:]``.  If *object* "
"is ``None`` or not supplied, creates a new :class:`OptionDummy` instance, "
"stores option values there, and returns a tuple ``(args, object)``.  If "
"*object* is supplied, it is modified in place and :func:`getopt` just "
"returns *args*; in both cases, the returned *args* is a modified copy of the"
" passed-in *args* list, which is left untouched."
msgstr ""
"Якщо *args* має значення ``None`` або не надається, використовується "
"``sys.argv[1:]``. Якщо *object* має значення ``None`` або не надано, створює"
" новий екземпляр :class:`OptionDummy`, зберігає там значення параметрів і "
"повертає кортеж ``(args, object)``. Якщо надається *object*, він змінюється "
"на місці, і :func:`getopt` просто повертає *args*; в обох випадках "
"повернутий *args* є модифікованою копією переданого списку *args*, який "
"залишається недоторканим."

#: ../../distutils/apiref.rst:1405
msgid ""
"Returns the list of ``(option, value)`` tuples processed by the previous run"
" of :meth:`getopt`  Raises :exc:`RuntimeError` if :meth:`getopt` hasn't been"
" called yet."
msgstr ""
"Повертає список кортежів ``(option, value)``, оброблених попереднім запуском"
" :meth:`getopt` Викликає :exc:`RuntimeError`, якщо :meth:`getopt` ще не було"
" викликано."

#: ../../distutils/apiref.rst:1412
msgid ""
"Generate help text (a list of strings, one per suggested line of output) "
"from the option table for this :class:`FancyGetopt` object."
msgstr ""
"Згенеруйте довідковий текст (список рядків, по одному на запропонований "
"рядок виводу) з таблиці параметрів для цього об’єкта :class:`FancyGetopt`."

#: ../../distutils/apiref.rst:1415
msgid "If supplied, prints the supplied *header* at the top of the help."
msgstr "Якщо надається, друкує наданий *заголовок* у верхній частині довідки."

#: ../../distutils/apiref.rst:1419
msgid ":mod:`distutils.filelist` --- The FileList class"
msgstr ":mod:`distutils.filelist` --- Клас FileList"

#: ../../distutils/apiref.rst:1426
msgid ""
"This module provides the :class:`FileList` class, used for poking about the "
"filesystem and building lists of files."
msgstr ""
"Цей модуль надає клас :class:`FileList`, який використовується для вивчення "
"файлової системи та створення списків файлів."

#: ../../distutils/apiref.rst:1431
msgid ":mod:`distutils.log` --- Simple :pep:`282`-style logging"
msgstr ":mod:`distutils.log` --- Просте журналювання у стилі :pep:`282`"

#: ../../distutils/apiref.rst:1438
msgid ":mod:`distutils.spawn` --- Spawn a sub-process"
msgstr ":mod:`distutils.spawn` --- Створення підпроцесу"

#: ../../distutils/apiref.rst:1444
msgid ""
"This module provides the :func:`spawn` function, a front-end to  various "
"platform-specific functions for launching another program in a  sub-process."
" Also provides :func:`find_executable` to search the path for a given "
"executable name."
msgstr ""
"Цей модуль надає функцію :func:`spawn`, інтерфейс для різних функцій, "
"специфічних для платформи, для запуску іншої програми в підпроцесі. Також "
"надає :func:`find_executable` для пошуку шляху для вказаного імені "
"виконуваного файлу."

#: ../../distutils/apiref.rst:1451
msgid ":mod:`distutils.sysconfig` --- System configuration information"
msgstr ":mod:`distutils.sysconfig` --- Інформація про конфігурацію системи"

#: ../../distutils/apiref.rst:1455
msgid ":mod:`distutils.sysconfig` has been merged into :mod:`sysconfig`."
msgstr ":mod:`distutils.sysconfig` було об’єднано в :mod:`sysconfig`."

#: ../../distutils/apiref.rst:1462
msgid ""
"The :mod:`distutils.sysconfig` module provides access to Python's low-level "
"configuration information.  The specific configuration variables available "
"depend heavily on the platform and configuration. The specific variables "
"depend on the build process for the specific version of Python being run; "
"the variables are those found in the :file:`Makefile` and configuration "
"header that are installed with Python on Unix systems.  The configuration "
"header is called :file:`pyconfig.h` for Python versions starting with 2.2, "
"and :file:`config.h` for earlier versions of Python."
msgstr ""
"Модуль :mod:`distutils.sysconfig` забезпечує доступ до низькорівневої "
"конфігураційної інформації Python. Конкретні доступні змінні конфігурації "
"значною мірою залежать від платформи та конфігурації. Конкретні змінні "
"залежать від процесу збирання для конкретної версії Python, що виконується; "
"змінні знаходяться в :file:`Makefile` та заголовку конфігурації, які "
"встановлено разом з Python у системах Unix. Заголовок конфігурації "
"називається :file:`pyconfig.h` для версій Python, починаючи з 2.2, і "
":file:`config.h` для попередніх версій Python."

#: ../../distutils/apiref.rst:1471
msgid ""
"Some additional functions are provided which perform some useful "
"manipulations for other parts of the :mod:`distutils` package."
msgstr ""
"Надаються деякі додаткові функції, які виконують деякі корисні маніпуляції "
"для інших частин пакета :mod:`distutils`."

#: ../../distutils/apiref.rst:1477
msgid "The result of ``os.path.normpath(sys.prefix)``."
msgstr "Результат ``os.path.normpath(sys.prefix)``."

#: ../../distutils/apiref.rst:1482
msgid "The result of ``os.path.normpath(sys.exec_prefix)``."
msgstr "Результат ``os.path.normpath(sys.exec_prefix)``."

#: ../../distutils/apiref.rst:1487
msgid ""
"Return the value of a single variable.  This is equivalent to "
"``get_config_vars().get(name)``."
msgstr ""
"Повертає значення однієї змінної. Це еквівалентно "
"``get_config_vars().get(name)``."

#: ../../distutils/apiref.rst:1493
msgid ""
"Return a set of variable definitions.  If there are no arguments, this "
"returns a dictionary mapping names of configuration variables to values.  If"
" arguments are provided, they should be strings, and the return value will "
"be a sequence giving the associated values. If a given name does not have a "
"corresponding value, ``None`` will be included for that variable."
msgstr ""
"Повертає набір визначень змінних. Якщо аргументів немає, повертається "
"словник, який зіставляє імена змінних конфігурації зі значеннями. Якщо "
"надано аргументи, вони мають бути рядками, а значення, що повертається, буде"
" послідовністю, що надає пов’язані значення. Якщо задане ім’я не має "
"відповідного значення, для цієї змінної буде включено значення \"Немає\"."

#: ../../distutils/apiref.rst:1502
msgid ""
"Return the full path name of the configuration header.  For Unix, this will "
"be the header generated by the :program:`configure` script; for other "
"platforms the header will have been supplied directly by the Python source "
"distribution.  The file is a platform-specific text file."
msgstr ""
"Повертає повну назву шляху до заголовка конфігурації. Для Unix це буде "
"заголовок, згенерований сценарієм :program:`configure`; для інших платформ "
"заголовок буде надано безпосередньо вихідним кодом Python. Файл є текстовим "
"файлом для конкретної платформи."

#: ../../distutils/apiref.rst:1510
msgid ""
"Return the full path name of the :file:`Makefile` used to build Python.  For"
" Unix, this will be a file generated by the :program:`configure` script; the"
" meaning for other platforms will vary.  The file is a platform-specific "
"text file, if it exists. This function is only useful on POSIX platforms."
msgstr ""
"Повертає повну назву шляху до :file:`Makefile`, який використовується для "
"створення Python. Для Unix це буде файл, згенерований сценарієм "
":program:`configure`; значення для інших платформ буде іншим. Файл є "
"текстовим файлом певної платформи, якщо він існує. Ця функція корисна лише "
"на платформах POSIX."

#: ../../distutils/apiref.rst:1515
msgid ""
"The following functions are deprecated together with this module and they "
"have no direct replacement."
msgstr ""
"Наступні функції застаріли разом із цим модулем і не мають прямої заміни."

#: ../../distutils/apiref.rst:1521
msgid ""
"Return the directory for either the general or platform-dependent C include "
"files.  If *plat_specific* is true, the platform-dependent include directory"
" is returned; if false or omitted, the platform-independent directory is "
"returned. If *prefix* is given, it is used as either the prefix instead of "
":const:`PREFIX`, or as the exec-prefix instead of :const:`EXEC_PREFIX` if "
"*plat_specific* is true."
msgstr ""
"Повертає каталог для загальних або залежних від платформи C-файлів "
"включення. Якщо *plat_specific* має значення true, повертається залежний від"
" платформи каталог включення; якщо false або опущено, повертається "
"незалежний від платформи каталог. Якщо вказано *префікс*, він "
"використовується або як префікс замість :const:`PREFIX`, або як префікс exec"
" замість :const:`EXEC_PREFIX`, якщо *plat_specific* має значення true."

#: ../../distutils/apiref.rst:1531
msgid ""
"Return the directory for either the general or platform-dependent library "
"installation.  If *plat_specific* is true, the platform-dependent include "
"directory is returned; if false or omitted, the platform-independent "
"directory is returned.  If *prefix* is given, it is used as either the "
"prefix instead of :const:`PREFIX`, or as the exec-prefix instead of "
":const:`EXEC_PREFIX` if *plat_specific* is true.  If *standard_lib* is true,"
" the directory for the standard library is returned rather than the "
"directory for the installation of third-party extensions."
msgstr ""
"Поверніть каталог для встановлення загальної або залежної від платформи "
"бібліотеки. Якщо *plat_specific* має значення true, повертається залежний "
"від платформи каталог включення; якщо false або опущено, повертається "
"незалежний від платформи каталог. Якщо вказано *префікс*, він "
"використовується або як префікс замість :const:`PREFIX`, або як префікс exec"
" замість :const:`EXEC_PREFIX`, якщо *plat_specific* має значення true. Якщо "
"*standard_lib* має значення true, повертається каталог для стандартної "
"бібліотеки, а не каталог для встановлення розширень сторонніх розробників."

#: ../../distutils/apiref.rst:1540
msgid ""
"The following function is only intended for use within the :mod:`distutils` "
"package."
msgstr ""
"Наступна функція призначена лише для використання в пакеті :mod:`distutils`."

#: ../../distutils/apiref.rst:1546
msgid ""
"Do any platform-specific customization of a "
":class:`distutils.ccompiler.CCompiler` instance."
msgstr ""
"Виконайте будь-яке налаштування екземпляра "
":class:`distutils.ccompiler.CCompiler` для певної платформи."

#: ../../distutils/apiref.rst:1549
msgid ""
"This function is only needed on Unix at this time, but should be called "
"consistently to support forward-compatibility.  It inserts the information "
"that varies across Unix flavors and is stored in Python's :file:`Makefile`."
"  This information includes the selected compiler, compiler and linker "
"options, and the extension used by the linker for shared objects."
msgstr ""
"На даний момент ця функція потрібна тільки в Unix, але її слід викликати "
"постійно, щоб підтримувати сумісність. Він вставляє інформацію, яка "
"різниться в різних варіантах Unix і зберігається в файлі :file:`Makefile` "
"Python. Ця інформація включає вибраний компілятор, параметри компілятора та "
"компонувальника, а також розширення, яке використовує компонувальник для "
"спільних об’єктів."

#: ../../distutils/apiref.rst:1555
msgid ""
"This function is even more special-purpose, and should only be used from "
"Python's own build procedures."
msgstr ""
"Ця функція ще більш спеціального призначення, і її слід використовувати лише"
" з власних процедур збірки Python."

#: ../../distutils/apiref.rst:1561
msgid ""
"Inform the :mod:`distutils.sysconfig` module that it is being used as part "
"of the build process for Python.  This changes a lot of relative locations "
"for files, allowing them to be located in the build area rather than in an "
"installed Python."
msgstr ""
"Повідомте модуль :mod:`distutils.sysconfig`, що він використовується як "
"частина процесу збирання для Python. Це змінює багато відносних розташувань "
"файлів, дозволяючи їм розташовуватися в області збірки, а не у встановленому"
" Python."

#: ../../distutils/apiref.rst:1568
msgid ":mod:`distutils.text_file` --- The TextFile class"
msgstr ":mod:`distutils.text_file` --- Клас TextFile"

#: ../../distutils/apiref.rst:1574
msgid ""
"This module provides the :class:`TextFile` class, which gives an interface  "
"to text files that (optionally) takes care of stripping comments, ignoring  "
"blank lines, and joining lines with backslashes."
msgstr ""
"Цей модуль надає клас :class:`TextFile`, який надає інтерфейс для текстових "
"файлів, який (необов’язково) піклується про видалення коментарів, "
"ігнорування порожніх рядків і об’єднання рядків зворотними похилими рисками."

#: ../../distutils/apiref.rst:1581
msgid ""
"This class provides a file-like object that takes care of all  the things "
"you commonly want to do when processing a text file  that has some line-by-"
"line syntax: strip comments (as long as ``#``  is your comment character), "
"skip blank lines, join adjacent lines by escaping the newline (ie. backslash"
" at end of line), strip leading and/or trailing whitespace.  All of these "
"are optional and independently controllable."
msgstr ""
"Цей клас надає файлоподібний об’єкт, який піклується про всі речі, які ви "
"зазвичай хочете робити під час обробки текстового файлу, який має деякий "
"рядковий синтаксис: видалення коментарів (за умови, що ``#`` є вашим "
"символом коментаря ), пропускати порожні рядки, об’єднувати суміжні рядки "
"шляхом екранування символу нового рядка (тобто зворотної косої риски в кінці"
" рядка), видаляти пробіли на початку та/або в кінці. Усі вони необов’язкові "
"та управляються незалежно."

#: ../../distutils/apiref.rst:1588
msgid ""
"The class provides a :meth:`warn` method so you can generate  warning "
"messages that report physical line number, even if the  logical line in "
"question spans multiple physical lines.  Also  provides :meth:`unreadline` "
"for implementing line-at-a-time lookahead."
msgstr ""
"Клас надає метод :meth:`warn`, щоб ви могли генерувати попередження, які "
"повідомляють номер фізичного рядка, навіть якщо відповідний логічний рядок "
"охоплює кілька фізичних рядків. Також надає :meth:`unreadline` для "
"реалізації построкового перегляду."

#: ../../distutils/apiref.rst:1593
msgid ""
":class:`TextFile` instances are create with either *filename*, *file*, or "
"both. :exc:`RuntimeError` is raised if both are ``None``. *filename* should "
"be a string, and *file* a file object (or something that provides "
":meth:`readline` and :meth:`close`  methods).  It is recommended that you "
"supply at least *filename*,  so that :class:`TextFile` can include it in "
"warning messages.  If *file* is not supplied, :class:`TextFile` creates its "
"own using the :func:`open` built-in function."
msgstr ""
":class:`TextFile` екземпляри створюються з *filename*, *file* або обома. "
":exc:`RuntimeError` виникає, якщо обидва мають значення ``None``. *filename*"
" має бути рядком, а *file* — файловим об’єктом (або чимось, що надає методи "
":meth:`readline` і :meth:`close`). Рекомендовано вказати принаймні *ім’я "
"файлу*, щоб :class:`TextFile` міг включити його в попередження. Якщо *file* "
"не вказано, :class:`TextFile` створює власний за допомогою вбудованої "
"функції :func:`open`."

#: ../../distutils/apiref.rst:1601
msgid ""
"The options are all boolean, and affect the values returned by "
":meth:`readline`"
msgstr ""
"Усі параметри є логічними і впливають на значення, які повертає "
":meth:`readline`"

#: ../../distutils/apiref.rst:1606
msgid "option name"
msgstr "选项名称"

#: ../../distutils/apiref.rst:1606
msgid "default"
msgstr "默认值"

#: ../../distutils/apiref.rst:1608
msgid "*strip_comments*"
msgstr "*strip_comments*"

#: ../../distutils/apiref.rst:1608
msgid ""
"strip from ``'#'`` to end-of-line, as well as any whitespace leading up to "
"the ``'#'``\\ ---unless it is escaped by a backslash"
msgstr ""
"смуга від ``'#'`` до кінця рядка, а також будь-які пробіли, що ведуть до "
"``'#'``\\ --- якщо це не екрановано зворотною скісною рискою"

#: ../../distutils/apiref.rst:1608 ../../distutils/apiref.rst:1617
#: ../../distutils/apiref.rst:1622
msgid "true"
msgstr "true"

#: ../../distutils/apiref.rst:1614
msgid "*lstrip_ws*"
msgstr "*lstrip_ws*"

#: ../../distutils/apiref.rst:1614
msgid "strip leading whitespace from each line before returning it"
msgstr "видаляти початкові пробіли з кожного рядка перед поверненням"

#: ../../distutils/apiref.rst:1614 ../../distutils/apiref.rst:1632
#: ../../distutils/apiref.rst:1643
msgid "false"
msgstr "false"

#: ../../distutils/apiref.rst:1617
msgid "*rstrip_ws*"
msgstr "*rstrip_ws*"

#: ../../distutils/apiref.rst:1617
msgid ""
"strip trailing whitespace (including line terminator!) from each line before"
" returning it."
msgstr ""
"видаляти кінцеві пробіли (включно з символом закінчення рядка!) з кожного "
"рядка перед поверненням."

#: ../../distutils/apiref.rst:1622
msgid "*skip_blanks*"
msgstr "*skip_blanks*"

#: ../../distutils/apiref.rst:1622
msgid ""
"skip lines that are empty \\*after\\* stripping comments and whitespace.  "
"(If both lstrip_ws and rstrip_ws are false, then some lines may consist of "
"solely whitespace: these will \\*not\\* be skipped, even if *skip_blanks* is"
" true.)"
msgstr ""
"пропускати порожні рядки \\*після\\* видалення коментарів і пробілів. (Якщо "
"і lstrip_ws, і rstrip_ws false, то деякі рядки можуть складатися лише з "
"пробілів: вони \\*не\\* будуть пропущені, навіть якщо *skip_blanks* має "
"значення true.)"

#: ../../distutils/apiref.rst:1632
msgid "*join_lines*"
msgstr "*join_lines*"

#: ../../distutils/apiref.rst:1632
msgid ""
"if a backslash is the last non-newline character on a line after stripping "
"comments and whitespace, join the following line to it to form one logical "
"line; if N consecutive lines end with a backslash, then N+1 physical lines "
"will be joined to form one logical line."
msgstr ""
"якщо зворотна скісна риска є останнім символом у рядку після видалення "
"коментарів і пробілів, приєднайте наступний рядок до нього, щоб утворити "
"один логічний рядок; якщо N послідовних рядків закінчуються зворотною "
"скісною рискою, тоді N+1 фізичний рядок буде об’єднано в один логічний "
"рядок."

#: ../../distutils/apiref.rst:1643
msgid "*collapse_join*"
msgstr "*collapse_join*"

#: ../../distutils/apiref.rst:1643
msgid ""
"strip leading whitespace from lines that are joined to their predecessor; "
"only matters if ``(join_lines and not lstrip_ws)``"
msgstr ""
"видаляти початкові пробіли з рядків, які приєднані до їх попереднього; має "
"значення лише якщо ``(join_lines, а не lstrip_ws)``"

#: ../../distutils/apiref.rst:1650
msgid ""
"Note that since *rstrip_ws* can strip the trailing newline, the semantics of"
" :meth:`readline` must differ from those of the built-in file object's "
":meth:`readline` method!  In particular, :meth:`readline`  returns ``None`` "
"for end-of-file: an empty string might just be a  blank line (or an all-"
"whitespace line), if *rstrip_ws* is true  but *skip_blanks* is not."
msgstr ""
"Зауважте, що оскільки *rstrip_ws* може видаляти кінцевий новий рядок, "
"семантика :meth:`readline` має відрізнятися від методу :meth:`readline` "
"вбудованого файлового об’єкта! Зокрема, :meth:`readline` повертає ``None`` "
"для кінця файлу: порожній рядок може бути просто порожнім рядком (або рядком"
" із пробілами), якщо *rstrip_ws* має значення true, але *skip_blanks* не."

#: ../../distutils/apiref.rst:1659
msgid ""
"Open a new file *filename*.  This overrides any *file* or *filename* "
"constructor arguments."
msgstr ""
"Відкрийте новий файл *назва файлу*. Це перевизначає будь-які аргументи "
"конструктора *file* або *filename*."

#: ../../distutils/apiref.rst:1665
msgid ""
"Close the current file and forget everything we know about it (including the"
" filename and the current line number)."
msgstr ""
"Закрийте поточний файл і забудьте все, що ми знаємо про нього (включно з "
"назвою файлу та номером поточного рядка)."

#: ../../distutils/apiref.rst:1671
msgid ""
"Print (to stderr) a warning message tied to the current logical line in the "
"current file.  If the current logical line in the file spans multiple "
"physical lines, the warning refers to the whole range, such as ``\"lines "
"3-5\"``.  If *line* is supplied,  it overrides the current line number; it "
"may be a list or tuple  to indicate a range of physical lines, or an integer"
" for a  single physical line."
msgstr ""
"Вивести (у stderr) попереджувальне повідомлення, прив’язане до поточного "
"логічного рядка в поточному файлі. Якщо поточний логічний рядок у файлі "
"охоплює кілька фізичних рядків, попередження стосується всього діапазону, "
"наприклад \"рядків 3-5\". Якщо вказано *рядок*, він замінює поточний номер "
"рядка; це може бути список або кортеж для позначення діапазону фізичних "
"рядків або ціле число для окремого фізичного рядка."

#: ../../distutils/apiref.rst:1681
msgid ""
"Read and return a single logical line from the current file (or from an "
"internal buffer if lines have previously been \"unread\" with "
":meth:`unreadline`).  If the *join_lines* option  is true, this may involve "
"reading multiple physical lines concatenated into a single string.  Updates "
"the current line number,  so calling :meth:`warn` after :meth:`readline` "
"emits a warning  about the physical line(s) just read.  Returns ``None`` on "
"end-of-file,  since the empty string can occur if *rstrip_ws* is true but  "
"*strip_blanks* is not."
msgstr ""
"Читання та повернення одного логічного рядка з поточного файлу (або з "
"внутрішнього буфера, якщо рядки раніше були \"непрочитаними\" за допомогою "
":meth:`unreadline`). Якщо параметр *join_lines* має значення true, це може "
"передбачати читання кількох фізичних рядків, об’єднаних в один рядок. "
"Оновлює номер поточного рядка, тому виклик :meth:`warn` після "
":meth:`readline` видає попередження про щойно прочитаний фізичний рядок(и). "
"Повертає ``None`` у кінці файлу, оскільки порожній рядок може виникнути, "
"якщо *rstrip_ws* має значення true, а *strip_blanks* — ні."

#: ../../distutils/apiref.rst:1692
msgid ""
"Read and return the list of all logical lines remaining in the current file."
" This updates the current line number to the last line of the file."
msgstr ""
"Прочитати та повернути список усіх логічних рядків, що залишилися в "
"поточному файлі. Це оновить номер поточного рядка до останнього рядка файлу."

#: ../../distutils/apiref.rst:1698
msgid ""
"Push *line* (a string) onto an internal buffer that will be checked by "
"future :meth:`readline` calls.  Handy for implementing a parser with line-"
"at-a-time lookahead. Note that lines that are \"unread\" with "
":meth:`unreadline` are not subsequently re-cleansed (whitespace  stripped, "
"or whatever) when read with :meth:`readline`. If multiple calls are made to "
":meth:`unreadline` before a call to :meth:`readline`, the lines will be "
"returned most in most recent first order."
msgstr ""
"Надішліть *рядок* (рядок) у внутрішній буфер, який перевірятиметься "
"майбутніми викликами :meth:`readline`. Зручно для реалізації синтаксичного "
"аналізатора з построковим переглядом. Зауважте, що рядки, які є "
"\"непрочитаними\" за допомогою :meth:`unreadline`, згодом не очищаються "
"повторно (видаляються пробіли чи щось інше), коли читаються за допомогою "
":meth:`readline`. Якщо перед викликом :meth:`readline` зроблено декілька "
"викликів :meth:`unreadline`, рядки буде повернуто в найновішому першому "
"порядку."

#: ../../distutils/apiref.rst:1707
msgid ":mod:`distutils.version` --- Version number classes"
msgstr ":mod:`distutils.version` --- Класи номерів версій"

#: ../../distutils/apiref.rst:1722
msgid ":mod:`distutils.cmd` --- Abstract base class for Distutils commands"
msgstr ""
":mod:`distutils.cmd` --- Абстрактний базовий клас для команд Distutils"

#: ../../distutils/apiref.rst:1729
msgid "This module supplies the abstract base class :class:`Command`."
msgstr "Цей модуль надає абстрактний базовий клас :class:`Command`."

#: ../../distutils/apiref.rst:1734
msgid ""
"Abstract base class for defining command classes, the \"worker bees\" of the"
" Distutils.  A useful analogy for command classes is to think of them as "
"subroutines with local variables called *options*.  The options are declared"
" in :meth:`initialize_options` and defined (given their final values) in "
":meth:`finalize_options`, both of which must be defined by every command "
"class.  The distinction between the two is necessary because option values "
"might come from the outside world (command line, config file, ...), and any "
"options dependent on other options must be computed after these outside "
"influences have been processed --- hence :meth:`finalize_options`.  The body"
" of the subroutine, where it does all its work based on the values of its "
"options, is the :meth:`run` method, which must also be implemented by every "
"command class."
msgstr ""
"Абстрактний базовий клас для визначення класів команд, \"робочих бджіл\" "
"Distutils. Корисною аналогією для класів команд є розглядати їх як "
"підпрограми з локальними змінними, які називаються *options*. Параметри "
"оголошені в :meth:`initialize_options` і визначені (враховуючи їх кінцеві "
"значення) в :meth:`finalize_options`, обидва з яких повинні бути визначені "
"кожним класом команд. Розрізнення між цими двома параметрами є необхідним, "
"оскільки значення параметрів можуть надходити із зовнішнього світу "
"(командний рядок, конфігураційний файл, ...), а будь-які параметри, залежні "
"від інших параметрів, мають бути обчислені після обробки цих зовнішніх "
"впливів --- отже :meth:`finalize_options`. Тіло підпрограми, де вона виконує"
" всю свою роботу на основі значень своїх параметрів, є методом :meth:`run`, "
"який також має бути реалізований кожним класом команд."

#: ../../distutils/apiref.rst:1747
msgid ""
"The class constructor takes a single argument *dist*, a "
":class:`~distutils.core.Distribution` instance."
msgstr ""
"Конструктор класу приймає один аргумент *dist*, екземпляр "
":class:`~distutils.core.Distribution`."

#: ../../distutils/apiref.rst:1752
msgid "Creating a new Distutils command"
msgstr "Створення нової команди Distutils"

#: ../../distutils/apiref.rst:1754
msgid "This section outlines the steps to create a new Distutils command."
msgstr "У цьому розділі описано кроки для створення нової команди Distutils."

#: ../../distutils/apiref.rst:1756
msgid ""
"A new command lives in a module in the :mod:`distutils.command` package. "
"There is a sample template in that directory called "
":file:`command_template`.  Copy this file to a new module with the same name"
" as the new command you're implementing.  This module should implement a "
"class with the same name as the module (and the command).  So, for instance,"
" to create the command ``peel_banana`` (so that users can run ``setup.py "
"peel_banana``), you'd copy :file:`command_template` to "
":file:`distutils/command/peel_banana.py`, then edit it so that it's "
"implementing the class :class:`peel_banana`, a subclass of "
":class:`distutils.cmd.Command`."
msgstr ""
"Нова команда міститься в модулі в пакеті :mod:`distutils.command`. У цьому "
"каталозі є зразок шаблону під назвою :file:`command_template`. Скопіюйте цей"
" файл до нового модуля з такою ж назвою, як і нова команда, яку ви "
"реалізуєте. Цей модуль має реалізовувати клас із такою самою назвою, як і "
"модуль (і команда). Отже, наприклад, щоб створити команду ``peel_banana`` "
"(щоб користувачі могли запускати ``setup.py peel_banana``), ви повинні "
"скопіювати :file:`command_template` до :file:`distutils/command/peel_banana "
".py`, потім відредагуйте його так, щоб він реалізував клас "
":class:`peel_banana`, підклас :class:`distutils.cmd.Command`."

#: ../../distutils/apiref.rst:1766
msgid "Subclasses of :class:`Command` must define the following methods."
msgstr "Підкласи :class:`Command` повинні визначати такі методи."

#: ../../distutils/apiref.rst:1770
msgid ""
"Set default values for all the options that this command supports.  Note "
"that these defaults may be overridden by other commands, by the setup "
"script, by config files, or by the command-line.  Thus, this is not the "
"place to code dependencies between options; generally, "
":meth:`initialize_options` implementations are just a bunch of ``self.foo = "
"None`` assignments."
msgstr ""
"Установіть значення за замовчуванням для всіх параметрів, які підтримує ця "
"команда. Зауважте, що ці параметри за замовчуванням можуть бути замінені "
"іншими командами, сценарієм налаштування, файлами конфігурації або командним"
" рядком. Таким чином, це не місце для кодування залежностей між параметрами;"
" загалом, реалізації :meth:`initialize_options` — це просто купа призначень "
"``self.foo = None``."

#: ../../distutils/apiref.rst:1779
msgid ""
"Set final values for all the options that this command supports. This is "
"always called as late as possible, ie.  after any option assignments from "
"the command-line or from other commands have been done.  Thus, this is the "
"place to code option dependencies: if *foo* depends on *bar*, then it is "
"safe to set *foo* from *bar* as long as *foo* still has the same value it "
"was assigned in :meth:`initialize_options`."
msgstr ""
"Установіть остаточні значення для всіх параметрів, які підтримує ця команда."
" Це завжди викликається якомога пізніше, тобто. після виконання будь-яких "
"призначень параметрів із командного рядка чи інших команд. Таким чином, це "
"місце для кодування залежностей параметрів: якщо *foo* залежить від *bar*, "
"тоді безпечно встановити *foo* з *bar*, якщо *foo* все ще має те саме "
"значення, яке було призначено в :meth:`ініціалізувати_параметри`."

#: ../../distutils/apiref.rst:1789
msgid ""
"A command's raison d'etre: carry out the action it exists to perform, "
"controlled by the options initialized in :meth:`initialize_options`, "
"customized by other commands, the setup script, the command-line, and config"
" files, and finalized in :meth:`finalize_options`.  All terminal output and "
"filesystem interaction should be done by :meth:`run`."
msgstr ""
"Сенс існування команди: виконати дію, для виконання якої вона існує, що "
"контролюється параметрами, ініціалізованими в :meth:`initialize_options`, "
"налаштованими іншими командами, сценарієм налаштування, командним рядком і "
"файлами конфігурації, а також завершеними в :meth:`finalize_options`. Весь "
"вихід терміналу та взаємодія з файловою системою має здійснюватися за "
"допомогою :meth:`run`."

#: ../../distutils/apiref.rst:1798
msgid ""
"*sub_commands* formalizes the notion of a \"family\" of commands, e.g. "
"``install`` as the parent with sub-commands ``install_lib``, "
"``install_headers``, etc.  The parent of a family of commands defines "
"*sub_commands* as a class attribute; it's a list of 2-tuples "
"``(command_name, predicate)``, with *command_name* a string and *predicate* "
"a function, a string or ``None``.  *predicate* is a method of the parent "
"command that determines whether the corresponding command is applicable in "
"the current situation.  (E.g. ``install_headers`` is only applicable if we "
"have any C header files to install.)  If *predicate* is ``None``, that "
"command is always applicable."
msgstr ""
"*sub_commands* формалізує поняття \"сімейства\" команд, напр. ``install`` як"
" батьківський з підкомандами ``install_lib``, ``install_headers`` тощо. "
"Батьківський елемент сімейства команд визначає *sub_commands* як атрибут "
"класу; це список із двох кортежів ``(назва_команди, предикат)``, де "
"*назва_команди* є рядком, а *предикат* — функцією, рядком або ``None``. "
"*предикат* — це метод батьківської команди, який визначає, чи застосовна "
"відповідна команда в поточній ситуації. (Наприклад, ``install_headers`` "
"застосовний, лише якщо у нас є файли заголовків C для встановлення.) Якщо "
"*predicate* має значення ``None``, ця команда завжди застосовна."

#: ../../distutils/apiref.rst:1809
msgid ""
"*sub_commands* is usually defined at the *end* of a class, because "
"predicates can be methods of the class, so they must already have been "
"defined.  The canonical example is the :command:`install` command."
msgstr ""
"*sub_commands* зазвичай визначається в *кінці* класу, оскільки предикати "
"можуть бути методами класу, тому вони повинні бути вже визначені. Канонічним"
" прикладом є команда :command:`install`."

#: ../../distutils/apiref.rst:1815
msgid ":mod:`distutils.command` --- Individual Distutils commands"
msgstr ":mod:`distutils.command` --- Окремі команди Distutils"

#: ../../distutils/apiref.rst:1826
msgid ":mod:`distutils.command.bdist` --- Build a binary installer"
msgstr ":mod:`distutils.command.bdist` --- Створення бінарного інсталятора"

#: ../../distutils/apiref.rst:1836
msgid ""
":mod:`distutils.command.bdist_packager` --- Abstract base class for "
"packagers"
msgstr ""
":mod:`distutils.command.bdist_packager` --- Абстрактний базовий клас для "
"пакувальників"

#: ../../distutils/apiref.rst:1846
msgid ":mod:`distutils.command.bdist_dumb` --- Build a \"dumb\" installer"
msgstr ":mod:`distutils.command.bdist_dumb` --- Створення \"тупого\" інсталятора"

#: ../../distutils/apiref.rst:1856
msgid ""
":mod:`distutils.command.bdist_msi` --- Build a Microsoft Installer binary "
"package"
msgstr ""

#: ../../distutils/apiref.rst:1863
msgid "Use bdist_wheel (wheel packages) instead."
msgstr ""

#: ../../distutils/apiref.rst:1866
msgid "Builds a `Windows Installer`_ (.msi) binary package."
msgstr ""

#: ../../distutils/apiref.rst:1872
msgid ""
":mod:`distutils.command.bdist_rpm` --- Build a binary distribution as a "
"Redhat RPM and SRPM"
msgstr ""
":mod:`distutils.command.bdist_rpm` --- Створення бінарного дистрибутива як "
"Redhat RPM і SRPM"

#: ../../distutils/apiref.rst:1882
msgid ":mod:`distutils.command.sdist` --- Build a source distribution"
msgstr ":mod:`distutils.command.sdist` --- Створення вихідного дистрибутива"

#: ../../distutils/apiref.rst:1892
msgid ":mod:`distutils.command.build` --- Build all files of a package"
msgstr ":mod:`distutils.command.build` --- Збірка всіх файлів пакета"

#: ../../distutils/apiref.rst:1902
msgid ""
":mod:`distutils.command.build_clib` --- Build any C libraries in a package"
msgstr ""
":mod:`distutils.command.build_clib` --- Збірка будь-яких бібліотек C у "
"пакунок"

#: ../../distutils/apiref.rst:1912
msgid ""
":mod:`distutils.command.build_ext` --- Build any extensions in a package"
msgstr ""
":mod:`distutils.command.build_ext` --- Створення будь-яких розширень у "
"пакеті"

#: ../../distutils/apiref.rst:1922
msgid ""
":mod:`distutils.command.build_py` --- Build the .py/.pyc files of a package"
msgstr ""
":mod:`distutils.command.build_py` --- Створення файлів .py/.pyc пакета"

#: ../../distutils/apiref.rst:1932
msgid ""
"Alternative implementation of build_py which also runs the 2to3 conversion "
"library on each .py file that is going to be installed. To use this in a "
"setup.py file for a distribution that is designed to run with both Python "
"2.x and 3.x, add::"
msgstr ""
"Альтернативна реалізація build_py, яка також запускає бібліотеку "
"перетворення 2to3 для кожного файлу .py, який буде встановлено. Щоб "
"використовувати це у файлі setup.py для дистрибутива, призначеного для "
"роботи з Python 2.x і 3.x, додайте::"

#: ../../distutils/apiref.rst:1942
msgid "to your setup.py, and later::"
msgstr "до вашого setup.py, а пізніше::"

#: ../../distutils/apiref.rst:1946
msgid "to the invocation of setup()."
msgstr "до виклику setup()."

#: ../../distutils/apiref.rst:1950
msgid ""
":mod:`distutils.command.build_scripts` --- Build the scripts of a package"
msgstr ":mod:`distutils.command.build_scripts` --- Збірка сценаріїв пакета"

#: ../../distutils/apiref.rst:1960
msgid ":mod:`distutils.command.clean` --- Clean a package build area"
msgstr ":mod:`distutils.command.clean` --- Очистити область збірки пакета"

#: ../../distutils/apiref.rst:1965
msgid ""
"This command removes the temporary files created by :command:`build` and its"
" subcommands, like intermediary compiled object files.  With the ``--all`` "
"option, the complete build directory will be removed."
msgstr ""
"Ця команда видаляє тимчасові файли, створені :command:`build` та його "
"підкомандами, як-от проміжні скомпільовані об’єктні файли. З опцією "
"``--all`` буде видалено повний каталог збірки."

#: ../../distutils/apiref.rst:1969
msgid ""
"Extension modules built :ref:`in place <distutils-build-ext-inplace>` will "
"not be cleaned, as they are not in the build directory."
msgstr ""
"Модулі розширення, створені :ref:`in place <distutils-build-ext-inplace>`, "
"не будуть очищені, оскільки їх немає в каталозі збірки."

#: ../../distutils/apiref.rst:1974
msgid ":mod:`distutils.command.config` --- Perform package configuration"
msgstr ":mod:`distutils.command.config` --- Виконати налаштування пакета"

#: ../../distutils/apiref.rst:1984
msgid ":mod:`distutils.command.install` --- Install a package"
msgstr ":mod:`distutils.command.install` --- Встановити пакет"

#: ../../distutils/apiref.rst:1994
msgid ""
":mod:`distutils.command.install_data` --- Install data files from a package"
msgstr ""
":mod:`distutils.command.install_data` --- Встановити файли даних із пакета"

#: ../../distutils/apiref.rst:2004
msgid ""
":mod:`distutils.command.install_headers` --- Install C/C++ header files from"
" a package"
msgstr ""
":mod:`distutils.command.install_headers` --- Встановити файли заголовків "
"C/C++ із пакета"

#: ../../distutils/apiref.rst:2014
msgid ""
":mod:`distutils.command.install_lib` --- Install library files from a "
"package"
msgstr ""
":mod:`distutils.command.install_lib` --- Встановити файли бібліотеки з "
"пакета"

#: ../../distutils/apiref.rst:2024
msgid ""
":mod:`distutils.command.install_scripts` --- Install script files from a "
"package"
msgstr ""
":mod:`distutils.command.install_scripts` --- Встановити файли сценарію з "
"пакета"

#: ../../distutils/apiref.rst:2034
msgid ""
":mod:`distutils.command.register` --- Register a module with the Python "
"Package Index"
msgstr ""
":mod:`distutils.command.register` --- Реєстрація модуля в індексі пакетів "
"Python"

#: ../../distutils/apiref.rst:2040
msgid ""
"The ``register`` command registers the package with the Python Package  "
"Index. This is described in more detail in :pep:`301`."
msgstr ""
"Команда ``register`` реєструє пакет в індексі пакетів Python. Це описано "
"більш детально в :pep:`301`."

#: ../../distutils/apiref.rst:2047
msgid ":mod:`distutils.command.check` --- Check the meta-data of a package"
msgstr ":mod:`distutils.command.check` --- Перевірити метадані пакета"

#: ../../distutils/apiref.rst:2053
msgid ""
"The ``check`` command performs some tests on the meta-data of a package. For"
" example, it verifies that all required meta-data are provided as the "
"arguments passed to the :func:`setup` function."
msgstr ""
"Команда ``check`` виконує деякі перевірки метаданих пакета. Наприклад, він "
"перевіряє, що всі необхідні метадані надано як аргументи, передані до "
"функції :func:`setup`."
